tortoise_require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)
},{"base64-js":1,"buffer":3,"ieee754":9}],4:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":16}],5:[function(require,module,exports){
(function (Buffer){


class ResizeableBuffer{
  constructor(size=100){
    this.size = size
    this.length = 0
    this.buf = Buffer.alloc(size)
  }
  prepend(val){
    const length = this.length++
    if(length === this.size){
      this.resize()
    }
    const buf = this.clone()
    this.buf[0] = val
    buf.copy(this.buf,1, 0, length)
  }
  append(val){
    const length = this.length++
    if(length === this.size){
      this.resize()
    }
    this.buf[length] = val
  }
  clone(){
    return Buffer.from(this.buf.slice(0, this.length))
  }
  resize(){
    const length = this.length
    this.size = this.size * 2
    const buf = Buffer.alloc(this.size)
    this.buf.copy(buf,0, 0, length)
    this.buf = buf
  }
  toString(){
    return this.buf.slice(0, this.length).toString()
  }
  toJSON(){
    return this.toString()
  }
  reset(){
    this.length = 0
  }
}

module.exports = ResizeableBuffer

}).call(this,require("buffer").Buffer)
},{"buffer":3}],6:[function(require,module,exports){
(function (Buffer){

/*
CSV Parse

Please look at the [project documentation](https://csv.js.org/parse/) for additional
information.
*/

const { Transform } = require('stream')
const ResizeableBuffer = require('./ResizeableBuffer')

const cr = 13
const nl = 10
const space = 32
const tab = 9
const bom_utf8 = Buffer.from([239, 187, 191])

class Parser extends Transform {
  constructor(opts = {}){
    super({...{readableObjectMode: true}, ...opts})
    const options = {}
    // Merge with user options
    for(let opt in opts){
      options[underscore(opt)] = opts[opt]
    }
    // Normalize option `bom`
    if(options.bom === undefined || options.bom === null || options.bom === false){
      options.bom = false
    }else if(options.bom !== true){
      throw new Error(`Invalid Option: bom must be true, got ${JSON.stringify(options.bom)}`)
    }
    // Normalize option `cast`
    let fnCastField = null
    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){
      options.cast = undefined
    }else if(typeof options.cast === 'function'){
      fnCastField = options.cast
      options.cast = true
    }else if(options.cast !== true){
      throw new Error('Invalid Option: cast must be true or a function')
    }
    // Normalize option `cast_date`
    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){
      options.cast_date = false
    }else if(options.cast_date === true){
      options.cast_date = function(value){
        const date = Date.parse(value)
        return !isNaN(date) ? new Date(date) : value
      }
    }else if(typeof options.cast_date !== 'function'){
      throw new Error('Invalid Option: cast_date must be true or a function')
    }
    // Normalize option `columns`
    let fnFirstLineToHeaders = null
    if(options.columns === true){
      // Fields in the first line are converted as-is to columns
      fnFirstLineToHeaders = undefined
    }else if(typeof options.columns === 'function'){
      fnFirstLineToHeaders = options.columns
      options.columns = true
    }else if(Array.isArray(options.columns)){
      options.columns = normalizeColumnsArray(options.columns)
    }else if(options.columns === undefined || options.columns === null || options.columns === false){
      options.columns = false
    }else{
      throw new Error(`Invalid Option columns: expect an object or true, got ${JSON.stringify(options.columns)}`)
    }
    // Normalize option `comment`
    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){
      options.comment = null
    }else{
      if(typeof options.comment === 'string'){
        options.comment = Buffer.from(options.comment)
      }
      if(!Buffer.isBuffer(options.comment)){
        throw new Error(`Invalid Option: comment must be a buffer or a string, got ${JSON.stringify(options.comment)}`)
      }
    }
    // Normalize option `delimiter`
    if(options.delimiter === undefined || options.delimiter === null || options.delimiter === false){
      options.delimiter = Buffer.from(',')
    }else if(Buffer.isBuffer(options.delimiter)){
      if(options.delimiter.length === 0){
        throw new Error(`Invalid Option: delimiter must be a non empty buffer`)
      }
      // Great, nothing to do
    }else if(typeof options.delimiter === 'string'){
      if(options.delimiter.length === 0){
        throw new Error(`Invalid Option: delimiter must be a non empty string`)
      }
      options.delimiter = Buffer.from(options.delimiter)
    }else{
      throw new Error(`Invalid Option: delimiter must be a string or a buffer, got ${options.delimiter}`)
    }
    // Normalize option `escape`
    if(options.escape === undefined || options.escape === null){
      options.escape = Buffer.from('"')
    }else if(typeof options.escape === 'string'){
      options.escape = Buffer.from(options.escape)
    }
    if(!Buffer.isBuffer(options.escape)){
      throw new Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)
    }else if(options.escape.length !== 1){
      throw new Error(`Invalid Option Length: escape must be one character, got ${options.escape.length}`)
    }else{
      options.escape = options.escape[0]
    }
    // Normalize option `from`
    if(options.from === undefined || options.from === null){
      options.from = 1
    }else{
      if(typeof options.from === 'string' && /\d+/.test(options.from)){
        options.from = parseInt(options.from)
      }
      if(Number.isInteger(options.from)){
        if(options.from < 0){
          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)
        }
      }else{
        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)
      }
    }
    // Normalize option `from_line`
    if(options.from_line === undefined || options.from_line === null){
      options.from_line = 1
    }else{
      if(typeof options.from_line === 'string' && /\d+/.test(options.from_line)){
        options.from_line = parseInt(options.from_line)
      }
      if(Number.isInteger(options.from_line)){
        if(options.from_line <= 0){
          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)
        }
      }else{
        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)
      }
    }
    // Normalize option `info`
    if(options.info === undefined || options.info === null || options.info === false){
      options.info = false
    }else if(options.info !== true){
      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)
    }
    // Normalize option `max_record_size`
    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){
      options.max_record_size = 0
    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){
      // Great, nothing to do
    }else if(typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)){
      options.max_record_size = parseInt(options.max_record_size)
    }else{
      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)
    }
    // Normalize option `objname`
    if(options.objname === undefined || options.objname === null || options.objname === false){
      options.objname = undefined
    }else if(Buffer.isBuffer(options.objname)){
      if(options.objname.length === 0){
        throw new Error(`Invalid Option: objname must be a non empty buffer`)
      }
      options.objname = options.objname.toString()
    }else if(typeof options.objname === 'string'){
      if(options.objname.length === 0){
        throw new Error(`Invalid Option: objname must be a non empty string`)
      }
      // Great, nothing to do
    }else{
      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)
    }
    // Normalize option `quote`
    if(options.quote === null || options.quote === false || options.quote === ''){
      options.quote = null
    }else{
      if(options.quote === undefined || options.quote === true){
        options.quote = Buffer.from('"')
      }else if(typeof options.quote === 'string'){
        options.quote = Buffer.from(options.quote)
      }
      if(!Buffer.isBuffer(options.quote)){
        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)
      }else if(options.quote.length !== 1){
        throw new Error(`Invalid Option Length: quote must be one character, got ${options.quote.length}`)
      }else{
        options.quote = options.quote[0]
      }
    }
    // Normalize option `raw`
    if(options.raw === undefined || options.raw === null || options.raw === false){
      options.raw = false
    }else if(options.raw !== true){
      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)
    }
    // Normalize option `record_delimiter`
    if(!options.record_delimiter){
      options.record_delimiter = []
    }else if(!Array.isArray(options.record_delimiter)){
      options.record_delimiter = [options.record_delimiter]
    }
    options.record_delimiter = options.record_delimiter.map( function(rd){
      if(typeof rd === 'string'){
        rd = Buffer.from(rd)
      }
      return rd
    })
    // Normalize option `relax`
    if(typeof options.relax === 'boolean'){
      // Great, nothing to do
    }else if(options.relax === undefined || options.relax === null){
      options.relax = false
    }else{
      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)
    }
    // Normalize option `relax_column_count`
    if(typeof options.relax_column_count === 'boolean'){
      // Great, nothing to do
    }else if(options.relax_column_count === undefined || options.relax_column_count === null){
      options.relax_column_count = false
    }else{
      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)
    }
    // Normalize option `skip_empty_lines`
    if(typeof options.skip_empty_lines === 'boolean'){
      // Great, nothing to do
    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){
      options.skip_empty_lines = false
    }else{
      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)
    }
    // Normalize option `skip_lines_with_empty_values`
    if(typeof options.skip_lines_with_empty_values === 'boolean'){
      // Great, nothing to do
    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){
      options.skip_lines_with_empty_values = false
    }else{
      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)
    }
    // Normalize option `skip_lines_with_error`
    if(typeof options.skip_lines_with_error === 'boolean'){
      // Great, nothing to do
    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){
      options.skip_lines_with_error = false
    }else{
      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)
    }
    // Normalize option `rtrim`
    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){
      options.rtrim = false
    }else if(options.rtrim !== true){
      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)
    }
    // Normalize option `ltrim`
    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){
      options.ltrim = false
    }else if(options.ltrim !== true){
      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)
    }
    // Normalize option `trim`
    if(options.trim === undefined || options.trim === null || options.trim === false){
      options.trim = false
    }else if(options.trim !== true){
      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)
    }
    // Normalize options `trim`, `ltrim` and `rtrim`
    if(options.trim === true && opts.ltrim !== false){
      options.ltrim = true
    }else if(options.ltrim !== true){
      options.ltrim = false
    }
    if(options.trim === true && opts.rtrim !== false){
      options.rtrim = true
    }else if(options.rtrim !== true){
      options.rtrim = false
    }
    // Normalize option `to`
    if(options.to === undefined || options.to === null){
      options.to = -1
    }else{
      if(typeof options.to === 'string' && /\d+/.test(options.to)){
        options.to = parseInt(options.to)
      }
      if(Number.isInteger(options.to)){
        if(options.to <= 0){
          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)
        }
      }else{
        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)
      }
    }
    // Normalize option `to_line`
    if(options.to_line === undefined || options.to_line === null){
      options.to_line = -1
    }else{
      if(typeof options.to_line === 'string' && /\d+/.test(options.to_line)){
        options.to_line = parseInt(options.to_line)
      }
      if(Number.isInteger(options.to_line)){
        if(options.to_line <= 0){
          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)
        }
      }else{
        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)
      }
    }
    this.info = {
      comment_lines: 0,
      empty_lines: 0,
      invalid_field_length: 0,
      lines: 1,
      records: 0
    }
    this.options = options
    this.state = {
      bomSkipped: false,
      castField: fnCastField,
      commenting: false,
      enabled: options.from_line === 1,
      escaping: false,
      escapeIsQuote: options.escape === options.quote,
      expectedRecordLength: options.columns === null ? 0 : options.columns.length,
      field: new ResizeableBuffer(20),
      firstLineToHeaders: fnFirstLineToHeaders,
      info: Object.assign({}, this.info),
      previousBuf: undefined,
      quoting: false,
      stop: false,
      rawBuffer: new ResizeableBuffer(100),
      record: [],
      recordHasError: false,
      record_length: 0,
      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),
      trimChars: [Buffer.from(' ')[0], Buffer.from('\t')[0]],
      wasQuoting: false,
      wasRowDelimiter: false
    }
  }
  // Implementation of `Transform._transform`
  _transform(buf, encoding, callback){
    if(this.state.stop === true){
      return
    }
    const err = this.__parse(buf, false)
    if(err !== undefined){
      this.state.stop = true
    }
    callback(err)
  }
  // Implementation of `Transform._flush`
  _flush(callback){
    if(this.state.stop === true){
      return
    }
    const err = this.__parse(undefined, true)
    callback(err)
  }
  // Central parser implementation
  __parse(nextBuf, end){
    const {bom, comment, escape, from_line, info, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options
    let {record_delimiter} = this.options
    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state
    let buf
    if(previousBuf === undefined){
      if(nextBuf === undefined){
        // Handle empty string
        this.push(null)
        return
      }else{
        buf = nextBuf
      }
    }else if(previousBuf !== undefined && nextBuf === undefined){
      buf = previousBuf
    }else{
      buf = Buffer.concat([previousBuf, nextBuf])
    }
    // Handle UTF BOM
    if(bomSkipped === false){
      if(bom === false){
        this.state.bomSkipped = true
      }else if(buf.length < 3){
        // No enough data
        if(end === false){
          // Wait for more data
          this.state.previousBuf = buf
          return
        }
        // skip BOM detect because data length < 3
      }else{
        if(bom_utf8.compare(buf, 0, 3) === 0){
          // Skip BOM
          buf = buf.slice(3)
        }
        this.state.bomSkipped = true
      }
    }
    const bufLen = buf.length
    let pos
    for(pos = 0; pos < bufLen; pos++){
      // Ensure we get enough space to look ahead
      // There should be a way to move this out of the loop
      if(this.__needMoreData(pos, bufLen, end)){
        break
      }
      if(this.state.wasRowDelimiter === true){
        this.info.lines++
        if(info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false){
          this.state.info = Object.assign({}, this.info)
        }
        this.state.wasRowDelimiter = false
      }
      if(to_line !== -1 && this.info.lines > to_line){
        this.state.stop = true
        this.push(null)
        return
      }
      // Auto discovery of record_delimiter, unix, mac and windows supported
      if(this.state.quoting === false && record_delimiter.length === 0){
        const record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos)
        if(record_delimiterCount){
          record_delimiter = this.options.record_delimiter
        }
      }
      const chr = buf[pos]
      if(raw === true){
        rawBuffer.append(chr)
      }
      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){
        this.state.wasRowDelimiter = true
      }
      // Previous char was a valid escape char
      // treat the current char as a regular char
      if(this.state.escaping === true){
        this.state.escaping = false
      }else{
        // Escape is only active inside quoted fields
        if(this.state.quoting === true && chr === escape && pos + 1 < bufLen){
          // We are quoting, the char is an escape chr and there is a chr to escape
          if(escapeIsQuote){
            if(buf[pos+1] === quote){
              this.state.escaping = true
              continue
            }
          }else{
            this.state.escaping = true
            continue
          }
        }
        // Not currently escaping and chr is a quote
        // TODO: need to compare bytes instead of single char
        if(this.state.commenting === false && chr === quote){
          if(this.state.quoting === true){
            const nextChr = buf[pos+1]
            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)
            // const isNextChrComment = nextChr === comment
            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+1, nextChr)
            const isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos+1)
            const isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos+1) : this.__isRecordDelimiter(nextChr, buf, pos+1)
            // Escape a quote
            // Treat next char as a regular character
            // TODO: need to compare bytes instead of single char
            if(chr === escape && nextChr === quote){
              pos++
            }else if(!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable){
              this.state.quoting = false
              this.state.wasQuoting = true
              continue
            }else if(relax === false){
              const err = this.__error(
                new CsvError('CSV_INVALID_CLOSING_QUOTE', [
                  'Invalid Closing Quote:',
                  `got "${String.fromCharCode(nextChr)}"`,
                  `at line ${this.info.lines}`,
                  'instead of delimiter, row delimiter, trimable character',
                  '(if activated) or comment',
                ], this.__context())
              )
              if(err !== undefined) return err
            }else{
              this.state.quoting = false
              this.state.wasQuoting = true
              // continue
              this.state.field.prepend(quote)
            }
          }else{
            if(this.state.field.length !== 0){
              // In relax mode, treat opening quote preceded by chrs as regular
              if( relax === false ){
                const err = this.__error(
                  new CsvError('INVALID_OPENING_QUOTE', [
                    'Invalid Opening Quote:',
                    `a quote is found inside a field at line ${this.info.lines}`,
                  ], this.__context(), {
                    field: this.state.field,
                  })
                )
                if(err !== undefined) return err
              }
            }else{
              this.state.quoting = true
              continue
            }
          }
        }
        if(this.state.quoting === false){
          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)
          if(recordDelimiterLength !== 0){
            // Do not emit comments which take a full line
            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)
            if(skipCommentLine){
              this.info.comment_lines++
              // Skip full comment line
            }else{
              // Skip if line is empty and skip_empty_lines activated
              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){
                this.info.empty_lines++
                pos += recordDelimiterLength - 1
                continue
              }
              // Activate records emition if above from_line
              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0 ) >= from_line){
                this.state.enabled = true
                this.__resetField()
                this.__resetRow()
                pos += recordDelimiterLength - 1
                continue
              }else{
                const errField = this.__onField()
                if(errField !== undefined) return errField
                const errRecord = this.__onRow()
                if(errRecord !== undefined) return errRecord
              }
              if(to !== -1 && this.info.records >= to){
                this.state.stop = true
                this.push(null)
                return
              }
            }
            this.state.commenting = false
            pos += recordDelimiterLength - 1
            continue
          }
          if(this.state.commenting){
            continue
          }
          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)
          if(commentCount !== 0){
            this.state.commenting = true
            continue
          }
          let delimiterLength = this.__isDelimiter(chr, buf, pos)
          if(delimiterLength !== 0){
            const errField = this.__onField()
            if(errField !== undefined) return errField
            pos += delimiterLength - 1
            continue
          }
        }
      }
      if(this.state.commenting === false){
        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){
          const err = this.__error(
            new CsvError('CSV_MAX_RECORD_SIZE', [
              'Max Record Size:',
              'record exceed the maximum number of tolerated bytes',
              `of ${max_record_size}`,
              `at line ${this.info.lines}`,
            ], this.__context())
          )
          if(err !== undefined) return err
        }
      }

      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)
      // rtrim in non quoting is handle in __onField
      const rappend = rtrim === false || this.state.wasQuoting === false
      if( lappend === true && rappend === true ){
        this.state.field.append(chr)
      }else if(rtrim === true && !this.__isCharTrimable(chr)){
        const err = this.__error(
          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [
            'Invalid Closing Quote:',
            'found non trimable byte after quote',
            `at line ${this.info.lines}`,
          ], this.__context())
        )
        if(err !== undefined) return err
      }
    }
    if(end === true){
      if(this.state.quoting === true){
        const err = this.__error(
          new CsvError('CSV_QUOTE_NOT_CLOSED', [
            'Quote Not Closed:',
            `the parsing is finished with an opening quote at line ${this.info.lines}`,
          ], this.__context())
        )
        if(err !== undefined) return err
      }else{
        // Skip last line if it has no characters
        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){
          const errField = this.__onField()
          if(errField !== undefined) return errField
          const errRecord = this.__onRow()
          if(errRecord !== undefined) return errRecord
        }else if(this.state.wasRowDelimiter === true){
          this.info.empty_lines++
        }else if(this.state.commenting === true){
          this.info.comment_lines++
        }
      }
    }else{
      this.state.previousBuf = buf.slice(pos)
    }
    if(this.state.wasRowDelimiter === true){
      this.info.lines++
      this.state.wasRowDelimiter = false
    }
  }
  // Helper to test if a character is a space or a line delimiter
  __isCharTrimable(chr){
    return chr === space || chr === tab || chr === cr || chr === nl
  }
  __onRow(){
    const {columns, info, from, relax_column_count, raw, skip_lines_with_empty_values} = this.options
    const {enabled, record} = this.state
    // Convert the first line into column names
    if(columns === true){
      return this.__firstLineToColumns(record)
    }
    const recordLength = record.length
    if(columns === false && this.info.records === 0){
      this.state.expectedRecordLength = recordLength
    }else if(enabled === true){
      if(recordLength !== this.state.expectedRecordLength){
        if(relax_column_count === true){
          this.info.invalid_field_length++
        }else{
          if(columns === false){
            const err = this.__error(
              new CsvError('CSV_INVALID_RECORD_LENGTH_DONT_PREVIOUS_RECORDS', [
                'Invalid Record Length:',
                `expect ${this.state.expectedRecordLength},`,
                `got ${recordLength} on line ${this.info.lines}`,
              ], this.__context(), {
                record: record,
              })
            )
            if(err !== undefined) return err
          }else{
            const err = this.__error(
              new CsvError('CSV_INVALID_RECORD_LENGTH_DONT_MATCH_COLUMNS', [
                'Invalid Record Length:',
                `header length is ${columns.length},`,
                `got ${recordLength} on line ${this.info.lines}`,
              ], this.__context(), {
                record: record,
              })
            )
            if(err !== undefined) return err
          }
        }
      }
    }
    if(enabled === false){
      return this.__resetRow()
    }
    if(skip_lines_with_empty_values === true){
      if(record.every( (field) => field == null || field.toString && field.toString().trim() === '' )){
        this.__resetRow()
        return
      }
    }
    if(this.state.recordHasError === true){
      this.__resetRow()
      this.state.recordHasError = false
      return
    }
    this.info.records++
    if(from === 1 || this.info.records >= from){
      if(columns !== false){
        const obj = {}
        // Transform record array to an object
        for(let i in record){
          if(columns[i] === undefined || columns[i].disabled) continue
          obj[columns[i].name] = record[i]
        }
        const {objname} = this.options
        if(objname === undefined){
          if(raw === true || info === true){
            this.push(Object.assign(
              {record: obj},
              (raw === true ? {raw: this.state.rawBuffer.toString()}: {}),
              (info === true ? {info: this.state.info}: {})
            ))
          }else{
            this.push(obj)
          }
        }else{
          if(raw === true || info === true){
            this.push(Object.assign(
              {record: [obj[objname], obj]},
              raw === true ? {raw: this.state.rawBuffer.toString()}: {},
              info === true ? {info: this.state.info}: {}
            ))
          }else{
            this.push([obj[objname], obj])
          }
        }
      }else{
        if(raw === true || info === true){
          this.push(Object.assign(
            {record: record},
            raw === true ? {raw: this.state.rawBuffer.toString()}: {},
            info === true ? {info: this.state.info}: {}
          ))
        }else{
          this.push(record)
        }
      }
    }
    this.__resetRow()
  }
  __firstLineToColumns(record){
    const {firstLineToHeaders} = this.state
    try{
      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)
      if(!Array.isArray(headers)){
        return this.__error(
          new CsvError('CSV_INVALID_COLUMN_MAPPING', [
            'Invalid Column Mapping:',
            'expect an array from column function,',
            `got ${JSON.stringify(headers)}`
          ], this.__context(), {
            headers: headers,
          })
        )
      }
      const normalizedHeaders = normalizeColumnsArray(headers)
      this.state.expectedRecordLength = normalizedHeaders.length
      this.options.columns = normalizedHeaders
      this.__resetRow()
      return
    }catch(err){
      return err
    }
  }
  __resetRow(){
    if(this.options.raw === true){
      this.state.rawBuffer.reset()
    }
    this.state.record = []
    this.state.record_length = 0
  }
  __onField(){
    const {cast, rtrim, max_record_size} = this.options
    const {enabled, wasQuoting} = this.state
    // Deal with from_to options
    if(this.options.columns !== true && enabled === false){
      return this.__resetField()
    }
    let field = this.state.field.toString()
    if(rtrim === true && wasQuoting === false){
      field = field.trimRight()
    }
    if(cast === true){
      const [err, f] = this.__cast(field)
      if(err !== undefined) return err
      field = f
    }
    this.state.record.push(field)
    // Increment record length if record size must not exceed a limit
    if(max_record_size !== 0 && typeof field === 'string'){
      this.state.record_length += field.length
    }
    this.__resetField()
  }
  __resetField(){
    this.state.field.reset()
    this.state.wasQuoting = false
  }
  // Return a tuple with the error and the casted value
  __cast(field){
    const {columns, relax_column_count} = this.options
    const isColumns = Array.isArray(columns)
    // Dont loose time calling cast
    // because the final record is an object
    // and this field can't be associated to a key present in columns
    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){
      return [undefined, undefined]
    }
    const context = this.__context()
    if(this.state.castField !== null){
      try{
        return [undefined, this.state.castField.call(null, field, context)]
      }catch(err){
        return [err]
      }
    }
    if(this.__isFloat(field)){
      return [undefined, parseFloat(field)]
    }else if(this.options.cast_date !== false){
      return [undefined, this.options.cast_date.call(null, field, context)]
    }
    return [undefined, field]
  }
  // Keep it in case we implement the `cast_int` option
  // __isInt(value){
  //   // return Number.isInteger(parseInt(value))
  //   // return !isNaN( parseInt( obj ) );
  //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
  // }
  __isFloat(value){
    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery
  }
  __compareBytes(sourceBuf, targetBuf, pos, firtByte){
    if(sourceBuf[0] !== firtByte) return 0
    const sourceLength = sourceBuf.length
    for(let i = 1; i < sourceLength; i++){
      if(sourceBuf[i] !== targetBuf[pos+i]) return 0
    }
    return sourceLength
  }
  __needMoreData(i, bufLen, end){
    if(end){
      return false
    }
    const {comment, delimiter} = this.options
    const {quoting, recordDelimiterMaxLength} = this.state
    const numOfCharLeft = bufLen - i - 1
    const requiredLength = Math.max(
      // Skip if the remaining buffer smaller than comment
      comment ? comment.length : 0,
      // Skip if the remaining buffer smaller than row delimiter
      recordDelimiterMaxLength,
      // Skip if the remaining buffer can be row delimiter following the closing quote
      // 1 is for quote.length
      quoting ? (1 + recordDelimiterMaxLength) : 0,
      // Skip if the remaining buffer can be delimiter
      delimiter.length,
      // Skip if the remaining buffer can be escape sequence
      // 1 is for escape.length
      1
    )
    return numOfCharLeft < requiredLength
  }
  __isDelimiter(chr, buf, pos){
    const {delimiter} = this.options
    const delLength = delimiter.length
    if(delimiter[0] !== chr) return 0
    for(let i = 1; i < delLength; i++){
      if(delimiter[i] !== buf[pos+i]) return 0
    }
    return delimiter.length
  }
  __isRecordDelimiter(chr, buf, pos){
    const {record_delimiter} = this.options
    const recordDelimiterLength = record_delimiter.length
    loop1: for(let i = 0; i < recordDelimiterLength; i++){
      const rd = record_delimiter[i]
      const rdLength = rd.length
      if(rd[0] !== chr){
        continue
      }
      for(let j = 1; j < rdLength; j++){
        if(rd[j] !== buf[pos+j]){
          continue loop1
        }
      }
      return rd.length
    }
    return 0
  }
  __autoDiscoverRowDelimiter(buf, pos){
    const chr = buf[pos]
    if(chr === cr){
      if(buf[pos+1] === nl){
        this.options.record_delimiter.push(Buffer.from('\r\n'))
        this.state.recordDelimiterMaxLength = 2
        return 2
      }else{
        this.options.record_delimiter.push(Buffer.from('\r'))
        this.state.recordDelimiterMaxLength = 1
        return 1
      }
    }else if(chr === nl){
      this.options.record_delimiter.push(Buffer.from('\n'))
      this.state.recordDelimiterMaxLength = 1
      return 1
    }
    return 0
  }
  __error(msg){
    const {skip_lines_with_error} = this.options
    const err = typeof msg === 'string' ? new Error(msg) : msg
    if(skip_lines_with_error){
      this.state.recordHasError = true
      this.emit('skip', err)
      return undefined
    }else{
      return err
    }
  }
  __context(){
    const {columns} = this.options
    const isColumns = Array.isArray(columns)
    return {
      column: isColumns === true ?
        ( columns.length > this.state.record.length ?
          columns[this.state.record.length].name :
          null
        ) :
        this.state.record.length,
      empty_lines: this.info.empty_lines,
      header: columns === true,
      index: this.state.record.length,
      invalid_field_length: this.info.invalid_field_length,
      quoting: this.state.wasQuoting,
      lines: this.info.lines,
      records: this.info.records
    }
  }
}

const parse = function(){
  let data, options, callback
  for(let i in arguments){
    const argument = arguments[i]
    const type = typeof argument
    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){
      data = argument
    }else if(options === undefined && isObject(argument)){
      options = argument
    }else if(callback === undefined && type === 'function'){
      callback = argument
    }else{
      throw new Error(`Invalid argument: got ${JSON.stringify(argument)} at index ${i}`)
    }
  }
  const parser = new Parser(options)
  if(callback){
    const records = options === undefined || options.objname === undefined ? [] : {}
    parser.on('readable', function(){
      let record
      while((record = this.read()) !== null){
        if(options === undefined || options.objname === undefined){
          records.push(record)
        }else{
          records[record[0]] = record[1]
        }
      }
    })
    parser.on('error', function(err){
      callback(err, undefined, parser.info)
    })
    parser.on('end', function(){
      callback(undefined, records, parser.info)
    })
  }
  if(data !== undefined){
    parser.write(data)
    parser.end()
  }
  return parser
}

class CsvError extends Error {
  constructor(code, message, ...contexts) {
    if(Array.isArray(message)) message = message.join(' ')
    super([message])
    Error.captureStackTrace(this, CsvError)
    this.code = code
    for(const context of contexts){
      for(const key in context){
        const value = context[key]
        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))
      }
    }
  }
}

parse.Parser = Parser

parse.CsvError = CsvError

module.exports = parse

const underscore = function(str){
  return str.replace(/([A-Z])/g, function(_, match){
    return '_' + match.toLowerCase()
  })
}

const isObject = function(obj){
  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))
}

const normalizeColumnsArray = function(columns){
  const normalizedColumns = [];

  for(let i=0; i< columns.length; i++){
    const column = columns[i]
    if(column === undefined || column === null || column === false){
      normalizedColumns[i] = { disabled: true }
    }else if(typeof column === 'string'){
      normalizedColumns[i] = { name: column }
    }else if(isObject(column)){
      if(typeof column.name !== 'string'){
        throw new Error(`Invalid Option columns: property "name" is required at position ${i} when column is an object literal`)
      }
      normalizedColumns[i] = column
    }else{
      throw new Error(`Invalid Option columns: expect a string or an object, got ${JSON.stringify(column)} at position ${i}`)
    }
  }
  return normalizedColumns;
}

}).call(this,require("buffer").Buffer)
},{"./ResizeableBuffer":5,"buffer":3,"stream":35}],7:[function(require,module,exports){
(function (Buffer){

const parse = require('.')

module.exports = function(data, options={}){
  if(typeof data === 'string'){
    data = Buffer.from(data)
  }
  const records = options && options.objname ? {} : []
  const parser = new parse.Parser(options)
  parser.push = function(record){
    if(options.objname === undefined)
      records.push(record)
    else{
      records[record[0]] = record[1]
    }
  }
  const err1 = parser.__parse(data, false)
  if(err1 !== undefined) throw err1
  const err2 = parser.__parse(undefined, true)
  if(err2 !== undefined) throw err2
  return records
}

}).call(this,require("buffer").Buffer)
},{".":6,"buffer":3}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],9:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],10:[function(require,module,exports){
var structuredClone = require('./structured-clone');
var HELLO_INTERVAL_LENGTH = 200;
var HELLO_TIMEOUT_LENGTH = 60000;

function IFrameEndpoint() {
  var listeners = {};
  var isInitialized = false;
  var connected = false;
  var postMessageQueue = [];
  var helloInterval;

  function postToParent(message) {
    // See http://dev.opera.com/articles/view/window-postmessage-messagechannel/#crossdoc
    //     https://github.com/Modernizr/Modernizr/issues/388
    //     http://jsfiddle.net/ryanseddon/uZTgD/2/
    if (structuredClone.supported()) {
      window.parent.postMessage(message, '*');
    } else {
      window.parent.postMessage(JSON.stringify(message), '*');
    }
  }

  function post(type, content) {
    var message;
    // Message object can be constructed from 'type' and 'content' arguments or it can be passed
    // as the first argument.
    if (arguments.length === 1 && typeof type === 'object' && typeof type.type === 'string') {
      message = type;
    } else {
      message = {
        type: type,
        content: content
      };
    }
    if (connected) {
      postToParent(message);
    } else {
      postMessageQueue.push(message);
    }
  }

  function postHello() {
    postToParent({
      type: 'hello'
    });
  }

  function addListener(type, fn) {
    listeners[type] = fn;
  }

  function removeAllListeners() {
    listeners = {};
  }

  function getListenerNames() {
    return Object.keys(listeners);
  }

  function messageListener(message) {
    // Anyone can send us a message. Only pay attention to messages from parent.
    if (message.source !== window.parent) return;
    var messageData = message.data;
    if (typeof messageData === 'string') messageData = JSON.parse(messageData);

    if (!connected && messageData.type === 'hello') {
      connected = true;
      stopPostingHello();
      while (postMessageQueue.length > 0) {
        post(postMessageQueue.shift());
      }
    }

    if (connected && listeners[messageData.type]) {
      listeners[messageData.type](messageData.content);
    }
  }

  function disconnect() {
    connected = false;
    stopPostingHello();
    window.removeEventListener('message', messsageListener);
  }

  /**
    Initialize communication with the parent frame. This should not be called until the app's custom
    listeners are registered (via our 'addListener' public method) because, once we open the
    communication, the parent window may send any messages it may have queued. Messages for which
    we don't have handlers will be silently ignored.
  */
  function initialize() {
    if (isInitialized) {
      return;
    }
    isInitialized = true;
    if (window.parent === window) return;

    // We kick off communication with the parent window by sending a "hello" message. Then we wait
    // for a handshake (another "hello" message) from the parent window.
    startPostingHello();
    window.addEventListener('message', messageListener, false);
  }

  function startPostingHello() {
    if (helloInterval) {
      stopPostingHello();
    }
    helloInterval = window.setInterval(postHello, HELLO_INTERVAL_LENGTH);
    window.setTimeout(stopPostingHello, HELLO_TIMEOUT_LENGTH);
    // Post the first msg immediately.
    postHello();
  }

  function stopPostingHello() {
    window.clearInterval(helloInterval);
    helloInterval = null;
  }

  // Public API.
  return {
    initialize: initialize,
    getListenerNames: getListenerNames,
    addListener: addListener,
    removeAllListeners: removeAllListeners,
    disconnect: disconnect,
    post: post
  };
}

var instance = null;

// IFrameEndpoint is a singleton, as iframe can't have multiple parents anyway.
module.exports = function getIFrameEndpoint() {
  if (!instance) {
    instance = new IFrameEndpoint();
  }
  return instance;
};

},{"./structured-clone":13}],11:[function(require,module,exports){
var ParentEndpoint = require('./parent-endpoint');
var getIFrameEndpoint = require('./iframe-endpoint');

// Not a real UUID as there's an RFC for that (needed for proper distributed computing).
// But in this fairly parochial situation, we just need to be fairly sure to avoid repeats.
function getPseudoUUID() {
  var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  var len = chars.length;
  var ret = [];

  for (var i = 0; i < 10; i++) {
    ret.push(chars[Math.floor(Math.random() * len)]);
  }
  return ret.join('');
}

module.exports = function IframePhoneRpcEndpoint(handler, namespace, targetWindow, targetOrigin, phone) {
  var pendingCallbacks = Object.create({});

  // if it's a non-null object, rather than a function, 'handler' is really an options object
  if (handler && typeof handler === 'object') {
    namespace = handler.namespace;
    targetWindow = handler.targetWindow;
    targetOrigin = handler.targetOrigin;
    phone = handler.phone;
    handler = handler.handler;
  }

  if (!phone) {
    if (targetWindow === window.parent) {
      phone = getIFrameEndpoint();
      phone.initialize();
    } else {
      phone = new ParentEndpoint(targetWindow, targetOrigin);
    }
  }

  phone.addListener(namespace, function (message) {
    var callbackObj;

    if (message.messageType === 'call' && typeof this.handler === 'function') {
      this.handler.call(undefined, message.value, function (returnValue) {
        phone.post(namespace, {
          messageType: 'returnValue',
          uuid: message.uuid,
          value: returnValue
        });
      });
    } else if (message.messageType === 'returnValue') {
      callbackObj = pendingCallbacks[message.uuid];

      if (callbackObj) {
        window.clearTimeout(callbackObj.timeout);
        if (callbackObj.callback) {
          callbackObj.callback.call(undefined, message.value);
        }
        pendingCallbacks[message.uuid] = null;
      }
    }
  }.bind(this));

  function call(message, callback) {
    var uuid = getPseudoUUID();

    pendingCallbacks[uuid] = {
      callback: callback,
      timeout: window.setTimeout(function () {
        if (callback) {
          callback(undefined, new Error("IframePhone timed out waiting for reply"));
        }
      }, 2000)
    };

    phone.post(namespace, {
      messageType: 'call',
      uuid: uuid,
      value: message
    });
  }

  function disconnect() {
    phone.disconnect();
  }

  this.handler = handler;
  this.call = call.bind(this);
  this.disconnect = disconnect.bind(this);
};

},{"./iframe-endpoint":10,"./parent-endpoint":12}],12:[function(require,module,exports){
var structuredClone = require('./structured-clone');

/**
  Call as:
    new ParentEndpoint(targetWindow, targetOrigin, afterConnectedCallback)
      targetWindow is a WindowProxy object. (Messages will be sent to it)

      targetOrigin is the origin of the targetWindow. (Messages will be restricted to this origin)

      afterConnectedCallback is an optional callback function to be called when the connection is
        established.

  OR (less secure):
    new ParentEndpoint(targetIframe, afterConnectedCallback)

      targetIframe is a DOM object (HTMLIframeElement); messages will be sent to its contentWindow.

      afterConnectedCallback is an optional callback function

    In this latter case, targetOrigin will be inferred from the value of the src attribute of the
    provided DOM object at the time of the constructor invocation. This is less secure because the
    iframe might have been navigated to an unexpected domain before constructor invocation.

  Note that it is important to specify the expected origin of the iframe's content to safeguard
  against sending messages to an unexpected domain. This might happen if our iframe is navigated to
  a third-party URL unexpectedly. Furthermore, having a reference to Window object (as in the first
  form of the constructor) does not protect against sending a message to the wrong domain. The
  window object is actualy a WindowProxy which transparently proxies the Window object of the
  underlying iframe, so that when the iframe is navigated, the "same" WindowProxy now references a
  completely differeent Window object, possibly controlled by a hostile domain.

  See http://www.esdiscuss.org/topic/a-dom-use-case-that-can-t-be-emulated-with-direct-proxies for
  more about this weird behavior of WindowProxies (the type returned by <iframe>.contentWindow).
*/

module.exports = function ParentEndpoint(targetWindowOrIframeEl, targetOrigin, afterConnectedCallback) {
  var postMessageQueue = [];
  var connected = false;
  var handlers = {};
  var targetWindowIsIframeElement;

  function getIframeOrigin(iframe) {
    return iframe.src.match(/(.*?\/\/.*?)\//)[1];
  }

  function post(type, content) {
    var message;
    // Message object can be constructed from 'type' and 'content' arguments or it can be passed
    // as the first argument.
    if (arguments.length === 1 && typeof type === 'object' && typeof type.type === 'string') {
      message = type;
    } else {
      message = {
        type: type,
        content: content
      };
    }
    if (connected) {
      var tWindow = getTargetWindow();
      // if we are laready connected ... send the message
      // See http://dev.opera.com/articles/view/window-postmessage-messagechannel/#crossdoc
      //     https://github.com/Modernizr/Modernizr/issues/388
      //     http://jsfiddle.net/ryanseddon/uZTgD/2/
      if (structuredClone.supported()) {
        tWindow.postMessage(message, targetOrigin);
      } else {
        tWindow.postMessage(JSON.stringify(message), targetOrigin);
      }
    } else {
      // else queue up the messages to send after connection complete.
      postMessageQueue.push(message);
    }
  }

  function addListener(messageName, func) {
    handlers[messageName] = func;
  }

  function removeListener(messageName) {
    handlers[messageName] = null;
  }

  // Note that this function can't be used when IFrame element hasn't been added to DOM yet
  // (.contentWindow would be null). At the moment risk is purely theoretical, as the parent endpoint
  // only listens for an incoming 'hello' message and the first time we call this function
  // is in #receiveMessage handler (so iframe had to be initialized before, as it could send 'hello').
  // It would become important when we decide to refactor the way how communication is initialized.
  function getTargetWindow() {
    if (targetWindowIsIframeElement) {
      var tWindow = targetWindowOrIframeEl.contentWindow;
      if (!tWindow) {
        throw "IFrame element needs to be added to DOM before communication " +
              "can be started (.contentWindow is not available)";
      }
      return tWindow;
    }
    return targetWindowOrIframeEl;
  }

  function receiveMessage(message) {
    var messageData;
    if (message.source === getTargetWindow() && (targetOrigin === '*' || message.origin === targetOrigin)) {
      messageData = message.data;
      if (typeof messageData === 'string') {
        messageData = JSON.parse(messageData);
      }
      if (handlers[messageData.type]) {
        handlers[messageData.type](messageData.content);
      } else {
        console.log("cant handle type: " + messageData.type);
      }
    }
  }

  function disconnect() {
    connected = false;
    window.removeEventListener('message', receiveMessage);
  }

  // handle the case that targetWindowOrIframeEl is actually an <iframe> rather than a Window(Proxy) object
  // Note that if it *is* a WindowProxy, this probe will throw a SecurityException, but in that case
  // we also don't need to do anything
  try {
    targetWindowIsIframeElement = targetWindowOrIframeEl.constructor === HTMLIFrameElement;
  } catch (e) {
    targetWindowIsIframeElement = false;
  }

  if (targetWindowIsIframeElement) {
    // Infer the origin ONLY if the user did not supply an explicit origin, i.e., if the second
    // argument is empty or is actually a callback (meaning it is supposed to be the
    // afterConnectionCallback)
    if (!targetOrigin || targetOrigin.constructor === Function) {
      afterConnectedCallback = targetOrigin;
      targetOrigin = getIframeOrigin(targetWindowOrIframeEl);
    }
  }

  // Handle pages served through file:// protocol. Behaviour varies in different browsers. Safari sets origin
  // to 'file://' and everything works fine, but Chrome and Safari set message.origin to null.
  // Also, https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage says:
  //  > Lastly, posting a message to a page at a file: URL currently requires that the targetOrigin argument be "*".
  //  > file:// cannot be used as a security restriction; this restriction may be modified in the future.
  // So, using '*' seems like the only possible solution.
  if (targetOrigin === 'file://') {
    targetOrigin = '*';
  }

  // when we receive 'hello':
  addListener('hello', function () {
    connected = true;

    // send hello response
    post({
      type: 'hello',
      // `origin` property isn't used by IframeEndpoint anymore (>= 1.2.0), but it's being sent to be
      // backward compatible with old IframeEndpoint versions (< v1.2.0).
      origin: window.location.href.match(/(.*?\/\/.*?)\//)[1]
    });

    // give the user a chance to do things now that we are connected
    // note that is will happen before any queued messages
    if (afterConnectedCallback && typeof afterConnectedCallback === "function") {
      afterConnectedCallback();
    }

    // Now send any messages that have been queued up ...
    while (postMessageQueue.length > 0) {
      post(postMessageQueue.shift());
    }
  });

  window.addEventListener('message', receiveMessage, false);

  // Public API.
  return {
    post: post,
    addListener: addListener,
    removeListener: removeListener,
    disconnect: disconnect,
    getTargetWindow: getTargetWindow,
    targetOrigin: targetOrigin
  };
};

},{"./structured-clone":13}],13:[function(require,module,exports){
var featureSupported = false;

(function () {
  var result = 0;

  if (!!window.postMessage) {
    try {
      // Safari 5.1 will sometimes throw an exception and sometimes won't, lolwut?
      // When it doesn't we capture the message event and check the
      // internal [[Class]] property of the message being passed through.
      // Safari will pass through DOM nodes as Null iOS safari on the other hand
      // passes it through as DOMWindow, gotcha.
      window.onmessage = function (e) {
        var type = Object.prototype.toString.call(e.data);
        result = (type.indexOf("Null") != -1 || type.indexOf("DOMWindow") != -1) ? 1 : 0;
        featureSupported = {
          'structuredClones': result
        };
      };
      // Spec states you can't transmit DOM nodes and it will throw an error
      // postMessage implimentations that support cloned data will throw.
      window.postMessage(document.createElement("a"), "*");
    } catch (e) {
      // BBOS6 throws but doesn't pass through the correct exception
      // so check error message
      result = (e.DATA_CLONE_ERR || e.message == "Cannot post cyclic structures.") ? 1 : 0;
      featureSupported = {
        'structuredClones': result
      };
    }
  }
}());

exports.supported = function supported() {
  return featureSupported && featureSupported.structuredClones > 0;
};

},{}],14:[function(require,module,exports){
module.exports = {
  /**
   * Allows to communicate with an iframe.
   */
  ParentEndpoint:  require('./lib/parent-endpoint'),
  /**
   * Allows to communicate with a parent page.
   * IFrameEndpoint is a singleton, as iframe can't have multiple parents anyway.
   */
  getIFrameEndpoint: require('./lib/iframe-endpoint'),
  structuredClone: require('./lib/structured-clone'),

  // TODO: May be misnamed
  IframePhoneRpcEndpoint: require('./lib/iframe-phone-rpc-endpoint')

};

},{"./lib/iframe-endpoint":10,"./lib/iframe-phone-rpc-endpoint":11,"./lib/parent-endpoint":12,"./lib/structured-clone":13}],15:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],16:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],17:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],18:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":19}],19:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],20:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":21}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":23,"./_stream_writable":25,"core-util-is":4,"inherits":15,"process-nextick-args":18}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":24,"core-util-is":4,"inherits":15}],23:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":21,"./internal/streams/BufferList":26,"./internal/streams/destroy":27,"./internal/streams/stream":28,"_process":19,"core-util-is":4,"events":8,"inherits":15,"isarray":17,"process-nextick-args":18,"safe-buffer":29,"string_decoder/":30,"util":2}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":21,"core-util-is":4,"inherits":15}],25:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":21,"./internal/streams/destroy":27,"./internal/streams/stream":28,"_process":19,"core-util-is":4,"inherits":15,"process-nextick-args":18,"safe-buffer":29,"timers":36,"util-deprecate":38}],26:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":29,"util":2}],27:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":18}],28:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":8}],29:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":3}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":29}],31:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":32}],32:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":21,"./lib/_stream_passthrough.js":22,"./lib/_stream_readable.js":23,"./lib/_stream_transform.js":24,"./lib/_stream_writable.js":25}],33:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":32}],34:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":25}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":8,"inherits":15,"readable-stream/duplex.js":20,"readable-stream/passthrough.js":31,"readable-stream/readable.js":32,"readable-stream/transform.js":33,"readable-stream/writable.js":34}],36:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":19,"timers":36}],37:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Tone=e():t.Tone=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function n(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,s){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(s,i,function(e){return t[e]}.bind(null,i));return s},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=684)}([function(t,e,n){"use strict";n.d(e,"a",(function(){return s})),n.d(e,"b",(function(){return i})),n.d(e,"c",(function(){return o})),n.d(e,"d",(function(){return r})),n.d(e,"e",(function(){return a})),n.d(e,"f",(function(){return c})),n.d(e,"g",(function(){return u})),n.d(e,"i",(function(){return h})),n.d(e,"h",(function(){return l})),n.d(e,"j",(function(){return d})),n.d(e,"k",(function(){return p}));const s=new WeakSet,i=new WeakMap,o=new WeakMap,r=new WeakMap,a=new WeakMap,c=new WeakMap,u=new WeakMap,h=new WeakMap,l=new WeakMap,d=new WeakMap,p=new WeakMap},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(4);const i=(t,e)=>{Object(s.a)(t,e,"channelCount"),Object(s.a)(t,e,"channelCountMode"),Object(s.a)(t,e,"channelInterpretation")}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s})),n.d(e,"b",(function(){return i}));const s=-34028234663852886e22,i=-s},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>t.context===e},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>{const s=e[n];void 0!==s&&s!==t[n]&&(t[n]=s)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>{const s=e[n];void 0!==s&&s!==t[n].value&&(t[n].value=s)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(9);const o=t=>Object(i.a)(s.c,t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","InvalidStateError")}catch(t){return t.code=11,t.name="InvalidStateError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(9);const o=t=>Object(i.a)(s.b,t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>{const n=t.get(e);if(void 0===n)throw new Error("A value with the given key could not be found.");return n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","NotSupportedError")}catch(t){return t.code=9,t.name="NotSupportedError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>(t.connect=e.connect.bind(e),t.disconnect=e.disconnect.bind(e),t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>"inputs"in t},function(t,e,n){"use strict";n.d(e,"AudioContext",(function(){return Oi})),n.d(e,"AudioWorkletNode",(function(){return qi})),n.d(e,"OfflineAudioContext",(function(){return Vi})),n.d(e,"isAnyAudioContext",(function(){return Ni})),n.d(e,"isAnyAudioNode",(function(){return Pi})),n.d(e,"isAnyAudioParam",(function(){return Li})),n.d(e,"isAnyOfflineAudioContext",(function(){return zi})),n.d(e,"isSupported",(function(){return Bi}));var s=n(18),i=n(516),o=n(517),r=n(518),a=n(667),c=n(519),u=n(520),h=n(521),l=n(522),d=n(523),p=n(524),f=n(525),_=n(526),m=n(527),g=n(528),v=n(529),y=n(665),b=n(530),x=n(531),w=n(532),T=n(670),O=n(533),S=n(534),C=n(535),k=n(536),A=n(537),D=n(538),M=n(539),j=n(540),E=n(541),R=n(542),q=n(543),I=n(544),F=n(545),V=n(546),N=n(547),P=n(548),L=n(549),z=n(550),B=n(671),W=n(551),U=n(552),G=n(553),Y=n(554),Q=n(672),Z=n(555),X=n(556),H=n(557),$=n(558),J=n(559),K=n(560),tt=n(561),et=n(562),nt=n(563),st=n(564),it=n(565),ot=n(566),rt=n(567),at=n(568),ct=n(569),ut=n(673),ht=n(570),lt=n(571),dt=n(15),pt=n(37),ft=n(7),_t=n(572),mt=n(573),gt=n(574),vt=n(575),yt=n(576),bt=n(577),xt=n(578),wt=n(579),Tt=n(580),Ot=n(581),St=n(582),Ct=n(583),kt=n(584),At=n(585),Dt=n(586),Mt=n(587),jt=n(588),Et=n(589),Rt=n(590),qt=n(668),It=n(591),Ft=n(669),Vt=n(592),Nt=n(593),Pt=n(594),Lt=n(595),zt=n(674),Bt=n(666),Wt=n(596),Ut=n(597),Gt=n(675),Yt=n(598),Qt=n(599),Zt=n(600),Xt=n(601),Ht=n(602),$t=n(603),Jt=n(604),Kt=n(605),te=n(606),ee=n(607),ne=n(608),se=n(609),ie=n(610),oe=n(611),re=n(612),ae=n(613),ce=n(614),ue=n(615),he=n(616),le=n(617),de=n(618),pe=n(619),fe=n(620),_e=n(10),me=n(621),ge=n(622),ve=n(623),ye=n(624),be=n(625),xe=n(626),we=n(627),Te=n(628),Oe=n(629),Se=n(630),Ce=n(631),ke=n(632),Ae=n(633),De=n(634),Me=n(635),je=n(636),Ee=n(637),Re=n(638),qe=n(639),Ie=n(640),Fe=n(641),Ve=n(642),Ne=n(643),Pe=n(644),Le=n(645),ze=n(646),Be=n(647),We=n(648),Ue=n(649),Ge=n(650),Ye=n(651),Qe=n(652),Ze=n(653),Xe=n(654),He=n(44),$e=n(655),Je=n(656),Ke=n(657),tn=n(658),en=n(659),nn=n(660),sn=n(661),on=n(662),rn=n(0),an=n(33),cn=n(34),un=n(8),hn=n(26),ln=n(6),dn=n(27),pn=n(9),fn=n(16),_n=n(23),mn=n(45),gn=n(19),vn=n(38),yn=n(32),bn=n(14),xn=n(663),wn=n(664),Tn=n(28);n(46),n(130);const On=Object(k.a)(new Map,new WeakMap),Sn=Object(Ke.a)(),Cn=Object(oe.a)(Sn),kn=Object(Tt.a)(Cn),An=Object(Vt.a)(Sn),Dn=Object(rt.a)(kn,An,Cn),Mn=Object(Pt.a)(Dn),jn=Object(qt.a)(On,dt.a,Mn),En=Object(it.a)(un.a),Rn=Object(Te.a)(un.a,En,gn.a),qn=Object(l.a)(jn,ln.a,Rn),In=new WeakMap,Fn=Object(at.a)(rn.g),Vn=new WeakMap,Nn=Object(K.a)(Tn.a),Pn=Object(yt.a)(An),Ln=Object(bt.a)(Sn),zn=Object(xt.a)(Sn),Bn=Object(y.a)(Object(o.a)(rn.b),In,On,Object(lt.a)(rn.h,cn.a,un.a,ln.a,dn.a,_n.a),dt.a,pt.a,_e.a,Object(W.a)(an.a,rn.h,un.a,ln.a,dn.a,Fn,_n.a,kn),Object(Q.a)(Vn,un.a,pn.a),Nn,Fn,Pn,Ln,zn,kn),Wn=Object(h.a)(Bn,qn,dt.a,jn,Fn,kn),Un=new WeakSet,Gn=Object(It.a)(Sn),Yn=Object(V.a)(new Uint32Array(1)),Qn=Object(tn.a)(Yn,dt.a),Zn=Object(en.a)(Yn),Xn=Object(d.a)(Un,On,_e.a,Gn,Cn,Object(De.a)(Gn),Qn,Zn),Hn=Object(Jt.a)(Mn),$n=Object(c.a)(Hn),Jn=Object(Pe.a)(Mn),Kn=Object(Le.a)(Mn),ts=Object(ze.a)(Mn),es=Object(sn.a)(Mn),ns=Object(Oe.a)(En,hn.a,gn.a),ss=Object(E.a)(ns),is=Object(Ft.a)($n,On,Mn,Object(je.a)(Mn),Object(Ee.a)(Cn),Object(Re.a)(Mn),Object(qe.a)(Mn),Jn,Kn,ts,wn.a,Object(nn.a)(vn.a),es),os=Object(we.a)(Object(ot.a)(hn.a),ns),rs=Object(f.a)(ss,is,ln.a,os,Rn),as=Object(b.a)(Object(r.a)(rn.d),Vn,rn.e,x.a,s.createCancelAndHoldAutomationEvent,s.createCancelScheduledValuesAutomationEvent,s.createExponentialRampToValueAutomationEvent,s.createLinearRampToValueAutomationEvent,s.createSetTargetAutomationEvent,s.createSetValueAutomationEvent,s.createSetValueCurveAutomationEvent,An),cs=Object(p.a)(Bn,rs,as,ft.a,is,Fn,kn,Tn.a),us=Object(m.a)(Bn,g.a,dt.a,ft.a,Object(Nt.a)(Hn,vn.a),Fn,kn,Rn),hs=Object(Wt.a)(Mn),ls=Object(C.a)(ss,hs,ln.a,os,Rn),ds=Object(S.a)(Bn,as,ls,pt.a,hs,Fn,kn),ps=Object(Rt.a)(fn.a,Ln),fs=Object(on.a)(ft.a,Mn,ps),_s=Object(Ut.a)(Mn,fs),ms=Object(D.a)(_s,ln.a,Rn),gs=Object(A.a)(Bn,ms,_s,Fn,kn),vs=Object(Gt.a)(Mn),ys=Object(j.a)(vs,ln.a,Rn),bs=Object(M.a)(Bn,ys,vs,Fn,kn),xs=Object(Qt.a)($n,is,Hn,ps),ws=Object(Yt.a)($n,On,Mn,xs,Jn,ts),Ts=Object(F.a)(ss,ws,ln.a,os,Rn),Os=Object(I.a)(Bn,as,Ts,ws,Fn,kn,Tn.a),Ss=Object(Xt.a)(Mn,Hn,ps),Cs=Object(Zt.a)(Mn,Ss,_e.a,vn.a),ks=Object(P.a)(Cs,ln.a,Rn),As=Object(N.a)(Bn,ks,Cs,Fn,kn),Ds=Object(Ht.a)(Mn),Ms=Object(G.a)(ss,Ds,ln.a,os,Rn),js=Object(U.a)(Bn,as,Ms,Ds,Fn,kn),Es=Object($t.a)(Mn,_e.a),Rs=Object(H.a)(ss,Es,ln.a,os,Rn),qs=Object(X.a)(Bn,as,Rs,Es,_e.a,Fn,kn),Is=Object(st.a)(ss,Hn,ln.a,os,Rn),Fs=Object(nt.a)(Bn,as,Is,Hn,Fn,kn),Vs=Object(he.a)(Mn),Ns=Object(te.a)(pt.a,ft.a,Vs,_e.a),Ps=Object(Se.a)(On,Hn,Vs,Object(Ze.a)(Hn,Cn)),Ls=Object(ht.a)(is,Mn,ln.a,Cn,Rn,Ps),zs=Object(Kt.a)(Mn,Ns),Bs=Object(ut.a)(Bn,zs,Ls,Fn,kn),Ws=Object(v.a)(as,_s,ws,Vs,kn),Us=new WeakMap,Gs=Object(jt.a)(us,Ws,Nn,kn,Us,Tn.a),Ys=Object(re.a)($n,On,Mn,Jn,Kn,ts,es),Qs=Object(ve.a)(ss,Ys,ln.a,os,Rn),Zs=Object(ge.a)(Bn,as,ft.a,Ys,Qs,Fn,kn,Tn.a),Xs=Object(q.a)(is),Hs=Object(fe.a)(Xs,ft.a,Mn,Hn,mn.a,ps),$s=Object(pe.a)(Xs,ft.a,Mn,Hs,mn.a,ps,vn.a),Js=Object(ce.a)(an.a,ft.a,Mn,_s,Hn,Vs,$s,_e.a,cn.a,ps),Ks=Object(ae.a)(Mn,Js),ti=Object(be.a)(ss,_s,ws,Hn,Ks,ln.a,Cn,os,Rn,Ps),ei=Object(ye.a)(Bn,as,Ks,ti,Fn,kn),ni=Object(ue.a)(Dn),si=Object(xe.a)(ni,Fn,new WeakSet),ii=Object(de.a)(_s,vs,Hn,$s,_e.a,ps),oi=Object(le.a)(Mn,ii,_e.a),ri=Object(Ae.a)(ss,oi,ln.a,os,Rn),ai=Object(ke.a)(Bn,as,oi,ri,Fn,kn),ci=Object(Je.a)($s,ln.a,Rn),ui=Object($e.a)(Bn,ft.a,$s,ci,Fn,kn),hi=Object(Ot.a)(Sn),li=Object(tt.a)(Sn),di=hi?Object(a.a)(_e.a,Object(J.a)(Sn),li,Object(et.a)(i.a),Dn,Fn,new WeakMap,new WeakMap,Sn):void 0,pi=Object(wt.a)(Pn,kn),fi=Object(B.a)(Un,On,z.a,$.a,new WeakSet,Fn,pi,kn,Cn,yn.a,bn.a,Qn,Zn),_i=Object(O.a)(di,Wn,Xn,cs,ds,gs,bs,Os,As,fi,js,qs,Fs,Bs,Gs,Zs,ei,si,ai,ui),mi=Object(ee.a)(Mn),gi=Object(Ct.a)(Bn,mi,Fn,kn),vi=Object(ne.a)(Mn,_e.a),yi=Object(kt.a)(Bn,vi,Fn,kn),bi=Object(se.a)(Mn),xi=Object(At.a)(Bn,bi,Fn,kn),wi=Object(ie.a)(ft.a,Mn,kn),Ti=Object(Dt.a)(Bn,wi,Fn),Oi=Object(_.a)(_i,ft.a,_e.a,He.a,gi,yi,xi,Ti,An),Si=Object(ct.a)(Us),Ci=Object(u.a)(Si),ki=Object(R.a)(dt.a),Ai=Object(Y.a)(Si),Di=Object(Z.a)(dt.a),Mi=Object(Bt.a)(In,ki,dt.a,ft.a,_s,vs,ws,Hn,Vs,_e.a,Di,li,ps),ji=Object(zt.a)(ft.a,Mn,Mi,Hn,_e.a,ps),Ei=Object(Lt.a)(Sn),Ri=Object(T.a)(ss,ki,is,_s,vs,ws,Hn,Ai,Di,li,ln.a,Ei,Cn,os,Rn,Ps),qi=hi?Object(w.a)(Ci,Bn,as,Ri,ji,Fn,kn,Ei,Tn.a):void 0,Ii=(Object(Mt.a)(ft.a,_e.a,He.a,Gs,An),Object(L.a)(_e.a,Cn)),Fi=Object(Ce.a)(Un,On,En,Si,Ps,yn.a,Qn,Zn),Vi=(Object(Et.a)(On,ft.a,Ii,Gs,Fi),Object(me.a)(_i,On,ft.a,Ii,Fi)),Ni=Object(_t.a)(rn.g,Pn),Pi=Object(mt.a)(rn.c,Ln),Li=Object(gt.a)(rn.e,zn),zi=Object(vt.a)(rn.g,kn),Bi=()=>Object(St.a)(On,Object(Me.a)(Cn),Object(Ie.a)(An),Object(Fe.a)(Cn),Object(Ve.a)(An),Object(Ne.a)(Cn),Object(Be.a)(Ei,Cn),Object(We.a)(Mn,Cn),Object(Ue.a)(Mn,Cn),Object(Ge.a)(Cn),Object(Ye.a)(Sn),Object(Qe.a)(An),Object(Xe.a)(Cn),xn.a)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{const e=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const n=t.decodeAudioData(e.buffer,()=>{});return void 0!==n&&(n.catch(()=>{}),!0)}catch{}return!1}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","IndexSizeError")}catch(t){return t.code=1,t.name="IndexSizeError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s)=>{for(const e of t)if(n(e)){if(s)return!1;throw Error("The set contains at least one similar element.")}return t.add(e),!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(20);const o=t=>{if(s.a.has(t))throw new Error("The AudioNode is already stored.");s.a.add(t),Object(i.a)(t).forEach(t=>t(!0))}},function(t,e,n){!function(t,e,n,s){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e,n=n&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n,s=s&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s;var i=function(t,e,n){return{endTime:e,insertTime:n,type:"exponentialRampToValue",value:t}},o=function(t,e,n){return{endTime:e,insertTime:n,type:"linearRampToValue",value:t}},r=function(t,e){return{startTime:e,type:"setValue",value:t}},a=function(t,e,n){return{duration:n,startTime:e,type:"setValueCurve",values:t}},c=function(t,e,n){var s=n.startTime,i=n.target,o=n.timeConstant;return i+(e-i)*Math.exp((s-t)/o)},u=function(t){return"exponentialRampToValue"===t.type},h=function(t){return"linearRampToValue"===t.type},l=function(t){return u(t)||h(t)},d=function(t){return"setValue"===t.type},p=function(t){return"setValueCurve"===t.type},f=function t(e,n,s,i){var o=e[n];return void 0===o?i:l(o)||d(o)?o.value:p(o)?o.values[o.values.length-1]:c(s,t(e,n-1,o.startTime,i),o)},_=function(t,e,n,s,i){return void 0===n?[s.insertTime,i]:l(n)?[n.endTime,n.value]:d(n)?[n.startTime,n.value]:p(n)?[n.startTime+n.duration,n.values[n.values.length-1]]:[n.startTime,f(t,e-1,n.startTime,i)]},m=function(t){return"cancelAndHold"===t.type},g=function(t){return"cancelScheduledValues"===t.type},v=function(t){return m(t)||g(t)?t.cancelTime:u(t)||h(t)?t.endTime:t.startTime},y=function(t,e,n,s){var i=s.endTime,o=s.value;return n===o?o:0<n&&0<o||n<0&&o<0?n*Math.pow(o/n,(t-e)/(i-e)):0},b=function(t,e,n,s){return n+(t-e)/(s.endTime-e)*(s.value-n)},x=function(t,e){var n=e.duration,s=e.startTime,i=e.values;return function(t,e){var n=Math.floor(e),s=Math.ceil(e);return n===s?t[n]:(1-(e-n))*t[n]+(1-(s-e))*t[s]}(i,(t-s)/n*(i.length-1))},w=function(t){return"setTarget"===t.type},T=function(){function t(e){n(this,t),this._automationEvents=[],this._currenTime=0,this._defaultValue=e}return s(t,[{key:Symbol.iterator,value:function(){return this._automationEvents[Symbol.iterator]()}},{key:"add",value:function(t){var e=v(t);if(m(t)||g(t)){var n=this._automationEvents.findIndex((function(t){return v(t)>=e})),s=this._automationEvents[n];if(-1!==n&&(this._automationEvents=this._automationEvents.slice(0,n)),m(t)){var c=this._automationEvents[this._automationEvents.length-1];if(void 0!==s&&l(s)){if(w(c))throw new Error("The internal list is malformed.");var d=p(c)?c.startTime+c.duration:v(c),f=p(c)?c.values[c.values.length-1]:c.value,_=u(s)?y(e,d,f,s):b(e,d,f,s),x=u(s)?i(_,e,this._currenTime):o(_,e,this._currenTime);this._automationEvents.push(x)}void 0!==c&&w(c)&&this._automationEvents.push(r(this.getValue(e),e)),void 0!==c&&p(c)&&c.startTime+c.duration>e&&(this._automationEvents[this._automationEvents.length-1]=a(new Float32Array([6,7]),c.startTime,e-c.startTime))}}else{var T=this._automationEvents.findIndex((function(t){return v(t)>e})),O=-1===T?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[T-1];if(void 0!==O&&p(O)&&v(O)+O.duration>e)return!1;var S=u(t)?i(t.value,t.endTime,this._currenTime):h(t)?o(t.value,e,this._currenTime):t;if(-1===T)this._automationEvents.push(S);else{if(p(t)&&e+t.duration>v(this._automationEvents[T]))return!1;this._automationEvents.splice(T,0,S)}}return!0}},{key:"flush",value:function(t){var e=this._automationEvents.findIndex((function(e){return v(e)>t}));if(e>1){var n=this._automationEvents.slice(e-1),s=n[0];w(s)&&n.unshift(r(f(this._automationEvents,e-2,s.startTime,this._defaultValue),s.startTime)),this._automationEvents=n}}},{key:"getValue",value:function(t){if(0===this._automationEvents.length)return this._defaultValue;var n=this._automationEvents[this._automationEvents.length-1],s=this._automationEvents.findIndex((function(e){return v(e)>t})),i=this._automationEvents[s],o=v(n)<=t?n:this._automationEvents[s-1];if(void 0!==o&&w(o)&&(void 0===i||!l(i)||i.insertTime>t))return c(t,f(this._automationEvents,s-2,o.startTime,this._defaultValue),o);if(void 0!==o&&d(o)&&(void 0===i||!l(i)))return o.value;if(void 0!==o&&p(o)&&(void 0===i||!l(i)||o.startTime+o.duration>t))return t<o.startTime+o.duration?x(t,o):o.values[o.values.length-1];if(void 0!==o&&l(o)&&(void 0===i||!l(i)))return o.value;if(void 0!==i&&u(i)){var r=_(this._automationEvents,s-1,o,i,this._defaultValue),a=e(r,2),m=a[0],g=a[1];return y(t,m,g,i)}if(void 0!==i&&h(i)){var T=_(this._automationEvents,s-1,o,i,this._defaultValue),O=e(T,2),S=O[0],C=O[1];return b(t,S,C,i)}return this._defaultValue}}]),t}();t.AutomationEventList=T,t.createCancelAndHoldAutomationEvent=function(t){return{cancelTime:t,type:"cancelAndHold"}},t.createCancelScheduledValuesAutomationEvent=function(t){return{cancelTime:t,type:"cancelScheduledValues"}},t.createExponentialRampToValueAutomationEvent=function(t,e){return{endTime:e,type:"exponentialRampToValue",value:t}},t.createLinearRampToValueAutomationEvent=function(t,e){return{endTime:e,type:"linearRampToValue",value:t}},t.createSetTargetAutomationEvent=function(t,e,n){return{startTime:e,target:t,timeConstant:n,type:"setTarget"}},t.createSetValueAutomationEvent=r,t.createSetValueCurveAutomationEvent=a,Object.defineProperty(t,"__esModule",{value:!0})}(e,n(676),n(682),n(683))},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(0);const i=t=>s.h.has(t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(9);const o=t=>Object(i.a)(s.i,t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(20);const o=t=>{if(!s.a.has(t))throw new Error("The AudioNode is not stored.");s.a.delete(t),Object(i.a)(t).forEach(t=>t(!1))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(24);const i=t=>Object(s.a)(t[0])},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(0);const i=t=>s.a.has(t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>"context"in t},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>"context"in t},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(9);const o=t=>Object(i.a)(s.d,t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(0),i=n(9);const o=t=>Object(i.a)(s.e,t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>{const s={value:t};return Object.defineProperties(n,{currentTarget:s,target:s}),"function"==typeof e?e.call(t,n):e.handleEvent.call(t,n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(15);const i=t=>{var e;t.getChannelData=(e=t.getChannelData,n=>{try{return e.call(t,n)}catch(t){if(12===t.code)throw Object(s.a)();throw t}})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{var e;t.start=(e=t.start,(n=0,s=0,i)=>{if("number"==typeof i&&i<0||s<0||n<0)throw new RangeError("The parameters can't be negative.");e.call(t,n,s,i)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{var e;t.stop=(e=t.stop,(n=0)=>{if(n<0)throw new RangeError("The parameter can't be negative.");e.call(t,n)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{try{t.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(12);const i=(t,e,n,i)=>{if(Object(s.a)(e)){const s=e.inputs[i];return t.connect(s,n,0),[s,n,0]}return t.connect(e,n,i),[e,n,i]}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(12);const i=(t,e,n,i)=>{Object(s.a)(e)?t.disconnect(e.inputs[i],n,0):t.disconnect(e,n,i)}},function(t,e,n){"use strict";function s(t,e,n,s,i){if("function"==typeof t.copyFromChannel)0===e[n].byteLength&&(e[n]=new Float32Array(128)),t.copyFromChannel(e[n],s,i);else{const o=t.getChannelData(s);if(0===e[n].byteLength)e[n]=o.slice(i,i+128);else{const t=new Float32Array(o.buffer,i*Float32Array.BYTES_PER_ELEMENT,128);e[n].set(t)}}}n.d(e,"a",(function(){return s}))},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>{const n=[];for(let s=0;s<t;s+=1){const t=[],i="number"==typeof e?e:e[s];for(let e=0;e<i;e+=1)t.push(new Float32Array(128));n.push(t)}return n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","InvalidAccessError")}catch(t){return t.code=15,t.name="InvalidAccessError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s)=>{let i=Object.getPrototypeOf(t);for(;!i.hasOwnProperty(e);)i=Object.getPrototypeOf(i);const{get:o,set:r}=Object.getOwnPropertyDescriptor(i,e);Object.defineProperty(t,e,{get:n(o),set:s(r)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>void 0===t||"number"==typeof t||"string"==typeof t&&("balanced"===t||"interactive"===t||"playback"===t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));class s{constructor(t){this._map=new Map(t)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(t,e=null){return this._map.forEach((n,s)=>t.call(e,n,s,this))}get(t){return this._map.get(t)}has(t){return this._map.has(t)}keys(){return this._map.keys()}values(){return this._map.values()}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s,i)=>{"function"==typeof t.copyToChannel?0!==e[n].byteLength&&t.copyToChannel(e[n],s,i):0!==e[n].byteLength&&t.getChannelData(s).set(e[n],i)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s,i,o,r,a,c,u,h)=>{const l=u.length;let d=a;for(let a=0;a<l;a+=1){let l=n[0]*u[a];for(let e=1;e<i;e+=1){const s=d-e&c-1;l+=n[e]*o[s],l-=t[e]*r[s]}for(let t=i;t<s;t+=1)l+=n[t]*o[d-t&c-1];for(let n=i;n<e;n+=1)l-=t[n]*r[d-n&c-1];o[d]=u[a],r[d]=l,d=d+1&c-1,h[a]=l}return d}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>null===t?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(t*e)))))},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","UnknownError")}catch(t){return t.name="UnknownError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{if(null===t)return!1;const e=t.length;return e%2!=0?0!==t[Math.floor(e/2)]:t[e/2-1]+t[e/2]!==0}},function(t,e,n){"use strict";n(47),n(48),n(49),n(50),n(51),n(52),n(53),n(54),n(55),n(56),n(57),n(58),n(59),n(60),n(61),n(62),n(63),n(64),n(65),n(66),n(67),n(68),n(69),n(70),n(71),n(72),n(73),n(74),n(75),n(76),n(77),n(78),n(79),n(80),n(81),n(82),n(83),n(84),n(85),n(86),n(87),n(88),n(89),n(90),n(91),n(92),n(93),n(94),n(95),n(96),n(97),n(98),n(99),n(100),n(101),n(102),n(103),n(104),n(105),n(106),n(107),n(108),n(109),n(110),n(111),n(112),n(113),n(114),n(115),n(116),n(117),n(118),n(119),n(120),n(121),n(122),n(123),n(124),n(125),n(126),n(127),n(128),n(129)},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e,n){"use strict";n(131),n(132),n(133),n(134),n(135),n(136),n(137),n(138),n(139),n(140),n(141),n(142),n(143),n(144),n(145),n(146),n(147),n(148),n(149),n(150),n(151),n(152),n(153),n(154),n(155),n(156),n(157),n(158),n(159),n(160),n(161),n(162),n(163),n(164),n(165),n(166),n(167),n(168),n(169),n(170),n(171),n(172),n(173),n(174),n(175),n(176),n(177),n(178),n(179),n(180),n(181),n(182),n(183),n(184),n(185),n(186),n(187),n(188),n(189),n(190),n(191),n(192),n(193),n(194),n(195),n(196),n(197),n(198),n(199),n(200),n(201),n(202),n(203),n(204),n(205),n(206),n(207),n(208),n(209),n(210),n(211),n(212),n(213),n(214),n(215),n(216),n(217),n(218),n(219),n(220),n(221),n(222),n(223),n(224),n(225),n(226),n(227),n(228),n(229),n(230),n(231),n(232),n(233),n(234),n(235),n(236),n(237),n(238),n(239),n(240),n(241),n(242),n(243),n(244),n(245),n(246),n(247),n(248),n(249),n(250),n(251),n(252),n(253),n(254),n(255),n(256),n(257),n(258),n(259),n(260),n(261),n(262),n(263),n(264),n(265),n(266),n(267),n(268),n(269),n(270),n(271),n(272),n(273),n(274),n(275),n(276),n(277),n(278),n(279),n(280),n(281),n(282),n(283),n(284),n(285),n(286),n(287),n(288),n(289),n(290),n(291),n(292),n(293),n(294),n(295),n(296),n(297),n(298),n(299),n(300),n(301),n(302),n(303),n(304),n(305),n(306),n(307),n(308),n(309),n(310),n(311),n(312),n(313),n(314),n(315),n(316),n(317),n(318),n(319),n(320),n(321),n(322),n(323),n(324),n(325),n(326),n(327),n(328),n(329),n(330),n(331),n(332),n(333),n(334),n(335),n(336),n(337),n(338),n(339),n(340),n(341),n(342),n(343),n(344),n(345),n(346),n(347),n(348),n(349),n(350),n(351),n(352),n(353),n(354),n(355),n(356),n(357),n(358),n(359),n(360),n(361),n(362),n(363),n(364),n(365),n(366),n(367),n(368),n(369),n(370),n(371),n(372),n(373),n(374),n(375),n(376),n(377),n(378),n(379),n(380),n(381),n(382),n(383),n(384),n(385),n(386),n(387),n(388),n(389),n(390),n(391),n(392),n(393),n(394),n(395),n(396),n(397),n(398),n(399),n(400),n(401),n(402),n(403),n(404),n(405),n(406),n(407),n(408),n(409),n(410),n(411),n(412),n(413),n(414),n(415),n(416),n(417),n(418),n(419),n(420),n(421),n(422),n(423),n(424),n(425),n(426),n(427),n(428),n(429),n(430),n(431),n(432),n(433),n(434),n(435),n(436),n(437),n(438),n(439),n(440),n(441),n(442),n(443),n(444),n(445),n(446),n(447),n(448),n(449),n(450),n(451),n(452),n(453),n(454),n(455),n(456),n(457),n(458),n(459),n(460),n(461),n(462),n(463),n(464),n(465),n(466),n(467),n(468),n(469),n(470),n(471),n(472),n(473),n(474),n(475),n(476),n(477),n(478),n(479),n(480),n(481),n(482),n(483),n(484),n(485),n(486),n(487),n(488),n(489),n(490),n(491),n(492),n(493),n(494),n(495),n(496),n(497),n(498),n(499),n(500),n(501),n(502),n(503),n(504),n(505),n(506),n(507),n(508),n(509),n(510),n(511),n(512),n(513),n(514)},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","AbortError")}catch(t){return t.code=20,t.name="AbortError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n,s)=>{const i=[];for(let t=0;t<s.numberOfInputs;t+=1)i.push(new Set);t.set(e,{activeInputs:i,outputs:new Set,passiveInputs:new WeakMap,renderer:n})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{t.set(e,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:n})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{const s=t(e,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});n.connect(s).connect(s.context.destination);const i=()=>{n.removeEventListener("ended",i),n.disconnect(s),s.disconnect()};n.addEventListener("ended",i)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{t(e).add(n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8},i=(t,e,n,i,o,r)=>class extends t{constructor(t,n=s){const a=o(t),c={...s,...n},u=i(a,c);super(t,!1,u,r(a)?e():null),this._nativeAnalyserNode=u}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(t){this._nativeAnalyserNode.fftSize=t}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(t){const e=this._nativeAnalyserNode.maxDecibels;if(this._nativeAnalyserNode.maxDecibels=t,!(t>this._nativeAnalyserNode.minDecibels))throw this._nativeAnalyserNode.maxDecibels=e,n()}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(t){const e=this._nativeAnalyserNode.minDecibels;if(this._nativeAnalyserNode.minDecibels=t,!(this._nativeAnalyserNode.maxDecibels>t))throw this._nativeAnalyserNode.minDecibels=e,n()}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(t){this._nativeAnalyserNode.smoothingTimeConstant=t}getByteFrequencyData(t){this._nativeAnalyserNode.getByteFrequencyData(t)}getByteTimeDomainData(t){this._nativeAnalyserNode.getByteTimeDomainData(t)}getFloatFrequencyData(t){this._nativeAnalyserNode.getFloatFrequencyData(t)}getFloatTimeDomainData(t){this._nativeAnalyserNode.getFloatTimeDomainData(t)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n)=>()=>{const i=new WeakMap;return{render(o,r,a){const c=i.get(r);return void 0!==c?Promise.resolve(c):(async(o,r,a)=>{let c=e(o);if(!Object(s.a)(c,r)){const e={channelCount:c.channelCount,channelCountMode:c.channelCountMode,channelInterpretation:c.channelInterpretation,fftSize:c.fftSize,maxDecibels:c.maxDecibels,minDecibels:c.minDecibels,smoothingTimeConstant:c.smoothingTimeConstant};c=t(r,e)}return i.set(r,c),await n(o,r,c,a),c})(o,r,a)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var s=n(32),i=n(29);const o={numberOfChannels:1},r=(t,e,n,r,a,c,u,h)=>{let l=null;return class d{constructor(d){if(null===a)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:p,numberOfChannels:f,sampleRate:_}={...o,...d};null===l&&(l=new a(1,1,44100));const m=null!==r&&e(c,c)?new r({length:p,numberOfChannels:f,sampleRate:_}):l.createBuffer(f,p,_);if(0===m.numberOfChannels)throw n();return"function"!=typeof m.copyFromChannel?(u(m),Object(i.a)(m)):e(s.a,()=>Object(s.a)(m))||h(m),t.add(m),m}static[Symbol.hasInstance](e){return null!==e&&"object"==typeof e&&Object.getPrototypeOf(e)===d.prototype||t.has(e)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var s=n(2),i=n(17),o=n(21);const r={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},a=(t,e,n,a,c,u,h,l)=>class extends t{constructor(t,i=r){const o=u(t),a={...r,...i},l=c(o,a),d=h(o),p=d?e():null;super(t,!1,l,p),this._audioBufferSourceNodeRenderer=p,this._isBufferNullified=!1,this._isBufferSet=null!==i.buffer&&void 0!==i.buffer,this._nativeAudioBufferSourceNode=l,this._onended=null,this._playbackRate=n(this,d,l.playbackRate,s.b,s.a)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(t){try{this._nativeAudioBufferSourceNode.buffer=t}catch(e){if(null!==t||17!==e.code)throw e;if(null!==this._nativeAudioBufferSourceNode.buffer){const t=this._nativeAudioBufferSourceNode.buffer,e=t.numberOfChannels;for(let n=0;n<e;n+=1)t.getChannelData(n).fill(0);this._isBufferNullified=!0}}if(null!==t){if(this._isBufferSet)throw a();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(t){this._nativeAudioBufferSourceNode.loop=t}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(t){this._nativeAudioBufferSourceNode.loopEnd=t}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(t){this._nativeAudioBufferSourceNode.loopStart=t}get onended(){return this._onended}set onended(t){const e="function"==typeof t?l(this,t):null;this._nativeAudioBufferSourceNode.onended=e;const n=this._nativeAudioBufferSourceNode.onended;this._onended=null!==n&&n===e?t:n}get playbackRate(){return this._playbackRate}start(t=0,e=0,n){if(this._nativeAudioBufferSourceNode.start(t,e,n),null!==this._audioBufferSourceNodeRenderer)this._audioBufferSourceNodeRenderer.start=void 0===n?[t,e]:[t,e,n];else{Object(i.a)(this);const t=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",t),setTimeout(()=>Object(o.a)(this),1e3)};this._nativeAudioBufferSourceNode.addEventListener("ended",t)}}stop(t=0){this._nativeAudioBufferSourceNode.stop(t),null!==this._audioBufferSourceNodeRenderer&&(this._audioBufferSourceNodeRenderer.stop=t)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>()=>{const r=new WeakMap;let a=null,c=null;return{set start(t){a=t},set stop(t){c=t},render(u,h,l){const d=r.get(h);return void 0!==d?Promise.resolve(d):(async(u,h,l)=>{let d=n(u);const p=Object(s.a)(d,h);if(!p){const t={buffer:d.buffer,channelCount:d.channelCount,channelCountMode:d.channelCountMode,channelInterpretation:d.channelInterpretation,loop:d.loop,loopEnd:d.loopEnd,loopStart:d.loopStart,playbackRate:d.playbackRate.value};d=e(h,t),null!==a&&d.start(...a),null!==c&&d.stop(c)}return r.set(h,d),p?await t(h,u.playbackRate,d.playbackRate,l):await i(h,u.playbackRate,d.playbackRate,l),await o(u,h,d,l),d})(u,h,l)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(39);const i=(t,e,n,i,o,r,a,c,u)=>class extends t{constructor(t={}){if(null===u)throw new Error("Missing the native AudioContext constructor.");const e=new u(t);if(null===e)throw i();if(!Object(s.a)(t.latencyHint))throw new TypeError(`The provided value '${t.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(void 0!==t.sampleRate&&e.sampleRate!==t.sampleRate)throw n();super(e,2);const{latencyHint:o}=t,{sampleRate:r}=e;if(this._baseLatency="number"==typeof e.baseLatency?e.baseLatency:"balanced"===o?512/r:"interactive"===o||void 0===o?256/r:"playback"===o?1024/r:128*Math.max(2,Math.min(128,Math.round(o*r/128)))/r,this._nativeAudioContext=e,this._state=null,"running"===e.state){this._state="suspended";const t=()=>{"suspended"===this._state&&(this._state=null),e.removeEventListener("statechange",t)};e.addEventListener("statechange",t)}}get baseLatency(){return this._baseLatency}get state(){return null!==this._state?this._state:this._nativeAudioContext.state}close(){return"closed"===this.state?this._nativeAudioContext.close().then(()=>{throw e()}):("suspended"===this._state&&(this._state=null),this._nativeAudioContext.close())}createMediaElementSource(t){return new o(this,{mediaElement:t})}createMediaStreamDestination(){return new r(this)}createMediaStreamSource(t){return new a(this,{mediaStream:t})}createMediaStreamTrackSource(t){return new c(this,{mediaStreamTrack:t})}resume(){return"suspended"===this._state?new Promise((t,e)=>{const n=()=>{this._nativeAudioContext.removeEventListener("statechange",n),"running"===this._nativeAudioContext.state?t():this.resume().then(t,e)};this._nativeAudioContext.addEventListener("statechange",n)}):this._nativeAudioContext.resume().catch(t=>{if(void 0===t||15===t.code)throw e();throw t})}suspend(){return this._nativeAudioContext.suspend().catch(t=>{if(void 0===t)throw e();throw t})}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s,i,o,r,a)=>class extends t{constructor(t,n){const s=o(t),c=r(s),u=i(s,n,c);super(t,!1,u,c?e(a):null),this._isNodeOfNativeOfflineAudioContext=c,this._nativeAudioDestinationNode=u}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(t){if(this._isNodeOfNativeOfflineAudioContext)throw s();if(t>this._nativeAudioDestinationNode.maxChannelCount)throw n();this._nativeAudioDestinationNode.channelCount=t}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(t){if(this._isNodeOfNativeOfflineAudioContext)throw s();this._nativeAudioDestinationNode.channelCountMode=t}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{let e=null;return{render:(n,s,i)=>(null===e&&(e=(async(e,n,s)=>{const i=n.destination;return await t(e,n,i,s),i})(n,s,i)),e)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(2);const i=(t,e,n,i,o)=>(r,a)=>{const c=a.listener,{forwardX:u,forwardY:h,forwardZ:l,positionX:d,positionY:p,positionZ:f,upX:_,upY:m,upZ:g}=void 0===c.forwardX?(()=>{const u=e(a,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),h=o(a),l=i(a,256,9,0),d=(e,i)=>{const o=n(a,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:i});return o.connect(u,0,e),o.start(),Object.defineProperty(o.offset,"defaultValue",{get:()=>i}),t({context:r},h,o.offset,s.b,s.a)};let p=[0,0,-1,0,1,0],f=[0,0,0];return l.onaudioprocess=({inputBuffer:t})=>{const e=[t.getChannelData(0)[0],t.getChannelData(1)[0],t.getChannelData(2)[0],t.getChannelData(3)[0],t.getChannelData(4)[0],t.getChannelData(5)[0]];e.some((t,e)=>t!==p[e])&&(c.setOrientation(...e),p=e);const n=[t.getChannelData(6)[0],t.getChannelData(7)[0],t.getChannelData(8)[0]];n.some((t,e)=>t!==f[e])&&(c.setPosition(...n),f=n)},u.connect(l),{forwardX:d(0,0),forwardY:d(1,0),forwardZ:d(2,-1),positionX:d(6,0),positionY:d(7,0),positionZ:d(8,0),upX:d(3,0),upY:d(4,1),upZ:d(5,0)}})():c;return{get forwardX(){return u},get forwardY(){return h},get forwardZ(){return l},get positionX(){return d},get positionY(){return p},get positionZ(){return f},get upX(){return _},get upY(){return m},get upZ(){return g}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(18);const i=(t,e,n,i,o,r,a,c,u,h,l,d)=>(p,f,_,m=null,g=null)=>{const v=new s.AutomationEventList(_.defaultValue),y=f?i(v):null,b={get defaultValue(){return _.defaultValue},get maxValue(){return null===m?_.maxValue:m},get minValue(){return null===g?_.minValue:g},get value(){return _.value},set value(t){_.value=t,b.setValueAtTime(t,p.context.currentTime)},cancelAndHoldAtTime(t){if("function"==typeof _.cancelAndHoldAtTime)null===y&&v.flush(p.context.currentTime),v.add(o(t)),_.cancelAndHoldAtTime(t);else{const e=Array.from(v).pop();null===y&&v.flush(p.context.currentTime),v.add(o(t));const n=Array.from(v).pop();_.cancelScheduledValues(t),e!==n&&void 0!==n&&("exponentialRampToValue"===n.type?_.exponentialRampToValueAtTime(n.value,n.endTime):"linearRampToValue"===n.type?_.linearRampToValueAtTime(n.value,n.endTime):"setValue"===n.type?_.setValueAtTime(n.value,n.startTime):"setValueCurve"===n.type&&_.setValueCurveAtTime(n.values,n.startTime,n.duration))}return b},cancelScheduledValues:t=>(null===y&&v.flush(p.context.currentTime),v.add(r(t)),_.cancelScheduledValues(t),b),exponentialRampToValueAtTime:(t,e)=>(null===y&&v.flush(p.context.currentTime),v.add(a(t,e)),_.exponentialRampToValueAtTime(t,e),b),linearRampToValueAtTime:(t,e)=>(null===y&&v.flush(p.context.currentTime),v.add(c(t,e)),_.linearRampToValueAtTime(t,e),b),setTargetAtTime:(t,e,n)=>(null===y&&v.flush(p.context.currentTime),v.add(u(t,e,n)),_.setTargetAtTime(t,e,n),b),setValueAtTime:(t,e)=>(null===y&&v.flush(p.context.currentTime),v.add(h(t,e)),_.setValueAtTime(t,e),b),setValueCurveAtTime(t,e,n){if(null!==d&&"webkitAudioContext"===d.name){const s=e+n,i=p.context.sampleRate,o=Math.ceil(e*i),r=Math.floor(s*i),a=r-o,c=new Float32Array(a);for(let s=0;s<a;s+=1){const r=(t.length-1)/n*((o+s)/i-e),a=Math.floor(r),u=Math.ceil(r);c[s]=a===u?t[a]:(1-(r-a))*t[a]+(1-(u-r))*t[u]}null===y&&v.flush(p.context.currentTime),v.add(l(c,e,n)),_.setValueCurveAtTime(c,e,n);const u=r/i;u<s&&b.setValueAtTime(c[c.length-1],u),b.setValueAtTime(t[t.length-1],s)}else null===y&&v.flush(p.context.currentTime),v.add(l(t,e,n)),_.setValueCurveAtTime(t,e,n);return b}};return n.set(b,_),e.set(b,p),t(b,y),b}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>({replay(e){for(const n of t)if("exponentialRampToValue"===n.type){const{endTime:t,value:s}=n;e.exponentialRampToValueAtTime(s,t)}else if("linearRampToValue"===n.type){const{endTime:t,value:s}=n;e.linearRampToValueAtTime(s,t)}else if("setTarget"===n.type){const{startTime:t,target:s,timeConstant:i}=n;e.setTargetAtTime(s,t,i)}else if("setValue"===n.type){const{startTime:t,value:s}=n;e.setValueAtTime(s,t)}else{if("setValueCurve"!==n.type)throw new Error("Can't apply an unknown automation.");{const{duration:t,startTime:s,values:i}=n;e.setValueCurveAtTime(i,s,t)}}}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var s=n(0),i=n(40);const o={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,outputChannelCount:void 0,parameterData:{},processorOptions:{}},r=t=>{const e=[];for(let n=0;n<t;n+=1)e.push(1);return e},a=(t,e,n,a,c,u,h,l,d)=>class extends e{constructor(e,d,p=o){const f=u(e),_=h(f),m=(t=>({...t,outputChannelCount:void 0!==t.outputChannelCount?t.outputChannelCount:1===t.numberOfInputs&&1===t.numberOfOutputs?[t.channelCount]:r(t.numberOfOutputs)}))({...o,...p}),g=s.j.get(f),v=void 0===g?void 0:g.get(d),y=c(f,_?null:e.baseLatency,l,d,v,m);super(e,!0,y,_?a(d,m,v):null);const b=[];y.parameters.forEach((t,e)=>{const s=n(this,_,t);b.push([e,s])}),this._nativeAudioWorkletNode=y,this._onprocessorerror=null,this._parameters=new i.a(b),_&&t(f,this)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(t){const e="function"==typeof t?d(this,t):null;this._nativeAudioWorkletNode.onprocessorerror=e;const n=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=null!==n&&n===e?t:n}get parameters(){return null===this._parameters?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s,i,o,r,a,c,u,h,l,d,p,f,_,m,g,v,y)=>class extends f{constructor(e,n){super(e,n),this._nativeContext=e,this._audioWorklet=void 0===t?void 0:{addModule:(e,n)=>t(this,e,n)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new e(this)}createBiquadFilter(){return new i(this)}createBuffer(t,e,s){return new n({length:e,numberOfChannels:t,sampleRate:s})}createBufferSource(){return new s(this)}createChannelMerger(t=6){return new o(this,{numberOfInputs:t})}createChannelSplitter(t=6){return new r(this,{numberOfOutputs:t})}createConstantSource(){return new a(this)}createConvolver(){return new c(this)}createDelay(t=1){return new h(this,{maxDelayTime:t})}createDynamicsCompressor(){return new l(this)}createGain(){return new d(this)}createIIRFilter(t,e){return new p(this,{feedback:e,feedforward:t})}createOscillator(){return new _(this)}createPanner(){return new m(this)}createPeriodicWave(t,e,n={disableNormalization:!1}){return new g(this,{...n,imag:e,real:t})}createStereoPanner(){return new v(this)}createWaveShaper(){return new y(this)}decodeAudioData(t,e,n){return u(this._nativeContext,t).then(t=>("function"==typeof e&&e(t),t)).catch(t=>{throw"function"==typeof n&&n(t),t})}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(2);const i={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"},o=(t,e,n,o,r,a,c)=>class extends t{constructor(t,o=i){const u=a(t),h={...i,...o},l=r(u,h),d=c(u);super(t,!1,l,d?n():null),this._Q=e(this,d,l.Q,s.b,s.a),this._detune=e(this,d,l.detune,1200*Math.log2(s.b),-1200*Math.log2(s.b)),this._frequency=e(this,d,l.frequency,t.sampleRate/2,0),this._gain=e(this,d,l.gain,40*Math.log10(s.b),s.a),this._nativeBiquadFilterNode=l}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(t){this._nativeBiquadFilterNode.type=t}getFrequencyResponse(t,e,n){if(this._nativeBiquadFilterNode.getFrequencyResponse(t,e,n),t.length!==e.length||e.length!==n.length)throw o()}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>()=>{const r=new WeakMap;return{render(a,c,u){const h=r.get(c);return void 0!==h?Promise.resolve(h):(async(a,c,u)=>{let h=n(a);const l=Object(s.a)(h,c);if(!l){const t={Q:h.Q.value,channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,detune:h.detune.value,frequency:h.frequency.value,gain:h.gain.value,type:h.type};h=e(c,t)}return r.set(c,h),l?(await t(c,a.Q,h.Q,u),await t(c,a.detune,h.detune,u),await t(c,a.frequency,h.frequency,u),await t(c,a.gain,h.gain,u)):(await i(c,a.Q,h.Q,u),await i(c,a.detune,h.detune,u),await i(c,a.frequency,h.frequency,u),await i(c,a.gain,h.gain,u)),await o(a,c,h,u),h})(a,c,u)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>(n,s)=>{const i=e.get(n);if(void 0!==i)return i;const o=t.get(n);if(void 0!==o)return o;try{const i=s();return i instanceof Promise?(t.set(n,i),i.catch(()=>!1).then(s=>(t.delete(n),e.set(n,s),s))):(e.set(n,i),i)}catch{return e.set(n,!1),!1}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6},i=(t,e,n,i,o)=>class extends t{constructor(t,r=s){const a=i(t),c={...s,...r};super(t,!1,n(a,c),o(a)?e():null)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n)=>()=>{const i=new WeakMap;return{render(o,r,a){const c=i.get(r);return void 0!==c?Promise.resolve(c):(async(o,r,a)=>{let c=e(o);if(!Object(s.a)(c,r)){const e={channelCount:c.channelCount,channelCountMode:c.channelCountMode,channelInterpretation:c.channelInterpretation,numberOfInputs:c.numberOfInputs};c=t(r,e)}return i.set(r,c),await n(o,r,c,a),c})(o,r,a)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6},i=(t,e,n,i,o)=>class extends t{constructor(t,r=s){const a=i(t),c=(t=>({...t,channelCount:t.numberOfOutputs}))({...s,...r});super(t,!1,n(a,c),o(a)?e():null)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n)=>()=>{const i=new WeakMap;return{render(o,r,a){const c=i.get(r);return void 0!==c?Promise.resolve(c):(async(o,r,a)=>{let c=e(o);if(!Object(s.a)(c,r)){const e={channelCount:c.channelCount,channelCountMode:c.channelCountMode,channelInterpretation:c.channelInterpretation,numberOfOutputs:c.numberOfOutputs};c=t(r,e)}return i.set(r,c),await n(o,r,c,a),c})(o,r,a)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n,s,i)=>t(n,e,s,i)},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(25);const i=t=>(e,n,i=0,o=0)=>{const r=e[i];if(void 0===r)throw t();return Object(s.a)(n)?r.connect(n,0,o):r.connect(n,0)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{const s=t(e),i=e.createBuffer(1,2,e.sampleRate);return s.buffer=i,s.loop=!0,s.connect(n),s.start(),()=>{s.stop(),s.disconnect(n)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var s=n(2),i=n(17),o=n(21);const r={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1},a=(t,e,n,a,c,u,h)=>class extends t{constructor(t,i=r){const o=c(t),h={...r,...i},l=a(o,h),d=u(o),p=d?n():null;super(t,!1,l,p),this._constantSourceNodeRenderer=p,this._nativeConstantSourceNode=l,this._offset=e(this,d,l.offset,s.b,s.a),this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(t){const e="function"==typeof t?h(this,t):null;this._nativeConstantSourceNode.onended=e;const n=this._nativeConstantSourceNode.onended;this._onended=null!==n&&n===e?t:n}start(t=0){if(this._nativeConstantSourceNode.start(t),null!==this._constantSourceNodeRenderer)this._constantSourceNodeRenderer.start=t;else{Object(i.a)(this);const t=()=>{this._nativeConstantSourceNode.removeEventListener("ended",t),setTimeout(()=>Object(o.a)(this),1e3)};this._nativeConstantSourceNode.addEventListener("ended",t)}}stop(t=0){this._nativeConstantSourceNode.stop(t),null!==this._constantSourceNodeRenderer&&(this._constantSourceNodeRenderer.stop=t)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>()=>{const r=new WeakMap;let a=null,c=null;return{set start(t){a=t},set stop(t){c=t},render(u,h,l){const d=r.get(h);return void 0!==d?Promise.resolve(d):(async(u,h,l)=>{let d=n(u);const p=Object(s.a)(d,h);if(!p){const t={channelCount:d.channelCount,channelCountMode:d.channelCountMode,channelInterpretation:d.channelInterpretation,offset:d.offset.value};d=e(h,t),null!==a&&d.start(a),null!==c&&d.stop(c)}return r.set(h,d),p?await t(h,u.offset,d.offset,l):await i(h,u.offset,d.offset,l),await o(u,h,d,l),d})(u,h,l)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>(t[0]=e,t[0])},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:!1},i=(t,e,n,i,o)=>class extends t{constructor(t,r=s){const a=i(t),c={...s,...r},u=n(a,c);super(t,!1,u,o(a)?e():null),this._isBufferNullified=!1,this._nativeConvolverNode=u}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(t){if(this._nativeConvolverNode.buffer=t,null===t&&null!==this._nativeConvolverNode.buffer){const t=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=t.createBuffer(1,1,t.sampleRate),this._isBufferNullified=!0}else this._isBufferNullified=!1}get normalize(){return this._nativeConvolverNode.normalize}set normalize(t){this._nativeConvolverNode.normalize=t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(12),i=n(3);const o=(t,e,n)=>()=>{const o=new WeakMap;return{render(r,a,c){const u=o.get(a);return void 0!==u?Promise.resolve(u):(async(r,a,c)=>{let u=e(r);if(!Object(i.a)(u,a)){const e={buffer:u.buffer,channelCount:u.channelCount,channelCountMode:u.channelCountMode,channelInterpretation:u.channelInterpretation,disableNormalization:!u.normalize};u=t(a,e)}return o.set(a,u),Object(s.a)(u)?await n(r,a,u.inputs[0],c):await n(r,a,u,c),u})(r,a,c)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>(n,s,i)=>{if(null===e)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new e(n,s,i)}catch(e){if("IndexSizeError"===e.name||"SyntaxError"===e.name)throw t();throw e}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","DataCloneError")}catch(t){return t.code=25,t.name="DataCloneError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(22);const i=(t,e,n,i,o,r,a,c)=>(u,h)=>{const l=e.get(u);if(void 0===l)throw new Error("Missing the expected cycle count.");const d=r(u.context),p=c(d);if(l===h){if(e.delete(u),!p&&a(u)){const e=i(u),{outputs:r}=n(u);for(const n of r)if(Object(s.a)(n)){const s=i(n[0]);t(e,s,n[1],n[2])}else{const t=o(n[0]);e.connect(t,n[1])}}}else e.set(u,l-h)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1},i=(t,e,n,i,o,r)=>class extends t{constructor(t,a=s){const c=o(t),u={...s,...a},h=i(c,u),l=r(c);super(t,!1,h,l?n(u.maxDelayTime):null),this._delayTime=e(this,l,h.delayTime,u.maxDelayTime,0)}get delayTime(){return this._delayTime}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>r=>{const a=new WeakMap;return{render(c,u,h){const l=a.get(u);return void 0!==l?Promise.resolve(l):(async(c,u,h)=>{let l=n(c);const d=Object(s.a)(l,u);if(!d){const t={channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,delayTime:l.delayTime.value,maxDelayTime:r};l=e(u,t)}return a.set(u,l),d?await t(u,c.delayTime,l.delayTime,h):await i(u,c.delayTime,l.delayTime,h),await o(c,u,l,h),l})(c,u,h)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{t(e).delete(n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(25);const i=(t,e,n)=>{const s=e[n];if(void 0===s)throw t();return s},o=t=>(e,n,o,r=0)=>void 0===n?e.forEach(t=>t.disconnect()):"number"==typeof n?i(t,e,n).disconnect():Object(s.a)(n)?void 0===o?e.forEach(t=>t.disconnect(n)):void 0===r?i(t,e,o).disconnect(n,0):i(t,e,o).disconnect(n,0,r):void 0===o?e.forEach(t=>t.disconnect(n)):i(t,e,o).disconnect(n,0)},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24},i=(t,e,n,i,o,r,a)=>class extends t{constructor(t,o=s){const c=r(t),u={...s,...o},h=i(c,u),l=a(c);super(t,!1,h,l?n():null),this._attack=e(this,l,h.attack,1,0),this._knee=e(this,l,h.knee,40,0),this._nativeDynamicsCompressorNode=h,this._ratio=e(this,l,h.ratio,20,1),this._release=e(this,l,h.release,1,0),this._threshold=e(this,l,h.threshold,0,-100)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(t){const e=this._nativeDynamicsCompressorNode.channelCount;if(this._nativeDynamicsCompressorNode.channelCount=t,t>2)throw this._nativeDynamicsCompressorNode.channelCount=e,o()}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(t){const e=this._nativeDynamicsCompressorNode.channelCountMode;if(this._nativeDynamicsCompressorNode.channelCountMode=t,"max"===t)throw this._nativeDynamicsCompressorNode.channelCountMode=e,o()}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return"number"==typeof this._nativeDynamicsCompressorNode.reduction.value?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>()=>{const r=new WeakMap;return{render(a,c,u){const h=r.get(c);return void 0!==h?Promise.resolve(h):(async(a,c,u)=>{let h=n(a);const l=Object(s.a)(h,c);if(!l){const t={attack:h.attack.value,channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,knee:h.knee.value,ratio:h.ratio.value,release:h.release.value,threshold:h.threshold.value};h=e(c,t)}return r.set(c,h),l?(await t(c,a.attack,h.attack,u),await t(c,a.knee,h.knee,u),await t(c,a.ratio,h.ratio,u),await t(c,a.release,h.release,u),await t(c,a.threshold,h.threshold,u)):(await i(c,a.attack,h.attack,u),await i(c,a.knee,h.knee,u),await i(c,a.ratio,h.ratio,u),await i(c,a.release,h.release,u),await i(c,a.threshold,h.threshold,u)),await o(a,c,h,u),h})(a,c,u)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>{try{return new DOMException("","EncodingError")}catch(t){return t.code=0,t.name="EncodingError",t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>new Promise((n,s)=>{if(null===t)return void s(new SyntaxError);const i=t.document.head;if(null===i)s(new SyntaxError);else{const o=t.document.createElement("script"),r=new Blob([e],{type:"application/javascript"}),a=URL.createObjectURL(r),c=t.onerror,u=()=>{t.onerror=c,URL.revokeObjectURL(a)};t.onerror=(e,n,i,o,r)=>n===a||n===t.location.href&&1===i&&1===o?(u(),s(r),!1):null!==c?c(e,n,i,o,r):void 0,o.onerror=()=>{u(),s(new SyntaxError)},o.onload=()=>{u(),n()},o.src=a,o.type="module",i.appendChild(o)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>class{constructor(t){this._nativeEventTarget=t,this._listeners=new WeakMap}addEventListener(e,n,s){if(null!==n){let i=this._listeners.get(n);void 0===i&&(i=t(this,n),"function"==typeof n&&this._listeners.set(n,i)),this._nativeEventTarget.addEventListener(e,i,s)}}dispatchEvent(t){return this._nativeEventTarget.dispatchEvent(t)}removeEventListener(t,e,n){const s=null===e?void 0:this._listeners.get(e);this._nativeEventTarget.removeEventListener(t,void 0===s?null:s,n)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n,s)=>{Object.defineProperties(t,{currentFrame:{configurable:!0,get:()=>Math.round(e*n)},currentTime:{configurable:!0,get:()=>e}});try{return s()}finally{null!==t&&(delete t.currentFrame,delete t.currentTime)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>async e=>{try{const t=await fetch(e);if(t.ok)return t.text()}catch{}throw t()}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(2);const i={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1},o=(t,e,n,o,r,a)=>class extends t{constructor(t,c=i){const u=r(t),h={...i,...c},l=o(u,h),d=a(u);super(t,!1,l,d?n():null),this._gain=e(this,d,l.gain,s.b,s.a)}get gain(){return this._gain}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>()=>{const r=new WeakMap;return{render(a,c,u){const h=r.get(c);return void 0!==h?Promise.resolve(h):(async(a,c,u)=>{let h=n(a);const l=Object(s.a)(h,c);if(!l){const t={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,gain:h.gain.value};h=e(c,t)}return r.set(c,h),l?await t(c,a.gain,h.gain,u):await i(c,a.gain,h.gain,u),await o(a,c,h,u),h})(a,c,u)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e);if(null===n.renderer)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return n.renderer}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e);if(null===n.renderer)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return n.renderer}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(0);const i=(t,e,n)=>i=>{if("closed"===i.state&&null!==e&&"webkitAudioContext"!==e.name){if(!t(i)){const t=s.f.get(i);if(void 0!==t)return t;const n=new e;return s.f.set(i,n),n}{const t=s.f.get(i);if(void 0!==t)return t;if(null!==n){const t=new n(1,1,44100);return s.f.set(i,t),t}}}return null}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(7);const i=t=>e=>{const n=t.get(e);if(void 0===n)throw Object(s.a)();return n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t.get(e);if(void 0===n)throw new Error("The context has no set of AudioWorkletNodes.");return n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(42),i=n(3);const o=(t,e,n,o,r,a)=>(c,u)=>{const h=new WeakMap;let l=null;const d=async(d,p,f)=>{let _=null,m=n(d);const g=Object(i.a)(m,p);if(void 0===p.createIIRFilter?_=t(p):g||(m=e(p,t=>t.createIIRFilter(u,c))),h.set(p,null===_?m:_),null!==_){if(null===l){if(null===o)throw new Error("Missing the native OfflineAudioContext constructor.");const t=new o(d.context.destination.channelCount,d.context.length,p.sampleRate);l=(async()=>(await r(d,t,t.destination,f),((t,e,n,i)=>{const o=n.length,r=i.length,a=Math.min(o,r);if(1!==n[0]){for(let t=0;t<o;t+=1)i[t]/=n[0];for(let t=1;t<r;t+=1)n[t]/=n[0]}const c=new Float32Array(32),u=new Float32Array(32),h=e.createBuffer(t.numberOfChannels,t.length,t.sampleRate),l=t.numberOfChannels;for(let e=0;e<l;e+=1){const l=t.getChannelData(e),d=h.getChannelData(e);c.fill(0),u.fill(0),Object(s.a)(n,o,i,r,a,c,u,0,32,l,d)}return h})(await a(t),p,c,u)))()}const t=await l;return _.buffer=t,_.start(0),_}return await r(d,p,m,f),m};return{render(t,e,n){const s=h.get(e);return void 0!==s?Promise.resolve(s):d(t,e,n)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(22);const i=(t,e,n,i,o,r)=>a=>(c,u)=>{const h=t.get(c);if(void 0===h){if(!a&&r(c)){const t=i(c),{outputs:r}=n(c);for(const n of r)if(Object(s.a)(n)){const s=i(n[0]);e(t,s,n[1],n[2])}else{const e=o(n[0]);t.disconnect(e,n[1])}}t.set(c,u)}else t.set(c,h+u)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>{const s=t.get(n);return e(s)||e(n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>t.has(n)||e(n)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>t.has(n)||e(n)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>{const s=t.get(n);return e(s)||e(n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>null!==t&&e instanceof t},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>null!==t&&"function"==typeof t.AudioNode&&e instanceof t.AudioNode},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>null!==t&&"function"==typeof t.AudioParam&&e instanceof t.AudioParam},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>t(n)||e(n)},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>null!==t&&e instanceof t},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>null!==t&&t.isSecureContext},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=async(t,e,n,s,i,o,r,a,c,u,h,l,d,p)=>{if(t(e,e)&&t(n,n)&&t(i,i)&&t(o,o)&&t(a,a)&&t(c,c)&&t(u,u)&&t(h,h)&&t(l,l)){return(await Promise.all([t(s,s),t(r,r),t(d,d),t(p,p)])).every(t=>t)}return!1}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s)=>class extends t{constructor(t,i){const o=n(t),r=e(o,i);if(s(o))throw TypeError();super(t,!0,r,null),this._mediaElement=i.mediaElement,this._nativeMediaElementAudioSourceNode=r}get mediaElement(){return void 0===this._nativeMediaElementAudioSourceNode.mediaElement?this._mediaElement:this._nativeMediaElementAudioSourceNode.mediaElement}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"},i=(t,e,n,i)=>class extends t{constructor(t,o=s){const r=n(t);if(i(r))throw new TypeError;const a={...s,...o},c=e(r,a);super(t,!1,c,null),this._nativeMediaStreamAudioDestinationNode=c}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s)=>class extends t{constructor(t,i){const o=n(t),r=e(o,i);if(s(o))throw new TypeError;super(t,!0,r,null),this._nativeMediaStreamAudioSourceNode=r}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>class extends t{constructor(t,s){const i=n(t);super(t,!0,e(i,s),null)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(39);const i=(t,e,n,i,o)=>class extends i{constructor(t={}){if(null===o)throw new Error("Missing the native AudioContext constructor.");const i=new o(t);if(null===i)throw n();if(!Object(s.a)(t.latencyHint))throw new TypeError(`The provided value '${t.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(void 0!==t.sampleRate&&i.sampleRate!==t.sampleRate)throw e();super(i,2);const{latencyHint:r}=t,{sampleRate:a}=i;if(this._baseLatency="number"==typeof i.baseLatency?i.baseLatency:"balanced"===r?512/a:"interactive"===r||void 0===r?256/a:"playback"===r?1024/a:128*Math.max(2,Math.min(128,Math.round(r*a/128)))/a,this._nativeAudioContext=i,this._state=null,"running"===i.state){this._state="suspended";const t=()=>{"suspended"===this._state&&(this._state=null),i.removeEventListener("statechange",t)};i.addEventListener("statechange",t)}}get baseLatency(){return this._baseLatency}get state(){return null!==this._state?this._state:this._nativeAudioContext.state}close(){return"closed"===this.state?this._nativeAudioContext.close().then(()=>{throw t()}):("suspended"===this._state&&(this._state=null),this._nativeAudioContext.close())}resume(){return"suspended"===this._state?new Promise((t,e)=>{const n=()=>{this._nativeAudioContext.removeEventListener("statechange",n),"running"===this._nativeAudioContext.state?t():this.resume().then(t,e)};this._nativeAudioContext.addEventListener("statechange",n)}):this._nativeAudioContext.resume().catch(e=>{if(void 0===e||15===e.code)throw t();throw e})}suspend(){return this._nativeAudioContext.suspend().catch(e=>{if(void 0===e)throw t();throw e})}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(0);const i=(t,e,n,i,o,r)=>class extends n{constructor(n,r){super(n),this._nativeContext=n,s.g.set(this,n);const a=n.sampleRate;Object.defineProperty(n,"sampleRate",{get:()=>a}),i(n)&&o.set(n,new Set),this._destination=new t(this,r),this._listener=e(this,n),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(t){const e="function"==typeof t?r(this,t):null;this._nativeContext.onstatechange=e;const n=this._nativeContext.onstatechange;this._onstatechange=null!==n&&n===e?t:n}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(14);const i={numberOfChannels:1},o=(t,e,n,o,r)=>class extends o{constructor(e){const{length:o,numberOfChannels:r,sampleRate:a}={...i,...e},c=n(r,o,a);t(s.a,()=>Object(s.a)(c))||c.addEventListener("statechange",(()=>{let t=0;const e=n=>{"running"===this._state&&(t>0?(c.removeEventListener("statechange",e),n.stopImmediatePropagation(),this._waitForThePromiseToSettle(n)):t+=1)};return e})()),super(c,r),this._length=o,this._nativeOfflineAudioContext=c,this._state=null}get length(){return void 0===this._nativeOfflineAudioContext.length?this._length:this._nativeOfflineAudioContext.length}get state(){return null===this._state?this._nativeOfflineAudioContext.state:this._state}startRendering(){return"running"===this._state?Promise.reject(e()):(this._state="running",r(this.destination,this._nativeOfflineAudioContext).then(t=>(this._state=null,t)).catch(t=>{throw this._state=null,t}))}_waitForThePromiseToSettle(t){null===this._state?this._nativeOfflineAudioContext.dispatchEvent(t):setTimeout(()=>this._waitForThePromiseToSettle(t))}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>(n,s,i)=>{const o=new Set;var r,a;return n.connect=(r=n.connect,(i,a=0,c=0)=>{const u=0===o.size;if(e(i))return r.call(n,i,a,c),t(o,[i,a,c],t=>t[0]===i&&t[1]===a&&t[2]===c,!0),u&&s(),i;r.call(n,i,a),t(o,[i,a],t=>t[0]===i&&t[1]===a,!0),u&&s()}),n.disconnect=(a=n.disconnect,(t,s,r)=>{const c=o.size>0;if(void 0===t)a.apply(n),o.clear();else if("number"==typeof t){a.call(n,t);for(const e of o)e[1]===t&&o.delete(e)}else{e(t)?a.call(n,t,s,r):a.call(n,t,s);for(const e of o)e[0]!==t||void 0!==s&&e[1]!==s||void 0!==r&&e[2]!==r||o.delete(e)}const u=0===o.size;c&&u&&i()}),n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>null===t?null:t.hasOwnProperty("AudioBuffer")?t.AudioBuffer:null},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>null===t?null:t.hasOwnProperty("AudioContext")?t.AudioContext:t.hasOwnProperty("webkitAudioContext")?t.webkitAudioContext:null},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>(n,s,i)=>{const o=n.destination;if(o.channelCount!==s)try{o.channelCount=s}catch{}i&&"explicit"!==o.channelCountMode&&(o.channelCountMode="explicit"),0===o.maxChannelCount&&Object.defineProperty(o,"maxChannelCount",{value:s});const r=t(n,{channelCount:s,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,gain:1});return e(r,"channelCount",t=>()=>t.call(r),t=>e=>{t.call(r,e);try{o.channelCount=e}catch(t){if(e>o.maxChannelCount)throw t}}),e(r,"channelCountMode",t=>()=>t.call(r),t=>e=>{t.call(r,e),o.channelCountMode=e}),e(r,"channelInterpretation",t=>()=>t.call(r),t=>e=>{t.call(r,e),o.channelInterpretation=e}),Object.defineProperty(r,"maxChannelCount",{get:()=>o.maxChannelCount}),r.connect(o),r}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{const s=t(e);return n(null!==s?s:e)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>null===t?null:t.hasOwnProperty("AudioWorkletNode")?t.AudioWorkletNode:null},function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var s=n(5),i=n(4),o=n(1);const r=t=>(e,n)=>{const r=t(e,t=>t.createBiquadFilter());return Object(o.a)(r,n),Object(s.a)(r,n,"Q"),Object(s.a)(r,n,"detune"),Object(s.a)(r,n,"frequency"),Object(s.a)(r,n,"gain"),Object(i.a)(r,n,"type"),r}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(1);const i=(t,e)=>(n,i)=>{const o=t(n,t=>t.createChannelMerger(i.numberOfInputs));return 1!==o.channelCount&&"explicit"!==o.channelCountMode&&e(n,o),Object(s.a)(o,i),o}},function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var s=n(5),i=n(1),o=n(30),r=n(31);const a=(t,e,n,a,c,u)=>(h,l)=>{if(void 0===h.createConstantSource)return a(h,l);const d=n(h,t=>t.createConstantSource());return Object(i.a)(d,l),Object(s.a)(d,l,"offset"),e(c,()=>c(h))||Object(o.a)(d),e(u,()=>u(h))||Object(r.a)(d),t(h,d),d}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(11);const i=(t,e,n,i)=>(o,{offset:r,...a})=>{const c=o.createBuffer(1,2,o.sampleRate),u=e(o),h=n(o,{...a,gain:r}),l=c.getChannelData(0);l[0]=1,l[1]=1,u.buffer=c,u.loop=!0;const d={get bufferSize(){},get channelCount(){return h.channelCount},set channelCount(t){h.channelCount=t},get channelCountMode(){return h.channelCountMode},set channelCountMode(t){h.channelCountMode=t},get channelInterpretation(){return h.channelInterpretation},set channelInterpretation(t){h.channelInterpretation=t},get context(){return h.context},get inputs(){return[]},get numberOfInputs(){return u.numberOfInputs},get numberOfOutputs(){return h.numberOfOutputs},get offset(){return h.gain},get onended(){return u.onended},set onended(t){u.onended=t},addEventListener:(...t)=>u.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>u.dispatchEvent(t[0]),removeEventListener:(...t)=>u.removeEventListener(t[0],t[1],t[2]),start(t=0){u.start.call(u,t)},stop(t=0){u.stop.call(u,t)}};return t(o,u),i(Object(s.a)(d,h),()=>u.connect(h),()=>u.disconnect(h))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(4),i=n(1);const o=(t,e,n,o)=>(r,a)=>{const c=t(r,t=>t.createConvolver());try{c.channelCount=1}catch(t){return e(r,a)}if(Object(i.a)(c,a),a.disableNormalization===c.normalize&&(c.normalize=!a.disableNormalization),Object(s.a)(c,a,"buffer"),a.channelCount>2)throw n();if(o(c,"channelCount",t=>()=>t.call(c),t=>e=>{if(e>2)throw n();return t.call(c,e)}),"max"===a.channelCountMode)throw n();return o(c,"channelCountMode",t=>()=>t.call(c),t=>e=>{if("max"===e)throw n();return t.call(c,e)}),c}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(1),i=n(11);const o=(t,e,n)=>(o,{buffer:r,channelCount:a,channelCountMode:c,channelInterpretation:u,disableNormalization:h})=>{const l=t(o,t=>t.createConvolver());Object(s.a)(l,{channelCount:Math.max(a,2),channelCountMode:"max"===c?c:"clamped-max",channelInterpretation:u});const d=e(o,{channelCount:a,channelCountMode:c,channelInterpretation:u,gain:1}),p={get buffer(){return l.buffer},set buffer(t){l.buffer=t},get bufferSize(){},get channelCount(){return d.channelCount},set channelCount(t){t>2&&(l.channelCount=t),d.channelCount=t},get channelCountMode(){return d.channelCountMode},set channelCountMode(t){"max"===t&&(l.channelCountMode=t),d.channelCountMode=t},get channelInterpretation(){return l.channelInterpretation},set channelInterpretation(t){l.channelInterpretation=t,d.channelInterpretation=t},get context(){return l.context},get inputs(){return[l]},get numberOfInputs(){return l.numberOfInputs},get numberOfOutputs(){return l.numberOfOutputs},get normalize(){return l.normalize},set normalize(t){l.normalize=t},addEventListener:(...t)=>l.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>l.dispatchEvent(t[0]),removeEventListener:(...t)=>l.removeEventListener(t[0],t[1],t[2])};h===p.normalize&&(p.normalize=!h),r!==p.buffer&&(p.buffer=r);return n(Object(i.a)(p,d),()=>l.connect(d),()=>l.disconnect(d))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(5),i=n(1);const o=t=>(e,n)=>{const o=t(e,t=>t.createDelay(n.maxDelayTime));return Object(i.a)(o,n),Object(s.a)(o,n,"delayTime"),o}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(5),i=n(1);const o=(t,e)=>(n,o)=>{const r=t(n,t=>t.createDynamicsCompressor());if(Object(i.a)(r,o),o.channelCount>2)throw e();if("max"===o.channelCountMode)throw e();return Object(s.a)(r,o,"attack"),Object(s.a)(r,o,"knee"),Object(s.a)(r,o,"ratio"),Object(s.a)(r,o,"release"),Object(s.a)(r,o,"threshold"),r}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(5),i=n(1);const o=t=>(e,n)=>{const o=t(e,t=>t.createGain());return Object(i.a)(o,n),Object(s.a)(o,n,"gain"),o}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(1);const i=(t,e)=>(n,i,o)=>{if(void 0===n.createIIRFilter)return e(n,i,o);const r=t(n,t=>t.createIIRFilter(o.feedforward,o.feedback));return Object(s.a)(r,o),r}},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var s=n(43),i=n(42),o=n(11);function r(t,e){const n=e[0]*e[0]+e[1]*e[1];return[(t[0]*e[0]+t[1]*e[1])/n,(t[1]*e[0]-t[0]*e[1])/n]}function a(t,e){let n=[0,0];for(let o=t.length-1;o>=0;o-=1)i=e,n=[(s=n)[0]*i[0]-s[1]*i[1],s[0]*i[1]+s[1]*i[0]],n[0]+=t[o];var s,i;return n}const c=(t,e,n,c)=>(u,h,{channelCount:l,channelCountMode:d,channelInterpretation:p,feedback:f,feedforward:_})=>{const m=Object(s.a)(h,u.sampleRate),g=f.length,v=_.length,y=Math.min(g,v);if(0===f.length||f.length>20)throw c();if(0===f[0])throw e();if(0===_.length||_.length>20)throw c();if(0===_[0])throw e();if(1!==f[0]){for(let t=0;t<v;t+=1)_[t]/=f[0];for(let t=1;t<g;t+=1)f[t]/=f[0]}const b=n(u,m,l,l);b.channelCount=l,b.channelCountMode=d,b.channelInterpretation=p;const x=[],w=[],T=[];for(let t=0;t<l;t+=1){x.push(0);const t=new Float32Array(32),e=new Float32Array(32);t.fill(0),e.fill(0),w.push(t),T.push(e)}b.onaudioprocess=t=>{const e=t.inputBuffer,n=t.outputBuffer,s=e.numberOfChannels;for(let t=0;t<s;t+=1){const s=e.getChannelData(t),o=n.getChannelData(t);x[t]=Object(i.a)(f,g,_,v,y,w[t],T[t],x[t],32,s,o)}};const O=u.sampleRate/2,S={get bufferSize(){return m},get channelCount(){return b.channelCount},set channelCount(t){b.channelCount=t},get channelCountMode(){return b.channelCountMode},set channelCountMode(t){b.channelCountMode=t},get channelInterpretation(){return b.channelInterpretation},set channelInterpretation(t){b.channelInterpretation=t},get context(){return b.context},get inputs(){return[b]},get numberOfInputs(){return b.numberOfInputs},get numberOfOutputs(){return b.numberOfOutputs},addEventListener:(...t)=>b.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>b.dispatchEvent(t[0]),getFrequencyResponse(e,n,s){if(e.length!==n.length||n.length!==s.length)throw t();const i=e.length;for(let t=0;t<i;t+=1){const i=-Math.PI*(e[t]/O),o=[Math.cos(i),Math.sin(i)],c=r(a(_,o),a(f,o));n[t]=Math.sqrt(c[0]*c[0]+c[1]*c[1]),s[t]=Math.atan2(c[1],c[0])}},removeEventListener:(...t)=>b.removeEventListener(t[0],t[1],t[2])};return Object(o.a)(S,b)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>t(e,t=>t.createMediaElementSource(n.mediaElement))},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(1);const i=(t,e)=>(n,i)=>{if(void 0===n.createMediaStreamDestination)throw e();const o=t(n,t=>t.createMediaStreamDestination());return Object(s.a)(o,i),1===o.numberOfOutputs&&Object.defineProperty(o,"numberOfOutputs",{get:()=>0}),o}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,{mediaStream:n})=>{const s=n.getAudioTracks(),i=t(e,t=>{const e=s.sort((t,e)=>t.id<e.id?-1:t.id>e.id?1:0).slice(0,1);return t.createMediaStreamSource(new MediaStream(e))});return Object.defineProperty(i,"mediaStream",{value:n}),i}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>(s,{mediaStreamTrack:i})=>"function"==typeof s.createMediaStreamTrackSource?e(s,t=>t.createMediaStreamTrackSource(i)):e(s,e=>{const s=new MediaStream([i]),o=e.createMediaStreamSource(s);if("audio"!==i.kind)throw t();if(n(e))throw new TypeError;return o})},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>null===t?null:t.hasOwnProperty("OfflineAudioContext")?t.OfflineAudioContext:t.hasOwnProperty("webkitOfflineAudioContext")?t.webkitOfflineAudioContext:null},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var s=n(5),i=n(4),o=n(1),r=n(30),a=n(31);const c=(t,e,n,c,u,h,l)=>(d,p)=>{const f=n(d,t=>t.createOscillator());return Object(o.a)(f,p),Object(s.a)(f,p,"detune"),Object(s.a)(f,p,"frequency"),void 0!==p.periodicWave?f.setPeriodicWave(p.periodicWave):Object(i.a)(f,p,"type"),e(c,()=>c(d))||Object(r.a)(f),e(u,()=>u(d))||l(f,d),e(h,()=>h(d))||Object(a.a)(f),t(d,f),f}},function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var s=n(5),i=n(4),o=n(1);const r=(t,e)=>(n,r)=>{const a=t(n,t=>t.createPanner());return void 0===a.orientationX?e(n,r):(Object(o.a)(a,r),Object(s.a)(a,r,"orientationX"),Object(s.a)(a,r,"orientationY"),Object(s.a)(a,r,"orientationZ"),Object(s.a)(a,r,"positionX"),Object(s.a)(a,r,"positionY"),Object(s.a)(a,r,"positionZ"),Object(i.a)(a,r,"coneInnerAngle"),Object(i.a)(a,r,"coneOuterAngle"),Object(i.a)(a,r,"coneOuterGain"),Object(i.a)(a,r,"distanceModel"),Object(i.a)(a,r,"maxDistance"),Object(i.a)(a,r,"panningModel"),Object(i.a)(a,r,"refDistance"),Object(i.a)(a,r,"rolloffFactor"),a)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(1),i=n(11);const o=(t,e,n,o,r,a,c,u,h,l)=>(d,{coneInnerAngle:p,coneOuterAngle:f,coneOuterGain:_,distanceModel:m,maxDistance:g,orientationX:v,orientationY:y,orientationZ:b,panningModel:x,positionX:w,positionY:T,positionZ:O,refDistance:S,rolloffFactor:C,...k})=>{const A=n(d,t=>t.createPanner());if(k.channelCount>2)throw u();if("max"===k.channelCountMode)throw u();Object(s.a)(A,k);const D={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},M=o(d,{...D,channelInterpretation:"speakers",numberOfInputs:6}),j=r(d,{...k,gain:1}),E=r(d,{...D,gain:1}),R=r(d,{...D,gain:0}),q=r(d,{...D,gain:0}),I=r(d,{...D,gain:0}),F=r(d,{...D,gain:0}),V=r(d,{...D,gain:0}),N=a(d,256,6,1),P=c(d,{...D,curve:new Float32Array([1,1]),oversample:"none"});let L=[v,y,b],z=[w,T,O];N.onaudioprocess=({inputBuffer:t})=>{const e=[t.getChannelData(0)[0],t.getChannelData(1)[0],t.getChannelData(2)[0]];e.some((t,e)=>t!==L[e])&&(A.setOrientation(...e),L=e);const n=[t.getChannelData(3)[0],t.getChannelData(4)[0],t.getChannelData(5)[0]];n.some((t,e)=>t!==z[e])&&(A.setPosition(...n),z=n)},Object.defineProperty(R.gain,"defaultValue",{get:()=>0}),Object.defineProperty(q.gain,"defaultValue",{get:()=>0}),Object.defineProperty(I.gain,"defaultValue",{get:()=>0}),Object.defineProperty(F.gain,"defaultValue",{get:()=>0}),Object.defineProperty(V.gain,"defaultValue",{get:()=>0});const B={get bufferSize(){},get channelCount(){return A.channelCount},set channelCount(t){if(t>2)throw u();j.channelCount=t,A.channelCount=t},get channelCountMode(){return A.channelCountMode},set channelCountMode(t){if("max"===t)throw u();j.channelCountMode=t,A.channelCountMode=t},get channelInterpretation(){return A.channelInterpretation},set channelInterpretation(t){j.channelInterpretation=t,A.channelInterpretation=t},get coneInnerAngle(){return A.coneInnerAngle},set coneInnerAngle(t){A.coneInnerAngle=t},get coneOuterAngle(){return A.coneOuterAngle},set coneOuterAngle(t){A.coneOuterAngle=t},get coneOuterGain(){return A.coneOuterGain},set coneOuterGain(t){if(t<0||t>1)throw e();A.coneOuterGain=t},get context(){return A.context},get distanceModel(){return A.distanceModel},set distanceModel(t){A.distanceModel=t},get inputs(){return[j]},get maxDistance(){return A.maxDistance},set maxDistance(t){if(t<0)throw new RangeError;A.maxDistance=t},get numberOfInputs(){return A.numberOfInputs},get numberOfOutputs(){return A.numberOfOutputs},get orientationX(){return E.gain},get orientationY(){return R.gain},get orientationZ(){return q.gain},get panningModel(){return A.panningModel},set panningModel(t){if(A.panningModel=t,A.panningModel!==t&&"HRTF"===t)throw u()},get positionX(){return I.gain},get positionY(){return F.gain},get positionZ(){return V.gain},get refDistance(){return A.refDistance},set refDistance(t){if(t<0)throw new RangeError;A.refDistance=t},get rolloffFactor(){return A.rolloffFactor},set rolloffFactor(t){if(t<0)throw new RangeError;A.rolloffFactor=t},addEventListener:(...t)=>j.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>j.dispatchEvent(t[0]),removeEventListener:(...t)=>j.removeEventListener(t[0],t[1],t[2])};p!==B.coneInnerAngle&&(B.coneInnerAngle=p),f!==B.coneOuterAngle&&(B.coneOuterAngle=f),_!==B.coneOuterGain&&(B.coneOuterGain=_),m!==B.distanceModel&&(B.distanceModel=m),g!==B.maxDistance&&(B.maxDistance=g),v!==B.orientationX.value&&(B.orientationX.value=v),y!==B.orientationY.value&&(B.orientationY.value=y),b!==B.orientationZ.value&&(B.orientationZ.value=b),x!==B.panningModel&&(B.panningModel=x),w!==B.positionX.value&&(B.positionX.value=w),T!==B.positionY.value&&(B.positionY.value=T),O!==B.positionZ.value&&(B.positionZ.value=O),S!==B.refDistance&&(B.refDistance=S),C!==B.rolloffFactor&&(B.rolloffFactor=C),1===L[0]&&0===L[1]&&0===L[2]||A.setOrientation(...L),0===z[0]&&0===z[1]&&0===z[2]||A.setPosition(...z);return l(Object(i.a)(B,A),()=>{j.connect(A),t(j,P,0,0),P.connect(E).connect(M,0,0),P.connect(R).connect(M,0,1),P.connect(q).connect(M,0,2),P.connect(I).connect(M,0,3),P.connect(F).connect(M,0,4),P.connect(V).connect(M,0,5),M.connect(N).connect(d.destination)},()=>{j.disconnect(A),h(j,P,0,0),P.disconnect(E),E.disconnect(M),P.disconnect(R),R.disconnect(M),P.disconnect(q),q.disconnect(M),P.disconnect(I),I.disconnect(M),P.disconnect(F),F.disconnect(M),P.disconnect(V),V.disconnect(M),M.disconnect(N),N.disconnect(d.destination)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,{disableNormalization:n,imag:s,real:i})=>{const o=t(e),r=new Float32Array(s),a=new Float32Array(i);return null!==o?o.createPeriodicWave(a,r,{disableNormalization:n}):e.createPeriodicWave(a,r,{disableNormalization:n})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n,s,i)=>t(e,t=>t.createScriptProcessor(n,s,i))},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(5),i=n(1);const o=(t,e,n)=>(o,r)=>t(o,t=>{const a=r.channelCountMode;if("clamped-max"===a)throw n();if(void 0===o.createStereoPanner)return e(o,r);const c=t.createStereoPanner();return Object(i.a)(c,r),Object(s.a)(c,r,"pan"),Object.defineProperty(c,"channelCountMode",{get:()=>a,set:t=>{if(t!==a)throw n()}}),c})},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(11);const i=(t,e,n,i,o,r)=>{const a=new Float32Array([1,1]),c=Math.PI/2,u={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},h={...u,oversample:"none"},l=(t,s,r,l,d)=>{if(1===s)return((t,e,s,o)=>{const r=new Float32Array(16385),l=new Float32Array(16385);for(let t=0;t<16385;t+=1){const e=t/16384*c;r[t]=Math.cos(e),l[t]=Math.sin(e)}const d=n(t,{...u,gain:0}),p=i(t,{...h,curve:r}),f=i(t,{...h,curve:a}),_=n(t,{...u,gain:0}),m=i(t,{...h,curve:l});return{connectGraph(){e.connect(d),e.connect(f.inputs[0]),e.connect(_),f.connect(s),s.connect(p.inputs[0]),s.connect(m.inputs[0]),p.connect(d.gain),m.connect(_.gain),d.connect(o,0,0),_.connect(o,0,1)},disconnectGraph(){e.disconnect(d),e.disconnect(f.inputs[0]),e.disconnect(_),f.disconnect(s),s.disconnect(p.inputs[0]),s.disconnect(m.inputs[0]),p.disconnect(d.gain),m.disconnect(_.gain),d.disconnect(o,0,0),_.disconnect(o,0,1)}}})(t,r,l,d);if(2===s)return((t,s,o,r)=>{const l=new Float32Array(16385),d=new Float32Array(16385),p=new Float32Array(16385),f=new Float32Array(16385),_=Math.floor(8192.5);for(let t=0;t<16385;t+=1)if(t>_){const e=(t-_)/(16384-_)*c;l[t]=Math.cos(e),d[t]=Math.sin(e),p[t]=0,f[t]=1}else{const e=t/(16384-_)*c;l[t]=1,d[t]=0,p[t]=Math.cos(e),f[t]=Math.sin(e)}const m=e(t,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2}),g=n(t,{...u,gain:0}),v=i(t,{...h,curve:l}),y=n(t,{...u,gain:0}),b=i(t,{...h,curve:d}),x=i(t,{...h,curve:a}),w=n(t,{...u,gain:0}),T=i(t,{...h,curve:p}),O=n(t,{...u,gain:0}),S=i(t,{...h,curve:f});return{connectGraph(){s.connect(m),s.connect(x.inputs[0]),m.connect(g,1),m.connect(y,1),m.connect(w,1),m.connect(O,1),x.connect(o),o.connect(v.inputs[0]),o.connect(b.inputs[0]),o.connect(T.inputs[0]),o.connect(S.inputs[0]),v.connect(g.gain),b.connect(y.gain),T.connect(w.gain),S.connect(O.gain),g.connect(r,0,0),w.connect(r,0,0),y.connect(r,0,1),O.connect(r,0,1)},disconnectGraph(){s.disconnect(m),s.disconnect(x.inputs[0]),m.disconnect(g,1),m.disconnect(y,1),m.disconnect(w,1),m.disconnect(O,1),x.disconnect(o),o.disconnect(v.inputs[0]),o.disconnect(b.inputs[0]),o.disconnect(T.inputs[0]),o.disconnect(S.inputs[0]),v.disconnect(g.gain),b.disconnect(y.gain),T.disconnect(w.gain),S.disconnect(O.gain),g.disconnect(r,0,0),w.disconnect(r,0,0),y.disconnect(r,0,1),O.disconnect(r,0,1)}}})(t,r,l,d);throw o()};return(e,{channelCount:i,channelCountMode:a,pan:c,...u})=>{if("max"===a)throw o();const h=t(e,{...u,channelCount:1,channelCountMode:a,numberOfInputs:2}),d=n(e,{...u,channelCount:i,channelCountMode:a,gain:1}),p=n(e,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:c});let{connectGraph:f,disconnectGraph:_}=l(e,i,d,p,h);Object.defineProperty(p.gain,"defaultValue",{get:()=>0});const m={get bufferSize(){},get channelCount(){return d.channelCount},set channelCount(t){d.channelCount!==t&&(g&&_(),({connectGraph:f,disconnectGraph:_}=l(e,t,d,p,h)),g&&f()),d.channelCount=t},get channelCountMode(){return d.channelCountMode},set channelCountMode(t){if("clamped-max"===t||"max"===t)throw o();d.channelCountMode=t},get channelInterpretation(){return d.channelInterpretation},set channelInterpretation(t){d.channelInterpretation=t},get context(){return d.context},get inputs(){return[d]},get numberOfInputs(){return d.numberOfInputs},get numberOfOutputs(){return d.numberOfOutputs},get pan(){return p.gain},addEventListener:(...t)=>d.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>d.dispatchEvent(t[0]),removeEventListener:(...t)=>d.removeEventListener(t[0],t[1],t[2])};let g=!1;return r(Object(s.a)(m,h),()=>{f(),g=!0},()=>{_(),g=!1})}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(4),i=n(1);const o=(t,e,n,o,r,a,c)=>(u,h)=>{const l=n(u,t=>t.createWaveShaper());try{return l.curve=new Float32Array([1]),o(u,h)}catch{}Object(i.a)(l,h);const d=h.curve;if(null!==d&&d.length<2)throw e();Object(s.a)(l,h,"curve"),Object(s.a)(l,h,"oversample");let p=null,f=!1;c(l,"curve",t=>()=>t.call(l),e=>n=>(e.call(l,n),f&&(r(n)&&null===p?p=t(u,l):r(n)||null===p||(p(),p=null)),n));return a(l,()=>{f=!0,r(l.curve)&&(p=t(u,l))},()=>{f=!1,null!==p&&(p(),p=null)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(1),i=n(11);const o=(t,e,n,o,r,a)=>(c,{curve:u,oversample:h,...l})=>{const d=n(c,t=>t.createWaveShaper()),p=n(c,t=>t.createWaveShaper());Object(s.a)(d,l),Object(s.a)(p,l);const f=o(c,{...l,gain:1}),_=o(c,{...l,gain:-1}),m=o(c,{...l,gain:1}),g=o(c,{...l,gain:-1});let v=null,y=!1,b=null;const x={get bufferSize(){},get channelCount(){return d.channelCount},set channelCount(t){f.channelCount=t,_.channelCount=t,d.channelCount=t,m.channelCount=t,p.channelCount=t,g.channelCount=t},get channelCountMode(){return d.channelCountMode},set channelCountMode(t){f.channelCountMode=t,_.channelCountMode=t,d.channelCountMode=t,m.channelCountMode=t,p.channelCountMode=t,g.channelCountMode=t},get channelInterpretation(){return d.channelInterpretation},set channelInterpretation(t){f.channelInterpretation=t,_.channelInterpretation=t,d.channelInterpretation=t,m.channelInterpretation=t,p.channelInterpretation=t,g.channelInterpretation=t},get context(){return d.context},get curve(){return b},set curve(n){if(null!==u&&u.length<2)throw e();if(null===n)d.curve=n,p.curve=n;else{const t=n.length,e=new Float32Array(t+2-t%2),s=new Float32Array(t+2-t%2);e[0]=n[0],s[0]=-n[t-1];const i=Math.ceil((t+1)/2),o=(t+1)/2-1;for(let r=1;r<i;r+=1){const a=r/i*o,c=Math.floor(a),u=Math.ceil(a);e[r]=c===u?n[c]:(1-(a-c))*n[c]+(1-(u-a))*n[u],s[r]=c===u?-n[t-1-c]:-(1-(a-c))*n[t-1-c]-(1-(u-a))*n[t-1-u]}e[i]=t%2==1?n[i-1]:(n[i-2]+n[i-1])/2,d.curve=e,p.curve=s}b=n,y&&(r(b)&&null===v?v=t(c,f):null!==v&&(v(),v=null))},get inputs(){return[f]},get numberOfInputs(){return d.numberOfInputs},get numberOfOutputs(){return d.numberOfOutputs},get oversample(){return d.oversample},set oversample(t){d.oversample=t,p.oversample=t},addEventListener:(...t)=>f.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>f.dispatchEvent(t[0]),removeEventListener:(...t)=>f.removeEventListener(t[0],t[1],t[2])};u!==x.curve&&(x.curve=u),h!==x.oversample&&(x.oversample=h);return a(Object(i.a)(x,m),()=>{f.connect(d).connect(m),f.connect(_).connect(p).connect(g).connect(m),y=!0,r(b)&&(v=t(c,f))},()=>{f.disconnect(d),d.disconnect(m),f.disconnect(_),_.disconnect(p),p.disconnect(g),g.disconnect(m),y=!1,null!==v&&(v(),v=null)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(14);const i={numberOfChannels:1},o=(t,e,n,o,r)=>class extends t{constructor(t,n,r){let a;if("number"==typeof t&&void 0!==n&&void 0!==r)a={length:n,numberOfChannels:t,sampleRate:r};else{if("object"!=typeof t)throw new Error("The given parameters are not valid.");a=t}const{length:c,numberOfChannels:u,sampleRate:h}={...i,...a},l=o(u,c,h);e(s.a,()=>Object(s.a)(l))||l.addEventListener("statechange",(()=>{let t=0;const e=n=>{"running"===this._state&&(t>0?(l.removeEventListener("statechange",e),n.stopImmediatePropagation(),this._waitForThePromiseToSettle(n)):t+=1)};return e})()),super(l,u),this._length=c,this._nativeOfflineAudioContext=l,this._state=null}get length(){return void 0===this._nativeOfflineAudioContext.length?this._length:this._nativeOfflineAudioContext.length}get state(){return null===this._state?this._nativeOfflineAudioContext.state:this._state}startRendering(){return"running"===this._state?Promise.reject(n()):(this._state="running",r(this.destination,this._nativeOfflineAudioContext).then(t=>(this._state=null,t)).catch(t=>{throw this._state=null,t}))}_waitForThePromiseToSettle(t){null===this._state?this._nativeOfflineAudioContext.dispatchEvent(t):setTimeout(()=>this._waitForThePromiseToSettle(t))}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var s=n(17),i=n(21);const o={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,type:"sine"},r=(t,e,n,r,a,c,u,h)=>class extends t{constructor(t,n=o){const s=c(t),i={...o,...n},h=r(s,i),l=u(s),d=l?a():null,p=t.sampleRate/2;super(t,!1,h,d),this._detune=e(this,l,h.detune,153600,-153600),this._frequency=e(this,l,h.frequency,p,-p),this._nativeOscillatorNode=h,this._onended=null,this._oscillatorNodeRenderer=d,null!==this._oscillatorNodeRenderer&&void 0!==i.periodicWave&&(this._oscillatorNodeRenderer.periodicWave=i.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(t){const e="function"==typeof t?h(this,t):null;this._nativeOscillatorNode.onended=e;const n=this._nativeOscillatorNode.onended;this._onended=null!==n&&n===e?t:n}get type(){return this._nativeOscillatorNode.type}set type(t){if(this._nativeOscillatorNode.type=t,"custom"===t)throw n();null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(t){this._nativeOscillatorNode.setPeriodicWave(t),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.periodicWave=t)}start(t=0){if(this._nativeOscillatorNode.start(t),null!==this._oscillatorNodeRenderer)this._oscillatorNodeRenderer.start=t;else{Object(s.a)(this);const t=()=>{this._nativeOscillatorNode.removeEventListener("ended",t),setTimeout(()=>Object(i.a)(this),1e3)};this._nativeOscillatorNode.addEventListener("ended",t)}}stop(t=0){this._nativeOscillatorNode.stop(t),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.stop=t)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(3);const i=(t,e,n,i,o)=>()=>{const r=new WeakMap;let a=null,c=null,u=null;return{set periodicWave(t){a=t},set start(t){c=t},set stop(t){u=t},render(h,l,d){const p=r.get(l);return void 0!==p?Promise.resolve(p):(async(h,l,d)=>{let p=n(h);const f=Object(s.a)(p,l);if(!f){const t={channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,detune:p.detune.value,frequency:p.frequency.value,periodicWave:null===a?void 0:a,type:p.type};p=e(l,t),null!==c&&p.start(c),null!==u&&p.stop(u)}return r.set(l,p),f?(await t(l,h.detune,p.detune,d),await t(l,h.frequency,p.frequency,d)):(await i(l,h.detune,p.detune,d),await i(l,h.frequency,p.frequency,d)),await o(h,l,p,d),p})(h,l,d)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(2);const i={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1},o=(t,e,n,o,r,a)=>class extends t{constructor(t,c=i){const u=r(t),h={...i,...c},l=n(u,h),d=a(u);super(t,!1,l,d?o():null),this._nativePannerNode=l,this._orientationX=e(this,d,l.orientationX,s.b,s.a),this._orientationY=e(this,d,l.orientationY,s.b,s.a),this._orientationZ=e(this,d,l.orientationZ,s.b,s.a),this._positionX=e(this,d,l.positionX,s.b,s.a),this._positionY=e(this,d,l.positionY,s.b,s.a),this._positionZ=e(this,d,l.positionZ,s.b,s.a)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(t){this._nativePannerNode.coneInnerAngle=t}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(t){this._nativePannerNode.coneOuterAngle=t}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(t){this._nativePannerNode.coneOuterGain=t}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(t){this._nativePannerNode.distanceModel=t}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(t){this._nativePannerNode.maxDistance=t}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(t){this._nativePannerNode.panningModel=t}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(t){this._nativePannerNode.refDistance=t}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(t){this._nativePannerNode.rolloffFactor=t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(12),i=n(3);const o=(t,e,n,o,r,a,c,u,h,l)=>()=>{const d=new WeakMap;let p=null;return{render(f,_,m){const g=d.get(_);return void 0!==g?Promise.resolve(g):(async(f,_,m)=>{let g=null,v=a(f);const y={channelCount:v.channelCount,channelCountMode:v.channelCountMode,channelInterpretation:v.channelInterpretation},b={...y,coneInnerAngle:v.coneInnerAngle,coneOuterAngle:v.coneOuterAngle,coneOuterGain:v.coneOuterGain,distanceModel:v.distanceModel,maxDistance:v.maxDistance,panningModel:v.panningModel,refDistance:v.refDistance,rolloffFactor:v.rolloffFactor},x=Object(i.a)(v,_);if("bufferSize"in v)g=o(_,{...y,gain:1});else if(!x){const t={...b,orientationX:v.orientationX.value,orientationY:v.orientationY.value,orientationZ:v.orientationZ.value,positionX:v.positionX.value,positionY:v.positionY.value,positionZ:v.positionZ.value};v=r(_,t)}if(d.set(_,null===g?v:g),null!==g){if(null===p){if(null===c)throw new Error("Missing the native OfflineAudioContext constructor.");const t=new c(6,f.context.length,_.sampleRate),s=e(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});s.connect(t.destination),p=(async()=>{const e=await Promise.all([f.orientationX,f.orientationY,f.orientationZ,f.positionX,f.positionY,f.positionZ].map(async(e,s)=>{const i=n(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:0===s?1:0});return await u(t,e,i.offset,m),i}));for(let t=0;t<6;t+=1)e[t].connect(s,0,t),e[t].start(0);return l(t)})()}const t=await p,s=o(_,{...y,gain:1});await h(f,_,s,m);const i=[];for(let e=0;e<t.numberOfChannels;e+=1)i.push(t.getChannelData(e));let a=[i[0][0],i[1][0],i[2][0]],d=[i[3][0],i[4][0],i[5][0]],v=o(_,{...y,gain:1}),x=r(_,{...b,orientationX:a[0],orientationY:a[1],orientationZ:a[2],positionX:d[0],positionY:d[1],positionZ:d[2]});s.connect(v).connect(x.inputs[0]),x.connect(g);for(let e=128;e<t.length;e+=128){const t=[i[0][e],i[1][e],i[2][e]],n=[i[3][e],i[4][e],i[5][e]];if(t.some((t,e)=>t!==a[e])||n.some((t,e)=>t!==d[e])){a=t,d=n;const i=e/_.sampleRate;v.gain.setValueAtTime(0,i),v=o(_,{...y,gain:0}),x=r(_,{...b,orientationX:a[0],orientationY:a[1],orientationZ:a[2],positionX:d[0],positionY:d[1],positionZ:d[2]}),v.gain.setValueAtTime(1,i),s.connect(v).connect(x.inputs[0]),x.connect(g)}}return g}return x?(await t(_,f.orientationX,v.orientationX,m),await t(_,f.orientationY,v.orientationY,m),await t(_,f.orientationZ,v.orientationZ,m),await t(_,f.positionX,v.positionX,m),await t(_,f.positionY,v.positionY,m),await t(_,f.positionZ,v.positionZ,m)):(await u(_,f.orientationX,v.orientationX,m),await u(_,f.orientationY,v.orientationY,m),await u(_,f.orientationZ,v.orientationZ,m),await u(_,f.positionX,v.positionX,m),await u(_,f.positionY,v.positionY,m),await u(_,f.positionZ,v.positionZ,m)),Object(s.a)(v)?await h(f,_,v.inputs[0],m):await h(f,_,v,m),v})(f,_,m)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={disableNormalization:!1},i=(t,e,n)=>class i{constructor(i,o){const r=e(i),a={...s,...o},c=t(r,a);return n.add(c),c}static[Symbol.hasInstance](t){return null!==t&&"object"==typeof t&&Object.getPrototypeOf(t)===i.prototype||n.has(t)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>(n,s,i,o)=>(t(s).replay(i),e(s,n,i,o))},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>async(s,i,o,r)=>{const a=t(s),c=[...r,s];await Promise.all(a.activeInputs.map((t,r)=>Array.from(t).filter(([t])=>!c.includes(t)).map(async([t,a])=>{const u=e(t),h=await u.render(t,i,c),l=s.context.destination;n(t)||s===l&&n(s)||h.connect(o,a,r)})).reduce((t,e)=>[...t,...e],[]))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>async(s,i,o,r)=>{const a=e(s);await Promise.all(Array.from(a.activeInputs).map(async([e,s])=>{const a=t(e),c=await a.render(e,i,r);n(e)||c.connect(o,s)}))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(14);const i=(t,e,n,i)=>o=>t(s.a,()=>Object(s.a)(o))?Promise.resolve(t(i,i)).then(t=>{if(!t){const t=n(o,512,0,1);o.oncomplete=()=>{t.onaudioprocess=null,t.disconnect()},t.onaudioprocess=()=>o.currentTime,t.connect(o.destination)}return o.startRendering()}):new Promise(t=>{const n=e(o,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});o.oncomplete=e=>{n.disconnect(),t(e.renderedBuffer)},n.connect(o.destination),o.startRendering()})},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(29);const i=(t,e,n,i,o,r,a,c)=>{const u=[];return(h,l)=>n(h).render(h,l,u).then(()=>Promise.all(Array.from(i(l)).map(t=>n(t).render(t,l,u)))).then(()=>o(l)).then(n=>("function"!=typeof n.copyFromChannel?(a(n),Object(s.a)(n)):e(r,()=>r(n))||c(n),t.add(n),n))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0},i=(t,e,n,i,o,r)=>class extends t{constructor(t,a=s){const c=o(t),u={...s,...a},h=n(c,u),l=r(c);super(t,!1,h,l?i():null),this._pan=e(this,l,h.pan,1,-1)}get pan(){return this._pan}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(12),i=n(3);const o=(t,e,n,o,r)=>()=>{const a=new WeakMap;return{render(c,u,h){const l=a.get(u);return void 0!==l?Promise.resolve(l):(async(c,u,h)=>{let l=n(c);const d=Object(i.a)(l,u);if(!d){const t={channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,pan:l.pan.value};l=e(u,t)}return a.set(u,l),d?await t(u,c.pan,l.pan,h):await o(u,c.pan,l.pan,h),Object(s.a)(l)?await r(c,u,l.inputs[0],h):await r(c,u,l,h),l})(c,u,h)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;try{new t({length:1,sampleRate:44100})}catch{return!1}return!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;const e=new t(1,1,44100).createBuffer(1,1,44100);if(void 0===e.copyToChannel)return!0;const n=new Float32Array(2);try{e.copyFromChannel(n,0,0)}catch{return!1}return!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e,t=>t.createBufferSource());n.start();try{n.start()}catch{return!0}return!1}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return Promise.resolve(!1);const e=new t(1,1,44100),n=e.createBuffer(1,1,e.sampleRate),s=e.createBufferSource();return n.getChannelData(0)[0]=1,s.buffer=n,s.start(0,0,0),s.connect(e.destination),new Promise(t=>{e.oncomplete=({renderedBuffer:e})=>{t(0===e.getChannelData(0)[0])},e.startRendering()})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e,t=>t.createBufferSource()),s=e.createBuffer(1,1,44100);n.buffer=s;try{n.start(0,1)}catch{return!1}return!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e,t=>t.createBufferSource());n.start();try{n.stop()}catch{return!1}return!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;if(void 0!==t.prototype&&void 0!==t.prototype.close)return!0;const e=new t,n=void 0!==e.close;try{e.close()}catch{}return n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return Promise.resolve(!1);const e=new t(1,1,44100);return new Promise(t=>{let n=!0;const s=s=>{n&&(n=!1,e.startRendering(),t(s instanceof TypeError))};let i;try{i=e.decodeAudioData(null,()=>{},s)}catch(t){s(t)}void 0!==i&&i.catch(s)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;let e;try{e=new t({latencyHint:"balanced"})}catch{return!1}return e.close(),!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;const e=new t(1,1,44100).createGain(),n=e.connect(e)===e;return e.disconnect(e),n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e,t=>t.createOscillator());try{n.start(-1)}catch(t){return t instanceof RangeError}return!1}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=e.createBuffer(1,1,44100),s=t(e,t=>t.createBufferSource());s.buffer=n,s.start(),s.stop();try{return s.stop(),!0}catch{return!1}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{const n=t(e,t=>t.createOscillator());try{n.stop(-1)}catch(t){return t instanceof RangeError}return!1}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>async()=>{if(null===t)return!0;if(null===e)return!1;const n=new Blob(['class A extends AudioWorkletProcessor{process(){this.port.postMessage(0)}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),s=new e(1,128,3200),i=URL.createObjectURL(n);let o=!1;try{await s.audioWorklet.addModule(i);const e=s.createGain(),n=new t(s,"a",{numberOfOutputs:0});n.port.onmessage=()=>o=!0,e.connect(n),await s.startRendering()}catch{}finally{URL.revokeObjectURL(i)}return o}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>()=>{if(null===e)return!1;const n=new e(1,1,44100),s=t(n,t=>t.createChannelMerger());try{s.channelCount=2}catch{return!0}return!1}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>()=>{if(null===e)return!1;const n=new e(1,1,44100);return void 0===n.createConstantSource||t(n,t=>t.createConstantSource()).offset.maxValue!==Number.POSITIVE_INFINITY}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;const e=new t(1,1,44100),n=e.createConvolver();n.buffer=e.createBuffer(1,1,e.sampleRate);try{n.buffer=e.createBuffer(1,1,e.sampleRate)}catch{return!1}return!0}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>null!==t&&t.hasOwnProperty("isSecureContext")},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return!1;const e=new t;try{return e.createMediaStreamSource(new MediaStream),!1}catch(t){return!0}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>()=>{if(null===e)return Promise.resolve(!1);const n=new e(1,1,44100),s=t(n,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(t=>{n.oncomplete=()=>{s.disconnect(),t(0!==n.currentTime)},n.startRendering()})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>()=>{if(null===t)return Promise.resolve(!1);const e=new t(1,1,44100);if(void 0===e.createStereoPanner)return Promise.resolve(!0);if(void 0===e.createConstantSource)return Promise.resolve(!0);const n=e.createConstantSource(),s=e.createStereoPanner();return n.channelCount=1,n.offset.value=1,s.channelCount=1,n.start(),n.connect(s).connect(e.destination),e.startRendering().then(t=>1!==t.getChannelData(0)[0])}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));const s={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"},i=(t,e,n,i,o,r)=>class extends t{constructor(t,e=s){const a=o(t),c={...s,...e},u=n(a,c);super(t,!0,u,r(a)?i():null),this._isCurveNullified=!1,this._nativeWaveShaperNode=u}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(t){if(null===t)this._isCurveNullified=!0,this._nativeWaveShaperNode.curve=new Float32Array([0,0]);else{if(t.length<2)throw e();this._isCurveNullified=!1,this._nativeWaveShaperNode.curve=t}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(t){this._nativeWaveShaperNode.oversample=t}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(12),i=n(3);const o=(t,e,n)=>()=>{const o=new WeakMap;return{render(r,a,c){const u=o.get(a);return void 0!==u?Promise.resolve(u):(async(r,a,c)=>{let u=e(r);if(!Object(i.a)(u,a)){const e={channelCount:u.channelCount,channelCountMode:u.channelCountMode,channelInterpretation:u.channelInterpretation,curve:u.curve,oversample:u.oversample};u=t(a,e)}return o.set(a,u),Object(s.a)(u)?await n(r,a,u.inputs[0],c):await n(r,a,u,c),u})(r,a,c)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>"undefined"==typeof window?null:window},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e)=>n=>{n.copyFromChannel=(s,i,o=0)=>{const r=t(o),a=t(i);if(a>=n.numberOfChannels)throw e();const c=n.length,u=n.getChannelData(a),h=s.length;for(let t=r<0?-r:0;t+r<c&&t<h;t+=1)s[t]=u[t+r]},n.copyToChannel=(s,i,o=0)=>{const r=t(o),a=t(i);if(a>=n.numberOfChannels)throw e();const c=n.length,u=n.getChannelData(a),h=s.length;for(let t=r<0?-r:0;t+r<c&&t<h;t+=1)u[t+r]=s[t]}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>e=>{var n,s;e.copyFromChannel=(n=e.copyFromChannel,(s,i,o=0)=>{const r=t(o),a=t(i);if(r<e.length)return n.call(e,s,a,r)}),e.copyToChannel=(s=e.copyToChannel,(n,i,o=0)=>{const r=t(o),a=t(i);if(r<e.length)return s.call(e,n,a,r)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>(e,n)=>{const s=n.createBuffer(1,1,n.sampleRate);null===e.buffer&&(e.buffer=s),t(e,"buffer",t=>()=>{const n=t.call(e);return n===s?null:n},t=>n=>t.call(e,null===n?s:n))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(11);const i=t=>(e,n)=>{const i=t(n,t=>t.createGain());e.connect(i);const o=(r=e.disconnect,()=>{r.call(e,i),e.removeEventListener("ended",o)});var r;e.addEventListener("ended",o),Object(s.a)(e,i),e.stop=(t=>{let n=!1;return(s=0)=>{if(n)try{t.call(e,s)}catch{i.gain.setValueAtTime(0,s)}else t.call(e,s),n=!0}})(e.stop)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n)=>(s,i)=>{i.channelCount=1,i.channelCountMode="explicit",Object.defineProperty(i,"channelCount",{get:()=>1,set:()=>{throw t()}}),Object.defineProperty(i,"channelCountMode",{get:()=>"explicit",set:()=>{throw t()}});const o=e(s,t=>t.createBufferSource());n(i,()=>{const t=i.numberOfInputs;for(let e=0;e<t;e+=1)o.connect(i,0,e)},()=>o.disconnect(i))}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=()=>new Promise(t=>{const e=new ArrayBuffer(0),{port1:n,port2:s}=new MessageChannel;n.onmessage=({data:e})=>t(null!==e),s.postMessage(e,[e])})},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=t=>{var e;t.start=(e=t.start,(n=0,s=0,i)=>{const o=t.buffer,r=null===o?s:Math.min(o.duration,s);null!==o&&r>o.duration-.5/t.context.sampleRate?e.call(t,n,0,0):e.call(t,n,r,i)})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return N}));var s=n(0),i=n(24),o=n(22);const r=t=>"port"in t;var a=n(33),c=n(20);const u=(t,e)=>{if(!Object(c.a)(t).delete(e))throw new Error("Missing the expected event listener.")};var h=n(34),l=n(8),d=n(26),p=n(6),f=n(27),_=n(9),m=n(16),g=n(23),v=n(19);const y=t=>!s.a.has(t),b=(t,e)=>{const n=Array.from(t).filter(e);if(n.length>1)throw Error("More than one element was found.");if(0===n.length)throw Error("No element was found.");const[s]=n;return t.delete(s),s};var x=n(17),w=n(21);const T=(t,e)=>{!r(t)&&e.every(t=>0===t.size)&&Object(w.a)(t)},O=t=>new Promise(e=>{const n=t.createScriptProcessor(256,1,1),s=t.createGain(),i=t.createBuffer(1,2,44100),o=i.getChannelData(0);o[0]=1,o[1]=1;const r=t.createBufferSource();r.buffer=i,r.loop=!0,r.connect(n).connect(t.destination),r.connect(s),r.disconnect(s),n.onaudioprocess=s=>{const i=s.inputBuffer.getChannelData(0);Array.prototype.some.call(i,t=>1===t)?e(!0):e(!1),r.stop(),n.onaudioprocess=null,r.disconnect(n),n.disconnect(t.destination)},r.start()}),S=(t,e)=>{const n=new Map;for(const e of t)for(const t of e){const e=n.get(t);n.set(t,void 0===e?1:e+1)}n.forEach((t,n)=>e(n,t))};var C=n(25);const k=(t,e,[n,s,i],o)=>{Object(m.a)(t[s],[e,n,i],t=>t[0]===e&&t[1]===n,o)},A=(t,e,[n,s],i)=>{Object(m.a)(t,[e,n,s],t=>t[0]===e&&t[1]===n,i)},D=(t,e,[n,s,i],o)=>{const r=t.get(n);void 0===r?t.set(n,new Set([[s,e,i]])):Object(m.a)(r,[s,e,i],t=>t[0]===s&&t[1]===e,o)},M=(t,[e,n,s],i)=>{const o=t.get(e);void 0===o?t.set(e,new Set([[n,s]])):Object(m.a)(o,[n,s],t=>t[0]===n,i)},j=(t,e,n,s)=>{const i=Object(_.a)(t,e),o=b(i,t=>t[0]===n&&t[1]===s);return 0===i.size&&t.delete(e),o},E=(t,e,n)=>{const s=Object(_.a)(t,e),i=b(s,t=>t[0]===n);return 0===s.size&&t.delete(e),i},R=(t,e,n,s)=>{const{activeInputs:i,passiveInputs:o}=Object(l.a)(e),{outputs:r}=Object(l.a)(t),u=Object(c.a)(t),d=r=>{const c=Object(p.a)(e),u=Object(p.a)(t);if(r){const r=j(o,t,n,s);k(i,t,r,!1),Object(v.a)(t)||Object(a.a)(u,c,n,s),y(e)&&Object(x.a)(e)}else{const r=((t,e,n,s)=>b(t[s],t=>t[0]===e&&t[1]===n))(i,t,n,s);D(o,s,r,!1),Object(v.a)(t)||Object(h.a)(u,c,n,s),Object(g.a)(e)&&T(e,i)}};return!!Object(m.a)(r,[e,n,s],t=>t[0]===e&&t[1]===n&&t[2]===s,!0)&&(u.add(d),Object(g.a)(t)?k(i,t,[n,s,d],!0):D(o,s,[t,n,d],!0),!0)},q=(t,e,n)=>{const{activeInputs:s,passiveInputs:i}=Object(d.a)(e),{outputs:o}=Object(l.a)(t),r=Object(c.a)(t),a=o=>{const r=Object(p.a)(t),a=Object(f.a)(e);if(o){const e=E(i,t,n);A(s,t,e,!1),Object(v.a)(t)||r.connect(a,n)}else{const e=((t,e,n)=>b(t,t=>t[0]===e&&t[1]===n))(s,t,n);M(i,e,!1),Object(v.a)(t)||r.disconnect(a,n)}};return!!Object(m.a)(o,[e,n],t=>t[0]===e&&t[1]===n,!0)&&(r.add(a),Object(g.a)(t)?A(s,t,[n,a],!0):M(i,[t,n,a],!0),!0)},I=(t,e,n)=>{for(const s of t)if(s[0]===e&&s[1]===n)return t.delete(s),s;return null},F=(t,e,n,s)=>{const[i,o]=((t,e,n,s)=>{const{activeInputs:i,passiveInputs:o}=Object(l.a)(e),r=I(i[s],t,n);if(null===r){return[j(o,t,n,s)[2],!1]}return[r[2],!0]})(t,e,n,s);if(null!==i&&(u(t,i),o&&!Object(v.a)(t)&&Object(h.a)(Object(p.a)(t),Object(p.a)(e),n,s)),Object(g.a)(e)){const{activeInputs:t}=Object(l.a)(e);T(e,t)}},V=(t,e,n)=>{const[s,i]=((t,e,n)=>{const{activeInputs:s,passiveInputs:i}=Object(d.a)(e),o=I(s,t,n);if(null===o){return[E(i,t,n)[1],!1]}return[o[2],!0]})(t,e,n);null!==s&&(u(t,s),i&&!Object(v.a)(t)&&Object(p.a)(t).disconnect(Object(f.a)(e),n))},N=(t,e,n,c,u,h,_,g,v,b,w,T,D,M,j)=>class extends b{constructor(e,i,o,r){super(o),this._context=e,this._nativeAudioNode=o;const a=w(e);T(a)&&!0!==n(O,()=>O(a))&&(t=>{const e=new Map;var n,s;t.connect=(n=t.connect.bind(t),(t,s=0,i=0)=>{const o=Object(C.a)(t)?n(t,s,i):n(t,s),r=e.get(t);return void 0===r?e.set(t,[{input:i,output:s}]):r.every(t=>t.input!==i||t.output!==s)&&r.push({input:i,output:s}),o}),t.disconnect=(s=t.disconnect,(n,i,o)=>{if(s.apply(t),void 0===n)e.clear();else if("number"==typeof n)for(const[t,s]of e){const i=s.filter(t=>t.output!==n);0===i.length?e.delete(t):e.set(t,i)}else if(e.has(n))if(void 0===i)e.delete(n);else{const t=e.get(n);if(void 0!==t){const s=t.filter(t=>t.output!==i&&(t.input!==o||void 0===o));0===s.length?e.delete(n):e.set(n,s)}}for(const[n,s]of e)s.forEach(e=>{Object(C.a)(n)?t.connect(n,e.output,e.input):t.connect(n,e.output)})})})(o),s.c.set(this,o),s.i.set(this,new Set),i&&Object(x.a)(this),t(this,r,o)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(t){this._nativeAudioNode.channelCount=t}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(t){this._nativeAudioNode.channelCountMode=t}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(t){this._nativeAudioNode.channelInterpretation=t}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(t,n=0,s=0){if(n<0||n>=this._nativeAudioNode.numberOfOutputs)throw u();const o=w(this._context),g=j(o);if(D(t)||M(t))throw h();if(Object(i.a)(t)){const i=Object(p.a)(t);try{const c=Object(a.a)(this._nativeAudioNode,i,n,s);if(g||y(this)?this._nativeAudioNode.disconnect(...c):y(t)&&Object(x.a)(t),r(t)){const t=e.get(i);if(void 0===t){const t=o.createGain();t.connect(c[0],0,c[2]),e.set(i,new Map([[s,t]]))}else if(void 0===t.get(s)){const e=o.createGain();e.connect(c[0],0,c[2]),t.set(s,e)}}}catch(t){if(12===t.code)throw h();throw t}if(g?((t,e,n,s)=>{const{outputs:i}=Object(l.a)(t);if(Object(m.a)(i,[e,n,s],t=>t[0]===e&&t[1]===n&&t[2]===s,!0)){const{activeInputs:i}=Object(l.a)(e);return k(i,t,[n,s,null],!0),!0}return!1})(this,t,n,s):R(this,t,n,s)){const e=v([this],t);S(e,c(g))}return t}const b=Object(f.a)(t);if("playbackRate"===b.name)throw _();try{this._nativeAudioNode.connect(b,n),(g||y(this))&&this._nativeAudioNode.disconnect(b,n)}catch(t){if(12===t.code)throw h();throw t}if(g?((t,e,n)=>{const{outputs:s}=Object(l.a)(t);if(Object(m.a)(s,[e,n],t=>t[0]===e&&t[1]===n,!0)){const{activeInputs:s}=Object(d.a)(e);return A(s,t,[n,null],!0),!0}return!1})(this,t,n):q(this,t,n)){const e=v([this],t);S(e,c(g))}}disconnect(t,e,n){let s;if(void 0===t)s=(t=>{const e=Object(l.a)(t),n=[];for(const s of e.outputs)Object(o.a)(s)?F(t,...s):V(t,...s),n.push(s[0]);return e.outputs.clear(),n})(this);else if("number"==typeof t){if(t<0||t>=this.numberOfOutputs)throw u();s=((t,e)=>{const n=Object(l.a)(t),s=[];for(const i of n.outputs)i[1]===e&&(Object(o.a)(i)?F(t,...i):V(t,...i),s.push(i[0]),n.outputs.delete(i));return s})(this,t)}else{if(void 0!==e&&(e<0||e>=this.numberOfOutputs))throw u();if(Object(i.a)(t)&&void 0!==n&&(n<0||n>=t.numberOfInputs))throw u();if(s=((t,e,n,s)=>{const i=Object(l.a)(t);return Array.from(i.outputs).filter(t=>!(t[0]!==e||void 0!==n&&t[1]!==n||void 0!==s&&t[2]!==s)).map(e=>(Object(o.a)(e)?F(t,...e):V(t,...e),i.outputs.delete(e),e[0]))})(this,t,e,n),0===s.length)throw h()}for(const t of s){const e=v([this],t);S(e,g)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var s=n(2),i=n(43),o=n(35),r=n(41),a=n(0);const c=async(t,e)=>new t(await(t=>new Promise((e,n)=>{const{port1:s,port2:i}=new MessageChannel;s.onmessage=({data:t})=>{s.close(),i.close(),e(t)},s.onmessageerror=({data:t})=>{s.close(),i.close(),n(t)},i.postMessage(t)}))(e));var u=n(36),h=n(40);const l=(t,e,n,l,d,p,f,_,m,g,v,y,b)=>(x,w,T,O)=>{if(0===O.numberOfInputs&&0===O.numberOfOutputs)throw g();if(void 0!==O.outputChannelCount){if(O.outputChannelCount.some(t=>t<1))throw g();if(O.outputChannelCount.length!==O.numberOfOutputs)throw n()}if("explicit"!==O.channelCountMode)throw g();const S=O.channelCount*O.numberOfInputs,C=O.outputChannelCount.reduce((t,e)=>t+e,0),k=void 0===T.parameterDescriptors?0:T.parameterDescriptors.length;if(S+k>6||C>6)throw g();const A=new MessageChannel,D=[],M=[];for(let t=0;t<O.numberOfInputs;t+=1)D.push(_(x,{channelCount:O.channelCount,channelCountMode:O.channelCountMode,channelInterpretation:O.channelInterpretation,gain:1})),M.push(p(x,{channelCount:O.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:O.channelCount}));const j=[];if(void 0!==T.parameterDescriptors)for(const{defaultValue:t,maxValue:e,minValue:n,name:i}of T.parameterDescriptors){const o=f(x,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:void 0!==O.parameterData[i]?O.parameterData[i]:void 0===t?0:t});Object.defineProperties(o.offset,{defaultValue:{get:()=>void 0===t?0:t},maxValue:{get:()=>void 0===e?s.b:e},minValue:{get:()=>void 0===n?s.a:n}}),j.push(o)}const E=d(x,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,S+k)}),R=Object(i.a)(w,x.sampleRate),q=m(x,R,S+k,Math.max(1,C)),I=p(x,{channelCount:Math.max(1,C),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,C)}),F=[];for(let t=0;t<O.numberOfOutputs;t+=1)F.push(d(x,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:O.outputChannelCount[t]}));for(let t=0;t<O.numberOfInputs;t+=1){D[t].connect(M[t]);for(let e=0;e<O.channelCount;e+=1)M[t].connect(E,e,t*O.channelCount+e)}const V=new h.a(void 0===T.parameterDescriptors?[]:T.parameterDescriptors.map(({name:t},e)=>{const n=j[e];return n.connect(E,0,S+e),n.start(0),[t,n.offset]}));E.connect(q);let N=O.channelInterpretation,P=null;const L=0===O.numberOfOutputs?[q]:F,z={get bufferSize(){return R},get channelCount(){return O.channelCount},set channelCount(t){throw l()},get channelCountMode(){return O.channelCountMode},set channelCountMode(t){throw l()},get channelInterpretation(){return N},set channelInterpretation(t){for(const e of D)e.channelInterpretation=t;N=t},get context(){return q.context},get inputs(){return D},get numberOfInputs(){return O.numberOfInputs},get numberOfOutputs(){return O.numberOfOutputs},get onprocessorerror(){return P},set onprocessorerror(t){"function"==typeof P&&z.removeEventListener("processorerror",P),P="function"==typeof t?t:null,"function"==typeof P&&z.addEventListener("processorerror",P)},get parameters(){return V},get port(){return A.port2},addEventListener:(...t)=>q.addEventListener(t[0],t[1],t[2]),connect:e.bind(null,L),disconnect:v.bind(null,L),dispatchEvent:(...t)=>q.dispatchEvent(t[0]),removeEventListener:(...t)=>q.removeEventListener(t[0],t[1],t[2])},B=new Map;var W,U;A.port1.addEventListener=(W=A.port1.addEventListener,(...t)=>{if("message"===t[0]){const e="function"==typeof t[1]?t[1]:"object"==typeof t[1]&&null!==t[1]&&"function"==typeof t[1].handleEvent?t[1].handleEvent:null;if(null!==e){const n=B.get(t[1]);void 0!==n?t[1]=n:(t[1]=t=>{y(x.currentTime,x.sampleRate,()=>e(t))},B.set(e,t[1]))}}return W.call(A.port1,t[0],t[1],t[2])}),A.port1.removeEventListener=(U=A.port1.removeEventListener,(...t)=>{if("message"===t[0]){const e=B.get(t[1]);void 0!==e&&(B.delete(t[1]),t[1]=e)}return U.call(A.port1,t[0],t[1],t[2])});let G=null;Object.defineProperty(A.port1,"onmessage",{get:()=>G,set:t=>{"function"==typeof G&&A.port1.removeEventListener("message",G),G="function"==typeof t?t:null,"function"==typeof G&&(A.port1.addEventListener("message",G),A.port1.start())}}),T.prototype.port=A.port1;let Y=null;((t,e,n,s)=>{let i=a.k.get(t);void 0===i&&(i=new WeakMap,a.k.set(t,i));const o=c(n,s);return i.set(e,o),o})(x,z,T,O).then(t=>Y=t);const Q=Object(u.a)(O.numberOfInputs,O.channelCount),Z=Object(u.a)(O.numberOfOutputs,O.outputChannelCount),X=void 0===T.parameterDescriptors?[]:T.parameterDescriptors.reduce((t,{name:e})=>({...t,[e]:new Float32Array(128)}),{});let H=!0;const $=()=>{O.numberOfOutputs>0&&q.disconnect(I);for(let t=0,e=0;t<O.numberOfOutputs;t+=1){const n=F[t];for(let s=0;s<O.outputChannelCount[t];s+=1)I.disconnect(n,e+s,s);e+=O.outputChannelCount[t]}};q.onaudioprocess=({inputBuffer:e,outputBuffer:n})=>{if(null!==Y)for(let s=0;s<R;s+=128){for(let t=0;t<O.numberOfInputs;t+=1)for(let n=0;n<O.channelCount;n+=1)Object(o.a)(e,Q[t],n,n,s);void 0!==T.parameterDescriptors&&T.parameterDescriptors.forEach(({name:t},n)=>{Object(o.a)(e,X,t,S+n,s)});for(let t=0;t<O.numberOfInputs;t+=1)for(let e=0;e<O.outputChannelCount[t];e+=1)0===Z[t][e].byteLength&&(Z[t][e]=new Float32Array(128));try{const e=Q.map((e,n)=>{const s=t.get(z);return void 0===s||void 0===s.get(n)?[]:e}),i=y(x.currentTime+s/x.sampleRate,x.sampleRate,()=>Y.process(e,Z,X));H=i;for(let t=0,e=0;t<O.numberOfOutputs;t+=1){for(let i=0;i<O.outputChannelCount[t];i+=1)Object(r.a)(n,Z[t],i,e+i,s);e+=O.outputChannelCount[t]}}catch(t){H=!1,z.dispatchEvent(new ErrorEvent("processorerror",{error:t}))}if(!H){for(let t=0;t<O.numberOfInputs;t+=1){D[t].disconnect(M[t]);for(let e=0;e<O.channelCount;e+=1)M[s].disconnect(E,e,t*O.channelCount+e)}if(void 0!==T.parameterDescriptors){const t=T.parameterDescriptors.length;for(let e=0;e<t;e+=1){const t=j[e];t.disconnect(E,0,S+e),t.stop()}}E.disconnect(q),q.onaudioprocess=null,J?$():et();break}}};let J=!1;const K=_(x,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),tt=()=>q.connect(K).connect(K.context.destination),et=()=>{q.disconnect(K),K.disconnect()};return tt(),b(z,()=>{if(H){et(),O.numberOfOutputs>0&&q.connect(I);for(let t=0,e=0;t<O.numberOfOutputs;t+=1){const n=F[t];for(let s=0;s<O.outputChannelCount[t];s+=1)I.connect(n,e+s,s);e+=O.outputChannelCount[t]}}J=!0},()=>{H&&(tt(),$()),J=!1})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var s=n(0);const i={construct:()=>i},o=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,r=(t,e)=>{const n=[];let s=t.replace(/^[\s]+/,""),i=s.match(o);for(;null!==i;){const t=i[1].slice(1,-1),r=i[0].replace(/([\s]+)?;?$/,"").replace(t,new URL(t,e).toString());n.push(r),s=s.slice(i[0].length).replace(/^[\s]+/,""),i=s.match(o)}return[n.join(";"),s]},a=t=>{if(void 0!==t&&!Array.isArray(t))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},c=t=>{if(!(t=>{try{new new Proxy(t,i)}catch{return!1}return!0})(t))throw new TypeError("The given value for processorCtor should be a constructor.");if(null===t.prototype||"object"!=typeof t.prototype)throw new TypeError("The given value for processorCtor should have a prototype.")},u=(t,e,n,i,o,u,h,l,d)=>(p,f,_={credentials:"omit"})=>{const m=u(p),g=new URL(f,d.location.href).toString();if(void 0!==m.audioWorklet)return i(f).then(t=>{const[e,n]=r(t,g),s=new Blob([`${e};(registerProcessor=>{${n}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`],{type:"application/javascript; charset=utf-8"}),i=URL.createObjectURL(s),a=o(m);return(null!==a?a:m).audioWorklet.addModule(i,_).then(()=>URL.revokeObjectURL(i)).catch(t=>{throw URL.revokeObjectURL(i),void 0!==t.code&&"SyntaxError"!==t.name||(t.code=12),t})});const v=l.get(p);if(void 0!==v&&v.has(f))return Promise.resolve();const y=h.get(p);if(void 0!==y){const t=y.get(f);if(void 0!==t)return t}const b=i(f).then(t=>{const[n,s]=r(t,g);return e(`${n};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${s}\n})})(window,'_AWGS')`)}).then(()=>{const e=d._AWGS.pop();if(void 0===e)throw new SyntaxError;n(m.currentTime,m.sampleRate,()=>e(class{},void 0,(e,n)=>{if(""===e.trim())throw t();const i=s.j.get(m);if(void 0!==i){if(i.has(e))throw t();c(n),a(n.parameterDescriptors),i.set(e,n)}else c(n),a(n.parameterDescriptors),s.j.set(m,new Map([[e,n]]))},m.sampleRate,void 0,void 0))}).catch(t=>{throw void 0!==t.code&&"SyntaxError"!==t.name||(t.code=12),t});return void 0===y?h.set(p,new Map([[f,b]])):y.set(f,b),b.then(()=>{const t=l.get(p);void 0===t?l.set(p,new Set([f])):t.add(f)}).catch(()=>{}).then(()=>{const t=h.get(p);void 0!==t&&t.delete(f)}),b}},function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var s=n(4),i=n(1);const o=t=>"function"==typeof t.getFloatTimeDomainData,r=(t,e,n)=>(r,a)=>{const c=n(r,t=>t.createAnalyser());if(Object(i.a)(c,a),!(a.maxDecibels>a.minDecibels))throw e();return Object(s.a)(c,a,"fftSize"),Object(s.a)(c,a,"maxDecibels"),Object(s.a)(c,a,"minDecibels"),Object(s.a)(c,a,"smoothingTimeConstant"),t(o,()=>o(c))||(t=>{t.getFloatTimeDomainData=e=>{const n=new Uint8Array(e.length);t.getByteTimeDomainData(n);const s=Math.max(n.length,t.fftSize);for(let t=0;t<s;t+=1)e[t]=.0078125*(n[t]-128);return e}})(c),c}},function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var s=n(5),i=n(4),o=n(1),r=n(7);var a=n(30),c=n(31);const u=(t,e,n,u,h,l,d,p,f,_,m,g,v)=>(y,b={})=>{const x=n(y,t=>t.createBufferSource());return Object(o.a)(x,b),Object(s.a)(x,b,"playbackRate"),Object(i.a)(x,b,"buffer"),Object(i.a)(x,b,"loop"),Object(i.a)(x,b,"loopEnd"),Object(i.a)(x,b,"loopStart"),e(u,()=>u(y))||(t=>{t.start=(e=>{let n=!1;return(s=0,i=0,o)=>{if(n)throw Object(r.a)();e.call(t,s,i,o),n=!0}})(t.start)})(x),e(h,h)||((t,e)=>{let n=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;var i,o;t.start=(i=t.start,o=t.stop,(r=0,a=0,c=Number.POSITIVE_INFINITY)=>{if(i.call(t,r,a),c>=0&&c<Number.POSITIVE_INFINITY){const i=Math.max(r,e.currentTime),a=c/t.playbackRate.value;n=i+a,o.call(t,Math.min(n,s))}}),t.stop=(i=>(o=0)=>{s=Math.max(o,e.currentTime),i.call(t,Math.min(n,s))})(t.stop)})(x,y),e(l,()=>l(y))||m(x),e(d,()=>d(y))||g(x,y),e(p,()=>p(y))||Object(a.a)(x),e(f,()=>f(y))||v(x,y),e(_,()=>_(y))||Object(c.a)(x),t(y,x),x}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var s=n(35),i=n(41),o=n(36),r=n(8),a=n(0),c=n(6),u=n(9);var h=n(3);const l=async(t,e,n,h,l,d)=>{const p=null===e?128*Math.ceil(t.context.length/128):e.length,f=h.channelCount*h.numberOfInputs,_=h.outputChannelCount.reduce((t,e)=>t+e,0),m=0===_?null:n.createBuffer(_,p,n.sampleRate);if(void 0===l)throw new Error("Missing the processor constructor.");const g=Object(r.a)(t),v=await((t,e)=>{const n=Object(u.a)(a.k,t),s=Object(c.a)(e);return Object(u.a)(n,s)})(n,t),y=Object(o.a)(h.numberOfInputs,h.channelCount),b=Object(o.a)(h.numberOfOutputs,h.outputChannelCount),x=Array.from(t.parameters.keys()).reduce((t,e)=>({...t,[e]:new Float32Array(128)}),{});for(let o=0;o<p;o+=128){if(h.numberOfInputs>0&&null!==e)for(let t=0;t<h.numberOfInputs;t+=1)for(let n=0;n<h.channelCount;n+=1)Object(s.a)(e,y[t],n,n,o);void 0!==l.parameterDescriptors&&null!==e&&l.parameterDescriptors.forEach(({name:t},n)=>{Object(s.a)(e,x,t,f+n,o)});for(let t=0;t<h.numberOfInputs;t+=1)for(let e=0;e<h.outputChannelCount[t];e+=1)0===b[t][e].byteLength&&(b[t][e]=new Float32Array(128));try{const t=y.map((t,e)=>0===g.activeInputs[e].size?[]:t),e=d(o/n.sampleRate,n.sampleRate,()=>v.process(t,b,x));if(null!==m)for(let t=0,e=0;t<h.numberOfOutputs;t+=1){for(let n=0;n<h.outputChannelCount[t];n+=1)Object(i.a)(m,b[t],n,e+n,o);e+=h.outputChannelCount[t]}if(!e)break}catch(e){t.dispatchEvent(new ErrorEvent("processorerror",{error:e}));break}}return m},d=(t,e,n,s,i,o,r,a,c,u,d,p,f,_,m,g)=>(v,y,b)=>{const x=new WeakMap;let w=null;return{render(T,O,S){a(O,T);const C=x.get(O);return void 0!==C?Promise.resolve(C):(async(a,T,O)=>{let S=d(a),C=null;const k=Object(h.a)(S,T);if(null===p){const t=y.outputChannelCount.reduce((t,e)=>t+e,0),n=i(T,{channelCount:Math.max(1,t),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,t)}),o=[];for(let t=0;t<a.numberOfOutputs;t+=1)o.push(s(T,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:y.outputChannelCount[t]}));const u=r(T,{channelCount:y.channelCount,channelCountMode:y.channelCountMode,channelInterpretation:y.channelInterpretation,gain:1});u.connect=e.bind(null,o),u.disconnect=c.bind(null,o),C=[n,o,u]}else k||(S=new p(T,v));if(x.set(T,null===C?S:C[2]),null!==C){if(null===w){if(void 0===b)throw new Error("Missing the processor constructor.");if(null===f)throw new Error("Missing the native OfflineAudioContext constructor.");const t=a.channelCount*a.numberOfInputs,e=void 0===b.parameterDescriptors?0:b.parameterDescriptors.length,n=t+e,c=async()=>{const c=new f(n,128*Math.ceil(a.context.length/128),T.sampleRate),u=[],h=[];for(let t=0;t<y.numberOfInputs;t+=1)u.push(r(c,{channelCount:y.channelCount,channelCountMode:y.channelCountMode,channelInterpretation:y.channelInterpretation,gain:1})),h.push(i(c,{channelCount:y.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:y.channelCount}));const l=await Promise.all(Array.from(a.parameters.values()).map(async t=>{const e=o(c,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:t.value});return await _(c,t,e.offset,O),e})),d=s(c,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,t+e)});for(let t=0;t<y.numberOfInputs;t+=1){u[t].connect(h[t]);for(let e=0;e<y.channelCount;e+=1)h[t].connect(d,e,t*y.channelCount+e)}for(const[e,n]of l.entries())n.connect(d,0,t+e),n.start(0);return d.connect(c.destination),await Promise.all(u.map(t=>m(a,c,t,O))),g(c)};w=l(a,0===n?null:await c(),T,y,b,u)}const t=await w,e=n(T),[c,h,d]=C;null!==t&&(e.buffer=t,e.start(0)),e.connect(c);for(let t=0,e=0;t<a.numberOfOutputs;t+=1){const n=h[t];for(let s=0;s<y.outputChannelCount[t];s+=1)c.connect(n,e+s,s);e+=y.outputChannelCount[t]}return d}if(k)for(const[e,n]of a.parameters.entries())await t(T,n,S.parameters.get(e),O);else for(const[t,e]of a.parameters.entries())await _(T,e,S.parameters.get(t),O);return await m(a,T,S,O),S})(T,O,S)}}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(29);const i=(t,e,n,i,o,r,a,c,u,h,l,d,p)=>(f,_)=>{const m=a(f)?f:r(f);if(o.has(_)){const t=n();return Promise.reject(t)}try{o.add(_)}catch{}if(e(l,()=>l(m))){return("closed"===m.state&&null!==u&&c(m)?new u(1,1,m.sampleRate):m).decodeAudioData(_).catch(t=>{if(t instanceof DOMException&&"NotSupportedError"===t.name)throw new TypeError;throw t}).then(n=>(e(h,()=>h(n))||p(n),t.add(n),n))}return new Promise((e,n)=>{const o=()=>{try{(t=>{const{port1:e}=new MessageChannel;e.postMessage(t,[t])})(_)}catch{}},r=t=>{n(t),o()};try{m.decodeAudioData(_,n=>{"function"!=typeof n.copyFromChannel&&(d(n),Object(s.a)(n)),t.add(n),o(),e(n)},t=>{r(null===t?i():t)})}catch(t){r(t)}})}},function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var s=n(24);const i=(t,e,n)=>function i(o,r){const a=Object(s.a)(r)?r:n(t,r);if((t=>"delayTime"in t)(a))return[];if(o[0]===a)return[o];if(o.includes(a))return[];const{outputs:c}=e(a);return Array.from(c).map(t=>i([...o,a],t[0])).reduce((t,e)=>t.concat(e),[])}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(37);const i={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"},o=(t,e,n,o,r)=>class extends t{constructor(t,a){const c=o(t),u=r(c),h={...i,...a},l=e(c,u?null:t.baseLatency,h);super(t,!1,l,u?n(h.feedback,h.feedforward):null),(t=>{var e;t.getFrequencyResponse=(e=t.getFrequencyResponse,(n,i,o)=>{if(n.length!==i.length||i.length!==o.length)throw Object(s.a)();return e.call(t,n,i,o)})})(l),this._nativeIIRFilterNode=l}getFrequencyResponse(t,e,n){return this._nativeIIRFilterNode.getFrequencyResponse(t,e,n)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));const s=(t,e,n,s,i,o)=>(r,a,c,u,h,l)=>{if(null!==c)try{const n=e(r,t=>new c(t,u,l)),i=new Map;let a=null;if(Object.defineProperties(n,{channelCount:{get:()=>l.channelCount,set:()=>{throw t()}},channelCountMode:{get:()=>"explicit",set:()=>{throw t()}},onprocessorerror:{get:()=>a,set:t=>{"function"==typeof a&&n.removeEventListener("processorerror",a),a="function"==typeof t?t:null,"function"==typeof a&&n.addEventListener("processorerror",a)}}}),n.addEventListener=(p=n.addEventListener,(...t)=>{if("processorerror"===t[0]){const e="function"==typeof t[1]?t[1]:"object"==typeof t[1]&&null!==t[1]&&"function"==typeof t[1].handleEvent?t[1].handleEvent:null;if(null!==e){const n=i.get(t[1]);void 0!==n?t[1]=n:(t[1]=n=>{e(new ErrorEvent(t[0],{...n,error:new Error}))},i.set(e,t[1]))}}return p.call(n,t[0],t[1],t[2])}),n.removeEventListener=(d=n.removeEventListener,(...t)=>{if("processorerror"===t[0]){const e=i.get(t[1]);void 0!==e&&(i.delete(t[1]),t[1]=e)}return d.call(n,t[0],t[1],t[2])}),0!==l.numberOfOutputs){const t=s(r,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return n.connect(t).connect(t.context.destination),o(n,()=>t.disconnect(),()=>t.connect(t.context.destination))}return n}catch(t){if(11===t.code)throw i();throw t}var d,p;if(void 0===h)throw i();return(t=>{const{port1:e}=new MessageChannel;try{e.postMessage(t)}finally{e.close()}})(l),n(r,a,h,l)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var s=n(1),i=n(7);const o=t=>(e,n)=>{const o=t(e,t=>t.createChannelSplitter(n.numberOfOutputs));return Object(s.a)(o,n),(t=>{const e=t.numberOfOutputs;Object.defineProperty(t,"channelCount",{get:()=>e,set:t=>{if(t!==e)throw Object(i.a)()}}),Object.defineProperty(t,"channelCountMode",{get:()=>"explicit",set:t=>{if("explicit"!==t)throw Object(i.a)()}}),Object.defineProperty(t,"channelInterpretation",{get:()=>"discrete",set:t=>{if("discrete"!==t)throw Object(i.a)()}})})(o),o}},function(t,e,n){var s=n(677),i=n(678),o=n(679),r=n(681);t.exports=function(t,e){return s(t)||i(t,e)||o(t,e)||r()}},function(t,e){t.exports=function(t){if(Array.isArray(t))return t}},function(t,e){t.exports=function(t,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t)){var n=[],s=!0,i=!1,o=void 0;try{for(var r,a=t[Symbol.iterator]();!(s=(r=a.next()).done)&&(n.push(r.value),!e||n.length!==e);s=!0);}catch(t){i=!0,o=t}finally{try{s||null==a.return||a.return()}finally{if(i)throw o}}return n}}},function(t,e,n){var s=n(680);t.exports=function(t,e){if(t){if("string"==typeof t)return s(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(n):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?s(t,e):void 0}}},function(t,e){t.exports=function(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,s=new Array(e);n<e;n++)s[n]=t[n];return s}},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},function(t,e){t.exports=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},function(t,e){function n(t,e){for(var n=0;n<e.length;n++){var s=e[n];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,s.key,s)}}t.exports=function(t,e,s){return e&&n(t.prototype,e),s&&n(t,s),t}},function(t,e,n){"use strict";n.r(e),n.d(e,"getContext",(function(){return it})),n.d(e,"setContext",(function(){return ot})),n.d(e,"Clock",(function(){return Nt})),n.d(e,"Context",(function(){return H})),n.d(e,"BaseContext",(function(){return X})),n.d(e,"Delay",(function(){return Qt})),n.d(e,"Gain",(function(){return Mt})),n.d(e,"Offline",(function(){return Ht})),n.d(e,"OfflineContext",(function(){return et})),n.d(e,"Param",(function(){return St})),n.d(e,"ToneAudioBuffer",(function(){return tt})),n.d(e,"ToneAudioBuffers",(function(){return $t})),n.d(e,"ToneAudioNode",(function(){return Ct})),n.d(e,"connectSeries",(function(){return kt})),n.d(e,"connect",(function(){return At})),n.d(e,"disconnect",(function(){return Dt})),n.d(e,"FrequencyClass",(function(){return gt})),n.d(e,"Frequency",(function(){return bt})),n.d(e,"MidiClass",(function(){return Jt})),n.d(e,"Midi",(function(){return Kt})),n.d(e,"TimeClass",(function(){return _t})),n.d(e,"Time",(function(){return mt})),n.d(e,"TicksClass",(function(){return Lt})),n.d(e,"Ticks",(function(){return zt})),n.d(e,"TransportTimeClass",(function(){return xt})),n.d(e,"TransportTime",(function(){return wt})),n.d(e,"Emitter",(function(){return Z})),n.d(e,"IntervalTimeline",(function(){return Bt})),n.d(e,"StateTimeline",(function(){return Ot})),n.d(e,"Timeline",(function(){return W})),n.d(e,"isUndef",(function(){return p})),n.d(e,"isDefined",(function(){return f})),n.d(e,"isFunction",(function(){return _})),n.d(e,"isNumber",(function(){return m})),n.d(e,"isObject",(function(){return g})),n.d(e,"isBoolean",(function(){return v})),n.d(e,"isArray",(function(){return y})),n.d(e,"isString",(function(){return b})),n.d(e,"isNote",(function(){return x})),n.d(e,"dbToGain",(function(){return at})),n.d(e,"gainToDb",(function(){return ct})),n.d(e,"intervalToFrequencyRatio",(function(){return ut})),n.d(e,"ftom",(function(){return lt})),n.d(e,"mtof",(function(){return pt})),n.d(e,"optionsFromArguments",(function(){return q})),n.d(e,"defaultArg",(function(){return I})),n.d(e,"Unit",(function(){return ee})),n.d(e,"debug",(function(){return s})),n.d(e,"Noise",(function(){return ie})),n.d(e,"UserMedia",(function(){return ae})),n.d(e,"Oscillator",(function(){return he})),n.d(e,"AMOscillator",(function(){return _e})),n.d(e,"FMOscillator",(function(){return me})),n.d(e,"PulseOscillator",(function(){return ge})),n.d(e,"FatOscillator",(function(){return ve})),n.d(e,"PWMOscillator",(function(){return ye})),n.d(e,"OmniOscillator",(function(){return xe})),n.d(e,"ToneOscillatorNode",(function(){return ue})),n.d(e,"LFO",(function(){return Se})),n.d(e,"ToneBufferSource",(function(){return se})),n.d(e,"Player",(function(){return Ae})),n.d(e,"Players",(function(){return De})),n.d(e,"GrainPlayer",(function(){return Me})),n.d(e,"Add",(function(){return we})),n.d(e,"Abs",(function(){return je})),n.d(e,"AudioToGain",(function(){return pe})),n.d(e,"GainToAudio",(function(){return Ee})),n.d(e,"GreaterThan",(function(){return Fe})),n.d(e,"GreaterThanZero",(function(){return Ie})),n.d(e,"Multiply",(function(){return fe})),n.d(e,"Negate",(function(){return Re})),n.d(e,"Pow",(function(){return Ve})),n.d(e,"Signal",(function(){return Rt})),n.d(e,"connectSignal",(function(){return qt})),n.d(e,"Scale",(function(){return Te})),n.d(e,"ScaleExp",(function(){return Ne})),n.d(e,"Subtract",(function(){return qe})),n.d(e,"SyncedSignal",(function(){return Pe})),n.d(e,"WaveShaper",(function(){return de})),n.d(e,"Zero",(function(){return Oe})),n.d(e,"AMSynth",(function(){return Qe})),n.d(e,"DuoSynth",(function(){return Je})),n.d(e,"FMSynth",(function(){return Ke})),n.d(e,"MetalSynth",(function(){return en})),n.d(e,"MembraneSynth",(function(){return nn})),n.d(e,"MonoSynth",(function(){return $e})),n.d(e,"NoiseSynth",(function(){return sn})),n.d(e,"PluckSynth",(function(){return dn})),n.d(e,"PolySynth",(function(){return pn})),n.d(e,"Sampler",(function(){return fn})),n.d(e,"Synth",(function(){return Ge})),n.d(e,"Loop",(function(){return mn})),n.d(e,"Part",(function(){return gn})),n.d(e,"Pattern",(function(){return kn})),n.d(e,"Sequence",(function(){return An})),n.d(e,"ToneEvent",(function(){return _n})),n.d(e,"AutoFilter",(function(){return En})),n.d(e,"AutoPanner",(function(){return qn})),n.d(e,"AutoWah",(function(){return Fn})),n.d(e,"BitCrusher",(function(){return Vn})),n.d(e,"Chebyshev",(function(){return Pn})),n.d(e,"Chorus",(function(){return Un})),n.d(e,"Distortion",(function(){return Gn})),n.d(e,"FeedbackDelay",(function(){return Qn})),n.d(e,"FrequencyShifter",(function(){return Xn})),n.d(e,"Freeverb",(function(){return Jn})),n.d(e,"JCReverb",(function(){return ns})),n.d(e,"PingPongDelay",(function(){return is})),n.d(e,"PitchShift",(function(){return os})),n.d(e,"Phaser",(function(){return rs})),n.d(e,"Reverb",(function(){return as})),n.d(e,"StereoWidener",(function(){return ls})),n.d(e,"Tremolo",(function(){return ds})),n.d(e,"Vibrato",(function(){return ps})),n.d(e,"Analyser",(function(){return fs})),n.d(e,"Meter",(function(){return ms})),n.d(e,"FFT",(function(){return gs})),n.d(e,"DCMeter",(function(){return vs})),n.d(e,"Waveform",(function(){return ys})),n.d(e,"Follower",(function(){return In})),n.d(e,"Channel",(function(){return ws})),n.d(e,"CrossFade",(function(){return Dn})),n.d(e,"Merge",(function(){return zn})),n.d(e,"MidSideMerge",(function(){return us})),n.d(e,"MidSideSplit",(function(){return cs})),n.d(e,"MultibandSplit",(function(){return Ts})),n.d(e,"Panner",(function(){return Rn})),n.d(e,"Panner3D",(function(){return Ss})),n.d(e,"PanVol",(function(){return xs})),n.d(e,"Recorder",(function(){return Cs})),n.d(e,"Solo",(function(){return bs})),n.d(e,"Split",(function(){return Ln})),n.d(e,"Volume",(function(){return Zt})),n.d(e,"Compressor",(function(){return ks})),n.d(e,"Gate",(function(){return As})),n.d(e,"Limiter",(function(){return Ds})),n.d(e,"MidSideCompressor",(function(){return Ms})),n.d(e,"MultibandCompressor",(function(){return js})),n.d(e,"AmplitudeEnvelope",(function(){return Ue})),n.d(e,"Envelope",(function(){return Le})),n.d(e,"FrequencyEnvelope",(function(){return He})),n.d(e,"EQ3",(function(){return Es})),n.d(e,"Filter",(function(){return Xe})),n.d(e,"OnePoleFilter",(function(){return hn})),n.d(e,"FeedbackCombFilter",(function(){return un})),n.d(e,"LowpassCombFilter",(function(){return ln})),n.d(e,"Convolver",(function(){return Rs})),n.d(e,"BiquadFilter",(function(){return Ze})),n.d(e,"version",(function(){return i})),n.d(e,"start",(function(){return rt})),n.d(e,"supported",(function(){return o.isSupported})),n.d(e,"now",(function(){return qs})),n.d(e,"immediate",(function(){return Is})),n.d(e,"Transport",(function(){return Fs})),n.d(e,"getTransport",(function(){return Vs})),n.d(e,"Destination",(function(){return Ns})),n.d(e,"Master",(function(){return Ps})),n.d(e,"getDestination",(function(){return Ls})),n.d(e,"Listener",(function(){return zs})),n.d(e,"getListener",(function(){return Bs})),n.d(e,"Draw",(function(){return Ws})),n.d(e,"getDraw",(function(){return Us})),n.d(e,"context",(function(){return Gs})),n.d(e,"loaded",(function(){return Ys})),n.d(e,"Buffer",(function(){return Qs})),n.d(e,"Buffers",(function(){return Zs})),n.d(e,"BufferSource",(function(){return Xs}));var s={};n.r(s),n.d(s,"assert",(function(){return r})),n.d(s,"assertRange",(function(){return a})),n.d(s,"assertContextRunning",(function(){return c})),n.d(s,"setLogger",(function(){return h})),n.d(s,"log",(function(){return l})),n.d(s,"warn",(function(){return d}));const i="14.7.39";var o=n(13);function r(t,e){if(!t)throw new Error(e)}function a(t,e,n=1/0){if(!(e<=t&&t<=n))throw new RangeError(`Value must be within [${e}, ${n}], got: ${t}`)}function c(t){t.isOffline||"running"===t.state||d('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')}let u=console;function h(t){u=t}function l(...t){u.log(...t)}function d(...t){u.warn(...t)}function p(t){return void 0===t}function f(t){return!p(t)}function _(t){return"function"==typeof t}function m(t){return"number"==typeof t}function g(t){return"[object Object]"===Object.prototype.toString.call(t)&&t.constructor===Object}function v(t){return"boolean"==typeof t}function y(t){return Array.isArray(t)}function b(t){return"string"==typeof t}function x(t){return b(t)&&/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t)}const w="object"==typeof self?self:null,T=w&&(w.hasOwnProperty("AudioContext")||w.hasOwnProperty("webkitAudioContext"));function O(t,e,n,s){var i,o=arguments.length,r=o<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,n):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(t,e,n,s);else for(var a=t.length-1;a>=0;a--)(i=t[a])&&(r=(o<3?i(r):o>3?i(e,n,r):i(e,n))||r);return o>3&&r&&Object.defineProperty(e,n,r),r}function S(t,e,n,s){return new(n||(n=Promise))((function(i,o){function r(t){try{c(s.next(t))}catch(t){o(t)}}function a(t){try{c(s.throw(t))}catch(t){o(t)}}function c(t){t.done?i(t.value):new n((function(e){e(t.value)})).then(r,a)}c((s=s.apply(t,e||[])).next())}))}class C{constructor(t,e,n){this._callback=t,this._type=e,this._updateInterval=n,this._createClock()}_createWorker(){const t=new Blob([`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(1e3*this._updateInterval).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`],{type:"text/javascript"}),e=URL.createObjectURL(t),n=new Worker(e);n.onmessage=this._callback.bind(this),this._worker=n}_createTimeout(){this._timeout=setTimeout(()=>{this._createTimeout(),this._callback()},1e3*this._updateInterval)}_createClock(){if("worker"===this._type)try{this._createWorker()}catch(t){this._type="timeout",this._createClock()}else"timeout"===this._type&&this._createTimeout()}_disposeClock(){this._timeout&&(clearTimeout(this._timeout),this._timeout=0),this._worker&&(this._worker.terminate(),this._worker.onmessage=null)}get updateInterval(){return this._updateInterval}set updateInterval(t){this._updateInterval=Math.max(t,128/44100),"worker"===this._type&&this._worker.postMessage(Math.max(1e3*t,1))}get type(){return this._type}set type(t){this._disposeClock(),this._type=t,this._createClock()}dispose(){this._disposeClock()}}function k(t){return Object(o.isAnyAudioParam)(t)}function A(t){return Object(o.isAnyAudioNode)(t)}function D(t){return Object(o.isAnyOfflineAudioContext)(t)}function M(t){return Object(o.isAnyAudioContext)(t)}function j(t){return t instanceof AudioBuffer}function E(t,e){return"value"===t||k(e)||A(e)||j(e)}function R(t,...e){if(!e.length)return t;const n=e.shift();if(g(t)&&g(n))for(const e in n)E(e,n[e])?t[e]=n[e]:g(n[e])?(t[e]||Object.assign(t,{[e]:{}}),R(t[e],n[e])):Object.assign(t,{[e]:n[e]});return R(t,...e)}function q(t,e,n=[],s){const i={},o=Array.from(e);if(g(o[0])&&s&&!Reflect.has(o[0],s)){Object.keys(o[0]).some(e=>Reflect.has(t,e))||(R(i,{[s]:o[0]}),n.splice(n.indexOf(s),1),o.shift())}if(1===o.length&&g(o[0]))R(i,o[0]);else for(let t=0;t<n.length;t++)f(o[t])&&(i[n[t]]=o[t]);return R(t,i)}function I(t,e){return p(t)?e:t}function F(t,e){return e.forEach(e=>{Reflect.has(t,e)&&delete t[e]}),t}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */class V{constructor(){this.debug=!1,this._wasDisposed=!1}static getDefaults(){return{}}log(...t){(this.debug||w&&this.toString()===w.TONE_DEBUG_CLASS)&&l(this,...t)}dispose(){return this._wasDisposed=!0,this}get disposed(){return this._wasDisposed}toString(){return this.name}}V.version=i;function N(t,e){return t>e+1e-6}function P(t,e){return N(t,e)||z(t,e)}function L(t,e){return t+1e-6<e}function z(t,e){return Math.abs(t-e)<1e-6}function B(t,e,n){return Math.max(Math.min(t,n),e)}class W extends V{constructor(){super(),this.name="Timeline",this._timeline=[];const t=q(W.getDefaults(),arguments,["memory"]);this.memory=t.memory,this.increasing=t.increasing}static getDefaults(){return{memory:1/0,increasing:!1}}get length(){return this._timeline.length}add(t){if(r(Reflect.has(t,"time"),"Timeline: events must have a time attribute"),t.time=t.time.valueOf(),this.increasing&&this.length){const e=this._timeline[this.length-1];r(P(t.time,e.time),"The time must be greater than or equal to the last scheduled time"),this._timeline.push(t)}else{const e=this._search(t.time);this._timeline.splice(e+1,0,t)}if(this.length>this.memory){const t=this.length-this.memory;this._timeline.splice(0,t)}return this}remove(t){const e=this._timeline.indexOf(t);return-1!==e&&this._timeline.splice(e,1),this}get(t,e="time"){const n=this._search(t,e);return-1!==n?this._timeline[n]:null}peek(){return this._timeline[0]}shift(){return this._timeline.shift()}getAfter(t,e="time"){const n=this._search(t,e);return n+1<this._timeline.length?this._timeline[n+1]:null}getBefore(t){const e=this._timeline.length;if(e>0&&this._timeline[e-1].time<t)return this._timeline[e-1];const n=this._search(t);return n-1>=0?this._timeline[n-1]:null}cancel(t){if(this._timeline.length>1){let e=this._search(t);if(e>=0)if(z(this._timeline[e].time,t)){for(let n=e;n>=0&&z(this._timeline[n].time,t);n--)e=n;this._timeline=this._timeline.slice(0,e)}else this._timeline=this._timeline.slice(0,e+1);else this._timeline=[]}else 1===this._timeline.length&&P(this._timeline[0].time,t)&&(this._timeline=[]);return this}cancelBefore(t){const e=this._search(t);return e>=0&&(this._timeline=this._timeline.slice(e+1)),this}previousEvent(t){const e=this._timeline.indexOf(t);return e>0?this._timeline[e-1]:null}_search(t,e="time"){if(0===this._timeline.length)return-1;let n=0;const s=this._timeline.length;let i=s;if(s>0&&this._timeline[s-1][e]<=t)return s-1;for(;n<i;){let s=Math.floor(n+(i-n)/2);const o=this._timeline[s],r=this._timeline[s+1];if(z(o[e],t)){for(let n=s;n<this._timeline.length;n++){if(!z(this._timeline[n][e],t))break;s=n}return s}if(L(o[e],t)&&N(r[e],t))return s;N(o[e],t)?i=s:n=s+1}return-1}_iterate(t,e=0,n=this._timeline.length-1){this._timeline.slice(e,n+1).forEach(t)}forEach(t){return this._iterate(t),this}forEachBefore(t,e){const n=this._search(t);return-1!==n&&this._iterate(e,0,n),this}forEachAfter(t,e){const n=this._search(t);return this._iterate(e,n+1),this}forEachBetween(t,e,n){let s=this._search(t),i=this._search(e);return-1!==s&&-1!==i?(this._timeline[s].time!==t&&(s+=1),this._timeline[i].time===e&&(i-=1),this._iterate(n,s,i)):-1===s&&this._iterate(n,0,i),this}forEachFrom(t,e){let n=this._search(t);for(;n>=0&&this._timeline[n].time>=t;)n--;return this._iterate(e,n+1),this}forEachAtTime(t,e){const n=this._search(t);if(-1!==n&&z(this._timeline[n].time,t)){let s=n;for(let e=n;e>=0&&z(this._timeline[e].time,t);e--)s=e;this._iterate(t=>{e(t)},s,n)}return this}dispose(){return super.dispose(),this._timeline=[],this}}const U=[];function G(t){U.push(t)}const Y=[];function Q(t){Y.push(t)}class Z extends V{constructor(){super(...arguments),this.name="Emitter"}on(t,e){return t.split(/\W+/).forEach(t=>{p(this._events)&&(this._events={}),this._events.hasOwnProperty(t)||(this._events[t]=[]),this._events[t].push(e)}),this}once(t,e){const n=(...s)=>{e(...s),this.off(t,n)};return this.on(t,n),this}off(t,e){return t.split(/\W+/).forEach(n=>{if(p(this._events)&&(this._events={}),this._events.hasOwnProperty(t))if(p(e))this._events[t]=[];else{const n=this._events[t];for(let t=0;t<n.length;t++)n[t]===e&&n.splice(t,1)}}),this}emit(t,...e){if(this._events&&this._events.hasOwnProperty(t)){const n=this._events[t].slice(0);for(let t=0,s=n.length;t<s;t++)n[t].apply(this,e)}return this}static mixin(t){["on","once","off","emit"].forEach(e=>{const n=Object.getOwnPropertyDescriptor(Z.prototype,e);Object.defineProperty(t.prototype,e,n)})}dispose(){return super.dispose(),this._events=void 0,this}}class X extends Z{constructor(){super(...arguments),this.isOffline=!1}}class H extends X{constructor(){super(),this.name="Context",this._constants=new Map,this._timeouts=new W,this._timeoutIds=0,this._initialized=!1,this.isOffline=!1,this._workletModules=new Map;const t=q(H.getDefaults(),arguments,["context"]);t.context?this._context=t.context:this._context=function(t){return new o.AudioContext(t)}({latencyHint:t.latencyHint}),this._ticker=new C(this.emit.bind(this,"tick"),t.clockSource,t.updateInterval),this.on("tick",this._timeoutLoop.bind(this)),this._context.onstatechange=()=>{this.emit("statechange",this.state)},this._setLatencyHint(t.latencyHint),this.lookAhead=t.lookAhead}static getDefaults(){return{clockSource:"worker",latencyHint:"interactive",lookAhead:.1,updateInterval:.05}}initialize(){var t;return this._initialized||(t=this,U.forEach(e=>e(t)),this._initialized=!0),this}createAnalyser(){return this._context.createAnalyser()}createOscillator(){return this._context.createOscillator()}createBufferSource(){return this._context.createBufferSource()}createBiquadFilter(){return this._context.createBiquadFilter()}createBuffer(t,e,n){return this._context.createBuffer(t,e,n)}createChannelMerger(t){return this._context.createChannelMerger(t)}createChannelSplitter(t){return this._context.createChannelSplitter(t)}createConstantSource(){return this._context.createConstantSource()}createConvolver(){return this._context.createConvolver()}createDelay(t){return this._context.createDelay(t)}createDynamicsCompressor(){return this._context.createDynamicsCompressor()}createGain(){return this._context.createGain()}createIIRFilter(t,e){return this._context.createIIRFilter(t,e)}createPanner(){return this._context.createPanner()}createPeriodicWave(t,e,n){return this._context.createPeriodicWave(t,e,n)}createStereoPanner(){return this._context.createStereoPanner()}createWaveShaper(){return this._context.createWaveShaper()}createMediaStreamSource(t){return r(M(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamSource(t)}createMediaStreamDestination(){return r(M(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamDestination()}decodeAudioData(t){return this._context.decodeAudioData(t)}get currentTime(){return this._context.currentTime}get state(){return this._context.state}get sampleRate(){return this._context.sampleRate}get listener(){return this.initialize(),this._listener}set listener(t){r(!this._initialized,"The listener cannot be set after initialization."),this._listener=t}get transport(){return this.initialize(),this._transport}set transport(t){r(!this._initialized,"The transport cannot be set after initialization."),this._transport=t}get draw(){return this.initialize(),this._draw}set draw(t){r(!this._initialized,"Draw cannot be set after initialization."),this._draw=t}get destination(){return this.initialize(),this._destination}set destination(t){r(!this._initialized,"The destination cannot be set after initialization."),this._destination=t}createAudioWorkletNode(t,e){return function(t,e,n){return r(f(o.AudioWorkletNode),"This node only works in a secure context (https or localhost)"),new o.AudioWorkletNode(t,e,n)}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */(this.rawContext,t,e)}addAudioWorkletModule(t,e){return S(this,void 0,void 0,(function*(){r(f(this.rawContext.audioWorklet),"AudioWorkletNode is only available in a secure context (https or localhost)"),this._workletModules.has(e)||this._workletModules.set(e,this.rawContext.audioWorklet.addModule(t)),yield this._workletModules.get(e)}))}workletsAreReady(){return S(this,void 0,void 0,(function*(){const t=[];this._workletModules.forEach(e=>t.push(e)),yield Promise.all(t)}))}get updateInterval(){return this._ticker.updateInterval}set updateInterval(t){this._ticker.updateInterval=t}get clockSource(){return this._ticker.type}set clockSource(t){this._ticker.type=t}get latencyHint(){return this._latencyHint}_setLatencyHint(t){let e=0;if(this._latencyHint=t,b(t))switch(t){case"interactive":e=.1;break;case"playback":e=.5;break;case"balanced":e=.25}this.lookAhead=e,this.updateInterval=e/2}get rawContext(){return this._context}now(){return this._context.currentTime+this.lookAhead}immediate(){return this._context.currentTime}resume(){return"suspended"===this._context.state&&M(this._context)?this._context.resume():Promise.resolve()}close(){return S(this,void 0,void 0,(function*(){var t;M(this._context)&&(yield this._context.close()),this._initialized&&(t=this,Y.forEach(e=>e(t)))}))}getConstant(t){if(this._constants.has(t))return this._constants.get(t);{const e=this._context.createBuffer(1,128,this._context.sampleRate),n=e.getChannelData(0);for(let e=0;e<n.length;e++)n[e]=t;const s=this._context.createBufferSource();return s.channelCount=1,s.channelCountMode="explicit",s.buffer=e,s.loop=!0,s.start(0),this._constants.set(t,s),s}}dispose(){return super.dispose(),this._ticker.dispose(),this._timeouts.dispose(),Object.keys(this._constants).map(t=>this._constants[t].disconnect()),this}_timeoutLoop(){const t=this.now();let e=this._timeouts.peek();for(;this._timeouts.length&&e&&e.time<=t;)e.callback(),this._timeouts.shift(),e=this._timeouts.peek()}setTimeout(t,e){this._timeoutIds++;const n=this.now();return this._timeouts.add({callback:t,id:this._timeoutIds,time:n+e}),this._timeoutIds}clearTimeout(t){return this._timeouts.forEach(e=>{e.id===t&&this._timeouts.remove(e)}),this}clearInterval(t){return this.clearTimeout(t)}setInterval(t,e){const n=++this._timeoutIds,s=()=>{const i=this.now();this._timeouts.add({callback:()=>{t(),s()},id:n,time:i+e})};return s(),n}}function $(t,e){y(e)?e.forEach(e=>$(t,e)):Object.defineProperty(t,e,{enumerable:!0,writable:!1})}function J(t,e){y(e)?e.forEach(e=>J(t,e)):Object.defineProperty(t,e,{writable:!0})}const K=()=>{};class tt extends V{constructor(){super(),this.name="ToneAudioBuffer",this.onload=K;const t=q(tt.getDefaults(),arguments,["url","onload","onerror"]);this.reverse=t.reverse,this.onload=t.onload,t.url&&j(t.url)||t.url instanceof tt?this.set(t.url):b(t.url)&&this.load(t.url).catch(t.onerror)}static getDefaults(){return{onerror:K,onload:K,reverse:!1}}get sampleRate(){return this._buffer?this._buffer.sampleRate:it().sampleRate}set(t){return t instanceof tt?t.loaded?this._buffer=t.get():t.onload=()=>{this.set(t),this.onload(this)}:this._buffer=t,this._reversed&&this._reverse(),this}get(){return this._buffer}load(t){return S(this,void 0,void 0,(function*(){const e=tt.load(t).then(t=>{this.set(t),this.onload(this)});tt.downloads.push(e);try{yield e}finally{const t=tt.downloads.indexOf(e);tt.downloads.splice(t,1)}return this}))}dispose(){return super.dispose(),this._buffer=void 0,this}fromArray(t){const e=y(t)&&t[0].length>0,n=e?t.length:1,s=e?t[0].length:t.length,i=it(),o=i.createBuffer(n,s,i.sampleRate),r=e||1!==n?t:[t];for(let t=0;t<n;t++)o.copyToChannel(r[t],t);return this._buffer=o,this}toMono(t){if(m(t))this.fromArray(this.toArray(t));else{let t=new Float32Array(this.length);const e=this.numberOfChannels;for(let n=0;n<e;n++){const e=this.toArray(n);for(let n=0;n<e.length;n++)t[n]+=e[n]}t=t.map(t=>t/e),this.fromArray(t)}return this}toArray(t){if(m(t))return this.getChannelData(t);if(1===this.numberOfChannels)return this.toArray(0);{const t=[];for(let e=0;e<this.numberOfChannels;e++)t[e]=this.getChannelData(e);return t}}getChannelData(t){return this._buffer?this._buffer.getChannelData(t):new Float32Array(0)}slice(t,e=this.duration){const n=Math.floor(t*this.sampleRate),s=Math.floor(e*this.sampleRate);r(n<s,"The start time must be less than the end time");const i=s-n,o=it().createBuffer(this.numberOfChannels,i,this.sampleRate);for(let t=0;t<this.numberOfChannels;t++)o.copyToChannel(this.getChannelData(t).subarray(n,s),t);return new tt(o)}_reverse(){if(this.loaded)for(let t=0;t<this.numberOfChannels;t++)this.getChannelData(t).reverse();return this}get loaded(){return this.length>0}get duration(){return this._buffer?this._buffer.duration:0}get length(){return this._buffer?this._buffer.length:0}get numberOfChannels(){return this._buffer?this._buffer.numberOfChannels:0}get reverse(){return this._reversed}set reverse(t){this._reversed!==t&&(this._reversed=t,this._reverse())}static fromArray(t){return(new tt).fromArray(t)}static fromUrl(t){return S(this,void 0,void 0,(function*(){const e=new tt;return yield e.load(t)}))}static load(t){return S(this,void 0,void 0,(function*(){const e=t.match(/\[(.+\|?)+\]$/);if(e){const n=e[1].split("|");let s=n[0];for(const t of n)if(tt.supportsType(t)){s=t;break}t=t.replace(e[0],s)}const n=""===tt.baseUrl||tt.baseUrl.endsWith("/")?tt.baseUrl:tt.baseUrl+"/",s=yield fetch(n+t);if(!s.ok)throw new Error("could not load url: "+t);const i=yield s.arrayBuffer();return yield it().decodeAudioData(i)}))}static supportsType(t){const e=t.split("."),n=e[e.length-1];return""!==document.createElement("audio").canPlayType("audio/"+n)}static loaded(){return S(this,void 0,void 0,(function*(){for(yield Promise.resolve();tt.downloads.length;)yield tt.downloads[0]}))}}tt.baseUrl="",tt.downloads=[];class et extends H{constructor(){var t,e,n;super({clockSource:"offline",context:D(arguments[0])?arguments[0]:(t=arguments[0],e=arguments[1]*arguments[2],n=arguments[2],new o.OfflineAudioContext(t,e,n)),lookAhead:0,updateInterval:D(arguments[0])?128/arguments[0].sampleRate:128/arguments[2]}),this.name="OfflineContext",this._currentTime=0,this.isOffline=!0,this._duration=D(arguments[0])?arguments[0].length/arguments[0].sampleRate:arguments[1]}now(){return this._currentTime}get currentTime(){return this._currentTime}_renderClock(t){return S(this,void 0,void 0,(function*(){let e=0;for(;this._duration-this._currentTime>=0;){this.emit("tick"),this._currentTime+=128/this.sampleRate,e++;const n=Math.floor(this.sampleRate/128);t&&e%n==0&&(yield new Promise(t=>setTimeout(t,1)))}}))}render(t=!0){return S(this,void 0,void 0,(function*(){yield this.workletsAreReady(),yield this._renderClock(t);const e=yield this._context.startRendering();return new tt(e)}))}close(){return Promise.resolve()}}const nt=new class extends X{constructor(){super(...arguments),this.lookAhead=0,this.latencyHint=0,this.isOffline=!1}createAnalyser(){return{}}createOscillator(){return{}}createBufferSource(){return{}}createBiquadFilter(){return{}}createBuffer(t,e,n){return{}}createChannelMerger(t){return{}}createChannelSplitter(t){return{}}createConstantSource(){return{}}createConvolver(){return{}}createDelay(t){return{}}createDynamicsCompressor(){return{}}createGain(){return{}}createIIRFilter(t,e){return{}}createPanner(){return{}}createPeriodicWave(t,e,n){return{}}createStereoPanner(){return{}}createWaveShaper(){return{}}createMediaStreamSource(t){return{}}createMediaStreamDestination(){return{}}decodeAudioData(t){return Promise.resolve({})}createAudioWorkletNode(t,e){return{}}get rawContext(){return{}}addAudioWorkletModule(t,e){return S(this,void 0,void 0,(function*(){return Promise.resolve()}))}resume(){return Promise.resolve()}setTimeout(t,e){return 0}clearTimeout(t){return this}setInterval(t,e){return 0}clearInterval(t){return this}getConstant(t){return{}}get currentTime(){return 0}get state(){return{}}get sampleRate(){return 0}get listener(){return{}}get transport(){return{}}get draw(){return{}}set draw(t){}get destination(){return{}}set destination(t){}now(){return 0}immediate(){return 0}};let st=nt;function it(){return st===nt&&T&&ot(new H),st}function ot(t){st=M(t)?new H(t):D(t)?new et(t):t}function rt(){return st.resume()}if(w&&!w.TONE_SILENCE_LOGGING){let t="v";"dev"===i&&(t="");const e=` * Tone.js ${t}${i} * `;console.log("%c"+e,"background: #000; color: #fff")}function at(t){return Math.pow(10,t/20)}function ct(t){return Math.log(t)/Math.LN10*20}function ut(t){return Math.pow(2,t/12)}let ht=440;function lt(t){return Math.round(dt(t))}function dt(t){return 69+12*Math.log2(t/ht)}function pt(t){return ht*Math.pow(2,(t-69)/12)}class ft extends V{constructor(t,e,n){super(),this.defaultUnits="s",this._val=e,this._units=n,this.context=t,this._expressions=this._getExpressions()}_getExpressions(){return{hz:{method:t=>this._frequencyToUnits(parseFloat(t)),regexp:/^(\d+(?:\.\d+)?)hz$/i},i:{method:t=>this._ticksToUnits(parseInt(t,10)),regexp:/^(\d+)i$/i},m:{method:t=>this._beatsToUnits(parseInt(t,10)*this._getTimeSignature()),regexp:/^(\d+)m$/i},n:{method:(t,e)=>{const n=parseInt(t,10),s="."===e?1.5:1;return 1===n?this._beatsToUnits(this._getTimeSignature())*s:this._beatsToUnits(4/n)*s},regexp:/^(\d+)n(\.?)$/i},number:{method:t=>this._expressions[this.defaultUnits].method.call(this,t),regexp:/^(\d+(?:\.\d+)?)$/},s:{method:t=>this._secondsToUnits(parseFloat(t)),regexp:/^(\d+(?:\.\d+)?)s$/},samples:{method:t=>parseInt(t,10)/this.context.sampleRate,regexp:/^(\d+)samples$/},t:{method:t=>{const e=parseInt(t,10);return this._beatsToUnits(8/(3*Math.floor(e)))},regexp:/^(\d+)t$/i},tr:{method:(t,e,n)=>{let s=0;return t&&"0"!==t&&(s+=this._beatsToUnits(this._getTimeSignature()*parseFloat(t))),e&&"0"!==e&&(s+=this._beatsToUnits(parseFloat(e))),n&&"0"!==n&&(s+=this._beatsToUnits(parseFloat(n)/4)),s},regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/}}}valueOf(){if(this._val instanceof ft&&this.fromType(this._val),p(this._val))return this._noArg();if(b(this._val)&&p(this._units)){for(const t in this._expressions)if(this._expressions[t].regexp.test(this._val.trim())){this._units=t;break}}else if(g(this._val)){let t=0;for(const e in this._val)if(f(this._val[e])){const n=this._val[e];t+=new this.constructor(this.context,e).valueOf()*n}return t}if(f(this._units)){const t=this._expressions[this._units],e=this._val.toString().trim().match(t.regexp);return e?t.method.apply(this,e.slice(1)):t.method.call(this,this._val)}return b(this._val)?parseFloat(this._val):this._val}_frequencyToUnits(t){return 1/t}_beatsToUnits(t){return 60/this._getBpm()*t}_secondsToUnits(t){return t}_ticksToUnits(t){return t*this._beatsToUnits(1)/this._getPPQ()}_noArg(){return this._now()}_getBpm(){return this.context.transport.bpm.value}_getTimeSignature(){return this.context.transport.timeSignature}_getPPQ(){return this.context.transport.PPQ}fromType(t){switch(this._units=void 0,this.defaultUnits){case"s":this._val=t.toSeconds();break;case"i":this._val=t.toTicks();break;case"hz":this._val=t.toFrequency();break;case"midi":this._val=t.toMidi()}return this}toFrequency(){return 1/this.toSeconds()}toSamples(){return this.toSeconds()*this.context.sampleRate}toMilliseconds(){return 1e3*this.toSeconds()}}class _t extends ft{constructor(){super(...arguments),this.name="TimeClass"}_getExpressions(){return Object.assign(super._getExpressions(),{now:{method:t=>this._now()+new this.constructor(this.context,t).valueOf(),regexp:/^\+(.+)/},quantize:{method:t=>{const e=new _t(this.context,t).valueOf();return this._secondsToUnits(this.context.transport.nextSubdivision(e))},regexp:/^@(.+)/}})}quantize(t,e=1){const n=new this.constructor(this.context,t).valueOf(),s=this.valueOf();return s+(Math.round(s/n)*n-s)*e}toNotation(){const t=this.toSeconds(),e=["1m"];for(let t=1;t<9;t++){const n=Math.pow(2,t);e.push(n+"n."),e.push(n+"n"),e.push(n+"t")}e.push("0");let n=e[0],s=new _t(this.context,e[0]).toSeconds();return e.forEach(e=>{const i=new _t(this.context,e).toSeconds();Math.abs(i-t)<Math.abs(s-t)&&(n=e,s=i)}),n}toBarsBeatsSixteenths(){const t=this._beatsToUnits(1);let e=this.valueOf()/t;e=parseFloat(e.toFixed(4));const n=Math.floor(e/this._getTimeSignature());let s=e%1*4;e=Math.floor(e)%this._getTimeSignature();const i=s.toString();return i.length>3&&(s=parseFloat(parseFloat(i).toFixed(3))),[n,e,s].join(":")}toTicks(){const t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.round(e*this._getPPQ())}toSeconds(){return this.valueOf()}toMidi(){return lt(this.toFrequency())}_now(){return this.context.now()}}function mt(t,e){return new _t(it(),t,e)}class gt extends _t{constructor(){super(...arguments),this.name="Frequency",this.defaultUnits="hz"}static get A4(){return ht}static set A4(t){!function(t){ht=t}(t)}_getExpressions(){return Object.assign({},super._getExpressions(),{midi:{regexp:/^(\d+(?:\.\d+)?midi)/,method(t){return"midi"===this.defaultUnits?t:gt.mtof(t)}},note:{regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method(t,e){const n=vt[t.toLowerCase()]+12*(parseInt(e,10)+1);return"midi"===this.defaultUnits?n:gt.mtof(n)}},tr:{regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method(t,e,n){let s=1;return t&&"0"!==t&&(s*=this._beatsToUnits(this._getTimeSignature()*parseFloat(t))),e&&"0"!==e&&(s*=this._beatsToUnits(parseFloat(e))),n&&"0"!==n&&(s*=this._beatsToUnits(parseFloat(n)/4)),s}}})}transpose(t){return new gt(this.context,this.valueOf()*ut(t))}harmonize(t){return t.map(t=>this.transpose(t))}toMidi(){return lt(this.valueOf())}toNote(){const t=this.toFrequency(),e=Math.log2(t/gt.A4);let n=Math.round(12*e)+57;const s=Math.floor(n/12);return s<0&&(n+=-12*s),yt[n%12]+s.toString()}toSeconds(){return 1/super.toSeconds()}toTicks(){const t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.floor(e*this._getPPQ())}_noArg(){return 0}_frequencyToUnits(t){return t}_ticksToUnits(t){return 1/(60*t/(this._getBpm()*this._getPPQ()))}_beatsToUnits(t){return 1/super._beatsToUnits(t)}_secondsToUnits(t){return 1/t}static mtof(t){return pt(t)}static ftom(t){return lt(t)}}const vt={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},yt=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];function bt(t,e){return new gt(it(),t,e)}class xt extends _t{constructor(){super(...arguments),this.name="TransportTime"}_now(){return this.context.transport.seconds}}function wt(t,e){return new xt(it(),t,e)}class Tt extends V{constructor(){super();const t=q(Tt.getDefaults(),arguments,["context"]);this.defaultContext?this.context=this.defaultContext:this.context=t.context}static getDefaults(){return{context:it()}}now(){return this.context.currentTime+this.context.lookAhead}immediate(){return this.context.currentTime}get sampleTime(){return 1/this.context.sampleRate}get blockTime(){return 128/this.context.sampleRate}toSeconds(t){return new _t(this.context,t).toSeconds()}toFrequency(t){return new gt(this.context,t).toFrequency()}toTicks(t){return new xt(this.context,t).toTicks()}_getPartialProperties(t){const e=this.get();return Object.keys(e).forEach(n=>{p(t[n])&&delete e[n]}),e}get(){const t=this.constructor.getDefaults();return Object.keys(t).forEach(e=>{if(Reflect.has(this,e)){const n=this[e];f(n)&&f(n.value)&&f(n.setValueAtTime)?t[e]=n.value:n instanceof Tt?t[e]=n._getPartialProperties(t[e]):y(n)||m(n)||b(n)||v(n)?t[e]=n:delete t[e]}}),t}set(t){return Object.keys(t).forEach(e=>{Reflect.has(this,e)&&f(this[e])&&(this[e]&&f(this[e].value)&&f(this[e].setValueAtTime)?this[e].value!==t[e]&&(this[e].value=t[e]):this[e]instanceof Tt?this[e].set(t[e]):this[e]=t[e])}),this}}class Ot extends W{constructor(t="stopped"){super(),this.name="StateTimeline",this._initial=t,this.setStateAtTime(this._initial,0)}getValueAtTime(t){const e=this.get(t);return null!==e?e.state:this._initial}setStateAtTime(t,e,n){return a(e,0),this.add(Object.assign({},n,{state:t,time:e})),this}getLastState(t,e){for(let n=this._search(e);n>=0;n--){const e=this._timeline[n];if(e.state===t)return e}}getNextState(t,e){const n=this._search(e);if(-1!==n)for(let e=n;e<this._timeline.length;e++){const n=this._timeline[e];if(n.state===t)return n}}}class St extends Tt{constructor(){super(q(St.getDefaults(),arguments,["param","units","convert"])),this.name="Param",this.overridden=!1,this._minOutput=1e-7;const t=q(St.getDefaults(),arguments,["param","units","convert"]);for(r(f(t.param)&&(k(t.param)||t.param instanceof St),"param must be an AudioParam");!k(t.param);)t.param=t.param._param;this._swappable=!!f(t.swappable)&&t.swappable,this._swappable?(this.input=this.context.createGain(),this._param=t.param,this.input.connect(this._param)):this._param=this.input=t.param,this._events=new W(1e3),this._initialValue=this._param.defaultValue,this.units=t.units,this.convert=t.convert,this._minValue=t.minValue,this._maxValue=t.maxValue,f(t.value)&&t.value!==this._toType(this._initialValue)&&this.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(Tt.getDefaults(),{convert:!0,units:"number"})}get value(){const t=this.now();return this.getValueAtTime(t)}set value(t){this.cancelScheduledValues(this.now()),this.setValueAtTime(t,this.now())}get minValue(){return f(this._minValue)?this._minValue:"time"===this.units||"frequency"===this.units||"normalRange"===this.units||"positive"===this.units||"transportTime"===this.units||"ticks"===this.units||"bpm"===this.units||"hertz"===this.units||"samples"===this.units?0:"audioRange"===this.units?-1:"decibels"===this.units?-1/0:this._param.minValue}get maxValue(){return f(this._maxValue)?this._maxValue:"normalRange"===this.units||"audioRange"===this.units?1:this._param.maxValue}_is(t,e){return this.units===e}_assertRange(t){return f(this.maxValue)&&f(this.minValue)&&a(t,this._fromType(this.minValue),this._fromType(this.maxValue)),t}_fromType(t){return this.convert&&!this.overridden?this._is(t,"time")?this.toSeconds(t):this._is(t,"decibels")?at(t):this._is(t,"frequency")?this.toFrequency(t):t:this.overridden?0:t}_toType(t){return this.convert&&"decibels"===this.units?ct(t):t}setValueAtTime(t,e){const n=this.toSeconds(e),s=this._fromType(t);return r(isFinite(s)&&isFinite(n),`Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._assertRange(s),this.log(this.units,"setValueAtTime",t,n),this._events.add({time:n,type:"setValueAtTime",value:s}),this._param.setValueAtTime(s,n),this}getValueAtTime(t){const e=Math.max(this.toSeconds(t),0),n=this._events.getAfter(e),s=this._events.get(e);let i=this._initialValue;if(null===s)i=this._initialValue;else if("setTargetAtTime"!==s.type||null!==n&&"setValueAtTime"!==n.type)if(null===n)i=s.value;else if("linearRampToValueAtTime"===n.type||"exponentialRampToValueAtTime"===n.type){let t=s.value;if("setTargetAtTime"===s.type){const e=this._events.getBefore(s.time);t=null===e?this._initialValue:e.value}i="linearRampToValueAtTime"===n.type?this._linearInterpolate(s.time,t,n.time,n.value,e):this._exponentialInterpolate(s.time,t,n.time,n.value,e)}else i=s.value;else{const t=this._events.getBefore(s.time);let n;n=null===t?this._initialValue:t.value,"setTargetAtTime"===s.type&&(i=this._exponentialApproach(s.time,n,s.value,s.constant,e))}return this._toType(i)}setRampPoint(t){t=this.toSeconds(t);let e=this.getValueAtTime(t);return this.cancelAndHoldAtTime(t),0===this._fromType(e)&&(e=this._toType(this._minOutput)),this.setValueAtTime(e,t),this}linearRampToValueAtTime(t,e){const n=this._fromType(t),s=this.toSeconds(e);return r(isFinite(n)&&isFinite(s),`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._assertRange(n),this._events.add({time:s,type:"linearRampToValueAtTime",value:n}),this.log(this.units,"linearRampToValueAtTime",t,s),this._param.linearRampToValueAtTime(n,s),this}exponentialRampToValueAtTime(t,e){let n=this._fromType(t);n=Math.max(this._minOutput,n),this._assertRange(n);const s=this.toSeconds(e);return r(isFinite(n)&&isFinite(s),`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._events.add({time:s,type:"exponentialRampToValueAtTime",value:n}),this.log(this.units,"exponentialRampToValueAtTime",t,s),this._param.exponentialRampToValueAtTime(n,s),this}exponentialRampTo(t,e,n){return n=this.toSeconds(n),this.setRampPoint(n),this.exponentialRampToValueAtTime(t,n+this.toSeconds(e)),this}linearRampTo(t,e,n){return n=this.toSeconds(n),this.setRampPoint(n),this.linearRampToValueAtTime(t,n+this.toSeconds(e)),this}targetRampTo(t,e,n){return n=this.toSeconds(n),this.setRampPoint(n),this.exponentialApproachValueAtTime(t,n,e),this}exponentialApproachValueAtTime(t,e,n){e=this.toSeconds(e),n=this.toSeconds(n);const s=Math.log(n+1)/Math.log(200);return this.setTargetAtTime(t,e,s),this.cancelAndHoldAtTime(e+.9*n),this.linearRampToValueAtTime(t,e+n),this}setTargetAtTime(t,e,n){const s=this._fromType(t);r(isFinite(n)&&n>0,"timeConstant must be a number greater than 0");const i=this.toSeconds(e);return this._assertRange(s),r(isFinite(s)&&isFinite(i),`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._events.add({constant:n,time:i,type:"setTargetAtTime",value:s}),this.log(this.units,"setTargetAtTime",t,i,n),this._param.setTargetAtTime(s,i,n),this}setValueCurveAtTime(t,e,n,s=1){n=this.toSeconds(n),e=this.toSeconds(e);const i=this._fromType(t[0])*s;this.setValueAtTime(this._toType(i),e);const o=n/(t.length-1);for(let n=1;n<t.length;n++){const i=this._fromType(t[n])*s;this.linearRampToValueAtTime(this._toType(i),e+n*o)}return this}cancelScheduledValues(t){const e=this.toSeconds(t);return r(isFinite(e),"Invalid argument to cancelScheduledValues: "+JSON.stringify(t)),this._events.cancel(e),this._param.cancelScheduledValues(e),this.log(this.units,"cancelScheduledValues",e),this}cancelAndHoldAtTime(t){const e=this.toSeconds(t),n=this._fromType(this.getValueAtTime(e));r(isFinite(e),"Invalid argument to cancelAndHoldAtTime: "+JSON.stringify(t)),this.log(this.units,"cancelAndHoldAtTime",e,"value="+n);const s=this._events.get(e),i=this._events.getAfter(e);return s&&z(s.time,e)?i?(this._param.cancelScheduledValues(i.time),this._events.cancel(i.time)):(this._param.cancelAndHoldAtTime(e),this._events.cancel(e+this.sampleTime)):i&&(this._param.cancelScheduledValues(i.time),this._events.cancel(i.time),"linearRampToValueAtTime"===i.type?this.linearRampToValueAtTime(this._toType(n),e):"exponentialRampToValueAtTime"===i.type&&this.exponentialRampToValueAtTime(this._toType(n),e)),this._events.add({time:e,type:"setValueAtTime",value:n}),this._param.setValueAtTime(n,e),this}rampTo(t,e=.1,n){return"frequency"===this.units||"bpm"===this.units||"decibels"===this.units?this.exponentialRampTo(t,e,n):this.linearRampTo(t,e,n),this}apply(t){const e=this.context.currentTime;t.setValueAtTime(this.getValueAtTime(e),e);const n=this._events.get(e);if(n&&"setTargetAtTime"===n.type){const s=this._events.getAfter(n.time),i=s?s.time:e+2,o=(i-e)/10;for(let n=e;n<i;n+=o)t.linearRampToValueAtTime(this.getValueAtTime(n),n)}return this._events.forEachAfter(this.context.currentTime,e=>{"cancelScheduledValues"===e.type?t.cancelScheduledValues(e.time):"setTargetAtTime"===e.type?t.setTargetAtTime(e.value,e.time,e.constant):t[e.type](e.value,e.time)}),this}setParam(t){r(this._swappable,"The Param must be assigned as 'swappable' in the constructor");const e=this.input;return e.disconnect(this._param),this.apply(t),this._param=t,e.connect(this._param),this}dispose(){return super.dispose(),this._events.dispose(),this}get defaultValue(){return this._toType(this._param.defaultValue)}_exponentialApproach(t,e,n,s,i){return n+(e-n)*Math.exp(-(i-t)/s)}_linearInterpolate(t,e,n,s,i){return e+(i-t)/(n-t)*(s-e)}_exponentialInterpolate(t,e,n,s,i){return e*Math.pow(s/e,(i-t)/(n-t))}}class Ct extends Tt{constructor(){super(...arguments),this.name="ToneAudioNode",this._internalChannels=[]}get numberOfInputs(){return f(this.input)?k(this.input)||this.input instanceof St?1:this.input.numberOfInputs:0}get numberOfOutputs(){return f(this.output)?this.output.numberOfOutputs:0}_isAudioNode(t){return f(t)&&(t instanceof Ct||A(t))}_getInternalNodes(){const t=this._internalChannels.slice(0);return this._isAudioNode(this.input)&&t.push(this.input),this._isAudioNode(this.output)&&this.input!==this.output&&t.push(this.output),t}_setChannelProperties(t){this._getInternalNodes().forEach(e=>{e.channelCount=t.channelCount,e.channelCountMode=t.channelCountMode,e.channelInterpretation=t.channelInterpretation})}_getChannelProperties(){const t=this._getInternalNodes();r(t.length>0,"ToneAudioNode does not have any internal nodes");const e=t[0];return{channelCount:e.channelCount,channelCountMode:e.channelCountMode,channelInterpretation:e.channelInterpretation}}get channelCount(){return this._getChannelProperties().channelCount}set channelCount(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelCount:t}))}get channelCountMode(){return this._getChannelProperties().channelCountMode}set channelCountMode(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelCountMode:t}))}get channelInterpretation(){return this._getChannelProperties().channelInterpretation}set channelInterpretation(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelInterpretation:t}))}connect(t,e=0,n=0){return At(this,t,e,n),this}toDestination(){return this.connect(this.context.destination),this}toMaster(){return d("toMaster() has been renamed toDestination()"),this.toDestination()}disconnect(t,e=0,n=0){return Dt(this,t,e,n),this}chain(...t){return kt(this,...t),this}fan(...t){return t.forEach(t=>this.connect(t)),this}dispose(){return super.dispose(),f(this.input)&&(this.input instanceof Ct?this.input.dispose():A(this.input)&&this.input.disconnect()),f(this.output)&&(this.output instanceof Ct?this.output.dispose():A(this.output)&&this.output.disconnect()),this._internalChannels=[],this}}function kt(...t){const e=t.shift();t.reduce((t,e)=>(t instanceof Ct?t.connect(e):A(t)&&At(t,e),e),e)}function At(t,e,n=0,s=0){for(r(f(t),"Cannot connect from undefined node"),r(f(e),"Cannot connect to undefined node"),(e instanceof Ct||A(e))&&r(e.numberOfInputs>0,"Cannot connect to node with no inputs"),r(t.numberOfOutputs>0,"Cannot connect from node with no outputs");e instanceof Ct||e instanceof St;)f(e.input)&&(e=e.input);for(;t instanceof Ct;)f(t.output)&&(t=t.output);k(e)?t.connect(e,n):t.connect(e,n,s)}function Dt(t,e,n=0,s=0){if(f(e))for(;e instanceof Ct;)e=e.input;for(;!A(t);)f(t.output)&&(t=t.output);k(e)?t.disconnect(e,n):A(e)?t.disconnect(e,n,s):t.disconnect()}class Mt extends Ct{constructor(){super(q(Mt.getDefaults(),arguments,["gain","units"])),this.name="Gain",this._gainNode=this.context.createGain(),this.input=this._gainNode,this.output=this._gainNode;const t=q(Mt.getDefaults(),arguments,["gain","units"]);this.gain=new St({context:this.context,convert:t.convert,param:this._gainNode.gain,units:t.units,value:t.gain,minValue:t.minValue,maxValue:t.maxValue}),$(this,"gain")}static getDefaults(){return Object.assign(Ct.getDefaults(),{convert:!0,gain:1,units:"gain"})}dispose(){return super.dispose(),this._gainNode.disconnect(),this.gain.dispose(),this}}class jt extends Ct{constructor(t){super(t),this.onended=K,this._startTime=-1,this._stopTime=-1,this._timeout=-1,this.output=new Mt({context:this.context,gain:0}),this._gainNode=this.output,this.getStateAtTime=function(t){const e=this.toSeconds(t);return-1!==this._startTime&&e>=this._startTime&&(-1===this._stopTime||e<=this._stopTime)?"started":"stopped"},this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut,this._curve=t.curve,this.onended=t.onended}static getDefaults(){return Object.assign(Ct.getDefaults(),{curve:"linear",fadeIn:0,fadeOut:0,onended:K})}_startGain(t,e=1){r(-1===this._startTime,"Source cannot be started more than once");const n=this.toSeconds(this._fadeIn);return this._startTime=t+n,this._startTime=Math.max(this._startTime,this.context.currentTime),n>0?(this._gainNode.gain.setValueAtTime(0,t),"linear"===this._curve?this._gainNode.gain.linearRampToValueAtTime(e,t+n):this._gainNode.gain.exponentialApproachValueAtTime(e,t,n)):this._gainNode.gain.setValueAtTime(e,t),this}stop(t){return this.log("stop",t),this._stopGain(this.toSeconds(t)),this}_stopGain(t){r(-1!==this._startTime,"'start' must be called before 'stop'"),this.cancelStop();const e=this.toSeconds(this._fadeOut);return this._stopTime=this.toSeconds(t)+e,this._stopTime=Math.max(this._stopTime,this.context.currentTime),e>0?"linear"===this._curve?this._gainNode.gain.linearRampTo(0,e,t):this._gainNode.gain.targetRampTo(0,e,t):(this._gainNode.gain.cancelAndHoldAtTime(t),this._gainNode.gain.setValueAtTime(0,t)),this.context.clearTimeout(this._timeout),this._timeout=this.context.setTimeout(()=>{const t="exponential"===this._curve?2*e:0;this._stopSource(this.now()+t),this._onended()},this._stopTime-this.context.currentTime),this}_onended(){if(this.onended!==K&&(this.onended(this),this.onended=K,!this.context.isOffline)){const t=()=>this.dispose();void 0!==window.requestIdleCallback?window.requestIdleCallback(t):setTimeout(t,1e3)}}get state(){return this.getStateAtTime(this.now())}cancelStop(){return this.log("cancelStop"),r(-1!==this._startTime,"Source is not started"),this._gainNode.gain.cancelScheduledValues(this._startTime+this.sampleTime),this.context.clearTimeout(this._timeout),this._stopTime=-1,this}dispose(){return super.dispose(),this._gainNode.disconnect(),this}}class Et extends jt{constructor(){super(q(Et.getDefaults(),arguments,["offset"])),this.name="ToneConstantSource",this._source=this.context.createConstantSource();const t=q(Et.getDefaults(),arguments,["offset"]);At(this._source,this._gainNode),this.offset=new St({context:this.context,convert:t.convert,param:this._source.offset,units:t.units,value:t.offset,minValue:t.minValue,maxValue:t.maxValue})}static getDefaults(){return Object.assign(jt.getDefaults(),{convert:!0,offset:1,units:"number"})}start(t){const e=this.toSeconds(t);return this.log("start",e),this._startGain(e),this._source.start(e),this}_stopSource(t){this._source.stop(t)}dispose(){return super.dispose(),"started"===this.state&&this.stop(),this._source.disconnect(),this.offset.dispose(),this}}class Rt extends Ct{constructor(){super(q(Rt.getDefaults(),arguments,["value","units"])),this.name="Signal",this.override=!0;const t=q(Rt.getDefaults(),arguments,["value","units"]);this.output=this._constantSource=new Et({context:this.context,convert:t.convert,offset:t.value,units:t.units,minValue:t.minValue,maxValue:t.maxValue}),this._constantSource.start(0),this.input=this._param=this._constantSource.offset}static getDefaults(){return Object.assign(Ct.getDefaults(),{convert:!0,units:"number",value:0})}connect(t,e=0,n=0){return qt(this,t,e,n),this}dispose(){return super.dispose(),this._param.dispose(),this._constantSource.dispose(),this}setValueAtTime(t,e){return this._param.setValueAtTime(t,e),this}getValueAtTime(t){return this._param.getValueAtTime(t)}setRampPoint(t){return this._param.setRampPoint(t),this}linearRampToValueAtTime(t,e){return this._param.linearRampToValueAtTime(t,e),this}exponentialRampToValueAtTime(t,e){return this._param.exponentialRampToValueAtTime(t,e),this}exponentialRampTo(t,e,n){return this._param.exponentialRampTo(t,e,n),this}linearRampTo(t,e,n){return this._param.linearRampTo(t,e,n),this}targetRampTo(t,e,n){return this._param.targetRampTo(t,e,n),this}exponentialApproachValueAtTime(t,e,n){return this._param.exponentialApproachValueAtTime(t,e,n),this}setTargetAtTime(t,e,n){return this._param.setTargetAtTime(t,e,n),this}setValueCurveAtTime(t,e,n,s){return this._param.setValueCurveAtTime(t,e,n,s),this}cancelScheduledValues(t){return this._param.cancelScheduledValues(t),this}cancelAndHoldAtTime(t){return this._param.cancelAndHoldAtTime(t),this}rampTo(t,e,n){return this._param.rampTo(t,e,n),this}get value(){return this._param.value}set value(t){this._param.value=t}get convert(){return this._param.convert}set convert(t){this._param.convert=t}get units(){return this._param.units}get overridden(){return this._param.overridden}set overridden(t){this._param.overridden=t}get maxValue(){return this._param.maxValue}get minValue(){return this._param.minValue}apply(t){return this._param.apply(t),this}}function qt(t,e,n,s){(e instanceof St||k(e)||e instanceof Rt&&e.override)&&(e.cancelScheduledValues(0),e.setValueAtTime(0,0),e instanceof Rt&&(e.overridden=!0)),At(t,e,n,s)}class It extends St{constructor(){super(q(It.getDefaults(),arguments,["value"])),this.name="TickParam",this._events=new W(1/0),this._multiplier=1;const t=q(It.getDefaults(),arguments,["value"]);this._multiplier=t.multiplier,this._events.cancel(0),this._events.add({ticks:0,time:0,type:"setValueAtTime",value:this._fromType(t.value)}),this.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(St.getDefaults(),{multiplier:1,units:"hertz",value:1})}setTargetAtTime(t,e,n){e=this.toSeconds(e),this.setRampPoint(e);const s=this._fromType(t),i=this._events.get(e),o=Math.round(Math.max(1/n,1));for(let t=0;t<=o;t++){const o=n*t+e,r=this._exponentialApproach(i.time,i.value,s,n,o);this.linearRampToValueAtTime(this._toType(r),o)}return this}setValueAtTime(t,e){const n=this.toSeconds(e);super.setValueAtTime(t,e);const s=this._events.get(n),i=this._events.previousEvent(s),o=this._getTicksUntilEvent(i,n);return s.ticks=Math.max(o,0),this}linearRampToValueAtTime(t,e){const n=this.toSeconds(e);super.linearRampToValueAtTime(t,e);const s=this._events.get(n),i=this._events.previousEvent(s),o=this._getTicksUntilEvent(i,n);return s.ticks=Math.max(o,0),this}exponentialRampToValueAtTime(t,e){e=this.toSeconds(e);const n=this._fromType(t),s=this._events.get(e),i=Math.round(Math.max(10*(e-s.time),1)),o=(e-s.time)/i;for(let t=0;t<=i;t++){const i=o*t+s.time,r=this._exponentialInterpolate(s.time,s.value,e,n,i);this.linearRampToValueAtTime(this._toType(r),i)}return this}_getTicksUntilEvent(t,e){if(null===t)t={ticks:0,time:0,type:"setValueAtTime",value:0};else if(p(t.ticks)){const e=this._events.previousEvent(t);t.ticks=this._getTicksUntilEvent(e,t.time)}const n=this._fromType(this.getValueAtTime(t.time));let s=this._fromType(this.getValueAtTime(e));const i=this._events.get(e);return i&&i.time===e&&"setValueAtTime"===i.type&&(s=this._fromType(this.getValueAtTime(e-this.sampleTime))),.5*(e-t.time)*(n+s)+t.ticks}getTicksAtTime(t){const e=this.toSeconds(t),n=this._events.get(e);return Math.max(this._getTicksUntilEvent(n,e),0)}getDurationOfTicks(t,e){const n=this.toSeconds(e),s=this.getTicksAtTime(e);return this.getTimeOfTick(s+t)-n}getTimeOfTick(t){const e=this._events.get(t,"ticks"),n=this._events.getAfter(t,"ticks");if(e&&e.ticks===t)return e.time;if(e&&n&&"linearRampToValueAtTime"===n.type&&e.value!==n.value){const s=this._fromType(this.getValueAtTime(e.time)),i=(this._fromType(this.getValueAtTime(n.time))-s)/(n.time-e.time),o=Math.sqrt(Math.pow(s,2)-2*i*(e.ticks-t)),r=(-s+o)/i,a=(-s-o)/i;return(r>0?r:a)+e.time}return e?0===e.value?1/0:e.time+(t-e.ticks)/e.value:t/this._initialValue}ticksToTime(t,e){return this.getDurationOfTicks(t,e)}timeToTicks(t,e){const n=this.toSeconds(e),s=this.toSeconds(t),i=this.getTicksAtTime(n);return this.getTicksAtTime(n+s)-i}_fromType(t){return"bpm"===this.units&&this.multiplier?1/(60/t/this.multiplier):super._fromType(t)}_toType(t){return"bpm"===this.units&&this.multiplier?t/this.multiplier*60:super._toType(t)}get multiplier(){return this._multiplier}set multiplier(t){const e=this.value;this._multiplier=t,this.cancelScheduledValues(0),this.setValueAtTime(e,0)}}class Ft extends Rt{constructor(){super(q(Ft.getDefaults(),arguments,["value"])),this.name="TickSignal";const t=q(Ft.getDefaults(),arguments,["value"]);this.input=this._param=new It({context:this.context,convert:t.convert,multiplier:t.multiplier,param:this._constantSource.offset,units:t.units,value:t.value})}static getDefaults(){return Object.assign(Rt.getDefaults(),{multiplier:1,units:"hertz",value:1})}ticksToTime(t,e){return this._param.ticksToTime(t,e)}timeToTicks(t,e){return this._param.timeToTicks(t,e)}getTimeOfTick(t){return this._param.getTimeOfTick(t)}getDurationOfTicks(t,e){return this._param.getDurationOfTicks(t,e)}getTicksAtTime(t){return this._param.getTicksAtTime(t)}get multiplier(){return this._param.multiplier}set multiplier(t){this._param.multiplier=t}dispose(){return super.dispose(),this._param.dispose(),this}}class Vt extends Tt{constructor(){super(q(Vt.getDefaults(),arguments,["frequency"])),this.name="TickSource",this._state=new Ot,this._tickOffset=new W;const t=q(Vt.getDefaults(),arguments,["frequency"]);this.frequency=new Ft({context:this.context,units:t.units,value:t.frequency}),$(this,"frequency"),this._state.setStateAtTime("stopped",0),this.setTicksAtTime(0,0)}static getDefaults(){return Object.assign({frequency:1,units:"hertz"},Tt.getDefaults())}get state(){return this.getStateAtTime(this.now())}start(t,e){const n=this.toSeconds(t);return"started"!==this._state.getValueAtTime(n)&&(this._state.setStateAtTime("started",n),f(e)&&this.setTicksAtTime(e,n)),this}stop(t){const e=this.toSeconds(t);if("stopped"===this._state.getValueAtTime(e)){const t=this._state.get(e);t&&t.time>0&&(this._tickOffset.cancel(t.time),this._state.cancel(t.time))}return this._state.cancel(e),this._state.setStateAtTime("stopped",e),this.setTicksAtTime(0,e),this}pause(t){const e=this.toSeconds(t);return"started"===this._state.getValueAtTime(e)&&this._state.setStateAtTime("paused",e),this}cancel(t){return t=this.toSeconds(t),this._state.cancel(t),this._tickOffset.cancel(t),this}getTicksAtTime(t){const e=this.toSeconds(t),n=this._state.getLastState("stopped",e),s={state:"paused",time:e};this._state.add(s);let i=n,o=0;return this._state.forEachBetween(n.time,e+this.sampleTime,t=>{let e=i.time;const n=this._tickOffset.get(t.time);n&&n.time>=i.time&&(o=n.ticks,e=n.time),"started"===i.state&&"started"!==t.state&&(o+=this.frequency.getTicksAtTime(t.time)-this.frequency.getTicksAtTime(e)),i=t}),this._state.remove(s),o}get ticks(){return this.getTicksAtTime(this.now())}set ticks(t){this.setTicksAtTime(t,this.now())}get seconds(){return this.getSecondsAtTime(this.now())}set seconds(t){const e=this.now(),n=this.frequency.timeToTicks(t,e);this.setTicksAtTime(n,e)}getSecondsAtTime(t){t=this.toSeconds(t);const e=this._state.getLastState("stopped",t),n={state:"paused",time:t};this._state.add(n);let s=e,i=0;return this._state.forEachBetween(e.time,t+this.sampleTime,t=>{let e=s.time;const n=this._tickOffset.get(t.time);n&&n.time>=s.time&&(i=n.seconds,e=n.time),"started"===s.state&&"started"!==t.state&&(i+=t.time-e),s=t}),this._state.remove(n),i}setTicksAtTime(t,e){return e=this.toSeconds(e),this._tickOffset.cancel(e),this._tickOffset.add({seconds:this.frequency.getDurationOfTicks(t,e),ticks:t,time:e}),this}getStateAtTime(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)}getTimeOfTick(t,e=this.now()){const n=this._tickOffset.get(e),s=this._state.get(e),i=Math.max(n.time,s.time),o=this.frequency.getTicksAtTime(i)+t-n.ticks;return this.frequency.getTimeOfTick(o)}forEachTickBetween(t,e,n){let s=this._state.get(t);this._state.forEachBetween(t,e,e=>{s&&"started"===s.state&&"started"!==e.state&&this.forEachTickBetween(Math.max(s.time,t),e.time-this.sampleTime,n),s=e});let i=null;if(s&&"started"===s.state){const o=Math.max(s.time,t),r=this.frequency.getTicksAtTime(o),a=r-this.frequency.getTicksAtTime(s.time);let c=Math.ceil(a)-a;c=z(c,1)?0:c;let u=this.frequency.getTimeOfTick(r+c);for(;u<e;){try{n(u,Math.round(this.getTicksAtTime(u)))}catch(t){i=t;break}u+=this.frequency.getDurationOfTicks(1,u)}}if(i)throw i;return this}dispose(){return super.dispose(),this._state.dispose(),this._tickOffset.dispose(),this.frequency.dispose(),this}}class Nt extends Tt{constructor(){super(q(Nt.getDefaults(),arguments,["callback","frequency"])),this.name="Clock",this.callback=K,this._lastUpdate=0,this._state=new Ot("stopped"),this._boundLoop=this._loop.bind(this);const t=q(Nt.getDefaults(),arguments,["callback","frequency"]);this.callback=t.callback,this._tickSource=new Vt({context:this.context,frequency:t.frequency,units:t.units}),this._lastUpdate=0,this.frequency=this._tickSource.frequency,$(this,"frequency"),this._state.setStateAtTime("stopped",0),this.context.on("tick",this._boundLoop)}static getDefaults(){return Object.assign(Tt.getDefaults(),{callback:K,frequency:1,units:"hertz"})}get state(){return this._state.getValueAtTime(this.now())}start(t,e){c(this.context);const n=this.toSeconds(t);return this.log("start",n),"started"!==this._state.getValueAtTime(n)&&(this._state.setStateAtTime("started",n),this._tickSource.start(n,e),n<this._lastUpdate&&this.emit("start",n,e)),this}stop(t){const e=this.toSeconds(t);return this.log("stop",e),this._state.cancel(e),this._state.setStateAtTime("stopped",e),this._tickSource.stop(e),e<this._lastUpdate&&this.emit("stop",e),this}pause(t){const e=this.toSeconds(t);return"started"===this._state.getValueAtTime(e)&&(this._state.setStateAtTime("paused",e),this._tickSource.pause(e),e<this._lastUpdate&&this.emit("pause",e)),this}get ticks(){return Math.ceil(this.getTicksAtTime(this.now()))}set ticks(t){this._tickSource.ticks=t}get seconds(){return this._tickSource.seconds}set seconds(t){this._tickSource.seconds=t}getSecondsAtTime(t){return this._tickSource.getSecondsAtTime(t)}setTicksAtTime(t,e){return this._tickSource.setTicksAtTime(t,e),this}getTimeOfTick(t,e=this.now()){return this._tickSource.getTimeOfTick(t,e)}getTicksAtTime(t){return this._tickSource.getTicksAtTime(t)}nextTickTime(t,e){const n=this.toSeconds(e),s=this.getTicksAtTime(n);return this._tickSource.getTimeOfTick(s+t,n)}_loop(){const t=this._lastUpdate,e=this.now();this._lastUpdate=e,this.log("loop",t,e),t!==e&&(this._state.forEachBetween(t,e,t=>{switch(t.state){case"started":const e=this._tickSource.getTicksAtTime(t.time);this.emit("start",t.time,e);break;case"stopped":0!==t.time&&this.emit("stop",t.time);break;case"paused":this.emit("pause",t.time)}}),this._tickSource.forEachTickBetween(t,e,(t,e)=>{this.callback(t,e)}))}getStateAtTime(t){const e=this.toSeconds(t);return this._state.getValueAtTime(e)}dispose(){return super.dispose(),this.context.off("tick",this._boundLoop),this._tickSource.dispose(),this._state.dispose(),this}}Z.mixin(Nt);class Pt extends V{constructor(t){super(),this.name="TimelineValue",this._timeline=new W({memory:10}),this._initialValue=t}set(t,e){return this._timeline.add({value:t,time:e}),this}get(t){const e=this._timeline.get(t);return e?e.value:this._initialValue}}class Lt extends xt{constructor(){super(...arguments),this.name="Ticks",this.defaultUnits="i"}_now(){return this.context.transport.ticks}_beatsToUnits(t){return this._getPPQ()*t}_secondsToUnits(t){return Math.floor(t/(60/this._getBpm())*this._getPPQ())}_ticksToUnits(t){return t}toTicks(){return this.valueOf()}toSeconds(){return this.valueOf()/this._getPPQ()*(60/this._getBpm())}}function zt(t,e){return new Lt(it(),t,e)}class Bt extends V{constructor(){super(...arguments),this.name="IntervalTimeline",this._root=null,this._length=0}add(t){r(f(t.time),"Events must have a time property"),r(f(t.duration),"Events must have a duration parameter"),t.time=t.time.valueOf();let e=new Wt(t.time,t.time+t.duration,t);for(null===this._root?this._root=e:this._root.insert(e),this._length++;null!==e;)e.updateHeight(),e.updateMax(),this._rebalance(e),e=e.parent;return this}remove(t){if(null!==this._root){const e=[];this._root.search(t.time,e);for(const n of e)if(n.event===t){this._removeNode(n),this._length--;break}}return this}get length(){return this._length}cancel(t){return this.forEachFrom(t,t=>this.remove(t)),this}_setRoot(t){this._root=t,null!==this._root&&(this._root.parent=null)}_replaceNodeInParent(t,e){null!==t.parent?(t.isLeftChild()?t.parent.left=e:t.parent.right=e,this._rebalance(t.parent)):this._setRoot(e)}_removeNode(t){if(null===t.left&&null===t.right)this._replaceNodeInParent(t,null);else if(null===t.right)this._replaceNodeInParent(t,t.left);else if(null===t.left)this._replaceNodeInParent(t,t.right);else{let e,n=null;if(t.getBalance()>0)if(null===t.left.right)e=t.left,e.right=t.right,n=e;else{for(e=t.left.right;null!==e.right;)e=e.right;e.parent&&(e.parent.right=e.left,n=e.parent,e.left=t.left,e.right=t.right)}else if(null===t.right.left)e=t.right,e.left=t.left,n=e;else{for(e=t.right.left;null!==e.left;)e=e.left;e.parent&&(e.parent.left=e.right,n=e.parent,e.left=t.left,e.right=t.right)}null!==t.parent?t.isLeftChild()?t.parent.left=e:t.parent.right=e:this._setRoot(e),n&&this._rebalance(n)}t.dispose()}_rotateLeft(t){const e=t.parent,n=t.isLeftChild(),s=t.right;s&&(t.right=s.left,s.left=t),null!==e?n?e.left=s:e.right=s:this._setRoot(s)}_rotateRight(t){const e=t.parent,n=t.isLeftChild(),s=t.left;s&&(t.left=s.right,s.right=t),null!==e?n?e.left=s:e.right=s:this._setRoot(s)}_rebalance(t){const e=t.getBalance();e>1&&t.left?t.left.getBalance()<0?this._rotateLeft(t.left):this._rotateRight(t):e<-1&&t.right&&(t.right.getBalance()>0?this._rotateRight(t.right):this._rotateLeft(t))}get(t){if(null!==this._root){const e=[];if(this._root.search(t,e),e.length>0){let t=e[0];for(let n=1;n<e.length;n++)e[n].low>t.low&&(t=e[n]);return t.event}}return null}forEach(t){if(null!==this._root){const e=[];this._root.traverse(t=>e.push(t)),e.forEach(e=>{e.event&&t(e.event)})}return this}forEachAtTime(t,e){if(null!==this._root){const n=[];this._root.search(t,n),n.forEach(t=>{t.event&&e(t.event)})}return this}forEachFrom(t,e){if(null!==this._root){const n=[];this._root.searchAfter(t,n),n.forEach(t=>{t.event&&e(t.event)})}return this}dispose(){return super.dispose(),null!==this._root&&this._root.traverse(t=>t.dispose()),this._root=null,this}}class Wt{constructor(t,e,n){this._left=null,this._right=null,this.parent=null,this.height=0,this.event=n,this.low=t,this.high=e,this.max=this.high}insert(t){t.low<=this.low?null===this.left?this.left=t:this.left.insert(t):null===this.right?this.right=t:this.right.insert(t)}search(t,e){t>this.max||(null!==this.left&&this.left.search(t,e),this.low<=t&&this.high>t&&e.push(this),this.low>t||null!==this.right&&this.right.search(t,e))}searchAfter(t,e){this.low>=t&&(e.push(this),null!==this.left&&this.left.searchAfter(t,e)),null!==this.right&&this.right.searchAfter(t,e)}traverse(t){t(this),null!==this.left&&this.left.traverse(t),null!==this.right&&this.right.traverse(t)}updateHeight(){null!==this.left&&null!==this.right?this.height=Math.max(this.left.height,this.right.height)+1:null!==this.right?this.height=this.right.height+1:null!==this.left?this.height=this.left.height+1:this.height=0}updateMax(){this.max=this.high,null!==this.left&&(this.max=Math.max(this.max,this.left.max)),null!==this.right&&(this.max=Math.max(this.max,this.right.max))}getBalance(){let t=0;return null!==this.left&&null!==this.right?t=this.left.height-this.right.height:null!==this.left?t=this.left.height+1:null!==this.right&&(t=-(this.right.height+1)),t}isLeftChild(){return null!==this.parent&&this.parent.left===this}get left(){return this._left}set left(t){this._left=t,null!==t&&(t.parent=this),this.updateHeight(),this.updateMax()}get right(){return this._right}set right(t){this._right=t,null!==t&&(t.parent=this),this.updateHeight(),this.updateMax()}dispose(){this.parent=null,this._left=null,this._right=null,this.event=null}}class Ut{constructor(t,e){this.id=Ut._eventId++;const n=Object.assign(Ut.getDefaults(),e);this.transport=t,this.callback=n.callback,this._once=n.once,this.time=n.time}static getDefaults(){return{callback:K,once:!1,time:0}}invoke(t){this.callback&&(this.callback(t),this._once&&this.transport.clear(this.id))}dispose(){return this.callback=void 0,this}}Ut._eventId=0;class Gt extends Ut{constructor(t,e){super(t,e),this._currentId=-1,this._nextId=-1,this._nextTick=this.time,this._boundRestart=this._restart.bind(this);const n=Object.assign(Gt.getDefaults(),e);this.duration=new Lt(t.context,n.duration).valueOf(),this._interval=new Lt(t.context,n.interval).valueOf(),this._nextTick=n.time,this.transport.on("start",this._boundRestart),this.transport.on("loopStart",this._boundRestart),this.context=this.transport.context,this._restart()}static getDefaults(){return Object.assign({},Ut.getDefaults(),{duration:1/0,interval:1,once:!1})}invoke(t){this._createEvents(t),super.invoke(t)}_createEvents(t){const e=this.transport.getTicksAtTime(t);e>=this.time&&e>=this._nextTick&&this._nextTick+this._interval<this.time+this.duration&&(this._nextTick+=this._interval,this._currentId=this._nextId,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new Lt(this.context,this._nextTick).toSeconds()))}_restart(t){this.transport.clear(this._currentId),this.transport.clear(this._nextId),this._nextTick=this.time;const e=this.transport.getTicksAtTime(t);e>this.time&&(this._nextTick=this.time+Math.ceil((e-this.time)/this._interval)*this._interval),this._currentId=this.transport.scheduleOnce(this.invoke.bind(this),new Lt(this.context,this._nextTick).toSeconds()),this._nextTick+=this._interval,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new Lt(this.context,this._nextTick).toSeconds())}dispose(){return super.dispose(),this.transport.clear(this._currentId),this.transport.clear(this._nextId),this.transport.off("start",this._boundRestart),this.transport.off("loopStart",this._boundRestart),this}}class Yt extends Tt{constructor(){super(q(Yt.getDefaults(),arguments)),this.name="Transport",this._loop=new Pt(!1),this._loopStart=0,this._loopEnd=0,this._scheduledEvents={},this._timeline=new W,this._repeatedEvents=new Bt,this._syncedSignals=[],this._swingAmount=0;const t=q(Yt.getDefaults(),arguments);this._ppq=t.ppq,this._clock=new Nt({callback:this._processTick.bind(this),context:this.context,frequency:0,units:"bpm"}),this._bindClockEvents(),this.bpm=this._clock.frequency,this._clock.frequency.multiplier=t.ppq,this.bpm.setValueAtTime(t.bpm,0),$(this,"bpm"),this._timeSignature=t.timeSignature,this._swingTicks=t.ppq/2}static getDefaults(){return Object.assign(Tt.getDefaults(),{bpm:120,loopEnd:"4m",loopStart:0,ppq:192,swing:0,swingSubdivision:"8n",timeSignature:4})}_processTick(t,e){if(this._swingAmount>0&&e%this._ppq!=0&&e%(2*this._swingTicks)!=0){const n=e%(2*this._swingTicks)/(2*this._swingTicks),s=Math.sin(n*Math.PI)*this._swingAmount;t+=new Lt(this.context,2*this._swingTicks/3).toSeconds()*s}this._loop.get(t)&&e>=this._loopEnd&&(this.emit("loopEnd",t),this._clock.setTicksAtTime(this._loopStart,t),e=this._loopStart,this.emit("loopStart",t,this._clock.getSecondsAtTime(t)),this.emit("loop",t)),this._timeline.forEachAtTime(e,e=>e.invoke(t))}schedule(t,e){const n=new Ut(this,{callback:t,time:new xt(this.context,e).toTicks()});return this._addEvent(n,this._timeline)}scheduleRepeat(t,e,n,s=1/0){const i=new Gt(this,{callback:t,duration:new _t(this.context,s).toTicks(),interval:new _t(this.context,e).toTicks(),time:new xt(this.context,n).toTicks()});return this._addEvent(i,this._repeatedEvents)}scheduleOnce(t,e){const n=new Ut(this,{callback:t,once:!0,time:new xt(this.context,e).toTicks()});return this._addEvent(n,this._timeline)}clear(t){if(this._scheduledEvents.hasOwnProperty(t)){const e=this._scheduledEvents[t.toString()];e.timeline.remove(e.event),e.event.dispose(),delete this._scheduledEvents[t.toString()]}return this}_addEvent(t,e){return this._scheduledEvents[t.id.toString()]={event:t,timeline:e},e.add(t),t.id}cancel(t=0){const e=this.toTicks(t);return this._timeline.forEachFrom(e,t=>this.clear(t.id)),this._repeatedEvents.forEachFrom(e,t=>this.clear(t.id)),this}_bindClockEvents(){this._clock.on("start",(t,e)=>{e=new Lt(this.context,e).toSeconds(),this.emit("start",t,e)}),this._clock.on("stop",t=>{this.emit("stop",t)}),this._clock.on("pause",t=>{this.emit("pause",t)})}get state(){return this._clock.getStateAtTime(this.now())}start(t,e){let n;return f(e)&&(n=this.toTicks(e)),this._clock.start(t,n),this}stop(t){return this._clock.stop(t),this}pause(t){return this._clock.pause(t),this}toggle(t){return t=this.toSeconds(t),"started"!==this._clock.getStateAtTime(t)?this.start(t):this.stop(t),this}get timeSignature(){return this._timeSignature}set timeSignature(t){y(t)&&(t=t[0]/t[1]*4),this._timeSignature=t}get loopStart(){return new _t(this.context,this._loopStart,"i").toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t)}get loopEnd(){return new _t(this.context,this._loopEnd,"i").toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t)}get loop(){return this._loop.get(this.now())}set loop(t){this._loop.set(t,this.now())}setLoopPoints(t,e){return this.loopStart=t,this.loopEnd=e,this}get swing(){return this._swingAmount}set swing(t){this._swingAmount=t}get swingSubdivision(){return new Lt(this.context,this._swingTicks).toNotation()}set swingSubdivision(t){this._swingTicks=this.toTicks(t)}get position(){const t=this.now(),e=this._clock.getTicksAtTime(t);return new Lt(this.context,e).toBarsBeatsSixteenths()}set position(t){const e=this.toTicks(t);this.ticks=e}get seconds(){return this._clock.seconds}set seconds(t){const e=this.now(),n=this._clock.frequency.timeToTicks(t,e);this.ticks=n}get progress(){if(this.loop){const t=this.now();return(this._clock.getTicksAtTime(t)-this._loopStart)/(this._loopEnd-this._loopStart)}return 0}get ticks(){return this._clock.ticks}set ticks(t){if(this._clock.ticks!==t){const e=this.now();if("started"===this.state){const n=this._clock.getTicksAtTime(e),s=this._clock.getTimeOfTick(Math.ceil(n));this.emit("stop",s),this._clock.setTicksAtTime(t,s),this.emit("start",s,this._clock.getSecondsAtTime(s))}else this._clock.setTicksAtTime(t,e)}}getTicksAtTime(t){return Math.round(this._clock.getTicksAtTime(t))}getSecondsAtTime(t){return this._clock.getSecondsAtTime(t)}get PPQ(){return this._clock.frequency.multiplier}set PPQ(t){this._clock.frequency.multiplier=t}nextSubdivision(t){if(t=this.toTicks(t),"started"!==this.state)return 0;{const e=this.now(),n=t-this.getTicksAtTime(e)%t;return this._clock.nextTickTime(n,e)}}syncSignal(t,e){if(!e){const n=this.now();if(0!==t.getValueAtTime(n)){const s=1/(60/this.bpm.getValueAtTime(n)/this.PPQ);e=t.getValueAtTime(n)/s}else e=0}const n=new Mt(e);return this.bpm.connect(n),n.connect(t._param),this._syncedSignals.push({initial:t.value,ratio:n,signal:t}),t.value=0,this}unsyncSignal(t){for(let e=this._syncedSignals.length-1;e>=0;e--){const n=this._syncedSignals[e];n.signal===t&&(n.ratio.dispose(),n.signal.value=n.initial,this._syncedSignals.splice(e,1))}return this}dispose(){return super.dispose(),this._clock.dispose(),J(this,"bpm"),this._timeline.dispose(),this._repeatedEvents.dispose(),this}}Z.mixin(Yt),G(t=>{t.transport=new Yt({context:t})}),Q(t=>{t.transport.dispose()});class Qt extends Ct{constructor(){super(q(Qt.getDefaults(),arguments,["delayTime","maxDelay"])),this.name="Delay";const t=q(Qt.getDefaults(),arguments,["delayTime","maxDelay"]),e=this.toSeconds(t.maxDelay);this._maxDelay=Math.max(e,this.toSeconds(t.delayTime)),this._delayNode=this.input=this.output=this.context.createDelay(e),this.delayTime=new St({context:this.context,param:this._delayNode.delayTime,units:"time",value:t.delayTime,minValue:0,maxValue:this.maxDelay}),$(this,"delayTime")}static getDefaults(){return Object.assign(Ct.getDefaults(),{delayTime:0,maxDelay:1})}get maxDelay(){return this._maxDelay}dispose(){return super.dispose(),this._delayNode.disconnect(),this.delayTime.dispose(),this}}class Zt extends Ct{constructor(){super(q(Zt.getDefaults(),arguments,["volume"])),this.name="Volume";const t=q(Zt.getDefaults(),arguments,["volume"]);this.input=this.output=new Mt({context:this.context,gain:t.volume,units:"decibels"}),this.volume=this.output.gain,$(this,"volume"),this._unmutedVolume=t.volume,this.mute=t.mute}static getDefaults(){return Object.assign(Ct.getDefaults(),{mute:!1,volume:0})}get mute(){return this.volume.value===-1/0}set mute(t){!this.mute&&t?(this._unmutedVolume=this.volume.value,this.volume.value=-1/0):this.mute&&!t&&(this.volume.value=this._unmutedVolume)}dispose(){return super.dispose(),this.input.dispose(),this.volume.dispose(),this}}class Xt extends Ct{constructor(){super(q(Xt.getDefaults(),arguments)),this.name="Destination",this.input=new Zt({context:this.context}),this.output=new Mt({context:this.context}),this.volume=this.input.volume;const t=q(Xt.getDefaults(),arguments);kt(this.input,this.output,this.context.rawContext.destination),this.mute=t.mute,this._internalChannels=[this.input,this.context.rawContext.destination,this.output]}static getDefaults(){return Object.assign(Ct.getDefaults(),{mute:!1,volume:0})}get mute(){return this.input.mute}set mute(t){this.input.mute=t}chain(...t){return this.input.disconnect(),t.unshift(this.input),t.push(this.output),kt(...t),this}get maxChannelCount(){return this.context.rawContext.destination.maxChannelCount}dispose(){return super.dispose(),this.volume.dispose(),this}}function Ht(t,e,n=2,s=it().sampleRate){return S(this,void 0,void 0,(function*(){const i=it(),o=new et(n,e,s);ot(o),yield t(o);const r=o.render();ot(i);const a=yield r;return new tt(a)}))}G(t=>{t.destination=new Xt({context:t})}),Q(t=>{t.destination.dispose()});class $t extends V{constructor(){super(),this.name="ToneAudioBuffers",this._buffers=new Map,this._loadingCount=0;const t=q($t.getDefaults(),arguments,["urls","onload","baseUrl"],"urls");this.baseUrl=t.baseUrl,Object.keys(t.urls).forEach(e=>{this._loadingCount++;const n=t.urls[e];this.add(e,n,this._bufferLoaded.bind(this,t.onload),t.onerror)})}static getDefaults(){return{baseUrl:"",onerror:K,onload:K,urls:{}}}has(t){return this._buffers.has(t.toString())}get(t){return r(this.has(t),"ToneAudioBuffers has no buffer named: "+t),this._buffers.get(t.toString())}_bufferLoaded(t){this._loadingCount--,0===this._loadingCount&&t&&t()}get loaded(){return Array.from(this._buffers).every(([t,e])=>e.loaded)}add(t,e,n=K,s=K){return b(e)?this._buffers.set(t.toString(),new tt(this.baseUrl+e,n,s)):this._buffers.set(t.toString(),new tt(e,n,s)),this}dispose(){return super.dispose(),this._buffers.forEach(t=>t.dispose()),this._buffers.clear(),this}}class Jt extends gt{constructor(){super(...arguments),this.name="MidiClass",this.defaultUnits="midi"}_frequencyToUnits(t){return lt(super._frequencyToUnits(t))}_ticksToUnits(t){return lt(super._ticksToUnits(t))}_beatsToUnits(t){return lt(super._beatsToUnits(t))}_secondsToUnits(t){return lt(super._secondsToUnits(t))}toMidi(){return this.valueOf()}toFrequency(){return pt(this.toMidi())}transpose(t){return new Jt(this.context,this.toMidi()+t)}}function Kt(t,e){return new Jt(it(),t,e)}class te extends Tt{constructor(){super(...arguments),this.name="Draw",this.expiration=.25,this.anticipation=.008,this._events=new W,this._boundDrawLoop=this._drawLoop.bind(this),this._animationFrame=-1}schedule(t,e){return this._events.add({callback:t,time:this.toSeconds(e)}),1===this._events.length&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop)),this}cancel(t){return this._events.cancel(this.toSeconds(t)),this}_drawLoop(){const t=this.context.currentTime;for(;this._events.length&&this._events.peek().time-this.anticipation<=t;){const e=this._events.shift();e&&t-e.time<=this.expiration&&e.callback()}this._events.length>0&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop))}dispose(){return super.dispose(),this._events.dispose(),cancelAnimationFrame(this._animationFrame),this}}G(t=>{t.draw=new te({context:t})}),Q(t=>{t.draw.dispose()});var ee=n(515);class ne extends Ct{constructor(t){super(t),this.input=void 0,this._state=new Ot("stopped"),this._synced=!1,this._scheduled=[],this._syncedStart=K,this._syncedStop=K,this._state.memory=100,this._state.increasing=!0,this._volume=this.output=new Zt({context:this.context,mute:t.mute,volume:t.volume}),this.volume=this._volume.volume,$(this,"volume"),this.onstop=t.onstop}static getDefaults(){return Object.assign(Ct.getDefaults(),{mute:!1,onstop:K,volume:0})}get state(){return this._synced?"started"===this.context.transport.state?this._state.getValueAtTime(this.context.transport.seconds):"stopped":this._state.getValueAtTime(this.now())}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}_clampToCurrentTime(t){return this._synced?t:Math.max(t,this.context.currentTime)}start(t,e,n){let s=p(t)&&this._synced?this.context.transport.seconds:this.toSeconds(t);if(s=this._clampToCurrentTime(s),this._synced||"started"!==this._state.getValueAtTime(s))if(this.log("start",s),this._state.setStateAtTime("started",s),this._synced){const t=this._state.get(s);t&&(t.offset=this.toSeconds(I(e,0)),t.duration=n?this.toSeconds(n):void 0);const i=this.context.transport.schedule(t=>{this._start(t,e,n)},s);this._scheduled.push(i),"started"===this.context.transport.state&&this.context.transport.getSecondsAtTime(this.immediate())>s&&this._syncedStart(this.now(),this.context.transport.seconds)}else c(this.context),this._start(s,e,n);else r(N(s,this._state.get(s).time),"Start time must be strictly greater than previous start time"),this._state.cancel(s),this._state.setStateAtTime("started",s),this.log("restart",s),this.restart(s,e,n);return this}stop(t){let e=p(t)&&this._synced?this.context.transport.seconds:this.toSeconds(t);if(e=this._clampToCurrentTime(e),"started"===this._state.getValueAtTime(e)||f(this._state.getNextState("started",e))){if(this.log("stop",e),this._synced){const t=this.context.transport.schedule(this._stop.bind(this),e);this._scheduled.push(t)}else this._stop(e);this._state.cancel(e),this._state.setStateAtTime("stopped",e)}return this}restart(t,e,n){return t=this.toSeconds(t),"started"===this._state.getValueAtTime(t)&&(this._state.cancel(t),this._restart(t,e,n)),this}sync(){return this._synced||(this._synced=!0,this._syncedStart=(t,e)=>{if(e>0){const n=this._state.get(e);if(n&&"started"===n.state&&n.time!==e){const s=e-this.toSeconds(n.time);let i;n.duration&&(i=this.toSeconds(n.duration)-s),this._start(t,this.toSeconds(n.offset)+s,i)}}},this._syncedStop=t=>{const e=this.context.transport.getSecondsAtTime(Math.max(t-this.sampleTime,0));"started"===this._state.getValueAtTime(e)&&this._stop(t)},this.context.transport.on("start",this._syncedStart),this.context.transport.on("loopStart",this._syncedStart),this.context.transport.on("stop",this._syncedStop),this.context.transport.on("pause",this._syncedStop),this.context.transport.on("loopEnd",this._syncedStop)),this}unsync(){return this._synced&&(this.context.transport.off("stop",this._syncedStop),this.context.transport.off("pause",this._syncedStop),this.context.transport.off("loopEnd",this._syncedStop),this.context.transport.off("start",this._syncedStart),this.context.transport.off("loopStart",this._syncedStart)),this._synced=!1,this._scheduled.forEach(t=>this.context.transport.clear(t)),this._scheduled=[],this._state.cancel(0),this._stop(0),this}dispose(){return super.dispose(),this.onstop=K,this.unsync(),this._volume.dispose(),this._state.dispose(),this}}class se extends jt{constructor(){super(q(se.getDefaults(),arguments,["url","onload"])),this.name="ToneBufferSource",this._source=this.context.createBufferSource(),this._internalChannels=[this._source],this._sourceStarted=!1,this._sourceStopped=!1;const t=q(se.getDefaults(),arguments,["url","onload"]);At(this._source,this._gainNode),this._source.onended=()=>this._stopSource(),this.playbackRate=new St({context:this.context,param:this._source.playbackRate,units:"positive",value:t.playbackRate}),this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this._buffer=new tt(t.url,t.onload,t.onerror),this._internalChannels.push(this._source)}static getDefaults(){return Object.assign(jt.getDefaults(),{url:new tt,loop:!1,loopEnd:0,loopStart:0,onload:K,onerror:K,playbackRate:1})}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t}get curve(){return this._curve}set curve(t){this._curve=t}start(t,e,n,s=1){r(this.buffer.loaded,"buffer is either not set or not loaded");const i=this.toSeconds(t);this._startGain(i,s),e=this.loop?I(e,this.loopStart):I(e,0);let o=Math.max(this.toSeconds(e),0);if(this.loop){const t=this.toSeconds(this.loopEnd)||this.buffer.duration,e=this.toSeconds(this.loopStart),n=t-e;P(o,t)&&(o=(o-e)%n+e),z(o,this.buffer.duration)&&(o=0)}if(this._source.buffer=this.buffer.get(),this._source.loopEnd=this.toSeconds(this.loopEnd)||this.buffer.duration,L(o,this.buffer.duration)&&(this._sourceStarted=!0,this._source.start(i,o)),f(n)){let t=this.toSeconds(n);t=Math.max(t,0),this.stop(i+t)}return this}_stopSource(t){!this._sourceStopped&&this._sourceStarted&&(this._sourceStopped=!0,this._source.stop(this.toSeconds(t)),this._onended())}get loopStart(){return this._source.loopStart}set loopStart(t){this._source.loopStart=this.toSeconds(t)}get loopEnd(){return this._source.loopEnd}set loopEnd(t){this._source.loopEnd=this.toSeconds(t)}get buffer(){return this._buffer}set buffer(t){this._buffer.set(t)}get loop(){return this._source.loop}set loop(t){this._source.loop=t,this._sourceStarted&&this.cancelStop()}dispose(){return super.dispose(),this._source.onended=null,this._source.disconnect(),this._buffer.dispose(),this.playbackRate.dispose(),this}}class ie extends ne{constructor(){super(q(ie.getDefaults(),arguments,["type"])),this.name="Noise",this._source=null;const t=q(ie.getDefaults(),arguments,["type"]);this._playbackRate=t.playbackRate,this.type=t.type,this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut}static getDefaults(){return Object.assign(ne.getDefaults(),{fadeIn:0,fadeOut:0,playbackRate:1,type:"white"})}get type(){return this._type}set type(t){if(r(t in re,"Noise: invalid type: "+t),this._type!==t&&(this._type=t,"started"===this.state)){const t=this.now();this._stop(t),this._start(t)}}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this._source&&(this._source.playbackRate.value=t)}_start(t){const e=re[this._type];this._source=new se({url:e,context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,loop:!0,onended:()=>this.onstop(this),playbackRate:this._playbackRate}).connect(this.output),this._source.start(this.toSeconds(t),Math.random()*(e.duration-.001))}_stop(t){this._source&&(this._source.stop(this.toSeconds(t)),this._source=null)}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t,this._source&&(this._source.fadeIn=this._fadeIn)}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t,this._source&&(this._source.fadeOut=this._fadeOut)}_restart(t){this._stop(t),this._start(t)}dispose(){return super.dispose(),this._source&&this._source.disconnect(),this}}const oe={brown:null,pink:null,white:null},re={get brown(){if(!oe.brown){const t=[];for(let e=0;e<2;e++){const n=new Float32Array(220500);t[e]=n;let s=0;for(let t=0;t<220500;t++){const e=2*Math.random()-1;n[t]=(s+.02*e)/1.02,s=n[t],n[t]*=3.5}}oe.brown=(new tt).fromArray(t)}return oe.brown},get pink(){if(!oe.pink){const t=[];for(let e=0;e<2;e++){const n=new Float32Array(220500);let s,i,o,r,a,c,u;t[e]=n,s=i=o=r=a=c=u=0;for(let t=0;t<220500;t++){const e=2*Math.random()-1;s=.99886*s+.0555179*e,i=.99332*i+.0750759*e,o=.969*o+.153852*e,r=.8665*r+.3104856*e,a=.55*a+.5329522*e,c=-.7616*c-.016898*e,n[t]=s+i+o+r+a+c+u+.5362*e,n[t]*=.11,u=.115926*e}}oe.pink=(new tt).fromArray(t)}return oe.pink},get white(){if(!oe.white){const t=[];for(let e=0;e<2;e++){const n=new Float32Array(220500);t[e]=n;for(let t=0;t<220500;t++)n[t]=2*Math.random()-1}oe.white=(new tt).fromArray(t)}return oe.white}};class ae extends Ct{constructor(){super(q(ae.getDefaults(),arguments,["volume"])),this.name="UserMedia";const t=q(ae.getDefaults(),arguments,["volume"]);this._volume=this.output=new Zt({context:this.context,volume:t.volume}),this.volume=this._volume.volume,$(this,"volume"),this.mute=t.mute}static getDefaults(){return Object.assign(Ct.getDefaults(),{mute:!1,volume:0})}open(t){return S(this,void 0,void 0,(function*(){r(ae.supported,"UserMedia is not supported"),"started"===this.state&&this.close();const e=yield ae.enumerateDevices();m(t)?this._device=e[t]:(this._device=e.find(e=>e.label===t||e.deviceId===t),!this._device&&e.length>0&&(this._device=e[0]),r(f(this._device),"No matching device "+t));const n={audio:{echoCancellation:!1,sampleRate:this.context.sampleRate,noiseSuppression:!1,mozNoiseSuppression:!1}};this._device&&(n.audio.deviceId=this._device.deviceId);const s=yield navigator.mediaDevices.getUserMedia(n);if(!this._stream){this._stream=s;const t=this.context.createMediaStreamSource(s);At(t,this.output),this._mediaStream=t}return this}))}close(){return this._stream&&this._mediaStream&&(this._stream.getAudioTracks().forEach(t=>{t.stop()}),this._stream=void 0,this._mediaStream.disconnect(),this._mediaStream=void 0),this._device=void 0,this}static enumerateDevices(){return S(this,void 0,void 0,(function*(){return(yield navigator.mediaDevices.enumerateDevices()).filter(t=>"audioinput"===t.kind)}))}get state(){return this._stream&&this._stream.active?"started":"stopped"}get deviceId(){return this._device?this._device.deviceId:void 0}get groupId(){return this._device?this._device.groupId:void 0}get label(){return this._device?this._device.label:void 0}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}dispose(){return super.dispose(),this.close(),this._volume.dispose(),this.volume.dispose(),this}static get supported(){return f(navigator.mediaDevices)&&f(navigator.mediaDevices.getUserMedia)}}function ce(t,e){return S(this,void 0,void 0,(function*(){const n=e/t.context.sampleRate,s=new et(1,n,t.context.sampleRate);return new t.constructor(Object.assign(t.get(),{frequency:2/n,detune:0,context:s})).toDestination().start(0),(yield s.render()).getChannelData(0)}))}class ue extends jt{constructor(){super(q(ue.getDefaults(),arguments,["frequency","type"])),this.name="ToneOscillatorNode",this._oscillator=this.context.createOscillator(),this._internalChannels=[this._oscillator];const t=q(ue.getDefaults(),arguments,["frequency","type"]);At(this._oscillator,this._gainNode),this.type=t.type,this.frequency=new St({context:this.context,param:this._oscillator.frequency,units:"frequency",value:t.frequency}),this.detune=new St({context:this.context,param:this._oscillator.detune,units:"cents",value:t.detune}),$(this,["frequency","detune"])}static getDefaults(){return Object.assign(jt.getDefaults(),{detune:0,frequency:440,type:"sine"})}start(t){const e=this.toSeconds(t);return this.log("start",e),this._startGain(e),this._oscillator.start(e),this}_stopSource(t){this._oscillator.stop(t)}setPeriodicWave(t){return this._oscillator.setPeriodicWave(t),this}get type(){return this._oscillator.type}set type(t){this._oscillator.type=t}dispose(){return super.dispose(),"started"===this.state&&this.stop(),this._oscillator.disconnect(),this.frequency.dispose(),this.detune.dispose(),this}}class he extends ne{constructor(){super(q(he.getDefaults(),arguments,["frequency","type"])),this.name="Oscillator",this._oscillator=null;const t=q(he.getDefaults(),arguments,["frequency","type"]);this.frequency=new Rt({context:this.context,units:"frequency",value:t.frequency}),$(this,"frequency"),this.detune=new Rt({context:this.context,units:"cents",value:t.detune}),$(this,"detune"),this._partials=t.partials,this._partialCount=t.partialCount,this._type=t.type,t.partialCount&&"custom"!==t.type&&(this._type=this.baseType+t.partialCount.toString()),this.phase=t.phase}static getDefaults(){return Object.assign(ne.getDefaults(),{detune:0,frequency:440,partialCount:0,partials:[],phase:0,type:"sine"})}_start(t){const e=this.toSeconds(t),n=new ue({context:this.context,onended:()=>this.onstop(this)});this._oscillator=n,this._wave?this._oscillator.setPeriodicWave(this._wave):this._oscillator.type=this._type,this._oscillator.connect(this.output),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.start(e)}_stop(t){const e=this.toSeconds(t);this._oscillator&&this._oscillator.stop(e)}_restart(t){const e=this.toSeconds(t);return this.log("restart",e),this._oscillator&&this._oscillator.cancelStop(),this._state.cancel(e),this}syncFrequency(){return this.context.transport.syncSignal(this.frequency),this}unsyncFrequency(){return this.context.transport.unsyncSignal(this.frequency),this}_getCachedPeriodicWave(){if("custom"===this._type){return he._periodicWaveCache.find(t=>{return t.phase===this._phase&&(e=t.partials,n=this._partials,e.length===n.length&&e.every((t,e)=>n[e]===t));var e,n})}{const t=he._periodicWaveCache.find(t=>t.type===this._type&&t.phase===this._phase);return this._partialCount=t?t.partialCount:this._partialCount,t}}get type(){return this._type}set type(t){this._type=t;const e=-1!==["sine","square","sawtooth","triangle"].indexOf(t);if(0===this._phase&&e)this._wave=void 0,this._partialCount=0,null!==this._oscillator&&(this._oscillator.type=t);else{const e=this._getCachedPeriodicWave();if(f(e)){const{partials:t,wave:n}=e;this._wave=n,this._partials=t,null!==this._oscillator&&this._oscillator.setPeriodicWave(this._wave)}else{const[e,n]=this._getRealImaginary(t,this._phase),s=this.context.createPeriodicWave(e,n);this._wave=s,null!==this._oscillator&&this._oscillator.setPeriodicWave(this._wave),he._periodicWaveCache.push({imag:n,partialCount:this._partialCount,partials:this._partials,phase:this._phase,real:e,type:this._type,wave:this._wave}),he._periodicWaveCache.length>100&&he._periodicWaveCache.shift()}}}get baseType(){return this._type.replace(this.partialCount.toString(),"")}set baseType(t){this.partialCount&&"custom"!==this._type&&"custom"!==t?this.type=t+this.partialCount:this.type=t}get partialCount(){return this._partialCount}set partialCount(t){a(t,0);let e=this._type;const n=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);if(n&&(e=n[1]),"custom"!==this._type)this.type=0===t?e:e+t.toString();else{const e=new Float32Array(t);this._partials.forEach((t,n)=>e[n]=t),this._partials=Array.from(e),this.type=this._type}}_getRealImaginary(t,e){let n=2048;const s=new Float32Array(n),i=new Float32Array(n);let o=1;if("custom"===t){if(o=this._partials.length+1,this._partialCount=this._partials.length,n=o,0===this._partials.length)return[s,i]}else{const e=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);e?(o=parseInt(e[2],10)+1,this._partialCount=parseInt(e[2],10),t=e[1],o=Math.max(o,2),n=o):this._partialCount=0,this._partials=[]}for(let r=1;r<n;++r){const n=2/(r*Math.PI);let a;switch(t){case"sine":a=r<=o?1:0,this._partials[r-1]=a;break;case"square":a=1&r?2*n:0,this._partials[r-1]=a;break;case"sawtooth":a=n*(1&r?1:-1),this._partials[r-1]=a;break;case"triangle":a=1&r?n*n*2*(r-1>>1&1?-1:1):0,this._partials[r-1]=a;break;case"custom":a=this._partials[r-1];break;default:throw new TypeError("Oscillator: invalid type: "+t)}0!==a?(s[r]=-a*Math.sin(e*r),i[r]=a*Math.cos(e*r)):(s[r]=0,i[r]=0)}return[s,i]}_inverseFFT(t,e,n){let s=0;const i=t.length;for(let o=0;o<i;o++)s+=t[o]*Math.cos(o*n)+e[o]*Math.sin(o*n);return s}getInitialValue(){const[t,e]=this._getRealImaginary(this._type,0);let n=0;const s=2*Math.PI;for(let i=0;i<32;i++)n=Math.max(this._inverseFFT(t,e,i/32*s),n);return B(-this._inverseFFT(t,e,this._phase)/n,-1,1)}get partials(){return this._partials.slice(0,this.partialCount)}set partials(t){this._partials=t,this._partialCount=this._partials.length,t.length&&(this.type="custom")}get phase(){return this._phase*(180/Math.PI)}set phase(t){this._phase=t*Math.PI/180,this.type=this._type}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),null!==this._oscillator&&this._oscillator.dispose(),this._wave=void 0,this.frequency.dispose(),this.detune.dispose(),this}}he._periodicWaveCache=[];class le extends Ct{constructor(){super(Object.assign(q(le.getDefaults(),arguments,["context"])))}connect(t,e=0,n=0){return qt(this,t,e,n),this}}class de extends le{constructor(){super(Object.assign(q(de.getDefaults(),arguments,["mapping","length"]))),this.name="WaveShaper",this._shaper=this.context.createWaveShaper(),this.input=this._shaper,this.output=this._shaper;const t=q(de.getDefaults(),arguments,["mapping","length"]);y(t.mapping)||t.mapping instanceof Float32Array?this.curve=Float32Array.from(t.mapping):_(t.mapping)&&this.setMap(t.mapping,t.length)}static getDefaults(){return Object.assign(Rt.getDefaults(),{length:1024})}setMap(t,e=1024){const n=new Float32Array(e);for(let s=0,i=e;s<i;s++){const e=s/(i-1)*2-1;n[s]=t(e,s)}return this.curve=n,this}get curve(){return this._shaper.curve}set curve(t){this._shaper.curve=t}get oversample(){return this._shaper.oversample}set oversample(t){r(["none","2x","4x"].some(e=>e.includes(t)),"oversampling must be either 'none', '2x', or '4x'"),this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.disconnect(),this}}class pe extends le{constructor(){super(...arguments),this.name="AudioToGain",this._norm=new de({context:this.context,mapping:t=>(t+1)/2}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class fe extends Rt{constructor(){super(Object.assign(q(fe.getDefaults(),arguments,["value"]))),this.name="Multiply",this.override=!1;const t=q(fe.getDefaults(),arguments,["value"]);this._mult=this.input=this.output=new Mt({context:this.context,minValue:t.minValue,maxValue:t.maxValue}),this.factor=this._param=this._mult.gain,this.factor.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(Rt.getDefaults(),{value:0})}dispose(){return super.dispose(),this._mult.dispose(),this}}class _e extends ne{constructor(){super(q(_e.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="AMOscillator",this._modulationScale=new pe({context:this.context}),this._modulationNode=new Mt({context:this.context});const t=q(_e.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new he({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase,type:t.type}),this.frequency=this._carrier.frequency,this.detune=this._carrier.detune,this._modulator=new he({context:this.context,phase:t.phase,type:t.modulationType}),this.harmonicity=new fe({context:this.context,units:"positive",value:t.harmonicity}),this.frequency.chain(this.harmonicity,this._modulator.frequency),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output),$(this,["frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(he.getDefaults(),{harmonicity:1,modulationType:"square"})}_start(t){this._modulator.start(t),this._carrier.start(t)}_stop(t){this._modulator.stop(t),this._carrier.stop(t)}_restart(t){this._modulator.restart(t),this._carrier.restart(t)}get type(){return this._carrier.type}set type(t){this._carrier.type=t}get baseType(){return this._carrier.baseType}set baseType(t){this._carrier.baseType=t}get partialCount(){return this._carrier.partialCount}set partialCount(t){this._carrier.partialCount=t}get modulationType(){return this._modulator.type}set modulationType(t){this._modulator.type=t}get phase(){return this._carrier.phase}set phase(t){this._carrier.phase=t,this._modulator.phase=t}get partials(){return this._carrier.partials}set partials(t){this._carrier.partials=t}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this._modulationScale.dispose(),this}}class me extends ne{constructor(){super(q(me.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="FMOscillator",this._modulationNode=new Mt({context:this.context,gain:0});const t=q(me.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new he({context:this.context,detune:t.detune,frequency:0,onstop:()=>this.onstop(this),phase:t.phase,type:t.type}),this.detune=this._carrier.detune,this.frequency=new Rt({context:this.context,units:"frequency",value:t.frequency}),this._modulator=new he({context:this.context,phase:t.phase,type:t.modulationType}),this.harmonicity=new fe({context:this.context,units:"positive",value:t.harmonicity}),this.modulationIndex=new fe({context:this.context,units:"positive",value:t.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output),this.detune.connect(this._modulator.detune),$(this,["modulationIndex","frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(he.getDefaults(),{harmonicity:1,modulationIndex:2,modulationType:"square"})}_start(t){this._modulator.start(t),this._carrier.start(t)}_stop(t){this._modulator.stop(t),this._carrier.stop(t)}_restart(t){return this._modulator.restart(t),this._carrier.restart(t),this}get type(){return this._carrier.type}set type(t){this._carrier.type=t}get baseType(){return this._carrier.baseType}set baseType(t){this._carrier.baseType=t}get partialCount(){return this._carrier.partialCount}set partialCount(t){this._carrier.partialCount=t}get modulationType(){return this._modulator.type}set modulationType(t){this._modulator.type=t}get phase(){return this._carrier.phase}set phase(t){this._carrier.phase=t,this._modulator.phase=t}get partials(){return this._carrier.partials}set partials(t){this._carrier.partials=t}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),this.frequency.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this.modulationIndex.dispose(),this}}class ge extends ne{constructor(){super(q(ge.getDefaults(),arguments,["frequency","width"])),this.name="PulseOscillator",this._widthGate=new Mt({context:this.context,gain:0}),this._thresh=new de({context:this.context,mapping:t=>t<=0?-1:1});const t=q(ge.getDefaults(),arguments,["frequency","width"]);this.width=new Rt({context:this.context,units:"audioRange",value:t.width}),this._triangle=new he({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase,type:"triangle"}),this.frequency=this._triangle.frequency,this.detune=this._triangle.detune,this._triangle.chain(this._thresh,this.output),this.width.chain(this._widthGate,this._thresh),$(this,["width","frequency","detune"])}static getDefaults(){return Object.assign(ne.getDefaults(),{detune:0,frequency:440,phase:0,type:"pulse",width:.2})}_start(t){t=this.toSeconds(t),this._triangle.start(t),this._widthGate.gain.setValueAtTime(1,t)}_stop(t){t=this.toSeconds(t),this._triangle.stop(t),this._widthGate.gain.cancelScheduledValues(t),this._widthGate.gain.setValueAtTime(0,t)}_restart(t){this._triangle.restart(t),this._widthGate.gain.cancelScheduledValues(t),this._widthGate.gain.setValueAtTime(1,t)}get phase(){return this._triangle.phase}set phase(t){this._triangle.phase=t}get type(){return"pulse"}get baseType(){return"pulse"}get partials(){return[]}get partialCount(){return 0}set carrierType(t){this._triangle.type=t}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),this._triangle.dispose(),this.width.dispose(),this._widthGate.dispose(),this._thresh.dispose(),this}}class ve extends ne{constructor(){super(q(ve.getDefaults(),arguments,["frequency","type","spread"])),this.name="FatOscillator",this._oscillators=[];const t=q(ve.getDefaults(),arguments,["frequency","type","spread"]);this.frequency=new Rt({context:this.context,units:"frequency",value:t.frequency}),this.detune=new Rt({context:this.context,units:"cents",value:t.detune}),this._spread=t.spread,this._type=t.type,this._phase=t.phase,this._partials=t.partials,this._partialCount=t.partialCount,this.count=t.count,$(this,["frequency","detune"])}static getDefaults(){return Object.assign(he.getDefaults(),{count:3,spread:20,type:"sawtooth"})}_start(t){t=this.toSeconds(t),this._forEach(e=>e.start(t))}_stop(t){t=this.toSeconds(t),this._forEach(e=>e.stop(t))}_restart(t){this._forEach(e=>e.restart(t))}_forEach(t){for(let e=0;e<this._oscillators.length;e++)t(this._oscillators[e],e)}get type(){return this._type}set type(t){this._type=t,this._forEach(e=>e.type=t)}get spread(){return this._spread}set spread(t){if(this._spread=t,this._oscillators.length>1){const e=-t/2,n=t/(this._oscillators.length-1);this._forEach((t,s)=>t.detune.value=e+n*s)}}get count(){return this._oscillators.length}set count(t){if(a(t,1),this._oscillators.length!==t){this._forEach(t=>t.dispose()),this._oscillators=[];for(let e=0;e<t;e++){const n=new he({context:this.context,volume:-6-1.1*t,type:this._type,phase:this._phase+e/t*360,partialCount:this._partialCount,onstop:0===e?()=>this.onstop(this):K});"custom"===this.type&&(n.partials=this._partials),this.frequency.connect(n.frequency),this.detune.connect(n.detune),n.detune.overridden=!1,n.connect(this.output),this._oscillators[e]=n}this.spread=this._spread,"started"===this.state&&this._forEach(t=>t.start())}}get phase(){return this._phase}set phase(t){this._phase=t,this._forEach(e=>e.phase=t)}get baseType(){return this._oscillators[0].baseType}set baseType(t){this._forEach(e=>e.baseType=t),this._type=this._oscillators[0].type}get partials(){return this._oscillators[0].partials}set partials(t){this._partials=t,this._partialCount=this._partials.length,t.length&&(this._type="custom",this._forEach(e=>e.partials=t))}get partialCount(){return this._oscillators[0].partialCount}set partialCount(t){this._partialCount=t,this._forEach(e=>e.partialCount=t),this._type=this._oscillators[0].type}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this._forEach(t=>t.dispose()),this}}class ye extends ne{constructor(){super(q(ye.getDefaults(),arguments,["frequency","modulationFrequency"])),this.name="PWMOscillator",this.sourceType="pwm",this._scale=new fe({context:this.context,value:2});const t=q(ye.getDefaults(),arguments,["frequency","modulationFrequency"]);this._pulse=new ge({context:this.context,frequency:t.modulationFrequency}),this._pulse.carrierType="sine",this.modulationFrequency=this._pulse.frequency,this._modulator=new he({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase}),this.frequency=this._modulator.frequency,this.detune=this._modulator.detune,this._modulator.chain(this._scale,this._pulse.width),this._pulse.connect(this.output),$(this,["modulationFrequency","frequency","detune"])}static getDefaults(){return Object.assign(ne.getDefaults(),{detune:0,frequency:440,modulationFrequency:.4,phase:0,type:"pwm"})}_start(t){t=this.toSeconds(t),this._modulator.start(t),this._pulse.start(t)}_stop(t){t=this.toSeconds(t),this._modulator.stop(t),this._pulse.stop(t)}_restart(t){this._modulator.restart(t),this._pulse.restart(t)}get type(){return"pwm"}get baseType(){return"pwm"}get partials(){return[]}get partialCount(){return 0}get phase(){return this._modulator.phase}set phase(t){this._modulator.phase=t}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),this._pulse.dispose(),this._scale.dispose(),this._modulator.dispose(),this}}const be={am:_e,fat:ve,fm:me,oscillator:he,pulse:ge,pwm:ye};class xe extends ne{constructor(){super(q(xe.getDefaults(),arguments,["frequency","type"])),this.name="OmniOscillator";const t=q(xe.getDefaults(),arguments,["frequency","type"]);this.frequency=new Rt({context:this.context,units:"frequency",value:t.frequency}),this.detune=new Rt({context:this.context,units:"cents",value:t.detune}),$(this,["frequency","detune"]),this.set(t)}static getDefaults(){return Object.assign(he.getDefaults(),me.getDefaults(),_e.getDefaults(),ve.getDefaults(),ge.getDefaults(),ye.getDefaults())}_start(t){this._oscillator.start(t)}_stop(t){this._oscillator.stop(t)}_restart(t){return this._oscillator.restart(t),this}get type(){let t="";return["am","fm","fat"].some(t=>this._sourceType===t)&&(t=this._sourceType),t+this._oscillator.type}set type(t){"fm"===t.substr(0,2)?(this._createNewOscillator("fm"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(2)):"am"===t.substr(0,2)?(this._createNewOscillator("am"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(2)):"fat"===t.substr(0,3)?(this._createNewOscillator("fat"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(3)):"pwm"===t?(this._createNewOscillator("pwm"),this._oscillator=this._oscillator):"pulse"===t?this._createNewOscillator("pulse"):(this._createNewOscillator("oscillator"),this._oscillator=this._oscillator,this._oscillator.type=t)}get partials(){return this._oscillator.partials}set partials(t){this._getOscType(this._oscillator,"pulse")||this._getOscType(this._oscillator,"pwm")||(this._oscillator.partials=t)}get partialCount(){return this._oscillator.partialCount}set partialCount(t){this._getOscType(this._oscillator,"pulse")||this._getOscType(this._oscillator,"pwm")||(this._oscillator.partialCount=t)}set(t){return Reflect.has(t,"type")&&t.type&&(this.type=t.type),super.set(t),this}_createNewOscillator(t){if(t!==this._sourceType){this._sourceType=t;const e=be[t],n=this.now();if(this._oscillator){const t=this._oscillator;t.stop(n),this.context.setTimeout(()=>t.dispose(),this.blockTime)}this._oscillator=new e({context:this.context}),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.connect(this.output),this._oscillator.onstop=()=>this.onstop(this),"started"===this.state&&this._oscillator.start(n)}}get phase(){return this._oscillator.phase}set phase(t){this._oscillator.phase=t}get sourceType(){return this._sourceType}set sourceType(t){let e="sine";"pwm"!==this._oscillator.type&&"pulse"!==this._oscillator.type&&(e=this._oscillator.type),"fm"===t?this.type="fm"+e:"am"===t?this.type="am"+e:"fat"===t?this.type="fat"+e:"oscillator"===t?this.type=e:"pulse"===t?this.type="pulse":"pwm"===t&&(this.type="pwm")}_getOscType(t,e){return t instanceof be[e]}get baseType(){return this._oscillator.baseType}set baseType(t){this._getOscType(this._oscillator,"pulse")||this._getOscType(this._oscillator,"pwm")||"pulse"===t||"pwm"===t||(this._oscillator.baseType=t)}get width(){return this._getOscType(this._oscillator,"pulse")?this._oscillator.width:void 0}get count(){return this._getOscType(this._oscillator,"fat")?this._oscillator.count:void 0}set count(t){this._getOscType(this._oscillator,"fat")&&m(t)&&(this._oscillator.count=t)}get spread(){return this._getOscType(this._oscillator,"fat")?this._oscillator.spread:void 0}set spread(t){this._getOscType(this._oscillator,"fat")&&m(t)&&(this._oscillator.spread=t)}get modulationType(){return this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am")?this._oscillator.modulationType:void 0}set modulationType(t){(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))&&b(t)&&(this._oscillator.modulationType=t)}get modulationIndex(){return this._getOscType(this._oscillator,"fm")?this._oscillator.modulationIndex:void 0}get harmonicity(){return this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am")?this._oscillator.harmonicity:void 0}get modulationFrequency(){return this._getOscType(this._oscillator,"pwm")?this._oscillator.modulationFrequency:void 0}asArray(t=1024){return S(this,void 0,void 0,(function*(){return ce(this,t)}))}dispose(){return super.dispose(),this.detune.dispose(),this.frequency.dispose(),this._oscillator.dispose(),this}}class we extends Rt{constructor(){super(Object.assign(q(we.getDefaults(),arguments,["value"]))),this.override=!1,this.name="Add",this._sum=new Mt({context:this.context}),this.input=this._sum,this.output=this._sum,this.addend=this._param,kt(this._constantSource,this._sum)}static getDefaults(){return Object.assign(Rt.getDefaults(),{value:0})}dispose(){return super.dispose(),this._sum.dispose(),this}}class Te extends le{constructor(){super(Object.assign(q(Te.getDefaults(),arguments,["min","max"]))),this.name="Scale";const t=q(Te.getDefaults(),arguments,["min","max"]);this._mult=this.input=new fe({context:this.context,value:t.max-t.min}),this._add=this.output=new we({context:this.context,value:t.min}),this._min=t.min,this._max=t.max,this.input.connect(this.output)}static getDefaults(){return Object.assign(le.getDefaults(),{max:1,min:0})}get min(){return this._min}set min(t){this._min=t,this._setRange()}get max(){return this._max}set max(t){this._max=t,this._setRange()}_setRange(){this._add.value=this._min,this._mult.value=this._max-this._min}dispose(){return super.dispose(),this._add.dispose(),this._mult.dispose(),this}}class Oe extends le{constructor(){super(Object.assign(q(Oe.getDefaults(),arguments))),this.name="Zero",this._gain=new Mt({context:this.context}),this.output=this._gain,this.input=void 0,At(this.context.getConstant(0),this._gain)}dispose(){return super.dispose(),Dt(this.context.getConstant(0),this._gain),this}}class Se extends Ct{constructor(){super(q(Se.getDefaults(),arguments,["frequency","min","max"])),this.name="LFO",this._stoppedValue=0,this._units="number",this.convert=!0,this._fromType=St.prototype._fromType,this._toType=St.prototype._toType,this._is=St.prototype._is,this._clampValue=St.prototype._clampValue;const t=q(Se.getDefaults(),arguments,["frequency","min","max"]);this._oscillator=new he({context:this.context,frequency:t.frequency,type:t.type}),this.frequency=this._oscillator.frequency,this._amplitudeGain=new Mt({context:this.context,gain:t.amplitude,units:"normalRange"}),this.amplitude=this._amplitudeGain.gain,this._stoppedSignal=new Rt({context:this.context,units:"audioRange",value:0}),this._zeros=new Oe({context:this.context}),this._a2g=new pe({context:this.context}),this._scaler=this.output=new Te({context:this.context,max:t.max,min:t.min}),this.units=t.units,this.min=t.min,this.max=t.max,this._oscillator.chain(this._a2g,this._amplitudeGain,this._scaler),this._zeros.connect(this._a2g),this._stoppedSignal.connect(this._a2g),$(this,["amplitude","frequency"]),this.phase=t.phase}static getDefaults(){return Object.assign(Ct.getDefaults(),{amplitude:1,frequency:"4n",max:1,min:0,phase:0,type:"sine",units:"number"})}start(t){return t=this.toSeconds(t),this._stoppedSignal.setValueAtTime(0,t),this._oscillator.start(t),this}stop(t){return t=this.toSeconds(t),this._stoppedSignal.setValueAtTime(this._stoppedValue,t),this._oscillator.stop(t),this}sync(){return this._oscillator.sync(),this._oscillator.syncFrequency(),this}unsync(){return this._oscillator.unsync(),this._oscillator.unsyncFrequency(),this}get min(){return this._toType(this._scaler.min)}set min(t){t=this._fromType(t),this._scaler.min=t}get max(){return this._toType(this._scaler.max)}set max(t){t=this._fromType(t),this._scaler.max=t}get type(){return this._oscillator.type}set type(t){this._oscillator.type=t,this._stoppedValue=this._oscillator.getInitialValue(),this._stoppedSignal.value=this._stoppedValue}get phase(){return this._oscillator.phase}set phase(t){this._oscillator.phase=t,this._stoppedValue=this._oscillator.getInitialValue(),this._stoppedSignal.value=this._stoppedValue}get units(){return this._units}set units(t){const e=this.min,n=this.max;this._units=t,this.min=e,this.max=n}get state(){return this._oscillator.state}connect(t,e,n){return(t instanceof St||t instanceof Rt)&&(this.convert=t.convert,this.units=t.units),qt(this,t,e,n),this}dispose(){return super.dispose(),this._oscillator.dispose(),this._stoppedSignal.dispose(),this._zeros.dispose(),this._scaler.dispose(),this._a2g.dispose(),this._amplitudeGain.dispose(),this.amplitude.dispose(),this}}function Ce(t,e=1/0){const n=new WeakMap;return function(s,i){Reflect.defineProperty(s,i,{configurable:!0,enumerable:!0,get:function(){return n.get(this)},set:function(s){a(s,t,e),n.set(this,s)}})}}function ke(t,e=1/0){const n=new WeakMap;return function(s,i){Reflect.defineProperty(s,i,{configurable:!0,enumerable:!0,get:function(){return n.get(this)},set:function(s){a(this.toSeconds(s),t,e),n.set(this,s)}})}}class Ae extends ne{constructor(){super(q(Ae.getDefaults(),arguments,["url","onload"])),this.name="Player",this._activeSources=new Set;const t=q(Ae.getDefaults(),arguments,["url","onload"]);this._buffer=new tt({onload:this._onload.bind(this,t.onload),onerror:t.onerror,reverse:t.reverse,url:t.url}),this.autostart=t.autostart,this._loop=t.loop,this._loopStart=t.loopStart,this._loopEnd=t.loopEnd,this._playbackRate=t.playbackRate,this.fadeIn=t.fadeIn,this.fadeOut=t.fadeOut}static getDefaults(){return Object.assign(ne.getDefaults(),{autostart:!1,fadeIn:0,fadeOut:0,loop:!1,loopEnd:0,loopStart:0,onload:K,onerror:K,playbackRate:1,reverse:!1})}load(t){return S(this,void 0,void 0,(function*(){return yield this._buffer.load(t),this._onload(),this}))}_onload(t=K){t(),this.autostart&&this.start()}_onSourceEnd(t){this.onstop(this),this._activeSources.delete(t),0!==this._activeSources.size||this._synced||"started"!==this._state.getValueAtTime(this.now())||this._state.setStateAtTime("stopped",this.now())}start(t,e,n){return super.start(t,e,n),this}_start(t,e,n){e=this._loop?I(e,this._loopStart):I(e,0);let s=this.toSeconds(e);this._synced&&(s*=this._playbackRate);const i=n;n=I(n,Math.max(this._buffer.duration-s,0));let o=this.toSeconds(n);o/=this._playbackRate,t=this.toSeconds(t);const r=new se({url:this._buffer,context:this.context,fadeIn:this.fadeIn,fadeOut:this.fadeOut,loop:this._loop,loopEnd:this._loopEnd,loopStart:this._loopStart,onended:this._onSourceEnd.bind(this),playbackRate:this._playbackRate}).connect(this.output);this._loop||this._synced||(this._state.cancel(t+o),this._state.setStateAtTime("stopped",t+o,{implicitEnd:!0})),this._activeSources.add(r),this._loop&&p(i)?r.start(t,s):r.start(t,s,o-this.toSeconds(this.fadeOut))}_stop(t){const e=this.toSeconds(t);this._activeSources.forEach(t=>t.stop(e))}restart(t,e,n){return super.restart(t,e,n),this}_restart(t,e,n){this._stop(t),this._start(t,e,n)}seek(t,e){const n=this.toSeconds(e);if("started"===this._state.getValueAtTime(n)){const e=this.toSeconds(t);this._stop(n),this._start(n,e)}return this}setLoopPoints(t,e){return this.loopStart=t,this.loopEnd=e,this}get loopStart(){return this._loopStart}set loopStart(t){this._loopStart=t,this.buffer.loaded&&a(this.toSeconds(t),0,this.buffer.duration),this._activeSources.forEach(e=>{e.loopStart=t})}get loopEnd(){return this._loopEnd}set loopEnd(t){this._loopEnd=t,this.buffer.loaded&&a(this.toSeconds(t),0,this.buffer.duration),this._activeSources.forEach(e=>{e.loopEnd=t})}get buffer(){return this._buffer}set buffer(t){this._buffer.set(t)}get loop(){return this._loop}set loop(t){if(this._loop!==t&&(this._loop=t,this._activeSources.forEach(e=>{e.loop=t}),t)){const t=this._state.getNextState("stopped",this.now());t&&this._state.cancel(t.time)}}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t;const e=this.now(),n=this._state.getNextState("stopped",e);n&&n.implicitEnd&&(this._state.cancel(n.time),this._activeSources.forEach(t=>t.cancelStop())),this._activeSources.forEach(n=>{n.playbackRate.setValueAtTime(t,e)})}get reverse(){return this._buffer.reverse}set reverse(t){this._buffer.reverse=t}get loaded(){return this._buffer.loaded}dispose(){return super.dispose(),this._activeSources.forEach(t=>t.dispose()),this._activeSources.clear(),this._buffer.dispose(),this}}O([ke(0)],Ae.prototype,"fadeIn",void 0),O([ke(0)],Ae.prototype,"fadeOut",void 0);class De extends Ct{constructor(){super(q(De.getDefaults(),arguments,["urls","onload"],"urls")),this.name="Players",this.input=void 0,this._players=new Map;const t=q(De.getDefaults(),arguments,["urls","onload"],"urls");this._volume=this.output=new Zt({context:this.context,volume:t.volume}),this.volume=this._volume.volume,$(this,"volume"),this._buffers=new $t({urls:t.urls,onload:t.onload,baseUrl:t.baseUrl,onerror:t.onerror}),this.mute=t.mute,this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut}static getDefaults(){return Object.assign(ne.getDefaults(),{baseUrl:"",fadeIn:0,fadeOut:0,mute:!1,onload:K,onerror:K,urls:{},volume:0})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t,this._players.forEach(e=>{e.fadeIn=t})}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t,this._players.forEach(e=>{e.fadeOut=t})}get state(){return Array.from(this._players).some(([t,e])=>"started"===e.state)?"started":"stopped"}has(t){return this._buffers.has(t)}player(t){if(r(this.has(t),`No Player with the name ${t} exists on this object`),!this._players.has(t)){const e=new Ae({context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,url:this._buffers.get(t)}).connect(this.output);this._players.set(t,e)}return this._players.get(t)}get loaded(){return this._buffers.loaded}add(t,e,n){return r(!this._buffers.has(t),"A buffer with that name already exists on this object"),this._buffers.add(t,e,n),this}stopAll(t){return this._players.forEach(e=>e.stop(t)),this}dispose(){return super.dispose(),this._volume.dispose(),this.volume.dispose(),this._players.forEach(t=>t.dispose()),this._buffers.dispose(),this}}class Me extends ne{constructor(){super(q(Me.getDefaults(),arguments,["url","onload"])),this.name="GrainPlayer",this._loopStart=0,this._loopEnd=0,this._activeSources=[];const t=q(Me.getDefaults(),arguments,["url","onload"]);this.buffer=new tt({onload:t.onload,onerror:t.onerror,reverse:t.reverse,url:t.url}),this._clock=new Nt({context:this.context,callback:this._tick.bind(this),frequency:1/t.grainSize}),this._playbackRate=t.playbackRate,this._grainSize=t.grainSize,this._overlap=t.overlap,this.detune=t.detune,this.overlap=t.overlap,this.loop=t.loop,this.playbackRate=t.playbackRate,this.grainSize=t.grainSize,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.reverse=t.reverse,this._clock.on("stop",this._onstop.bind(this))}static getDefaults(){return Object.assign(ne.getDefaults(),{onload:K,onerror:K,overlap:.1,grainSize:.2,playbackRate:1,detune:0,loop:!1,loopStart:0,loopEnd:0,reverse:!1})}_start(t,e,n){e=I(e,0),e=this.toSeconds(e),t=this.toSeconds(t);const s=1/this._clock.frequency.getValueAtTime(t);this._clock.start(t,e/s),n&&this.stop(t+this.toSeconds(n))}restart(t,e,n){return super.restart(t,e,n),this}_restart(t,e,n){this._stop(t),this._start(t,e,n)}_stop(t){this._clock.stop(t)}_onstop(t){this._activeSources.forEach(e=>{e.fadeOut=0,e.stop(t)}),this.onstop(this)}_tick(t){const e=this._clock.getTicksAtTime(t),n=e*this._grainSize;if(this.log("offset",n),!this.loop&&n>this.buffer.duration)return void this.stop(t);const s=n<this._overlap?0:this._overlap,i=new se({context:this.context,url:this.buffer,fadeIn:s,fadeOut:this._overlap,loop:this.loop,loopStart:this._loopStart,loopEnd:this._loopEnd,playbackRate:ut(this.detune/100)}).connect(this.output);i.start(t,this._grainSize*e),i.stop(t+this._grainSize/this.playbackRate),this._activeSources.push(i),i.onended=()=>{const t=this._activeSources.indexOf(i);-1!==t&&this._activeSources.splice(t,1)}}get playbackRate(){return this._playbackRate}set playbackRate(t){a(t,.001),this._playbackRate=t,this.grainSize=this._grainSize}get loopStart(){return this._loopStart}set loopStart(t){this.buffer.loaded&&a(this.toSeconds(t),0,this.buffer.duration),this._loopStart=this.toSeconds(t)}get loopEnd(){return this._loopEnd}set loopEnd(t){this.buffer.loaded&&a(this.toSeconds(t),0,this.buffer.duration),this._loopEnd=this.toSeconds(t)}get reverse(){return this.buffer.reverse}set reverse(t){this.buffer.reverse=t}get grainSize(){return this._grainSize}set grainSize(t){this._grainSize=this.toSeconds(t),this._clock.frequency.setValueAtTime(this._playbackRate/this._grainSize,this.now())}get overlap(){return this._overlap}set overlap(t){const e=this.toSeconds(t);a(e,0),this._overlap=e}get loaded(){return this.buffer.loaded}dispose(){return super.dispose(),this.buffer.dispose(),this._clock.dispose(),this._activeSources.forEach(t=>t.dispose()),this}}class je extends le{constructor(){super(...arguments),this.name="Abs",this._abs=new de({context:this.context,mapping:t=>Math.abs(t)<.001?0:Math.abs(t)}),this.input=this._abs,this.output=this._abs}dispose(){return super.dispose(),this._abs.dispose(),this}}class Ee extends le{constructor(){super(...arguments),this.name="GainToAudio",this._norm=new de({context:this.context,mapping:t=>2*Math.abs(t)-1}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class Re extends le{constructor(){super(...arguments),this.name="Negate",this._multiply=new fe({context:this.context,value:-1}),this.input=this._multiply,this.output=this._multiply}dispose(){return super.dispose(),this._multiply.dispose(),this}}class qe extends Rt{constructor(){super(Object.assign(q(qe.getDefaults(),arguments,["value"]))),this.override=!1,this.name="Subtract",this._sum=new Mt({context:this.context}),this.input=this._sum,this.output=this._sum,this._neg=new Re({context:this.context}),this.subtrahend=this._param,kt(this._constantSource,this._neg,this._sum)}static getDefaults(){return Object.assign(Rt.getDefaults(),{value:0})}dispose(){return super.dispose(),this._neg.dispose(),this._sum.dispose(),this}}class Ie extends le{constructor(){super(Object.assign(q(Ie.getDefaults(),arguments))),this.name="GreaterThanZero",this._thresh=this.output=new de({context:this.context,length:127,mapping:t=>t<=0?0:1}),this._scale=this.input=new fe({context:this.context,value:1e4}),this._scale.connect(this._thresh)}dispose(){return super.dispose(),this._scale.dispose(),this._thresh.dispose(),this}}class Fe extends Rt{constructor(){super(Object.assign(q(Fe.getDefaults(),arguments,["value"]))),this.name="GreaterThan",this.override=!1;const t=q(Fe.getDefaults(),arguments,["value"]);this._subtract=this.input=new qe({context:this.context,value:t.value}),this._gtz=this.output=new Ie({context:this.context}),this.comparator=this._param=this._subtract.subtrahend,$(this,"comparator"),this._subtract.connect(this._gtz)}static getDefaults(){return Object.assign(Rt.getDefaults(),{value:0})}dispose(){return super.dispose(),this._gtz.dispose(),this._subtract.dispose(),this.comparator.dispose(),this}}class Ve extends le{constructor(){super(Object.assign(q(Ve.getDefaults(),arguments,["value"]))),this.name="Pow";const t=q(Ve.getDefaults(),arguments,["value"]);this._exponentScaler=this.input=this.output=new de({context:this.context,mapping:this._expFunc(t.value),length:8192}),this._exponent=t.value}static getDefaults(){return Object.assign(le.getDefaults(),{value:1})}_expFunc(t){return e=>Math.pow(Math.abs(e),t)}get value(){return this._exponent}set value(t){this._exponent=t,this._exponentScaler.setMap(this._expFunc(this._exponent))}dispose(){return super.dispose(),this._exponentScaler.dispose(),this}}class Ne extends Te{constructor(){super(Object.assign(q(Ne.getDefaults(),arguments,["min","max","exponent"]))),this.name="ScaleExp";const t=q(Ne.getDefaults(),arguments,["min","max","exponent"]);this.input=this._exp=new Ve({context:this.context,value:t.exponent}),this._exp.connect(this._mult)}static getDefaults(){return Object.assign(Te.getDefaults(),{exponent:1})}get exponent(){return this._exp.value}set exponent(t){this._exp.value=t}dispose(){return super.dispose(),this._exp.dispose(),this}}class Pe extends Rt{constructor(){super(q(Rt.getDefaults(),arguments,["value","units"])),this.name="SyncedSignal",this.override=!1;const t=q(Rt.getDefaults(),arguments,["value","units"]);this._lastVal=t.value,this._synced=this.context.transport.scheduleRepeat(this._onTick.bind(this),"1i"),this._syncedCallback=this._anchorValue.bind(this),this.context.transport.on("start",this._syncedCallback),this.context.transport.on("pause",this._syncedCallback),this.context.transport.on("stop",this._syncedCallback),this._constantSource.disconnect(),this._constantSource.stop(0),this._constantSource=this.output=new Et({context:this.context,offset:t.value,units:t.units}).start(0),this.setValueAtTime(t.value,0)}_onTick(t){const e=super.getValueAtTime(this.context.transport.seconds);this._lastVal!==e&&(this._lastVal=e,this._constantSource.offset.setValueAtTime(e,t))}_anchorValue(t){const e=super.getValueAtTime(this.context.transport.seconds);this._lastVal=e,this._constantSource.offset.cancelAndHoldAtTime(t),this._constantSource.offset.setValueAtTime(e,t)}getValueAtTime(t){const e=new xt(this.context,t).toSeconds();return super.getValueAtTime(e)}setValueAtTime(t,e){const n=new xt(this.context,e).toSeconds();return super.setValueAtTime(t,n),this}linearRampToValueAtTime(t,e){const n=new xt(this.context,e).toSeconds();return super.linearRampToValueAtTime(t,n),this}exponentialRampToValueAtTime(t,e){const n=new xt(this.context,e).toSeconds();return super.exponentialRampToValueAtTime(t,n),this}setTargetAtTime(t,e,n){const s=new xt(this.context,e).toSeconds();return super.setTargetAtTime(t,s,n),this}cancelScheduledValues(t){const e=new xt(this.context,t).toSeconds();return super.cancelScheduledValues(e),this}setValueCurveAtTime(t,e,n,s){const i=new xt(this.context,e).toSeconds();return n=this.toSeconds(n),super.setValueCurveAtTime(t,i,n,s),this}cancelAndHoldAtTime(t){const e=new xt(this.context,t).toSeconds();return super.cancelAndHoldAtTime(e),this}setRampPoint(t){const e=new xt(this.context,t).toSeconds();return super.setRampPoint(e),this}exponentialRampTo(t,e,n){const s=new xt(this.context,n).toSeconds();return super.exponentialRampTo(t,e,s),this}linearRampTo(t,e,n){const s=new xt(this.context,n).toSeconds();return super.linearRampTo(t,e,s),this}targetRampTo(t,e,n){const s=new xt(this.context,n).toSeconds();return super.targetRampTo(t,e,s),this}dispose(){return super.dispose(),this.context.transport.clear(this._synced),this.context.transport.off("start",this._syncedCallback),this.context.transport.off("pause",this._syncedCallback),this.context.transport.off("stop",this._syncedCallback),this._constantSource.dispose(),this}}class Le extends Ct{constructor(){super(q(Le.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="Envelope",this._sig=new Rt({context:this.context,value:0}),this.output=this._sig,this.input=void 0;const t=q(Le.getDefaults(),arguments,["attack","decay","sustain","release"]);this.attack=t.attack,this.decay=t.decay,this.sustain=t.sustain,this.release=t.release,this.attackCurve=t.attackCurve,this.releaseCurve=t.releaseCurve,this.decayCurve=t.decayCurve}static getDefaults(){return Object.assign(Ct.getDefaults(),{attack:.01,attackCurve:"linear",decay:.1,decayCurve:"exponential",release:1,releaseCurve:"exponential",sustain:.5})}get value(){return this.getValueAtTime(this.now())}_getCurve(t,e){if(b(t))return t;{let n;for(n in ze)if(ze[n][e]===t)return n;return t}}_setCurve(t,e,n){if(b(n)&&Reflect.has(ze,n)){const s=ze[n];g(s)?"_decayCurve"!==t&&(this[t]=s[e]):this[t]=s}else{if(!y(n)||"_decayCurve"===t)throw new Error("Envelope: invalid curve: "+n);this[t]=n}}get attackCurve(){return this._getCurve(this._attackCurve,"In")}set attackCurve(t){this._setCurve("_attackCurve","In",t)}get releaseCurve(){return this._getCurve(this._releaseCurve,"Out")}set releaseCurve(t){this._setCurve("_releaseCurve","Out",t)}get decayCurve(){return this._decayCurve}set decayCurve(t){r(["linear","exponential"].some(e=>e===t),"Invalid envelope curve: "+t),this._decayCurve=t}triggerAttack(t,e=1){this.log("triggerAttack",t,e),t=this.toSeconds(t);let n=this.toSeconds(this.attack);const s=this.toSeconds(this.decay),i=this.getValueAtTime(t);if(i>0){n=(1-i)/(1/n)}if(n<this.sampleTime)this._sig.cancelScheduledValues(t),this._sig.setValueAtTime(e,t);else if("linear"===this._attackCurve)this._sig.linearRampTo(e,n,t);else if("exponential"===this._attackCurve)this._sig.targetRampTo(e,n,t);else{this._sig.cancelAndHoldAtTime(t);let s=this._attackCurve;for(let t=1;t<s.length;t++)if(s[t-1]<=i&&i<=s[t]){s=this._attackCurve.slice(t),s[0]=i;break}this._sig.setValueCurveAtTime(s,t,n,e)}if(s&&this.sustain<1){const i=e*this.sustain,o=t+n;this.log("decay",o),"linear"===this._decayCurve?this._sig.linearRampToValueAtTime(i,s+o):this._sig.exponentialApproachValueAtTime(i,o,s)}return this}triggerRelease(t){this.log("triggerRelease",t),t=this.toSeconds(t);const e=this.getValueAtTime(t);if(e>0){const n=this.toSeconds(this.release);n<this.sampleTime?this._sig.setValueAtTime(0,t):"linear"===this._releaseCurve?this._sig.linearRampTo(0,n,t):"exponential"===this._releaseCurve?this._sig.targetRampTo(0,n,t):(r(y(this._releaseCurve),"releaseCurve must be either 'linear', 'exponential' or an array"),this._sig.cancelAndHoldAtTime(t),this._sig.setValueCurveAtTime(this._releaseCurve,t,n,e))}return this}getValueAtTime(t){return this._sig.getValueAtTime(t)}triggerAttackRelease(t,e,n=1){return e=this.toSeconds(e),this.triggerAttack(e,n),this.triggerRelease(e+this.toSeconds(t)),this}cancel(t){return this._sig.cancelScheduledValues(this.toSeconds(t)),this}connect(t,e=0,n=0){return qt(this,t,e,n),this}asArray(t=1024){return S(this,void 0,void 0,(function*(){const e=t/this.context.sampleRate,n=new et(1,e,this.context.sampleRate),s=this.toSeconds(this.attack)+this.toSeconds(this.decay),i=s+this.toSeconds(this.release),o=.1*i,r=i+o,a=new this.constructor(Object.assign(this.get(),{attack:e*this.toSeconds(this.attack)/r,decay:e*this.toSeconds(this.decay)/r,release:e*this.toSeconds(this.release)/r,context:n}));return a._sig.toDestination(),a.triggerAttackRelease(e*(s+o)/r,0),(yield n.render()).getChannelData(0)}))}dispose(){return super.dispose(),this._sig.dispose(),this}}O([ke(0)],Le.prototype,"attack",void 0),O([ke(0)],Le.prototype,"decay",void 0),O([Ce(0,1)],Le.prototype,"sustain",void 0),O([ke(0)],Le.prototype,"release",void 0);const ze=(()=>{let t,e;const n=[];for(t=0;t<128;t++)n[t]=Math.sin(t/127*(Math.PI/2));const s=[];for(t=0;t<127;t++){e=t/127;const n=Math.sin(e*(2*Math.PI)*6.4-Math.PI/2)+1;s[t]=n/10+.83*e}s[127]=1;const i=[];for(t=0;t<128;t++)i[t]=Math.ceil(t/127*5)/5;const o=[];for(t=0;t<128;t++)e=t/127,o[t]=.5*(1-Math.cos(Math.PI*e));const r=[];for(t=0;t<128;t++){e=t/127;const n=4*Math.pow(e,3)+.2,s=Math.cos(n*Math.PI*2*e);r[t]=Math.abs(s*(1-e))}function a(t){const e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=1-t[n];return e}return{bounce:{In:a(r),Out:r},cosine:{In:n,Out:(c=n,c.slice(0).reverse())},exponential:"exponential",linear:"linear",ripple:{In:s,Out:a(s)},sine:{In:o,Out:a(o)},step:{In:i,Out:a(i)}};var c})();class Be extends Ct{constructor(){super(q(Be.getDefaults(),arguments)),this._scheduledEvents=[],this._synced=!1,this._original_triggerAttack=this.triggerAttack,this._original_triggerRelease=this.triggerRelease;const t=q(Be.getDefaults(),arguments);this._volume=this.output=new Zt({context:this.context,volume:t.volume}),this.volume=this._volume.volume,$(this,"volume")}static getDefaults(){return Object.assign(Ct.getDefaults(),{volume:0})}sync(){return this._synced||(this._synced=!0,this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",0)),this}_syncMethod(t,e){const n=this["_original_"+t]=this[t];this[t]=(...t)=>{const s=t[e],i=this.context.transport.schedule(s=>{t[e]=s,n.apply(this,t)},s);this._scheduledEvents.push(i)}}unsync(){return this._scheduledEvents.forEach(t=>this.context.transport.clear(t)),this._scheduledEvents=[],this._synced&&(this._synced=!1,this.triggerAttack=this._original_triggerAttack,this.triggerRelease=this._original_triggerRelease),this}triggerAttackRelease(t,e,n,s){const i=this.toSeconds(n),o=this.toSeconds(e);return this.triggerAttack(t,i,s),this.triggerRelease(i+o),this}dispose(){return super.dispose(),this._volume.dispose(),this.unsync(),this._scheduledEvents=[],this}}class We extends Be{constructor(){super(q(We.getDefaults(),arguments));const t=q(We.getDefaults(),arguments);this.portamento=t.portamento,this.onsilence=t.onsilence}static getDefaults(){return Object.assign(Be.getDefaults(),{detune:0,onsilence:K,portamento:0})}triggerAttack(t,e,n=1){this.log("triggerAttack",t,e,n);const s=this.toSeconds(e);return this._triggerEnvelopeAttack(s,n),this.setNote(t,s),this}triggerRelease(t){this.log("triggerRelease",t);const e=this.toSeconds(t);return this._triggerEnvelopeRelease(e),this}setNote(t,e){const n=this.toSeconds(e),s=t instanceof gt?t.toFrequency():t;if(this.portamento>0&&this.getLevelAtTime(n)>.05){const t=this.toSeconds(this.portamento);this.frequency.exponentialRampTo(s,t,n)}else this.frequency.setValueAtTime(s,n);return this}}O([ke(0)],We.prototype,"portamento",void 0);class Ue extends Le{constructor(){super(q(Ue.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="AmplitudeEnvelope",this._gainNode=new Mt({context:this.context,gain:0}),this.output=this._gainNode,this.input=this._gainNode,this._sig.connect(this._gainNode.gain),this.output=this._gainNode,this.input=this._gainNode}dispose(){return super.dispose(),this._gainNode.dispose(),this}}class Ge extends We{constructor(){super(q(Ge.getDefaults(),arguments)),this.name="Synth";const t=q(Ge.getDefaults(),arguments);this.oscillator=new xe(Object.assign({context:this.context,detune:t.detune,onstop:()=>this.onsilence(this)},t.oscillator)),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.envelope=new Ue(Object.assign({context:this.context},t.envelope)),this.oscillator.chain(this.envelope,this.output),$(this,["oscillator","frequency","detune","envelope"])}static getDefaults(){return Object.assign(We.getDefaults(),{envelope:Object.assign(F(Le.getDefaults(),Object.keys(Ct.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.3}),oscillator:Object.assign(F(xe.getDefaults(),[...Object.keys(ne.getDefaults()),"frequency","detune"]),{type:"triangle"})})}_triggerEnvelopeAttack(t,e){if(this.envelope.triggerAttack(t,e),this.oscillator.start(t),0===this.envelope.sustain){const e=this.toSeconds(this.envelope.attack),n=this.toSeconds(this.envelope.decay);this.oscillator.stop(t+e+n)}}_triggerEnvelopeRelease(t){this.envelope.triggerRelease(t),this.oscillator.stop(t+this.toSeconds(this.envelope.release))}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this}}class Ye extends We{constructor(){super(q(Ye.getDefaults(),arguments)),this.name="ModulationSynth";const t=q(Ye.getDefaults(),arguments);this._carrier=new Ge({context:this.context,oscillator:t.oscillator,envelope:t.envelope,onsilence:()=>this.onsilence(this),volume:-10}),this._modulator=new Ge({context:this.context,oscillator:t.modulation,envelope:t.modulationEnvelope,volume:-10}),this.oscillator=this._carrier.oscillator,this.envelope=this._carrier.envelope,this.modulation=this._modulator.oscillator,this.modulationEnvelope=this._modulator.envelope,this.frequency=new Rt({context:this.context,units:"frequency"}),this.detune=new Rt({context:this.context,value:t.detune,units:"cents"}),this.harmonicity=new fe({context:this.context,value:t.harmonicity,minValue:0}),this._modulationNode=new Mt({context:this.context,gain:0}),$(this,["frequency","harmonicity","oscillator","envelope","modulation","modulationEnvelope","detune"])}static getDefaults(){return Object.assign(We.getDefaults(),{harmonicity:3,oscillator:Object.assign(F(xe.getDefaults(),[...Object.keys(ne.getDefaults()),"frequency","detune"]),{type:"sine"}),envelope:Object.assign(F(Le.getDefaults(),Object.keys(Ct.getDefaults())),{attack:.01,decay:.01,sustain:1,release:.5}),modulation:Object.assign(F(xe.getDefaults(),[...Object.keys(ne.getDefaults()),"frequency","detune"]),{type:"square"}),modulationEnvelope:Object.assign(F(Le.getDefaults(),Object.keys(Ct.getDefaults())),{attack:.5,decay:0,sustain:1,release:.5})})}_triggerEnvelopeAttack(t,e){this._carrier._triggerEnvelopeAttack(t,e),this._modulator._triggerEnvelopeAttack(t,e)}_triggerEnvelopeRelease(t){return this._carrier._triggerEnvelopeRelease(t),this._modulator._triggerEnvelopeRelease(t),this}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this._carrier.dispose(),this._modulator.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._modulationNode.dispose(),this}}class Qe extends Ye{constructor(){super(q(Qe.getDefaults(),arguments)),this.name="AMSynth",this._modulationScale=new pe({context:this.context}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.detune.fan(this._carrier.detune,this._modulator.detune),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output)}dispose(){return super.dispose(),this._modulationScale.dispose(),this}}class Ze extends Ct{constructor(){super(q(Ze.getDefaults(),arguments,["frequency","type"])),this.name="BiquadFilter";const t=q(Ze.getDefaults(),arguments,["frequency","type"]);this._filter=this.context.createBiquadFilter(),this.input=this.output=this._filter,this.Q=new St({context:this.context,units:"number",value:t.Q,param:this._filter.Q}),this.frequency=new St({context:this.context,units:"frequency",value:t.frequency,param:this._filter.frequency}),this.detune=new St({context:this.context,units:"cents",value:t.detune,param:this._filter.detune}),this.gain=new St({context:this.context,units:"gain",value:t.gain,param:this._filter.gain}),this.type=t.type}static getDefaults(){return Object.assign(Ct.getDefaults(),{Q:1,type:"lowpass",frequency:350,detune:0,gain:0})}get type(){return this._filter.type}set type(t){r(-1!==["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(t),"Invalid filter type: "+t),this._filter.type=t}getFrequencyResponse(t=128){const e=new Float32Array(t);for(let n=0;n<t;n++){const s=19980*Math.pow(n/t,2)+20;e[n]=s}const n=new Float32Array(t),s=new Float32Array(t),i=this.context.createBiquadFilter();return i.type=this.type,i.Q.value=this.Q.value,i.frequency.value=this.frequency.value,i.gain.value=this.gain.value,i.getFrequencyResponse(e,n,s),n}dispose(){return super.dispose(),this._filter.disconnect(),this.Q.dispose(),this.frequency.dispose(),this.gain.dispose(),this.detune.dispose(),this}}class Xe extends Ct{constructor(){super(q(Xe.getDefaults(),arguments,["frequency","type","rolloff"])),this.name="Filter",this.input=new Mt({context:this.context}),this.output=new Mt({context:this.context}),this._filters=[];const t=q(Xe.getDefaults(),arguments,["frequency","type","rolloff"]);this._filters=[],this.Q=new Rt({context:this.context,units:"positive",value:t.Q}),this.frequency=new Rt({context:this.context,units:"frequency",value:t.frequency}),this.detune=new Rt({context:this.context,units:"cents",value:t.detune}),this.gain=new Rt({context:this.context,units:"decibels",value:t.gain}),this._type=t.type,this.rolloff=t.rolloff,$(this,["detune","frequency","gain","Q"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{Q:1,detune:0,frequency:350,gain:0,rolloff:-12,type:"lowpass"})}get type(){return this._type}set type(t){r(-1!==["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(t),"Invalid filter type: "+t),this._type=t,this._filters.forEach(e=>e.type=t)}get rolloff(){return this._rolloff}set rolloff(t){const e=m(t)?t:parseInt(t,10),n=[-12,-24,-48,-96];let s=n.indexOf(e);r(-1!==s,"rolloff can only be "+n.join(", ")),s+=1,this._rolloff=e,this.input.disconnect(),this._filters.forEach(t=>t.disconnect()),this._filters=new Array(s);for(let t=0;t<s;t++){const e=new Ze({context:this.context});e.type=this._type,this.frequency.connect(e.frequency),this.detune.connect(e.detune),this.Q.connect(e.Q),this.gain.connect(e.gain),this._filters[t]=e}this._internalChannels=this._filters,kt(this.input,...this._internalChannels,this.output)}getFrequencyResponse(t=128){const e=new Ze({frequency:this.frequency.value,gain:this.gain.value,Q:this.Q.value,type:this._type,detune:this.detune.value}),n=new Float32Array(t).map(()=>1);return this._filters.forEach(()=>{e.getFrequencyResponse(t).forEach((t,e)=>n[e]*=t)}),e.dispose(),n}dispose(){return super.dispose(),this._filters.forEach(t=>{t.dispose()}),J(this,["detune","frequency","gain","Q"]),this.frequency.dispose(),this.Q.dispose(),this.detune.dispose(),this.gain.dispose(),this}}class He extends Le{constructor(){super(q(He.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="FrequencyEnvelope";const t=q(He.getDefaults(),arguments,["attack","decay","sustain","release"]);this._octaves=t.octaves,this._baseFrequency=this.toFrequency(t.baseFrequency),this._exponent=this.input=new Ve({context:this.context,value:t.exponent}),this._scale=this.output=new Te({context:this.context,min:this._baseFrequency,max:this._baseFrequency*Math.pow(2,this._octaves)}),this._sig.chain(this._exponent,this._scale)}static getDefaults(){return Object.assign(Le.getDefaults(),{baseFrequency:200,exponent:1,octaves:4})}get baseFrequency(){return this._baseFrequency}set baseFrequency(t){const e=this.toFrequency(t);a(e,0),this._baseFrequency=e,this._scale.min=this._baseFrequency,this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){a(t,0),this._octaves=t,this._scale.max=this._baseFrequency*Math.pow(2,t)}get exponent(){return this._exponent.value}set exponent(t){this._exponent.value=t}dispose(){return super.dispose(),this._exponent.dispose(),this._scale.dispose(),this}}class $e extends We{constructor(){super(q($e.getDefaults(),arguments)),this.name="MonoSynth";const t=q($e.getDefaults(),arguments);this.oscillator=new xe(Object.assign(t.oscillator,{context:this.context,detune:t.detune,onstop:()=>this.onsilence(this)})),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.filter=new Xe(Object.assign(t.filter,{context:this.context})),this.filterEnvelope=new He(Object.assign(t.filterEnvelope,{context:this.context})),this.envelope=new Ue(Object.assign(t.envelope,{context:this.context})),this.oscillator.chain(this.filter,this.envelope,this.output),this.filterEnvelope.connect(this.filter.frequency),$(this,["oscillator","frequency","detune","filter","filterEnvelope","envelope"])}static getDefaults(){return Object.assign(We.getDefaults(),{envelope:Object.assign(F(Le.getDefaults(),Object.keys(Ct.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.9}),filter:Object.assign(F(Xe.getDefaults(),Object.keys(Ct.getDefaults())),{Q:1,rolloff:-12,type:"lowpass"}),filterEnvelope:Object.assign(F(He.getDefaults(),Object.keys(Ct.getDefaults())),{attack:.6,baseFrequency:200,decay:.2,exponent:2,octaves:3,release:2,sustain:.5}),oscillator:Object.assign(F(xe.getDefaults(),Object.keys(ne.getDefaults())),{type:"sawtooth"})})}_triggerEnvelopeAttack(t,e=1){if(this.envelope.triggerAttack(t,e),this.filterEnvelope.triggerAttack(t),this.oscillator.start(t),0===this.envelope.sustain){const e=this.toSeconds(this.envelope.attack),n=this.toSeconds(this.envelope.decay);this.oscillator.stop(t+e+n)}}_triggerEnvelopeRelease(t){this.envelope.triggerRelease(t),this.filterEnvelope.triggerRelease(t),this.oscillator.stop(t+this.toSeconds(this.envelope.release))}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this.filterEnvelope.dispose(),this.filter.dispose(),this}}class Je extends We{constructor(){super(q(Je.getDefaults(),arguments)),this.name="DuoSynth";const t=q(Je.getDefaults(),arguments);this.voice0=new $e(Object.assign(t.voice0,{context:this.context,onsilence:()=>this.onsilence(this)})),this.voice1=new $e(Object.assign(t.voice1,{context:this.context})),this.harmonicity=new fe({context:this.context,units:"positive",value:t.harmonicity}),this._vibrato=new Se({frequency:t.vibratoRate,context:this.context,min:-50,max:50}),this._vibrato.start(),this.vibratoRate=this._vibrato.frequency,this._vibratoGain=new Mt({context:this.context,units:"normalRange",gain:t.vibratoAmount}),this.vibratoAmount=this._vibratoGain.gain,this.frequency=new Rt({context:this.context,units:"frequency",value:440}),this.detune=new Rt({context:this.context,units:"cents",value:t.detune}),this.frequency.connect(this.voice0.frequency),this.frequency.chain(this.harmonicity,this.voice1.frequency),this._vibrato.connect(this._vibratoGain),this._vibratoGain.fan(this.voice0.detune,this.voice1.detune),this.detune.fan(this.voice0.detune,this.voice1.detune),this.voice0.connect(this.output),this.voice1.connect(this.output),$(this,["voice0","voice1","frequency","vibratoAmount","vibratoRate"])}getLevelAtTime(t){return t=this.toSeconds(t),this.voice0.envelope.getValueAtTime(t)+this.voice1.envelope.getValueAtTime(t)}static getDefaults(){return R(We.getDefaults(),{vibratoAmount:.5,vibratoRate:5,harmonicity:1.5,voice0:R(F($e.getDefaults(),Object.keys(We.getDefaults())),{filterEnvelope:{attack:.01,decay:0,sustain:1,release:.5},envelope:{attack:.01,decay:0,sustain:1,release:.5}}),voice1:R(F($e.getDefaults(),Object.keys(We.getDefaults())),{filterEnvelope:{attack:.01,decay:0,sustain:1,release:.5},envelope:{attack:.01,decay:0,sustain:1,release:.5}})})}_triggerEnvelopeAttack(t,e){this.voice0._triggerEnvelopeAttack(t,e),this.voice1._triggerEnvelopeAttack(t,e)}_triggerEnvelopeRelease(t){return this.voice0._triggerEnvelopeRelease(t),this.voice1._triggerEnvelopeRelease(t),this}dispose(){return super.dispose(),this.voice0.dispose(),this.voice1.dispose(),this.frequency.dispose(),this.detune.dispose(),this._vibrato.dispose(),this.vibratoRate.dispose(),this._vibratoGain.dispose(),this.harmonicity.dispose(),this}}class Ke extends Ye{constructor(){super(q(Ke.getDefaults(),arguments)),this.name="FMSynth";const t=q(Ke.getDefaults(),arguments);this.modulationIndex=new fe({context:this.context,value:t.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this.detune.fan(this._carrier.detune,this._modulator.detune),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output)}static getDefaults(){return Object.assign(Ye.getDefaults(),{modulationIndex:10})}dispose(){return super.dispose(),this.modulationIndex.dispose(),this}}const tn=[1,1.483,1.932,2.546,2.63,3.897];class en extends We{constructor(){super(q(en.getDefaults(),arguments)),this.name="MetalSynth",this._oscillators=[],this._freqMultipliers=[];const t=q(en.getDefaults(),arguments);this.detune=new Rt({context:this.context,units:"cents",value:t.detune}),this.frequency=new Rt({context:this.context,units:"frequency"}),this._amplitude=new Mt({context:this.context,gain:0}).connect(this.output),this._highpass=new Xe({Q:0,context:this.context,type:"highpass"}).connect(this._amplitude);for(let e=0;e<tn.length;e++){const n=new me({context:this.context,harmonicity:t.harmonicity,modulationIndex:t.modulationIndex,modulationType:"square",onstop:0===e?()=>this.onsilence(this):K,type:"square"});n.connect(this._highpass),this._oscillators[e]=n;const s=new fe({context:this.context,value:tn[e]});this._freqMultipliers[e]=s,this.frequency.chain(s,n.frequency),this.detune.connect(n.detune)}this._filterFreqScaler=new Te({context:this.context,max:7e3,min:this.toFrequency(t.resonance)}),this.envelope=new Le({attack:t.envelope.attack,attackCurve:"linear",context:this.context,decay:t.envelope.decay,release:t.envelope.release,sustain:0}),this.envelope.chain(this._filterFreqScaler,this._highpass.frequency),this.envelope.connect(this._amplitude.gain),this._octaves=t.octaves,this.octaves=t.octaves}static getDefaults(){return R(We.getDefaults(),{envelope:Object.assign(F(Le.getDefaults(),Object.keys(Ct.getDefaults())),{attack:.001,decay:1.4,release:.2}),harmonicity:5.1,modulationIndex:32,octaves:1.5,resonance:4e3})}_triggerEnvelopeAttack(t,e=1){return this.envelope.triggerAttack(t,e),this._oscillators.forEach(e=>e.start(t)),0===this.envelope.sustain&&this._oscillators.forEach(e=>{e.stop(t+this.toSeconds(this.envelope.attack)+this.toSeconds(this.envelope.decay))}),this}_triggerEnvelopeRelease(t){return this.envelope.triggerRelease(t),this._oscillators.forEach(e=>e.stop(t+this.toSeconds(this.envelope.release))),this}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}get modulationIndex(){return this._oscillators[0].modulationIndex.value}set modulationIndex(t){this._oscillators.forEach(e=>e.modulationIndex.value=t)}get harmonicity(){return this._oscillators[0].harmonicity.value}set harmonicity(t){this._oscillators.forEach(e=>e.harmonicity.value=t)}get resonance(){return this._filterFreqScaler.min}set resonance(t){this._filterFreqScaler.min=this.toFrequency(t),this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._filterFreqScaler.max=this._filterFreqScaler.min*Math.pow(2,t)}dispose(){return super.dispose(),this._oscillators.forEach(t=>t.dispose()),this._freqMultipliers.forEach(t=>t.dispose()),this.frequency.dispose(),this.detune.dispose(),this._filterFreqScaler.dispose(),this._amplitude.dispose(),this.envelope.dispose(),this._highpass.dispose(),this}}class nn extends Ge{constructor(){super(q(nn.getDefaults(),arguments)),this.name="MembraneSynth",this.portamento=0;const t=q(nn.getDefaults(),arguments);this.pitchDecay=t.pitchDecay,this.octaves=t.octaves,$(this,["oscillator","envelope"])}static getDefaults(){return R(We.getDefaults(),Ge.getDefaults(),{envelope:{attack:.001,attackCurve:"exponential",decay:.4,release:1.4,sustain:.01},octaves:10,oscillator:{type:"sine"},pitchDecay:.05})}setNote(t,e){const n=this.toSeconds(e),s=this.toFrequency(t instanceof gt?t.toFrequency():t),i=s*this.octaves;return this.oscillator.frequency.setValueAtTime(i,n),this.oscillator.frequency.exponentialRampToValueAtTime(s,n+this.toSeconds(this.pitchDecay)),this}dispose(){return super.dispose(),this}}O([Ce(0)],nn.prototype,"octaves",void 0),O([ke(0)],nn.prototype,"pitchDecay",void 0);class sn extends Be{constructor(){super(q(sn.getDefaults(),arguments)),this.name="NoiseSynth";const t=q(sn.getDefaults(),arguments);this.noise=new ie(Object.assign({context:this.context},t.noise)),this.envelope=new Ue(Object.assign({context:this.context},t.envelope)),this.noise.chain(this.envelope,this.output)}static getDefaults(){return Object.assign(Be.getDefaults(),{envelope:Object.assign(F(Le.getDefaults(),Object.keys(Ct.getDefaults())),{decay:.1,sustain:0}),noise:Object.assign(F(ie.getDefaults(),Object.keys(ne.getDefaults())),{type:"white"})})}triggerAttack(t,e=1){return t=this.toSeconds(t),this.envelope.triggerAttack(t,e),this.noise.start(t),0===this.envelope.sustain&&this.noise.stop(t+this.toSeconds(this.envelope.attack)+this.toSeconds(this.envelope.decay)),this}triggerRelease(t){return t=this.toSeconds(t),this.envelope.triggerRelease(t),this.noise.stop(t+this.toSeconds(this.envelope.release)),this}sync(){return this._syncMethod("triggerAttack",0),this._syncMethod("triggerRelease",0),this}triggerAttackRelease(t,e,n=1){return e=this.toSeconds(e),t=this.toSeconds(t),this.triggerAttack(e,n),this.triggerRelease(e+t),this}dispose(){return super.dispose(),this.noise.dispose(),this.envelope.dispose(),this}}const on=new Set;function rn(t){on.add(t)}function an(t,e){const n=`registerProcessor("${t}", ${e})`;on.add(n)}class cn extends Ct{constructor(t){super(t),this.name="ToneAudioWorklet",this.workletOptions={},this.onprocessorerror=K;const e=URL.createObjectURL(new Blob([Array.from(on).join("\n")],{type:"text/javascript"})),n=this._audioWorkletName();this._dummyGain=this.context.createGain(),this._dummyParam=this._dummyGain.gain,this.context.addAudioWorkletModule(e,n).then(()=>{this.disposed||(this._worklet=this.context.createAudioWorkletNode(n,this.workletOptions),this._worklet.onprocessorerror=this.onprocessorerror.bind(this),this.onReady(this._worklet))})}dispose(){return super.dispose(),this._dummyGain.disconnect(),this._worklet&&(this._worklet.port.postMessage("dispose"),this._worklet.disconnect()),this}}rn('\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it\'s disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === "dispose") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n');rn("\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n");rn("\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n");an("feedback-comb-filter",'\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: "delayTime",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}, {\n\t\t\t\tname: "feedback",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n');class un extends cn{constructor(){super(q(un.getDefaults(),arguments,["delayTime","resonance"])),this.name="FeedbackCombFilter";const t=q(un.getDefaults(),arguments,["delayTime","resonance"]);this.input=new Mt({context:this.context}),this.output=new Mt({context:this.context}),this.delayTime=new St({context:this.context,value:t.delayTime,units:"time",minValue:0,maxValue:1,param:this._dummyParam,swappable:!0}),this.resonance=new St({context:this.context,value:t.resonance,units:"normalRange",param:this._dummyParam,swappable:!0}),$(this,["resonance","delayTime"])}_audioWorkletName(){return"feedback-comb-filter"}static getDefaults(){return Object.assign(Ct.getDefaults(),{delayTime:.1,resonance:.5})}onReady(t){kt(this.input,t,this.output);const e=t.parameters.get("delayTime");this.delayTime.setParam(e);const n=t.parameters.get("feedback");this.resonance.setParam(n)}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this.delayTime.dispose(),this.resonance.dispose(),this}}class hn extends Ct{constructor(){super(q(hn.getDefaults(),arguments,["frequency","type"])),this.name="OnePoleFilter";const t=q(hn.getDefaults(),arguments,["frequency","type"]);this._frequency=t.frequency,this._type=t.type,this.input=new Mt({context:this.context}),this.output=new Mt({context:this.context}),this._createFilter()}static getDefaults(){return Object.assign(Ct.getDefaults(),{frequency:880,type:"lowpass"})}_createFilter(){const t=this._filter,e=this.toFrequency(this._frequency),n=1/(2*Math.PI*e);if("lowpass"===this._type){const t=1/(n*this.context.sampleRate),e=t-1;this._filter=this.context.createIIRFilter([t,0],[1,e])}else{const t=1/(n*this.context.sampleRate)-1;this._filter=this.context.createIIRFilter([1,-1],[1,t])}this.input.chain(this._filter,this.output),t&&this.context.setTimeout(()=>{this.disposed||(this.input.disconnect(t),t.disconnect())},this.blockTime)}get frequency(){return this._frequency}set frequency(t){this._frequency=t,this._createFilter()}get type(){return this._type}set type(t){this._type=t,this._createFilter()}getFrequencyResponse(t=128){const e=new Float32Array(t);for(let n=0;n<t;n++){const s=19980*Math.pow(n/t,2)+20;e[n]=s}const n=new Float32Array(t),s=new Float32Array(t);return this._filter.getFrequencyResponse(e,n,s),n}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this._filter.disconnect(),this}}class ln extends Ct{constructor(){super(q(ln.getDefaults(),arguments,["delayTime","resonance","dampening"])),this.name="LowpassCombFilter";const t=q(ln.getDefaults(),arguments,["delayTime","resonance","dampening"]);this._combFilter=this.output=new un({context:this.context,delayTime:t.delayTime,resonance:t.resonance}),this.delayTime=this._combFilter.delayTime,this.resonance=this._combFilter.resonance,this._lowpass=this.input=new hn({context:this.context,frequency:t.dampening,type:"lowpass"}),this._lowpass.connect(this._combFilter)}static getDefaults(){return Object.assign(Ct.getDefaults(),{dampening:3e3,delayTime:.1,resonance:.5})}get dampening(){return this._lowpass.frequency}set dampening(t){this._lowpass.frequency=t}dispose(){return super.dispose(),this._combFilter.dispose(),this._lowpass.dispose(),this}}class dn extends Be{constructor(){super(q(dn.getDefaults(),arguments)),this.name="PluckSynth";const t=q(dn.getDefaults(),arguments);this._noise=new ie({context:this.context,type:"pink"}),this.attackNoise=t.attackNoise,this._lfcf=new ln({context:this.context,dampening:t.dampening,resonance:t.resonance}),this.resonance=t.resonance,this.release=t.release,this._noise.connect(this._lfcf),this._lfcf.connect(this.output)}static getDefaults(){return R(Be.getDefaults(),{attackNoise:1,dampening:4e3,resonance:.7,release:1})}get dampening(){return this._lfcf.dampening}set dampening(t){this._lfcf.dampening=t}triggerAttack(t,e){const n=this.toFrequency(t);e=this.toSeconds(e);const s=1/n;return this._lfcf.delayTime.setValueAtTime(s,e),this._noise.start(e),this._noise.stop(e+s*this.attackNoise),this._lfcf.resonance.cancelScheduledValues(e),this._lfcf.resonance.setValueAtTime(this.resonance,e),this}triggerRelease(t){return this._lfcf.resonance.linearRampTo(0,this.release,t),this}dispose(){return super.dispose(),this._noise.dispose(),this._lfcf.dispose(),this}}class pn extends Be{constructor(){super(q(pn.getDefaults(),arguments,["voice","options"])),this.name="PolySynth",this._availableVoices=[],this._activeVoices=[],this._voices=[],this._gcTimeout=-1,this._averageActiveVoices=0;const t=q(pn.getDefaults(),arguments,["voice","options"]);r(!m(t.voice),"DEPRECATED: The polyphony count is no longer the first argument.");const e=t.voice.getDefaults();this.options=Object.assign(e,t.options),this.voice=t.voice,this.maxPolyphony=t.maxPolyphony,this._dummyVoice=this._getNextAvailableVoice();const n=this._voices.indexOf(this._dummyVoice);this._voices.splice(n,1),this._gcTimeout=this.context.setInterval(this._collectGarbage.bind(this),1)}static getDefaults(){return Object.assign(Be.getDefaults(),{maxPolyphony:32,options:{},voice:Ge})}get activeVoices(){return this._activeVoices.length}_makeVoiceAvailable(t){this._availableVoices.push(t);const e=this._activeVoices.findIndex(e=>e.voice===t);this._activeVoices.splice(e,1)}_getNextAvailableVoice(){if(this._availableVoices.length)return this._availableVoices.shift();if(this._voices.length<this.maxPolyphony){const t=new this.voice(Object.assign(this.options,{context:this.context,onsilence:this._makeVoiceAvailable.bind(this)}));return t.connect(this.output),this._voices.push(t),t}d("Max polyphony exceeded. Note dropped.")}_collectGarbage(){if(this._averageActiveVoices=Math.max(.95*this._averageActiveVoices,this.activeVoices),this._availableVoices.length&&this._voices.length>Math.ceil(this._averageActiveVoices+1)){const t=this._availableVoices.shift(),e=this._voices.indexOf(t);this._voices.splice(e,1),this.context.isOffline||t.dispose()}}_triggerAttack(t,e,n){t.forEach(t=>{const s=new Jt(this.context,t).toMidi(),i=this._getNextAvailableVoice();i&&(i.triggerAttack(t,e,n),this._activeVoices.push({midi:s,voice:i,released:!1}),this.log("triggerAttack",t,e))})}_triggerRelease(t,e){t.forEach(t=>{const n=new Jt(this.context,t).toMidi(),s=this._activeVoices.find(({midi:t,released:e})=>t===n&&!e);s&&(s.voice.triggerRelease(e),s.released=!0,this.log("triggerRelease",t,e))})}_scheduleEvent(t,e,n,s){r(!this.disposed,"Synth was already disposed"),n<=this.now()?"attack"===t?this._triggerAttack(e,n,s):this._triggerRelease(e,n):this.context.setTimeout(()=>{this._scheduleEvent(t,e,n,s)},n-this.now())}triggerAttack(t,e,n){Array.isArray(t)||(t=[t]);const s=this.toSeconds(e);return this._scheduleEvent("attack",t,s,n),this}triggerRelease(t,e){Array.isArray(t)||(t=[t]);const n=this.toSeconds(e);return this._scheduleEvent("release",t,n),this}triggerAttackRelease(t,e,n,s){const i=this.toSeconds(n);if(this.triggerAttack(t,i,s),y(e)){r(y(t),"If the duration is an array, the notes must also be an array"),t=t;for(let n=0;n<t.length;n++){const s=e[Math.min(n,e.length-1)],o=this.toSeconds(s);r(o>0,"The duration must be greater than 0"),this.triggerRelease(t[n],i+o)}}else{const n=this.toSeconds(e);r(n>0,"The duration must be greater than 0"),this.triggerRelease(t,i+n)}return this}sync(){return this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1),this}set(t){const e=F(t,["onsilence","context"]);return this.options=R(this.options,e),this._voices.forEach(t=>t.set(e)),this._dummyVoice.set(e),this}get(){return this._dummyVoice.get()}releaseAll(t){const e=this.toSeconds(t);return this._activeVoices.forEach(({voice:t})=>{t.triggerRelease(e)}),this}dispose(){return super.dispose(),this._dummyVoice.dispose(),this._voices.forEach(t=>t.dispose()),this._activeVoices=[],this._availableVoices=[],this.context.clearInterval(this._gcTimeout),this}}class fn extends Be{constructor(){super(q(fn.getDefaults(),arguments,["urls","onload","baseUrl"],"urls")),this.name="Sampler",this._activeSources=new Map;const t=q(fn.getDefaults(),arguments,["urls","onload","baseUrl"],"urls"),e={};Object.keys(t.urls).forEach(n=>{const s=parseInt(n,10);if(r(x(n)||m(s)&&isFinite(s),"url key is neither a note or midi pitch: "+n),x(n)){const s=new gt(this.context,n).toMidi();e[s]=t.urls[n]}else m(s)&&isFinite(s)&&(e[s]=t.urls[s])}),this._buffers=new $t({urls:e,onload:t.onload,baseUrl:t.baseUrl,onerror:t.onerror}),this.attack=t.attack,this.release=t.release,this.curve=t.curve,this._buffers.loaded&&Promise.resolve().then(t.onload)}static getDefaults(){return Object.assign(Be.getDefaults(),{attack:0,baseUrl:"",curve:"exponential",onload:K,onerror:K,release:.1,urls:{}})}_findClosest(t){let e=0;for(;e<96;){if(this._buffers.has(t+e))return-e;if(this._buffers.has(t-e))return e;e++}throw new Error("No available buffers for note: "+t)}triggerAttack(t,e,n=1){return this.log("triggerAttack",t,e,n),Array.isArray(t)||(t=[t]),t.forEach(t=>{const s=dt(new gt(this.context,t).toFrequency()),i=Math.round(s),o=s-i,r=this._findClosest(i),a=i-r,c=this._buffers.get(a),u=ut(r+o),h=new se({url:c,context:this.context,curve:this.curve,fadeIn:this.attack,fadeOut:this.release,playbackRate:u}).connect(this.output);h.start(e,0,c.duration/u,n),y(this._activeSources.get(i))||this._activeSources.set(i,[]),this._activeSources.get(i).push(h),h.onended=()=>{if(this._activeSources&&this._activeSources.has(i)){const t=this._activeSources.get(i),e=t.indexOf(h);-1!==e&&t.splice(e,1)}}}),this}triggerRelease(t,e){return this.log("triggerRelease",t,e),Array.isArray(t)||(t=[t]),t.forEach(t=>{const n=new gt(this.context,t).toMidi();if(this._activeSources.has(n)&&this._activeSources.get(n).length){const t=this._activeSources.get(n);e=this.toSeconds(e),t.forEach(t=>{t.stop(e)}),this._activeSources.set(n,[])}}),this}releaseAll(t){const e=this.toSeconds(t);return this._activeSources.forEach(t=>{for(;t.length;){t.shift().stop(e)}}),this}sync(){return this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1),this}triggerAttackRelease(t,e,n,s=1){const i=this.toSeconds(n);return this.triggerAttack(t,i,s),y(e)?(r(y(t),"notes must be an array when duration is array"),t.forEach((t,n)=>{const s=e[Math.min(n,e.length-1)];this.triggerRelease(t,i+this.toSeconds(s))})):this.triggerRelease(t,i+this.toSeconds(e)),this}add(t,e,n){if(r(x(t)||isFinite(t),"note must be a pitch or midi: "+t),x(t)){const s=new gt(this.context,t).toMidi();this._buffers.add(s,e,n)}else this._buffers.add(t,e,n);return this}get loaded(){return this._buffers.loaded}dispose(){return super.dispose(),this._buffers.dispose(),this._activeSources.forEach(t=>{t.forEach(t=>t.dispose())}),this._activeSources.clear(),this}}O([ke(0)],fn.prototype,"attack",void 0),O([ke(0)],fn.prototype,"release",void 0);class _n extends Tt{constructor(){super(q(_n.getDefaults(),arguments,["callback","value"])),this.name="ToneEvent",this._state=new Ot("stopped"),this._startOffset=0;const t=q(_n.getDefaults(),arguments,["callback","value"]);this._loop=t.loop,this.callback=t.callback,this.value=t.value,this._loopStart=this.toTicks(t.loopStart),this._loopEnd=this.toTicks(t.loopEnd),this._playbackRate=t.playbackRate,this._probability=t.probability,this._humanize=t.humanize,this.mute=t.mute,this._playbackRate=t.playbackRate,this._state.increasing=!0,this._rescheduleEvents()}static getDefaults(){return Object.assign(Tt.getDefaults(),{callback:K,humanize:!1,loop:!1,loopEnd:"1m",loopStart:0,mute:!1,playbackRate:1,probability:1,value:null})}_rescheduleEvents(t=-1){this._state.forEachFrom(t,t=>{let e;if("started"===t.state){-1!==t.id&&this.context.transport.clear(t.id);const n=t.time+Math.round(this.startOffset/this._playbackRate);if(!0===this._loop||m(this._loop)&&this._loop>1){e=1/0,m(this._loop)&&(e=this._loop*this._getLoopDuration());const s=this._state.getAfter(n);null!==s&&(e=Math.min(e,s.time-n)),e!==1/0&&(this._state.setStateAtTime("stopped",n+e+1,{id:-1}),e=new Lt(this.context,e));const i=new Lt(this.context,this._getLoopDuration());t.id=this.context.transport.scheduleRepeat(this._tick.bind(this),i,new Lt(this.context,n),e)}else t.id=this.context.transport.schedule(this._tick.bind(this),new Lt(this.context,n))}})}get state(){return this._state.getValueAtTime(this.context.transport.ticks)}get startOffset(){return this._startOffset}set startOffset(t){this._startOffset=t}get probability(){return this._probability}set probability(t){this._probability=t}get humanize(){return this._humanize}set humanize(t){this._humanize=t}start(t){const e=this.toTicks(t);return"stopped"===this._state.getValueAtTime(e)&&(this._state.add({id:-1,state:"started",time:e}),this._rescheduleEvents(e)),this}stop(t){this.cancel(t);const e=this.toTicks(t);if("started"===this._state.getValueAtTime(e)){this._state.setStateAtTime("stopped",e,{id:-1});const t=this._state.getBefore(e);let n=e;null!==t&&(n=t.time),this._rescheduleEvents(n)}return this}cancel(t){t=I(t,-1/0);const e=this.toTicks(t);return this._state.forEachFrom(e,t=>{this.context.transport.clear(t.id)}),this._state.cancel(e),this}_tick(t){const e=this.context.transport.getTicksAtTime(t);if(!this.mute&&"started"===this._state.getValueAtTime(e)){if(this.probability<1&&Math.random()>this.probability)return;if(this.humanize){let e=.02;v(this.humanize)||(e=this.toSeconds(this.humanize)),t+=(2*Math.random()-1)*e}this.callback(t,this.value)}}_getLoopDuration(){return Math.round((this._loopEnd-this._loopStart)/this._playbackRate)}get loop(){return this._loop}set loop(t){this._loop=t,this._rescheduleEvents()}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this._rescheduleEvents()}get loopEnd(){return new Lt(this.context,this._loopEnd).toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t),this._loop&&this._rescheduleEvents()}get loopStart(){return new Lt(this.context,this._loopStart).toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t),this._loop&&this._rescheduleEvents()}get progress(){if(this._loop){const t=this.context.transport.ticks,e=this._state.get(t);if(null!==e&&"started"===e.state){const n=this._getLoopDuration();return(t-e.time)%n/n}return 0}return 0}dispose(){return super.dispose(),this.cancel(),this._state.dispose(),this}}class mn extends Tt{constructor(){super(q(mn.getDefaults(),arguments,["callback","interval"])),this.name="Loop";const t=q(mn.getDefaults(),arguments,["callback","interval"]);this._event=new _n({context:this.context,callback:this._tick.bind(this),loop:!0,loopEnd:t.interval,playbackRate:t.playbackRate,probability:t.probability}),this.callback=t.callback,this.iterations=t.iterations}static getDefaults(){return Object.assign(Tt.getDefaults(),{interval:"4n",callback:K,playbackRate:1,iterations:1/0,probability:1,mute:!1,humanize:!1})}start(t){return this._event.start(t),this}stop(t){return this._event.stop(t),this}cancel(t){return this._event.cancel(t),this}_tick(t){this.callback(t)}get state(){return this._event.state}get progress(){return this._event.progress}get interval(){return this._event.loopEnd}set interval(t){this._event.loopEnd=t}get playbackRate(){return this._event.playbackRate}set playbackRate(t){this._event.playbackRate=t}get humanize(){return this._event.humanize}set humanize(t){this._event.humanize=t}get probability(){return this._event.probability}set probability(t){this._event.probability=t}get mute(){return this._event.mute}set mute(t){this._event.mute=t}get iterations(){return!0===this._event.loop?1/0:this._event.loop}set iterations(t){this._event.loop=t===1/0||t}dispose(){return super.dispose(),this._event.dispose(),this}}class gn extends _n{constructor(){super(q(gn.getDefaults(),arguments,["callback","events"])),this.name="Part",this._state=new Ot("stopped"),this._events=new Set;const t=q(gn.getDefaults(),arguments,["callback","events"]);this._state.increasing=!0,t.events.forEach(t=>{y(t)?this.add(t[0],t[1]):this.add(t)})}static getDefaults(){return Object.assign(_n.getDefaults(),{events:[]})}start(t,e){const n=this.toTicks(t);if("started"!==this._state.getValueAtTime(n)){e=I(e,this._loop?this._loopStart:0),e=this._loop?I(e,this._loopStart):I(e,0);const t=this.toTicks(e);this._state.add({id:-1,offset:t,state:"started",time:n}),this._forEach(e=>{this._startNote(e,n,t)})}return this}_startNote(t,e,n){e-=n,this._loop?t.startOffset>=this._loopStart&&t.startOffset<this._loopEnd?(t.startOffset<n&&(e+=this._getLoopDuration()),t.start(new Lt(this.context,e))):t.startOffset<this._loopStart&&t.startOffset>=n&&(t.loop=!1,t.start(new Lt(this.context,e))):t.startOffset>=n&&t.start(new Lt(this.context,e))}get startOffset(){return this._startOffset}set startOffset(t){this._startOffset=t,this._forEach(t=>{t.startOffset+=this._startOffset})}stop(t){const e=this.toTicks(t);return this._state.cancel(e),this._state.setStateAtTime("stopped",e),this._forEach(e=>{e.stop(t)}),this}at(t,e){const n=new xt(this.context,t).toTicks(),s=new Lt(this.context,1).toSeconds(),i=this._events.values();let o=i.next();for(;!o.done;){const t=o.value;if(Math.abs(n-t.startOffset)<s)return f(e)&&(t.value=e),t;o=i.next()}return f(e)?(this.add(t,e),this.at(t)):null}add(t,e){t instanceof Object&&Reflect.has(t,"time")&&(t=(e=t).time);const n=this.toTicks(t);let s;return e instanceof _n?(s=e,s.callback=this._tick.bind(this)):s=new _n({callback:this._tick.bind(this),context:this.context,value:e}),s.startOffset=n,s.set({humanize:this.humanize,loop:this.loop,loopEnd:this.loopEnd,loopStart:this.loopStart,playbackRate:this.playbackRate,probability:this.probability}),this._events.add(s),this._restartEvent(s),this}_restartEvent(t){this._state.forEach(e=>{"started"===e.state?this._startNote(t,e.time,e.offset):t.stop(new Lt(this.context,e.time))})}remove(t,e){return g(t)&&t.hasOwnProperty("time")&&(t=(e=t).time),t=this.toTicks(t),this._events.forEach(n=>{n.startOffset===t&&(p(e)||f(e)&&n.value===e)&&(this._events.delete(n),n.dispose())}),this}clear(){return this._forEach(t=>t.dispose()),this._events.clear(),this}cancel(t){return this._forEach(e=>e.cancel(t)),this._state.cancel(this.toTicks(t)),this}_forEach(t){return this._events&&this._events.forEach(e=>{e instanceof gn?e._forEach(t):t(e)}),this}_setAll(t,e){this._forEach(n=>{n[t]=e})}_tick(t,e){this.mute||this.callback(t,e)}_testLoopBoundries(t){this._loop&&(t.startOffset<this._loopStart||t.startOffset>=this._loopEnd)?t.cancel(0):"stopped"===t.state&&this._restartEvent(t)}get probability(){return this._probability}set probability(t){this._probability=t,this._setAll("probability",t)}get humanize(){return this._humanize}set humanize(t){this._humanize=t,this._setAll("humanize",t)}get loop(){return this._loop}set loop(t){this._loop=t,this._forEach(e=>{e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.loop=t,this._testLoopBoundries(e)})}get loopEnd(){return new Lt(this.context,this._loopEnd).toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t),this._loop&&this._forEach(e=>{e.loopEnd=t,this._testLoopBoundries(e)})}get loopStart(){return new Lt(this.context,this._loopStart).toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t),this._loop&&this._forEach(t=>{t.loopStart=this.loopStart,this._testLoopBoundries(t)})}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this._setAll("playbackRate",t)}get length(){return this._events.size}dispose(){return super.dispose(),this.clear(),this}}function*vn(t){let e=0;for(;e<t.length;)e=xn(e,t),yield t[e],e++}function*yn(t){let e=t.length-1;for(;e>=0;)e=xn(e,t),yield t[e],e--}function*bn(t,e){for(;;)yield*e(t)}function xn(t,e){return B(t,0,e.length-1)}function*wn(t,e){let n=e?0:t.length-1;for(;;)n=xn(n,t),yield t[n],e?(n++,n>=t.length-1&&(e=!1)):(n--,n<=0&&(e=!0))}function*Tn(t){let e=0,n=0;for(;e<t.length;)e=xn(e,t),yield t[e],n++,e+=n%2?2:-1}function*On(t){let e=t.length-1,n=0;for(;e>=0;)e=xn(e,t),yield t[e],n++,e+=n%2?-2:1}function*Sn(t){const e=[];for(let n=0;n<t.length;n++)e.push(n);for(;e.length>0;){const n=xn(e.splice(Math.floor(e.length*Math.random()),1)[0],t);yield t[n]}}function*Cn(t,e="up",n=0){switch(r(t.length>0,"The array must have more than one value in it"),e){case"up":yield*bn(t,vn);case"down":yield*bn(t,yn);case"upDown":yield*wn(t,!0);case"downUp":yield*wn(t,!1);case"alternateUp":yield*bn(t,Tn);case"alternateDown":yield*bn(t,On);case"random":yield*function*(t){for(;;){const e=Math.floor(Math.random()*t.length);yield t[e]}}(t);case"randomOnce":yield*bn(t,Sn);case"randomWalk":yield*function*(t){let e=Math.floor(Math.random()*t.length);for(;;)0===e?e++:e===t.length-1||Math.random()<.5?e--:e++,yield t[e]}(t)}}class kn extends mn{constructor(){super(q(kn.getDefaults(),arguments,["callback","values","pattern"])),this.name="Pattern";const t=q(kn.getDefaults(),arguments,["callback","values","pattern"]);this.callback=t.callback,this._values=t.values,this._pattern=Cn(t.values,t.pattern),this._type=t.pattern}static getDefaults(){return Object.assign(mn.getDefaults(),{pattern:"up",values:[],callback:K})}_tick(t){const e=this._pattern.next();this._value=e.value,this.callback(t,this._value)}get values(){return this._values}set values(t){this._values=t,this.pattern=this._type}get value(){return this._value}get pattern(){return this._type}set pattern(t){this._type=t,this._pattern=Cn(this._values,this._type)}}class An extends _n{constructor(){super(q(An.getDefaults(),arguments,["callback","events","subdivision"])),this.name="Sequence",this._part=new gn({callback:this._seqCallback.bind(this),context:this.context}),this._events=[],this._eventsArray=[];const t=q(An.getDefaults(),arguments,["callback","events","subdivision"]);this._subdivision=this.toTicks(t.subdivision),this.events=t.events,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.playbackRate=t.playbackRate,this.probability=t.probability,this.humanize=t.humanize,this.mute=t.mute,this.playbackRate=t.playbackRate}static getDefaults(){return Object.assign(F(_n.getDefaults(),["value"]),{events:[],loop:!0,loopEnd:0,loopStart:0,subdivision:"8n"})}_seqCallback(t,e){null!==e&&this.callback(t,e)}get events(){return this._events}set events(t){this.clear(),this._eventsArray=t,this._events=this._createSequence(this._eventsArray),this._eventsUpdated()}start(t,e){return this._part.start(t,e?this._indexTime(e):e),this}stop(t){return this._part.stop(t),this}get subdivision(){return new Lt(this.context,this._subdivision).toSeconds()}_createSequence(t){return new Proxy(t,{get:(t,e)=>t[e],set:(t,e,n)=>(b(e)&&isFinite(parseInt(e,10))&&y(n)?t[e]=this._createSequence(n):t[e]=n,this._eventsUpdated(),!0)})}_eventsUpdated(){this._part.clear(),this._rescheduleSequence(this._eventsArray,this._subdivision,this.startOffset),this.loopEnd=this.loopEnd}_rescheduleSequence(t,e,n){t.forEach((t,s)=>{const i=s*e+n;if(y(t))this._rescheduleSequence(t,e/t.length,i);else{const e=new Lt(this.context,i,"i").toSeconds();this._part.add(e,t)}})}_indexTime(t){return new Lt(this.context,t*this._subdivision+this.startOffset).toSeconds()}clear(){return this._part.clear(),this}dispose(){return super.dispose(),this._part.dispose(),this}get loop(){return this._part.loop}set loop(t){this._part.loop=t}get loopStart(){return this._loopStart}set loopStart(t){this._loopStart=t,this._part.loopStart=this._indexTime(t)}get loopEnd(){return this._loopEnd}set loopEnd(t){this._loopEnd=t,this._part.loopEnd=0===t?this._indexTime(this._eventsArray.length):this._indexTime(t)}get startOffset(){return this._part.startOffset}set startOffset(t){this._part.startOffset=t}get playbackRate(){return this._part.playbackRate}set playbackRate(t){this._part.playbackRate=t}get probability(){return this._part.probability}set probability(t){this._part.probability=t}get progress(){return this._part.progress}get humanize(){return this._part.humanize}set humanize(t){this._part.humanize=t}get length(){return this._part.length}}class Dn extends Ct{constructor(){super(Object.assign(q(Dn.getDefaults(),arguments,["fade"]))),this.name="CrossFade",this._panner=this.context.createStereoPanner(),this._split=this.context.createChannelSplitter(2),this._g2a=new Ee({context:this.context}),this.a=new Mt({context:this.context,gain:0}),this.b=new Mt({context:this.context,gain:0}),this.output=new Mt({context:this.context}),this._internalChannels=[this.a,this.b];const t=q(Dn.getDefaults(),arguments,["fade"]);this.fade=new Rt({context:this.context,units:"normalRange",value:t.fade}),$(this,"fade"),this.context.getConstant(1).connect(this._panner),this._panner.connect(this._split),this._panner.channelCount=1,this._panner.channelCountMode="explicit",At(this._split,this.a.gain,0),At(this._split,this.b.gain,1),this.fade.chain(this._g2a,this._panner.pan),this.a.connect(this.output),this.b.connect(this.output)}static getDefaults(){return Object.assign(Ct.getDefaults(),{fade:.5})}dispose(){return super.dispose(),this.a.dispose(),this.b.dispose(),this.output.dispose(),this.fade.dispose(),this._g2a.dispose(),this._panner.disconnect(),this._split.disconnect(),this}}class Mn extends Ct{constructor(t){super(t),this.name="Effect",this._dryWet=new Dn({context:this.context}),this.wet=this._dryWet.fade,this.effectSend=new Mt({context:this.context}),this.effectReturn=new Mt({context:this.context}),this.input=new Mt({context:this.context}),this.output=this._dryWet,this.input.fan(this._dryWet.a,this.effectSend),this.effectReturn.connect(this._dryWet.b),this.wet.setValueAtTime(t.wet,0),this._internalChannels=[this.effectReturn,this.effectSend],$(this,"wet")}static getDefaults(){return Object.assign(Ct.getDefaults(),{wet:1})}connectEffect(t){return this._internalChannels.push(t),this.effectSend.chain(t,this.effectReturn),this}dispose(){return super.dispose(),this._dryWet.dispose(),this.effectSend.dispose(),this.effectReturn.dispose(),this.wet.dispose(),this}}class jn extends Mn{constructor(t){super(t),this.name="LFOEffect",this._lfo=new Se({context:this.context,frequency:t.frequency,amplitude:t.depth}),this.depth=this._lfo.amplitude,this.frequency=this._lfo.frequency,this.type=t.type,$(this,["frequency","depth"])}static getDefaults(){return Object.assign(Mn.getDefaults(),{frequency:1,type:"sine",depth:1})}start(t){return this._lfo.start(t),this}stop(t){return this._lfo.stop(t),this}sync(){return this._lfo.sync(),this}unsync(){return this._lfo.unsync(),this}get type(){return this._lfo.type}set type(t){this._lfo.type=t}dispose(){return super.dispose(),this._lfo.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class En extends jn{constructor(){super(q(En.getDefaults(),arguments,["frequency","baseFrequency","octaves"])),this.name="AutoFilter";const t=q(En.getDefaults(),arguments,["frequency","baseFrequency","octaves"]);this.filter=new Xe(Object.assign(t.filter,{context:this.context})),this.connectEffect(this.filter),this._lfo.connect(this.filter.frequency),this.octaves=t.octaves,this.baseFrequency=t.baseFrequency}static getDefaults(){return Object.assign(jn.getDefaults(),{baseFrequency:200,octaves:2.6,filter:{type:"lowpass",rolloff:-12,Q:1}})}get baseFrequency(){return this._lfo.min}set baseFrequency(t){this._lfo.min=this.toFrequency(t),this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._lfo.max=this._lfo.min*Math.pow(2,t)}dispose(){return super.dispose(),this.filter.dispose(),this}}class Rn extends Ct{constructor(){super(Object.assign(q(Rn.getDefaults(),arguments,["pan"]))),this.name="Panner",this._panner=this.context.createStereoPanner(),this.input=this._panner,this.output=this._panner;const t=q(Rn.getDefaults(),arguments,["pan"]);this.pan=new St({context:this.context,param:this._panner.pan,value:t.pan,minValue:-1,maxValue:1}),this._panner.channelCount=t.channelCount,this._panner.channelCountMode="explicit",$(this,"pan")}static getDefaults(){return Object.assign(Ct.getDefaults(),{pan:0,channelCount:1})}dispose(){return super.dispose(),this._panner.disconnect(),this.pan.dispose(),this}}class qn extends jn{constructor(){super(q(qn.getDefaults(),arguments,["frequency"])),this.name="AutoPanner";const t=q(qn.getDefaults(),arguments,["frequency"]);this._panner=new Rn({context:this.context,channelCount:t.channelCount}),this.connectEffect(this._panner),this._lfo.connect(this._panner.pan),this._lfo.min=-1,this._lfo.max=1}static getDefaults(){return Object.assign(jn.getDefaults(),{channelCount:1})}dispose(){return super.dispose(),this._panner.dispose(),this}}class In extends Ct{constructor(){super(q(In.getDefaults(),arguments,["smoothing"])),this.name="Follower";const t=q(In.getDefaults(),arguments,["smoothing"]);this._abs=this.input=new je({context:this.context}),this._lowpass=this.output=new hn({context:this.context,frequency:1/this.toSeconds(t.smoothing),type:"lowpass"}),this._abs.connect(this._lowpass),this._smoothing=t.smoothing}static getDefaults(){return Object.assign(Ct.getDefaults(),{smoothing:.05})}get smoothing(){return this._smoothing}set smoothing(t){this._smoothing=t,this._lowpass.frequency=1/this.toSeconds(this.smoothing)}dispose(){return super.dispose(),this._abs.dispose(),this._lowpass.dispose(),this}}class Fn extends Mn{constructor(){super(q(Fn.getDefaults(),arguments,["baseFrequency","octaves","sensitivity"])),this.name="AutoWah";const t=q(Fn.getDefaults(),arguments,["baseFrequency","octaves","sensitivity"]);this._follower=new In({context:this.context,smoothing:t.follower}),this._sweepRange=new Ne({context:this.context,min:0,max:1,exponent:.5}),this._baseFrequency=this.toFrequency(t.baseFrequency),this._octaves=t.octaves,this._inputBoost=new Mt({context:this.context}),this._bandpass=new Xe({context:this.context,rolloff:-48,frequency:0,Q:t.Q}),this._peaking=new Xe({context:this.context,type:"peaking"}),this._peaking.gain.value=t.gain,this.gain=this._peaking.gain,this.Q=this._bandpass.Q,this.effectSend.chain(this._inputBoost,this._follower,this._sweepRange),this._sweepRange.connect(this._bandpass.frequency),this._sweepRange.connect(this._peaking.frequency),this.effectSend.chain(this._bandpass,this._peaking,this.effectReturn),this._setSweepRange(),this.sensitivity=t.sensitivity,$(this,["gain","Q"])}static getDefaults(){return Object.assign(Mn.getDefaults(),{baseFrequency:100,octaves:6,sensitivity:0,Q:2,gain:2,follower:.2})}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._setSweepRange()}get follower(){return this._follower.smoothing}set follower(t){this._follower.smoothing=t}get baseFrequency(){return this._baseFrequency}set baseFrequency(t){this._baseFrequency=this.toFrequency(t),this._setSweepRange()}get sensitivity(){return ct(1/this._inputBoost.gain.value)}set sensitivity(t){this._inputBoost.gain.value=1/at(t)}_setSweepRange(){this._sweepRange.min=this._baseFrequency,this._sweepRange.max=Math.min(this._baseFrequency*Math.pow(2,this._octaves),this.context.sampleRate/2)}dispose(){return super.dispose(),this._follower.dispose(),this._sweepRange.dispose(),this._bandpass.dispose(),this._peaking.dispose(),this._inputBoost.dispose(),this}}an("bit-crusher","\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n");class Vn extends Mn{constructor(){super(q(Vn.getDefaults(),arguments,["bits"])),this.name="BitCrusher";const t=q(Vn.getDefaults(),arguments,["bits"]);this._bitCrusherWorklet=new Nn({context:this.context,bits:t.bits}),this.connectEffect(this._bitCrusherWorklet),this.bits=this._bitCrusherWorklet.bits}static getDefaults(){return Object.assign(Mn.getDefaults(),{bits:4})}dispose(){return super.dispose(),this._bitCrusherWorklet.dispose(),this}}class Nn extends cn{constructor(){super(q(Nn.getDefaults(),arguments)),this.name="BitCrusherWorklet";const t=q(Nn.getDefaults(),arguments);this.input=new Mt({context:this.context}),this.output=new Mt({context:this.context}),this.bits=new St({context:this.context,value:t.bits,units:"positive",minValue:1,maxValue:16,param:this._dummyParam,swappable:!0})}static getDefaults(){return Object.assign(cn.getDefaults(),{bits:12})}_audioWorkletName(){return"bit-crusher"}onReady(t){kt(this.input,t,this.output);const e=t.parameters.get("bits");this.bits.setParam(e)}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this.bits.dispose(),this}}class Pn extends Mn{constructor(){super(q(Pn.getDefaults(),arguments,["order"])),this.name="Chebyshev";const t=q(Pn.getDefaults(),arguments,["order"]);this._shaper=new de({context:this.context,length:4096}),this._order=t.order,this.connectEffect(this._shaper),this.order=t.order,this.oversample=t.oversample}static getDefaults(){return Object.assign(Mn.getDefaults(),{order:1,oversample:"none"})}_getCoefficient(t,e,n){return n.has(e)||(0===e?n.set(e,0):1===e?n.set(e,t):n.set(e,2*t*this._getCoefficient(t,e-1,n)-this._getCoefficient(t,e-2,n))),n.get(e)}get order(){return this._order}set order(t){this._order=t,this._shaper.setMap(e=>this._getCoefficient(e,t,new Map))}get oversample(){return this._shaper.oversample}set oversample(t){this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.dispose(),this}}class Ln extends Ct{constructor(){super(q(Ln.getDefaults(),arguments,["channels"])),this.name="Split";const t=q(Ln.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(t.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(Ct.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class zn extends Ct{constructor(){super(q(zn.getDefaults(),arguments,["channels"])),this.name="Merge";const t=q(zn.getDefaults(),arguments,["channels"]);this._merger=this.output=this.input=this.context.createChannelMerger(t.channels)}static getDefaults(){return Object.assign(Ct.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._merger.disconnect(),this}}class Bn extends Ct{constructor(t){super(t),this.name="StereoEffect",this.input=new Mt({context:this.context}),this.input.channelCount=2,this.input.channelCountMode="explicit",this._dryWet=this.output=new Dn({context:this.context,fade:t.wet}),this.wet=this._dryWet.fade,this._split=new Ln({context:this.context,channels:2}),this._merge=new zn({context:this.context,channels:2}),this.input.connect(this._split),this.input.connect(this._dryWet.a),this._merge.connect(this._dryWet.b),$(this,["wet"])}connectEffectLeft(...t){this._split.connect(t[0],0,0),kt(...t),At(t[t.length-1],this._merge,0,0)}connectEffectRight(...t){this._split.connect(t[0],1,0),kt(...t),At(t[t.length-1],this._merge,0,1)}static getDefaults(){return Object.assign(Ct.getDefaults(),{wet:1})}dispose(){return super.dispose(),this._dryWet.dispose(),this._split.dispose(),this._merge.dispose(),this}}class Wn extends Bn{constructor(t){super(t),this.feedback=new Rt({context:this.context,value:t.feedback,units:"normalRange"}),this._feedbackL=new Mt({context:this.context}),this._feedbackR=new Mt({context:this.context}),this._feedbackSplit=new Ln({context:this.context,channels:2}),this._feedbackMerge=new zn({context:this.context,channels:2}),this._merge.connect(this._feedbackSplit),this._feedbackMerge.connect(this._split),this._feedbackSplit.connect(this._feedbackL,0,0),this._feedbackL.connect(this._feedbackMerge,0,0),this._feedbackSplit.connect(this._feedbackR,1,0),this._feedbackR.connect(this._feedbackMerge,0,1),this.feedback.fan(this._feedbackL.gain,this._feedbackR.gain),$(this,["feedback"])}static getDefaults(){return Object.assign(Bn.getDefaults(),{feedback:.5})}dispose(){return super.dispose(),this.feedback.dispose(),this._feedbackL.dispose(),this._feedbackR.dispose(),this._feedbackSplit.dispose(),this._feedbackMerge.dispose(),this}}class Un extends Wn{constructor(){super(q(Un.getDefaults(),arguments,["frequency","delayTime","depth"])),this.name="Chorus";const t=q(Un.getDefaults(),arguments,["frequency","delayTime","depth"]);this._depth=t.depth,this._delayTime=t.delayTime/1e3,this._lfoL=new Se({context:this.context,frequency:t.frequency,min:0,max:1}),this._lfoR=new Se({context:this.context,frequency:t.frequency,min:0,max:1,phase:180}),this._delayNodeL=new Qt({context:this.context}),this._delayNodeR=new Qt({context:this.context}),this.frequency=this._lfoL.frequency,$(this,["frequency"]),this._lfoL.frequency.connect(this._lfoR.frequency),this.connectEffectLeft(this._delayNodeL),this.connectEffectRight(this._delayNodeR),this._lfoL.connect(this._delayNodeL.delayTime),this._lfoR.connect(this._delayNodeR.delayTime),this.depth=this._depth,this.type=t.type,this.spread=t.spread}static getDefaults(){return Object.assign(Wn.getDefaults(),{frequency:1.5,delayTime:3.5,depth:.7,type:"sine",spread:180,feedback:0,wet:.5})}get depth(){return this._depth}set depth(t){this._depth=t;const e=this._delayTime*t;this._lfoL.min=Math.max(this._delayTime-e,0),this._lfoL.max=this._delayTime+e,this._lfoR.min=Math.max(this._delayTime-e,0),this._lfoR.max=this._delayTime+e}get delayTime(){return 1e3*this._delayTime}set delayTime(t){this._delayTime=t/1e3,this.depth=this._depth}get type(){return this._lfoL.type}set type(t){this._lfoL.type=t,this._lfoR.type=t}get spread(){return this._lfoR.phase-this._lfoL.phase}set spread(t){this._lfoL.phase=90-t/2,this._lfoR.phase=t/2+90}start(t){return this._lfoL.start(t),this._lfoR.start(t),this}stop(t){return this._lfoL.stop(t),this._lfoR.stop(t),this}sync(){return this._lfoL.sync(),this._lfoR.sync(),this}unsync(){return this._lfoL.unsync(),this._lfoR.unsync(),this}dispose(){return super.dispose(),this._lfoL.dispose(),this._lfoR.dispose(),this._delayNodeL.dispose(),this._delayNodeR.dispose(),this.frequency.dispose(),this}}class Gn extends Mn{constructor(){super(q(Gn.getDefaults(),arguments,["distortion"])),this.name="Distortion";const t=q(Gn.getDefaults(),arguments,["distortion"]);this._shaper=new de({context:this.context,length:4096}),this._distortion=t.distortion,this.connectEffect(this._shaper),this.distortion=t.distortion,this.oversample=t.oversample}static getDefaults(){return Object.assign(Mn.getDefaults(),{distortion:.4,oversample:"none"})}get distortion(){return this._distortion}set distortion(t){this._distortion=t;const e=100*t,n=Math.PI/180;this._shaper.setMap(t=>Math.abs(t)<.001?0:(3+e)*t*20*n/(Math.PI+e*Math.abs(t)))}get oversample(){return this._shaper.oversample}set oversample(t){this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.dispose(),this}}class Yn extends Mn{constructor(t){super(t),this.name="FeedbackEffect",this._feedbackGain=new Mt({context:this.context,gain:t.feedback,units:"normalRange"}),this.feedback=this._feedbackGain.gain,$(this,"feedback"),this.effectReturn.chain(this._feedbackGain,this.effectSend)}static getDefaults(){return Object.assign(Mn.getDefaults(),{feedback:.125})}dispose(){return super.dispose(),this._feedbackGain.dispose(),this.feedback.dispose(),this}}class Qn extends Yn{constructor(){super(q(Qn.getDefaults(),arguments,["delayTime","feedback"])),this.name="FeedbackDelay";const t=q(Qn.getDefaults(),arguments,["delayTime","feedback"]);this._delayNode=new Qt({context:this.context,delayTime:t.delayTime,maxDelay:t.maxDelay}),this.delayTime=this._delayNode.delayTime,this.connectEffect(this._delayNode),$(this,"delayTime")}static getDefaults(){return Object.assign(Yn.getDefaults(),{delayTime:.25,maxDelay:1})}dispose(){return super.dispose(),this._delayNode.dispose(),this.delayTime.dispose(),this}}class Zn extends Ct{constructor(t){super(t),this.name="PhaseShiftAllpass",this.input=new Mt({context:this.context}),this.output=new Mt({context:this.context}),this.offset90=new Mt({context:this.context});this._bank0=this._createAllPassFilterBank([.6923878,.9360654322959,.988229522686,.9987488452737]),this._bank1=this._createAllPassFilterBank([.4021921162426,.856171088242,.9722909545651,.9952884791278]),this._oneSampleDelay=this.context.createIIRFilter([0,1],[1,0]),kt(this.input,...this._bank0,this._oneSampleDelay,this.output),kt(this.input,...this._bank1,this.offset90)}_createAllPassFilterBank(t){return t.map(t=>{const e=[[t*t,0,-1],[1,0,-t*t]];return this.context.createIIRFilter(e[0],e[1])})}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this.offset90.dispose(),this._bank0.forEach(t=>t.disconnect()),this._bank1.forEach(t=>t.disconnect()),this._oneSampleDelay.disconnect(),this}}class Xn extends Mn{constructor(){super(q(Xn.getDefaults(),arguments,["frequency"])),this.name="FrequencyShifter";const t=q(Xn.getDefaults(),arguments,["frequency"]);this.frequency=new Rt({context:this.context,units:"frequency",value:t.frequency,minValue:-this.context.sampleRate/2,maxValue:this.context.sampleRate/2}),this._sine=new ue({context:this.context,type:"sine"}),this._cosine=new he({context:this.context,phase:-90,type:"sine"}),this._sineMultiply=new fe({context:this.context}),this._cosineMultiply=new fe({context:this.context}),this._negate=new Re({context:this.context}),this._add=new we({context:this.context}),this._phaseShifter=new Zn({context:this.context}),this.effectSend.connect(this._phaseShifter),this.frequency.fan(this._sine.frequency,this._cosine.frequency),this._phaseShifter.offset90.connect(this._cosineMultiply),this._cosine.connect(this._cosineMultiply.factor),this._phaseShifter.connect(this._sineMultiply),this._sine.connect(this._sineMultiply.factor),this._sineMultiply.connect(this._negate),this._cosineMultiply.connect(this._add),this._negate.connect(this._add.addend),this._add.connect(this.effectReturn);const e=this.immediate();this._sine.start(e),this._cosine.start(e)}static getDefaults(){return Object.assign(Mn.getDefaults(),{frequency:0})}dispose(){return super.dispose(),this.frequency.dispose(),this._add.dispose(),this._cosine.dispose(),this._cosineMultiply.dispose(),this._negate.dispose(),this._phaseShifter.dispose(),this._sine.dispose(),this._sineMultiply.dispose(),this}}const Hn=[1557/44100,1617/44100,1491/44100,1422/44100,1277/44100,1356/44100,1188/44100,1116/44100],$n=[225,556,441,341];class Jn extends Bn{constructor(){super(q(Jn.getDefaults(),arguments,["roomSize","dampening"])),this.name="Freeverb",this._combFilters=[],this._allpassFiltersL=[],this._allpassFiltersR=[];const t=q(Jn.getDefaults(),arguments,["roomSize","dampening"]);this.roomSize=new Rt({context:this.context,value:t.roomSize,units:"normalRange"}),this._allpassFiltersL=$n.map(t=>{const e=this.context.createBiquadFilter();return e.type="allpass",e.frequency.value=t,e}),this._allpassFiltersR=$n.map(t=>{const e=this.context.createBiquadFilter();return e.type="allpass",e.frequency.value=t,e}),this._combFilters=Hn.map((e,n)=>{const s=new ln({context:this.context,dampening:t.dampening,delayTime:e});return n<Hn.length/2?this.connectEffectLeft(s,...this._allpassFiltersL):this.connectEffectRight(s,...this._allpassFiltersR),this.roomSize.connect(s.resonance),s}),$(this,["roomSize"])}static getDefaults(){return Object.assign(Bn.getDefaults(),{roomSize:.7,dampening:3e3})}get dampening(){return this._combFilters[0].dampening}set dampening(t){this._combFilters.forEach(e=>e.dampening=t)}dispose(){return super.dispose(),this._allpassFiltersL.forEach(t=>t.disconnect()),this._allpassFiltersR.forEach(t=>t.disconnect()),this._combFilters.forEach(t=>t.dispose()),this.roomSize.dispose(),this}}const Kn=[.06748,.06404,.08212,.09004],ts=[.773,.802,.753,.733],es=[347,113,37];class ns extends Bn{constructor(){super(q(ns.getDefaults(),arguments,["roomSize"])),this.name="JCReverb",this._allpassFilters=[],this._feedbackCombFilters=[];const t=q(ns.getDefaults(),arguments,["roomSize"]);this.roomSize=new Rt({context:this.context,value:t.roomSize,units:"normalRange"}),this._scaleRoomSize=new Te({context:this.context,min:-.733,max:.197}),this._allpassFilters=es.map(t=>{const e=this.context.createBiquadFilter();return e.type="allpass",e.frequency.value=t,e}),this._feedbackCombFilters=Kn.map((t,e)=>{const n=new un({context:this.context,delayTime:t});return this._scaleRoomSize.connect(n.resonance),n.resonance.value=ts[e],e<Kn.length/2?this.connectEffectLeft(...this._allpassFilters,n):this.connectEffectRight(...this._allpassFilters,n),n}),this.roomSize.connect(this._scaleRoomSize),$(this,["roomSize"])}static getDefaults(){return Object.assign(Bn.getDefaults(),{roomSize:.5})}dispose(){return super.dispose(),this._allpassFilters.forEach(t=>t.disconnect()),this._feedbackCombFilters.forEach(t=>t.dispose()),this.roomSize.dispose(),this._scaleRoomSize.dispose(),this}}class ss extends Wn{constructor(t){super(t),this._feedbackL.disconnect(),this._feedbackL.connect(this._feedbackMerge,0,1),this._feedbackR.disconnect(),this._feedbackR.connect(this._feedbackMerge,0,0),$(this,["feedback"])}}class is extends ss{constructor(){super(q(is.getDefaults(),arguments,["delayTime","feedback"])),this.name="PingPongDelay";const t=q(is.getDefaults(),arguments,["delayTime","feedback"]);this._leftDelay=new Qt({context:this.context,maxDelay:t.maxDelay}),this._rightDelay=new Qt({context:this.context,maxDelay:t.maxDelay}),this._rightPreDelay=new Qt({context:this.context,maxDelay:t.maxDelay}),this.delayTime=new Rt({context:this.context,units:"time",value:t.delayTime}),this.connectEffectLeft(this._leftDelay),this.connectEffectRight(this._rightPreDelay,this._rightDelay),this.delayTime.fan(this._leftDelay.delayTime,this._rightDelay.delayTime,this._rightPreDelay.delayTime),this._feedbackL.disconnect(),this._feedbackL.connect(this._rightDelay),$(this,["delayTime"])}static getDefaults(){return Object.assign(ss.getDefaults(),{delayTime:.25,maxDelay:1})}dispose(){return super.dispose(),this._leftDelay.dispose(),this._rightDelay.dispose(),this._rightPreDelay.dispose(),this.delayTime.dispose(),this}}class os extends Yn{constructor(){super(q(os.getDefaults(),arguments,["pitch"])),this.name="PitchShift";const t=q(os.getDefaults(),arguments,["pitch"]);this._frequency=new Rt({context:this.context}),this._delayA=new Qt({maxDelay:1,context:this.context}),this._lfoA=new Se({context:this.context,min:0,max:.1,type:"sawtooth"}).connect(this._delayA.delayTime),this._delayB=new Qt({maxDelay:1,context:this.context}),this._lfoB=new Se({context:this.context,min:0,max:.1,type:"sawtooth",phase:180}).connect(this._delayB.delayTime),this._crossFade=new Dn({context:this.context}),this._crossFadeLFO=new Se({context:this.context,min:0,max:1,type:"triangle",phase:90}).connect(this._crossFade.fade),this._feedbackDelay=new Qt({delayTime:t.delayTime,context:this.context}),this.delayTime=this._feedbackDelay.delayTime,$(this,"delayTime"),this._pitch=t.pitch,this._windowSize=t.windowSize,this._delayA.connect(this._crossFade.a),this._delayB.connect(this._crossFade.b),this._frequency.fan(this._lfoA.frequency,this._lfoB.frequency,this._crossFadeLFO.frequency),this.effectSend.fan(this._delayA,this._delayB),this._crossFade.chain(this._feedbackDelay,this.effectReturn);const e=this.now();this._lfoA.start(e),this._lfoB.start(e),this._crossFadeLFO.start(e),this.windowSize=this._windowSize}static getDefaults(){return Object.assign(Yn.getDefaults(),{pitch:0,windowSize:.1,delayTime:0,feedback:0})}get pitch(){return this._pitch}set pitch(t){this._pitch=t;let e=0;t<0?(this._lfoA.min=0,this._lfoA.max=this._windowSize,this._lfoB.min=0,this._lfoB.max=this._windowSize,e=ut(t-1)+1):(this._lfoA.min=this._windowSize,this._lfoA.max=0,this._lfoB.min=this._windowSize,this._lfoB.max=0,e=ut(t)-1),this._frequency.value=e*(1.2/this._windowSize)}get windowSize(){return this._windowSize}set windowSize(t){this._windowSize=this.toSeconds(t),this.pitch=this._pitch}dispose(){return super.dispose(),this._frequency.dispose(),this._delayA.dispose(),this._delayB.dispose(),this._lfoA.dispose(),this._lfoB.dispose(),this._crossFade.dispose(),this._crossFadeLFO.dispose(),this._feedbackDelay.dispose(),this}}class rs extends Bn{constructor(){super(q(rs.getDefaults(),arguments,["frequency","octaves","baseFrequency"])),this.name="Phaser";const t=q(rs.getDefaults(),arguments,["frequency","octaves","baseFrequency"]);this._lfoL=new Se({context:this.context,frequency:t.frequency,min:0,max:1}),this._lfoR=new Se({context:this.context,frequency:t.frequency,min:0,max:1,phase:180}),this._baseFrequency=this.toFrequency(t.baseFrequency),this._octaves=t.octaves,this.Q=new Rt({context:this.context,value:t.Q,units:"positive"}),this._filtersL=this._makeFilters(t.stages,this._lfoL),this._filtersR=this._makeFilters(t.stages,this._lfoR),this.frequency=this._lfoL.frequency,this.frequency.value=t.frequency,this.connectEffectLeft(...this._filtersL),this.connectEffectRight(...this._filtersR),this._lfoL.frequency.connect(this._lfoR.frequency),this.baseFrequency=t.baseFrequency,this.octaves=t.octaves,this._lfoL.start(),this._lfoR.start(),$(this,["frequency","Q"])}static getDefaults(){return Object.assign(Bn.getDefaults(),{frequency:.5,octaves:3,stages:10,Q:10,baseFrequency:350})}_makeFilters(t,e){const n=[];for(let s=0;s<t;s++){const t=this.context.createBiquadFilter();t.type="allpass",this.Q.connect(t.Q),e.connect(t.frequency),n.push(t)}return n}get octaves(){return this._octaves}set octaves(t){this._octaves=t;const e=this._baseFrequency*Math.pow(2,t);this._lfoL.max=e,this._lfoR.max=e}get baseFrequency(){return this._baseFrequency}set baseFrequency(t){this._baseFrequency=this.toFrequency(t),this._lfoL.min=this._baseFrequency,this._lfoR.min=this._baseFrequency,this.octaves=this._octaves}dispose(){return super.dispose(),this.Q.dispose(),this._lfoL.dispose(),this._lfoR.dispose(),this._filtersL.forEach(t=>t.disconnect()),this._filtersR.forEach(t=>t.disconnect()),this.frequency.dispose(),this}}class as extends Mn{constructor(){super(q(as.getDefaults(),arguments,["decay"])),this.name="Reverb",this._convolver=this.context.createConvolver(),this.ready=Promise.resolve();const t=q(as.getDefaults(),arguments,["decay"]);this._decay=t.decay,this._preDelay=t.preDelay,this.generate(),this.connectEffect(this._convolver)}static getDefaults(){return Object.assign(Mn.getDefaults(),{decay:1.5,preDelay:.01})}get decay(){return this._decay}set decay(t){a(t=this.toSeconds(t),.001),this._decay=t,this.generate()}get preDelay(){return this._preDelay}set preDelay(t){a(t=this.toSeconds(t),0),this._preDelay=t,this.generate()}generate(){return S(this,void 0,void 0,(function*(){const t=this.ready,e=new et(2,this._decay+this._preDelay,this.context.sampleRate),n=new ie({context:e}),s=new ie({context:e}),i=new zn({context:e});n.connect(i,0,0),s.connect(i,0,1);const o=new Mt({context:e}).toDestination();i.connect(o),n.start(0),s.start(0),o.gain.setValueAtTime(0,0),o.gain.setValueAtTime(1,this._preDelay),o.gain.exponentialApproachValueAtTime(0,this._preDelay,this.decay);const r=e.render();return this.ready=r.then(K),yield t,this._convolver.buffer=(yield r).get(),this}))}dispose(){return super.dispose(),this._convolver.disconnect(),this}}class cs extends Ct{constructor(){super(q(cs.getDefaults(),arguments)),this.name="MidSideSplit",this._split=this.input=new Ln({channels:2,context:this.context}),this._midAdd=new we({context:this.context}),this.mid=new fe({context:this.context,value:Math.SQRT1_2}),this._sideSubtract=new qe({context:this.context}),this.side=new fe({context:this.context,value:Math.SQRT1_2}),this._split.connect(this._midAdd,0),this._split.connect(this._midAdd.addend,1),this._split.connect(this._sideSubtract,0),this._split.connect(this._sideSubtract.subtrahend,1),this._midAdd.connect(this.mid),this._sideSubtract.connect(this.side)}dispose(){return super.dispose(),this.mid.dispose(),this.side.dispose(),this._midAdd.dispose(),this._sideSubtract.dispose(),this._split.dispose(),this}}class us extends Ct{constructor(){super(q(us.getDefaults(),arguments)),this.name="MidSideMerge",this.mid=new Mt({context:this.context}),this.side=new Mt({context:this.context}),this._left=new we({context:this.context}),this._leftMult=new fe({context:this.context,value:Math.SQRT1_2}),this._right=new qe({context:this.context}),this._rightMult=new fe({context:this.context,value:Math.SQRT1_2}),this._merge=this.output=new zn({context:this.context}),this.mid.fan(this._left),this.side.connect(this._left.addend),this.mid.connect(this._right),this.side.connect(this._right.subtrahend),this._left.connect(this._leftMult),this._right.connect(this._rightMult),this._leftMult.connect(this._merge,0,0),this._rightMult.connect(this._merge,0,1)}dispose(){return super.dispose(),this.mid.dispose(),this.side.dispose(),this._leftMult.dispose(),this._rightMult.dispose(),this._left.dispose(),this._right.dispose(),this}}class hs extends Mn{constructor(t){super(t),this.name="MidSideEffect",this._midSideMerge=new us({context:this.context}),this._midSideSplit=new cs({context:this.context}),this._midSend=this._midSideSplit.mid,this._sideSend=this._midSideSplit.side,this._midReturn=this._midSideMerge.mid,this._sideReturn=this._midSideMerge.side,this.effectSend.connect(this._midSideSplit),this._midSideMerge.connect(this.effectReturn)}connectEffectMid(...t){this._midSend.chain(...t,this._midReturn)}connectEffectSide(...t){this._sideSend.chain(...t,this._sideReturn)}dispose(){return super.dispose(),this._midSideSplit.dispose(),this._midSideMerge.dispose(),this._midSend.dispose(),this._sideSend.dispose(),this._midReturn.dispose(),this._sideReturn.dispose(),this}}class ls extends hs{constructor(){super(q(ls.getDefaults(),arguments,["width"])),this.name="StereoWidener";const t=q(ls.getDefaults(),arguments,["width"]);this.width=new Rt({context:this.context,value:t.width,units:"normalRange"}),$(this,["width"]),this._twoTimesWidthMid=new fe({context:this.context,value:2}),this._twoTimesWidthSide=new fe({context:this.context,value:2}),this._midMult=new fe({context:this.context}),this._twoTimesWidthMid.connect(this._midMult.factor),this.connectEffectMid(this._midMult),this._oneMinusWidth=new qe({context:this.context}),this._oneMinusWidth.connect(this._twoTimesWidthMid),At(this.context.getConstant(1),this._oneMinusWidth),this.width.connect(this._oneMinusWidth.subtrahend),this._sideMult=new fe({context:this.context}),this.width.connect(this._twoTimesWidthSide),this._twoTimesWidthSide.connect(this._sideMult.factor),this.connectEffectSide(this._sideMult)}static getDefaults(){return Object.assign(hs.getDefaults(),{width:.5})}dispose(){return super.dispose(),this.width.dispose(),this._midMult.dispose(),this._sideMult.dispose(),this._twoTimesWidthMid.dispose(),this._twoTimesWidthSide.dispose(),this._oneMinusWidth.dispose(),this}}class ds extends Bn{constructor(){super(q(ds.getDefaults(),arguments,["frequency","depth"])),this.name="Tremolo";const t=q(ds.getDefaults(),arguments,["frequency","depth"]);this._lfoL=new Se({context:this.context,type:t.type,min:1,max:0}),this._lfoR=new Se({context:this.context,type:t.type,min:1,max:0}),this._amplitudeL=new Mt({context:this.context}),this._amplitudeR=new Mt({context:this.context}),this.frequency=new Rt({context:this.context,value:t.frequency,units:"frequency"}),this.depth=new Rt({context:this.context,value:t.depth,units:"normalRange"}),$(this,["frequency","depth"]),this.connectEffectLeft(this._amplitudeL),this.connectEffectRight(this._amplitudeR),this._lfoL.connect(this._amplitudeL.gain),this._lfoR.connect(this._amplitudeR.gain),this.frequency.fan(this._lfoL.frequency,this._lfoR.frequency),this.depth.fan(this._lfoR.amplitude,this._lfoL.amplitude),this.spread=t.spread}static getDefaults(){return Object.assign(Bn.getDefaults(),{frequency:10,type:"sine",depth:.5,spread:180})}start(t){return this._lfoL.start(t),this._lfoR.start(t),this}stop(t){return this._lfoL.stop(t),this._lfoR.stop(t),this}sync(){return this._lfoL.sync(),this._lfoR.sync(),this.context.transport.syncSignal(this.frequency),this}unsync(){return this._lfoL.unsync(),this._lfoR.unsync(),this.context.transport.unsyncSignal(this.frequency),this}get type(){return this._lfoL.type}set type(t){this._lfoL.type=t,this._lfoR.type=t}get spread(){return this._lfoR.phase-this._lfoL.phase}set spread(t){this._lfoL.phase=90-t/2,this._lfoR.phase=t/2+90}dispose(){return super.dispose(),this._lfoL.dispose(),this._lfoR.dispose(),this._amplitudeL.dispose(),this._amplitudeR.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class ps extends Mn{constructor(){super(q(ps.getDefaults(),arguments,["frequency","depth"])),this.name="Vibrato";const t=q(ps.getDefaults(),arguments,["frequency","depth"]);this._delayNode=new Qt({context:this.context,delayTime:0,maxDelay:t.maxDelay}),this._lfo=new Se({context:this.context,type:t.type,min:0,max:t.maxDelay,frequency:t.frequency,phase:-90}).start().connect(this._delayNode.delayTime),this.frequency=this._lfo.frequency,this.depth=this._lfo.amplitude,this.depth.value=t.depth,$(this,["frequency","depth"]),this.effectSend.chain(this._delayNode,this.effectReturn)}static getDefaults(){return Object.assign(Mn.getDefaults(),{maxDelay:.005,frequency:5,depth:.1,type:"sine"})}get type(){return this._lfo.type}set type(t){this._lfo.type=t}dispose(){return super.dispose(),this._delayNode.dispose(),this._lfo.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class fs extends Ct{constructor(){super(q(fs.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=q(fs.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new Mt({context:this.context}),this._split=new Ln({context:this.context,channels:t.channels}),this.input.connect(this._split),a(t.channels,1);for(let e=0;e<t.channels;e++)this._analysers[e]=this.context.createAnalyser(),this._split.connect(this._analysers[e],e,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(Ct.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,e)=>{const n=this._buffers[e];"fft"===this._type?t.getFloatFrequencyData(n):"waveform"===this._type&&t.getFloatTimeDomainData(n)}),1===this.channels?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((e,n)=>{e.fftSize=2*t,this._buffers[n]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){r("waveform"===t||"fft"===t,"Analyser: invalid type: "+t),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(e=>e.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class _s extends Ct{constructor(){super(q(_s.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new fs({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class ms extends _s{constructor(){super(q(ms.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=q(ms.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new fs({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(_s.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return d("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),e=(1===this.channels?[t]:t).map(t=>{const e=t.reduce((t,e)=>t+e*e,0),n=Math.sqrt(e/t.length);return this._rms=Math.max(n,this._rms*this.smoothing),this.normalRange?this._rms:ct(this._rms)});return 1===this.channels?e[0]:e}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}class gs extends _s{constructor(){super(q(gs.getDefaults(),arguments,["size"])),this.name="FFT";const t=q(gs.getDefaults(),arguments,["size"]);this.normalRange=t.normalRange,this._analyser.type="fft",this.size=t.size}static getDefaults(){return Object.assign(Ct.getDefaults(),{normalRange:!1,size:1024,smoothing:.8})}getValue(){return this._analyser.getValue().map(t=>this.normalRange?at(t):t)}get size(){return this._analyser.size}set size(t){this._analyser.size=t}get smoothing(){return this._analyser.smoothing}set smoothing(t){this._analyser.smoothing=t}getFrequencyOfIndex(t){return r(0<=t&&t<this.size,"index must be greater than or equal to 0 and less than "+this.size),t*this.context.sampleRate/(2*this.size)}}class vs extends _s{constructor(){super(q(vs.getDefaults(),arguments)),this.name="DCMeter",this._analyser.type="waveform",this._analyser.size=256}getValue(){return this._analyser.getValue()[0]}}class ys extends _s{constructor(){super(q(ys.getDefaults(),arguments,["size"])),this.name="Waveform";const t=q(ys.getDefaults(),arguments,["size"]);this._analyser.type="waveform",this.size=t.size}static getDefaults(){return Object.assign(_s.getDefaults(),{size:1024})}getValue(){return this._analyser.getValue()}get size(){return this._analyser.size}set size(t){this._analyser.size=t}}class bs extends Ct{constructor(){super(q(bs.getDefaults(),arguments,["solo"])),this.name="Solo";const t=q(bs.getDefaults(),arguments,["solo"]);this.input=this.output=new Mt({context:this.context}),bs._allSolos.has(this.context)||bs._allSolos.set(this.context,new Set),bs._allSolos.get(this.context).add(this),this.solo=t.solo}static getDefaults(){return Object.assign(Ct.getDefaults(),{solo:!1})}get solo(){return this._isSoloed()}set solo(t){t?this._addSolo():this._removeSolo(),bs._allSolos.get(this.context).forEach(t=>t._updateSolo())}get muted(){return 0===this.input.gain.value}_addSolo(){bs._soloed.has(this.context)||bs._soloed.set(this.context,new Set),bs._soloed.get(this.context).add(this)}_removeSolo(){bs._soloed.has(this.context)&&bs._soloed.get(this.context).delete(this)}_isSoloed(){return bs._soloed.has(this.context)&&bs._soloed.get(this.context).has(this)}_noSolos(){return!bs._soloed.has(this.context)||bs._soloed.has(this.context)&&0===bs._soloed.get(this.context).size}_updateSolo(){this._isSoloed()||this._noSolos()?this.input.gain.value=1:this.input.gain.value=0}dispose(){return super.dispose(),bs._allSolos.get(this.context).delete(this),this._removeSolo(),this}}bs._allSolos=new Map,bs._soloed=new Map;class xs extends Ct{constructor(){super(q(xs.getDefaults(),arguments,["pan","volume"])),this.name="PanVol";const t=q(xs.getDefaults(),arguments,["pan","volume"]);this._panner=this.input=new Rn({context:this.context,pan:t.pan,channelCount:t.channelCount}),this.pan=this._panner.pan,this._volume=this.output=new Zt({context:this.context,volume:t.volume}),this.volume=this._volume.volume,this._panner.connect(this._volume),this.mute=t.mute,$(this,["pan","volume"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{mute:!1,pan:0,volume:0,channelCount:1})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}dispose(){return super.dispose(),this._panner.dispose(),this.pan.dispose(),this._volume.dispose(),this.volume.dispose(),this}}class ws extends Ct{constructor(){super(q(ws.getDefaults(),arguments,["volume","pan"])),this.name="Channel";const t=q(ws.getDefaults(),arguments,["volume","pan"]);this._solo=this.input=new bs({solo:t.solo,context:this.context}),this._panVol=this.output=new xs({context:this.context,pan:t.pan,volume:t.volume,mute:t.mute,channelCount:t.channelCount}),this.pan=this._panVol.pan,this.volume=this._panVol.volume,this._solo.connect(this._panVol),$(this,["pan","volume"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{pan:0,volume:0,mute:!1,solo:!1,channelCount:1})}get solo(){return this._solo.solo}set solo(t){this._solo.solo=t}get muted(){return this._solo.muted||this.mute}get mute(){return this._panVol.mute}set mute(t){this._panVol.mute=t}_getBus(t){return ws.buses.has(t)||ws.buses.set(t,new Mt({context:this.context})),ws.buses.get(t)}send(t,e=0){const n=this._getBus(t),s=new Mt({context:this.context,units:"decibels",gain:e});return this.connect(s),s.connect(n),s}receive(t){return this._getBus(t).connect(this),this}dispose(){return super.dispose(),this._panVol.dispose(),this.pan.dispose(),this.volume.dispose(),this._solo.dispose(),this}}ws.buses=new Map;class Ts extends Ct{constructor(){super(q(Ts.getDefaults(),arguments,["lowFrequency","highFrequency"])),this.name="MultibandSplit",this.input=new Mt({context:this.context}),this.output=void 0,this.low=new Xe({context:this.context,frequency:0,type:"lowpass"}),this._lowMidFilter=new Xe({context:this.context,frequency:0,type:"highpass"}),this.mid=new Xe({context:this.context,frequency:0,type:"lowpass"}),this.high=new Xe({context:this.context,frequency:0,type:"highpass"}),this._internalChannels=[this.low,this.mid,this.high];const t=q(Ts.getDefaults(),arguments,["lowFrequency","highFrequency"]);this.lowFrequency=new Rt({context:this.context,units:"frequency",value:t.lowFrequency}),this.highFrequency=new Rt({context:this.context,units:"frequency",value:t.highFrequency}),this.Q=new Rt({context:this.context,units:"positive",value:t.Q}),this.input.fan(this.low,this.high),this.input.chain(this._lowMidFilter,this.mid),this.lowFrequency.fan(this.low.frequency,this._lowMidFilter.frequency),this.highFrequency.fan(this.mid.frequency,this.high.frequency),this.Q.connect(this.low.Q),this.Q.connect(this._lowMidFilter.Q),this.Q.connect(this.mid.Q),this.Q.connect(this.high.Q),$(this,["high","mid","low","highFrequency","lowFrequency"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{Q:1,highFrequency:2500,lowFrequency:400})}dispose(){return super.dispose(),J(this,["high","mid","low","highFrequency","lowFrequency"]),this.low.dispose(),this._lowMidFilter.dispose(),this.mid.dispose(),this.high.dispose(),this.lowFrequency.dispose(),this.highFrequency.dispose(),this.Q.dispose(),this}}class Os extends Ct{constructor(){super(...arguments),this.name="Listener",this.positionX=new St({context:this.context,param:this.context.rawContext.listener.positionX}),this.positionY=new St({context:this.context,param:this.context.rawContext.listener.positionY}),this.positionZ=new St({context:this.context,param:this.context.rawContext.listener.positionZ}),this.forwardX=new St({context:this.context,param:this.context.rawContext.listener.forwardX}),this.forwardY=new St({context:this.context,param:this.context.rawContext.listener.forwardY}),this.forwardZ=new St({context:this.context,param:this.context.rawContext.listener.forwardZ}),this.upX=new St({context:this.context,param:this.context.rawContext.listener.upX}),this.upY=new St({context:this.context,param:this.context.rawContext.listener.upY}),this.upZ=new St({context:this.context,param:this.context.rawContext.listener.upZ})}static getDefaults(){return Object.assign(Ct.getDefaults(),{positionX:0,positionY:0,positionZ:0,forwardX:0,forwardY:0,forwardZ:-1,upX:0,upY:1,upZ:0})}dispose(){return super.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this.forwardX.dispose(),this.forwardY.dispose(),this.forwardZ.dispose(),this.upX.dispose(),this.upY.dispose(),this.upZ.dispose(),this}}G(t=>{t.listener=new Os({context:t})}),Q(t=>{t.listener.dispose()});class Ss extends Ct{constructor(){super(q(Ss.getDefaults(),arguments,["positionX","positionY","positionZ"])),this.name="Panner3D";const t=q(Ss.getDefaults(),arguments,["positionX","positionY","positionZ"]);this._panner=this.input=this.output=this.context.createPanner(),this.panningModel=t.panningModel,this.maxDistance=t.maxDistance,this.distanceModel=t.distanceModel,this.coneOuterGain=t.coneOuterGain,this.coneOuterAngle=t.coneOuterAngle,this.coneInnerAngle=t.coneInnerAngle,this.refDistance=t.refDistance,this.rolloffFactor=t.rolloffFactor,this.positionX=new St({context:this.context,param:this._panner.positionX,value:t.positionX}),this.positionY=new St({context:this.context,param:this._panner.positionY,value:t.positionY}),this.positionZ=new St({context:this.context,param:this._panner.positionZ,value:t.positionZ}),this.orientationX=new St({context:this.context,param:this._panner.orientationX,value:t.orientationX}),this.orientationY=new St({context:this.context,param:this._panner.orientationY,value:t.orientationY}),this.orientationZ=new St({context:this.context,param:this._panner.orientationZ,value:t.orientationZ})}static getDefaults(){return Object.assign(Ct.getDefaults(),{coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:0,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1})}setPosition(t,e,n){return this.positionX.value=t,this.positionY.value=e,this.positionZ.value=n,this}setOrientation(t,e,n){return this.orientationX.value=t,this.orientationY.value=e,this.orientationZ.value=n,this}get panningModel(){return this._panner.panningModel}set panningModel(t){this._panner.panningModel=t}get refDistance(){return this._panner.refDistance}set refDistance(t){this._panner.refDistance=t}get rolloffFactor(){return this._panner.rolloffFactor}set rolloffFactor(t){this._panner.rolloffFactor=t}get distanceModel(){return this._panner.distanceModel}set distanceModel(t){this._panner.distanceModel=t}get coneInnerAngle(){return this._panner.coneInnerAngle}set coneInnerAngle(t){this._panner.coneInnerAngle=t}get coneOuterAngle(){return this._panner.coneOuterAngle}set coneOuterAngle(t){this._panner.coneOuterAngle=t}get coneOuterGain(){return this._panner.coneOuterGain}set coneOuterGain(t){this._panner.coneOuterGain=t}get maxDistance(){return this._panner.maxDistance}set maxDistance(t){this._panner.maxDistance=t}dispose(){return super.dispose(),this._panner.disconnect(),this.orientationX.dispose(),this.orientationY.dispose(),this.orientationZ.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this}}class Cs extends Ct{constructor(){super(q(Cs.getDefaults(),arguments)),this.name="Recorder";const t=q(Cs.getDefaults(),arguments);this.input=new Mt({context:this.context}),r(Cs.supported,"Media Recorder API is not available"),this._stream=this.context.createMediaStreamDestination(),this.input.connect(this._stream),this._recorder=new MediaRecorder(this._stream.stream,{mimeType:t.mimeType})}static getDefaults(){return Ct.getDefaults()}get mimeType(){return this._recorder.mimeType}static get supported(){return null!==w&&Reflect.has(w,"MediaRecorder")}get state(){return"inactive"===this._recorder.state?"stopped":"paused"===this._recorder.state?"paused":"started"}start(){return S(this,void 0,void 0,(function*(){r("started"!==this.state,"Recorder is already started");const t=new Promise(t=>{const e=()=>{this._recorder.removeEventListener("start",e,!1),t()};this._recorder.addEventListener("start",e,!1)});return this._recorder.start(),yield t}))}stop(){return S(this,void 0,void 0,(function*(){r("stopped"!==this.state,"Recorder is not started");const t=new Promise(t=>{const e=n=>{this._recorder.removeEventListener("dataavailable",e,!1),t(n.data)};this._recorder.addEventListener("dataavailable",e,!1)});return this._recorder.stop(),yield t}))}pause(){return r("started"===this.state,"Recorder must be started"),this._recorder.pause(),this}dispose(){return super.dispose(),this.input.dispose(),this._stream.disconnect(),this}}class ks extends Ct{constructor(){super(q(ks.getDefaults(),arguments,["threshold","ratio"])),this.name="Compressor",this._compressor=this.context.createDynamicsCompressor(),this.input=this._compressor,this.output=this._compressor;const t=q(ks.getDefaults(),arguments,["threshold","ratio"]);this.threshold=new St({minValue:this._compressor.threshold.minValue,maxValue:this._compressor.threshold.maxValue,context:this.context,convert:!1,param:this._compressor.threshold,units:"decibels",value:t.threshold}),this.attack=new St({minValue:this._compressor.attack.minValue,maxValue:this._compressor.attack.maxValue,context:this.context,param:this._compressor.attack,units:"time",value:t.attack}),this.release=new St({minValue:this._compressor.release.minValue,maxValue:this._compressor.release.maxValue,context:this.context,param:this._compressor.release,units:"time",value:t.release}),this.knee=new St({minValue:this._compressor.knee.minValue,maxValue:this._compressor.knee.maxValue,context:this.context,convert:!1,param:this._compressor.knee,units:"decibels",value:t.knee}),this.ratio=new St({minValue:this._compressor.ratio.minValue,maxValue:this._compressor.ratio.maxValue,context:this.context,convert:!1,param:this._compressor.ratio,units:"positive",value:t.ratio}),$(this,["knee","release","attack","ratio","threshold"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{attack:.003,knee:30,ratio:12,release:.25,threshold:-24})}get reduction(){return this._compressor.reduction}dispose(){return super.dispose(),this._compressor.disconnect(),this.attack.dispose(),this.release.dispose(),this.threshold.dispose(),this.ratio.dispose(),this.knee.dispose(),this}}class As extends Ct{constructor(){super(Object.assign(q(As.getDefaults(),arguments,["threshold","smoothing"]))),this.name="Gate";const t=q(As.getDefaults(),arguments,["threshold","smoothing"]);this._follower=new In({context:this.context,smoothing:t.smoothing}),this._gt=new Fe({context:this.context,value:at(t.threshold)}),this.input=new Mt({context:this.context}),this._gate=this.output=new Mt({context:this.context}),this.input.connect(this._gate),this.input.chain(this._follower,this._gt,this._gate.gain)}static getDefaults(){return Object.assign(Ct.getDefaults(),{smoothing:.1,threshold:-40})}get threshold(){return ct(this._gt.value)}set threshold(t){this._gt.value=at(t)}get smoothing(){return this._follower.smoothing}set smoothing(t){this._follower.smoothing=t}dispose(){return super.dispose(),this.input.dispose(),this._follower.dispose(),this._gt.dispose(),this._gate.dispose(),this}}class Ds extends Ct{constructor(){super(Object.assign(q(Ds.getDefaults(),arguments,["threshold"]))),this.name="Limiter";const t=q(Ds.getDefaults(),arguments,["threshold"]);this._compressor=this.input=this.output=new ks({context:this.context,ratio:20,attack:0,release:0,threshold:t.threshold}),this.threshold=this._compressor.threshold,$(this,"threshold")}static getDefaults(){return Object.assign(Ct.getDefaults(),{threshold:-12})}get reduction(){return this._compressor.reduction}dispose(){return super.dispose(),this._compressor.dispose(),this.threshold.dispose(),this}}class Ms extends Ct{constructor(){super(Object.assign(q(Ms.getDefaults(),arguments))),this.name="MidSideCompressor";const t=q(Ms.getDefaults(),arguments);this._midSideSplit=this.input=new cs({context:this.context}),this._midSideMerge=this.output=new us({context:this.context}),this.mid=new ks(Object.assign(t.mid,{context:this.context})),this.side=new ks(Object.assign(t.side,{context:this.context})),this._midSideSplit.mid.chain(this.mid,this._midSideMerge.mid),this._midSideSplit.side.chain(this.side,this._midSideMerge.side),$(this,["mid","side"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{mid:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16},side:{ratio:6,threshold:-30,release:.25,attack:.03,knee:10}})}dispose(){return super.dispose(),this.mid.dispose(),this.side.dispose(),this._midSideSplit.dispose(),this._midSideMerge.dispose(),this}}class js extends Ct{constructor(){super(Object.assign(q(js.getDefaults(),arguments))),this.name="MultibandCompressor";const t=q(js.getDefaults(),arguments);this._splitter=this.input=new Ts({context:this.context,lowFrequency:t.lowFrequency,highFrequency:t.highFrequency}),this.lowFrequency=this._splitter.lowFrequency,this.highFrequency=this._splitter.highFrequency,this.output=new Mt({context:this.context}),this.low=new ks(Object.assign(t.low,{context:this.context})),this.mid=new ks(Object.assign(t.mid,{context:this.context})),this.high=new ks(Object.assign(t.high,{context:this.context})),this._splitter.low.chain(this.low,this.output),this._splitter.mid.chain(this.mid,this.output),this._splitter.high.chain(this.high,this.output),$(this,["high","mid","low","highFrequency","lowFrequency"])}static getDefaults(){return Object.assign(Ct.getDefaults(),{lowFrequency:250,highFrequency:2e3,low:{ratio:6,threshold:-30,release:.25,attack:.03,knee:10},mid:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16},high:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16}})}dispose(){return super.dispose(),this._splitter.dispose(),this.low.dispose(),this.mid.dispose(),this.high.dispose(),this.output.dispose(),this}}class Es extends Ct{constructor(){super(q(Es.getDefaults(),arguments,["low","mid","high"])),this.name="EQ3",this.output=new Mt({context:this.context}),this._internalChannels=[];const t=q(Es.getDefaults(),arguments,["low","mid","high"]);this.input=this._multibandSplit=new Ts({context:this.context,highFrequency:t.highFrequency,lowFrequency:t.lowFrequency}),this._lowGain=new Mt({context:this.context,gain:t.low,units:"decibels"}),this._midGain=new Mt({context:this.context,gain:t.mid,units:"decibels"}),this._highGain=new Mt({context:this.context,gain:t.high,units:"decibels"}),this.low=this._lowGain.gain,this.mid=this._midGain.gain,this.high=this._highGain.gain,this.Q=this._multibandSplit.Q,this.lowFrequency=this._multibandSplit.lowFrequency,this.highFrequency=this._multibandSplit.highFrequency,this._multibandSplit.low.chain(this._lowGain,this.output),this._multibandSplit.mid.chain(this._midGain,this.output),this._multibandSplit.high.chain(this._highGain,this.output),$(this,["low","mid","high","lowFrequency","highFrequency"]),this._internalChannels=[this._multibandSplit]}static getDefaults(){return Object.assign(Ct.getDefaults(),{high:0,highFrequency:2500,low:0,lowFrequency:400,mid:0})}dispose(){return super.dispose(),J(this,["low","mid","high","lowFrequency","highFrequency"]),this._multibandSplit.dispose(),this.lowFrequency.dispose(),this.highFrequency.dispose(),this._lowGain.dispose(),this._midGain.dispose(),this._highGain.dispose(),this.low.dispose(),this.mid.dispose(),this.high.dispose(),this.Q.dispose(),this}}class Rs extends Ct{constructor(){super(q(Rs.getDefaults(),arguments,["url","onload"])),this.name="Convolver",this._convolver=this.context.createConvolver();const t=q(Rs.getDefaults(),arguments,["url","onload"]);this._buffer=new tt(t.url,e=>{this.buffer=e,t.onload()}),this.input=new Mt({context:this.context}),this.output=new Mt({context:this.context}),this._buffer.loaded&&(this.buffer=this._buffer),this.normalize=t.normalize,this.input.chain(this._convolver,this.output)}static getDefaults(){return Object.assign(Ct.getDefaults(),{normalize:!0,onload:K})}load(t){return S(this,void 0,void 0,(function*(){this.buffer=yield this._buffer.load(t)}))}get buffer(){return this._buffer.length?this._buffer:null}set buffer(t){t&&this._buffer.set(t),this._convolver.buffer&&(this.input.disconnect(),this._convolver.disconnect(),this._convolver=this.context.createConvolver(),this.input.chain(this._convolver,this.output));const e=this._buffer.get();this._convolver.buffer=e||null}get normalize(){return this._convolver.normalize}set normalize(t){this._convolver.normalize=t}dispose(){return super.dispose(),this._buffer.dispose(),this._convolver.disconnect(),this}}function qs(){return it().now()}function Is(){return it().immediate()}const Fs=it().transport;function Vs(){return it().transport}const Ns=it().destination,Ps=it().destination;function Ls(){return it().destination}const zs=it().listener;function Bs(){return it().listener}const Ws=it().draw;function Us(){return it().draw}const Gs=it();function Ys(){return tt.loaded()}const Qs=tt,Zs=$t,Xs=se}])}));

},{}],38:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],39:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],40:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],41:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":40,"_process":19,"inherits":39}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.abs = function (x) { return _1.NDArray.array(x).abs(); };
_1.NDArray.prototype.abs = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.abs(d1[i]);
    }
    return this;
};

},{"./":78}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.acos = function (x) { return _1.NDArray.array(x).acos(); };
_1.NDArray.prototype.acos = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.acos(d1[i]);
    }
    return this;
};

},{"./":78}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.acosh = function (x) { return _1.NDArray.array(x).acosh(); };
_1.NDArray.prototype.acosh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.acosh(d1[i]);
    }
    return this;
};

},{"./":78}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.add = function (x, y, alpha) {
    if (alpha === void 0) { alpha = 1; }
    return _1.NDArray.array(x).add(_1.NDArray.array(y), alpha);
};
_1.NDArray.prototype.add = function (x, alpha) {
    if (alpha === void 0) { alpha = 1; }
    this.equilateral(x);
    this.equidimensional(x);
    var l1 = this.length;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        if (this.dtype === 'float64') {
            nblas.daxpy(l1, alpha, d2, 1, d1, 1);
        }
        else if (this.dtype === 'float32') {
            nblas.saxpy(l1, alpha, d2, 1, d1, 1);
        }
    }
    catch (err) {
        var d1 = this.data;
        var d2 = x.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            d1[i] += alpha * d2[i];
        }
    }
    return this;
};

},{"../util":130,"./":78,"nblas":2}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.angle = function (x, y) {
    return _1.NDArray.array(x).angle(_1.NDArray.array(y));
};
_1.NDArray.prototype.angle = function (x) {
    return Math.acos(this.dot(x) / this.norm() / x.norm());
};

},{"./":78}],47:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.array = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return new (this.bind.apply(this, __spread([void 0], args)))();
};

},{"./":78}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.asin = function (x) { return _1.NDArray.array(x).asin(); };
_1.NDArray.prototype.asin = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.asin(d1[i]);
    }
    return this;
};

},{"./":78}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.asinh = function (x) { return _1.NDArray.array(x).asinh(); };
_1.NDArray.prototype.asinh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.asinh(d1[i]);
    }
    return this;
};

},{"./":78}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.atan = function (x) { return _1.NDArray.array(x).atan(); };
_1.NDArray.prototype.atan = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.atan(d1[i]);
    }
    return this;
};

},{"./":78}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.atanh = function (x) { return _1.NDArray.array(x).atanh(); };
_1.NDArray.prototype.atanh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.atanh(d1[i]);
    }
    return this;
};

},{"./":78}],52:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.augment = function (x, y) {
    return _1.NDArray.array(x).augment(_1.NDArray.array(y));
};
_1.NDArray.prototype.augment = function (x) {
    var _a = __read(this.shape, 2), r1 = _a[0], c1 = _a[1];
    var _b = __read(x.shape, 2), r2 = _b[0], c2 = _b[1];
    var d1 = this.data;
    var d2 = x.data;
    if (r2 === 0 || c2 === 0) {
        return this;
    }
    if (r1 !== r2) {
        throw new Error('rows do not match');
    }
    var y = _1.NDArray.zeros(r1, c1 + c2);
    var d3 = y.data;
    var i;
    var j;
    for (i = 0; i < r1; i += 1) {
        for (j = 0; j < c1; j += 1) {
            d3[i * (c1 + c2) + j] = d1[i * c1 + j];
        }
    }
    for (i = 0; i < r2; i += 1) {
        for (j = 0; j < c2; j += 1) {
            d3[i * (c1 + c2) + (j + c1)] = d2[i * c2 + j];
        }
    }
    return y;
};

},{"./":78}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.binOp = function (x, y, f) { return _1.NDArray.array(x).binOp(_1.NDArray.array(y), f); };
_1.NDArray.prototype.binOp = function (x, f) {
    this.equilateral(x);
    this.equidimensional(x);
    var _a = this, d1 = _a.data, l1 = _a.length;
    var d2 = x.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = f(d1[i], d2[i], i);
    }
    return this;
};

},{"./":78}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cbrt = function (x) { return _1.NDArray.array(x).cbrt(); };
_1.NDArray.prototype.cbrt = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.cbrt(d1[i]);
    }
    return this;
};

},{"./":78}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.ceil = function (x) { return _1.NDArray.array(x).ceil(); };
_1.NDArray.prototype.ceil = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.ceil(d1[i]);
    }
    return this;
};

},{"./":78}],56:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.check = function (x) {
    var _a;
    var indices = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        indices[_i - 1] = arguments[_i];
    }
    (_a = _1.NDArray.array(x)).check.apply(_a, __spread(indices));
};
_1.NDArray.prototype.check = function () {
    var indices = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        indices[_i] = arguments[_i];
    }
    var _a = this, s1 = _a.shape, l1 = _a.length;
    if (indices.length === 1) {
        var _b = __read(indices, 1), i = _b[0];
        if (i < 0 || i > l1 - 1 || !Number.isFinite(i)) {
            throw new Error('index out of bounds');
        }
    }
    else if (!s1.every(function (dim, i) {
        return dim > indices[i]
            && Number.isFinite(indices[i])
            && indices[i] >= 0;
    })) {
        throw new Error('index out of bounds');
    }
};

},{"./":78}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.combine = function (x, y) {
    return _1.NDArray.array(x).combine(_1.NDArray.array(y));
};
_1.NDArray.prototype.combine = function (x) {
    if (this.shape.length !== 1 && x.shape.length !== 1) {
        throw new Error('combine operation not permitted for multidimensional arrays');
    }
    var _a = this, l1 = _a.length, d1 = _a.data;
    var l2 = x.length, d2 = x.data;
    if (l2 === 0) {
        return this;
    }
    if (l1 === 0) {
        this.data = new (util_1.get_type(x.dtype))(d2);
        this.length = l2;
        this.dtype = x.dtype;
        return this;
    }
    var l3 = l1 + l2;
    var d3 = new (util_1.get_type(this.dtype))(l3);
    d3.set(d1);
    d3.set(d2, l1);
    this.data = d3;
    this.length = l3;
    this.shape = [l3];
    return this;
};

},{"../util":130,"./":78}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.copy = function (x) { return _1.NDArray.array(x).copy(); };
_1.NDArray.prototype.copy = function () {
    var copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    copy.data = new (util_1.get_type(this.dtype))(this.data);
    copy.shape = this.shape;
    copy.length = this.length;
    copy.dtype = this.dtype;
    return copy;
};

},{"../util":130,"./":78}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cos = function (x) { return _1.NDArray.array(x).cos(); };
_1.NDArray.prototype.cos = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.cos(d1[i]);
    }
    return this;
};

},{"./":78}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cosh = function (x) { return _1.NDArray.array(x).cosh(); };
_1.NDArray.prototype.cosh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.cosh(d1[i]);
    }
    return this;
};

},{"./":78}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cross = function (x, y) {
    return _1.NDArray.array(x).cross(_1.NDArray.array(y));
};
_1.NDArray.prototype.cross = function (x) {
    var l1 = this.length;
    var l2 = x.length;
    if (l1 !== 3 || l2 !== 3) {
        throw new Error('vectors must have three components');
    }
    var c1 = this.y * x.z - this.z * x.y;
    var c2 = this.z * x.x - this.x * x.z;
    var c3 = this.x * x.y - this.y * x.x;
    this.x = c1;
    this.y = c2;
    this.z = c3;
    return this;
};

},{"./":78}],62:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.det = function (x) { return _1.NDArray.array(x).det(); };
_1.NDArray.prototype.det = function () {
    this.square();
    var _a = __read(this.shape, 1), n = _a[0];
    var _b = __read(this.copy().lu_factor(), 2), LU = _b[0], ipiv = _b[1];
    var d1 = LU.data;
    var product = 1;
    var sign = 1;
    var i;
    for (i = 0; i < n; i += 1) {
        product *= d1[i * n + i];
        if (i !== ipiv[i] - 1) {
            sign *= -1;
        }
    }
    return sign * product;
};

},{"./":78}],63:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.diagonal = function (x) {
    return _1.NDArray.array(x).diagonal();
};
_1.NDArray.prototype.diagonal = function () {
    this.square();
    var l1 = this.length;
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var l2 = Math.min(r, c);
    return this.reshape(l1).slice(0, l1, l2 + 1);
};

},{"./":78}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.dot = function (x, y) {
    return _1.NDArray.array(x).dot(_1.NDArray.array(y));
};
_1.NDArray.prototype.dot = function (x) {
    this.equilateral(x);
    this.equidimensional(x);
    var l1 = this.length;
    var result = 0;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        if (this.dtype === 'float64') {
            result = nblas.ddot(l1, d2, 1, d1, 1);
        }
        if (this.dtype === 'float32') {
            result = nblas.sdot(l1, d2, 1, d1, 1);
        }
    }
    catch (err) {
        var d1 = this.data;
        var d2 = x.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            result += d1[i] * d2[i];
        }
    }
    return result;
};

},{"../util":130,"./":78,"nblas":2}],65:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
var rotate = function (x, c, s, k, l, i, j) {
    var _a = __read(x.shape, 1), n = _a[0];
    var d1 = x.data;
    var temp = d1[k * n + l];
    var tau = 1 / (c + s);
    d1[k * n + l] = temp - s * (d1[i * n + j] + tau * temp);
    d1[i * n + j] += s * (temp - tau * d1[i * n + j]);
};
_1.NDArray.eig = function (x) { return _1.NDArray.array(x).eig(); };
_1.NDArray.prototype.eig = function () {
    this.square();
    var _a = __read(this.shape, 1), n = _a[0];
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var jobvl = nlapack.NoEigenvector;
        var jobvr = nlapack.Eigenvector;
        var wr = _1.NDArray.zeros(n);
        var wi = _1.NDArray.zeros(n);
        var vl = _1.NDArray.zeros(n, n);
        var vr = _1.NDArray.zeros(n, n);
        var d1 = this.data;
        var d2 = wr.data;
        var d3 = wi.data;
        var d4 = vl.data;
        var d5 = vr.data;
        if (this.dtype === 'float64') {
            nlapack.dgeev(jobvl, jobvr, n, d1, n, d2, d3, d4, n, d5, n);
        }
        if (this.dtype === 'float32') {
            nlapack.sgeev(jobvl, jobvr, n, d1, n, d2, d3, d4, n, d5, n);
        }
        return [wr, vr];
    }
    catch (err) {
        var d1 = this.data;
        var p = _1.NDArray.eye(n);
        var max = 0;
        var i = 0;
        var j = 0;
        var k = 0;
        var l = 0;
        do {
            for (i = 0; i < n; i += 1) {
                for (j = i + 1; j < n; j += 1) {
                    if (Math.abs(d1[i * n + j]) >= max) {
                        max = Math.abs(d1[i * n + j]);
                        k = i;
                        l = j;
                    }
                }
            }
            var t = void 0;
            if (Math.abs(d1[k * n + l]) < Math.abs(d1[l * n + l]) * 1e-36) {
                t = d1[k * n + l] / d1[l * n + l];
            }
            else {
                var phi = d1[l * n + l] / 2 * d1[k * n + l];
                t = 1 / (Math.abs(phi) + Math.sqrt(phi * phi + 1));
            }
            var c = 1 / Math.sqrt(t * t + 1);
            var s = t * c;
            var e = d1[k * n + l];
            d1[k * n + l] = 0;
            d1[k * n + k] -= t * e;
            d1[l * n + l] += t * e;
            for (i = 0; i < k; i += 1) {
                rotate(this, c, s, i, k, i, l);
            }
            for (i = k + 1; i < l; i += 1) {
                rotate(this, c, s, k, i, i, l);
            }
            for (i = l + 1; i < n; i += 1) {
                rotate(this, c, s, k, i, l, i);
            }
            for (i = 0; i < n; i += 1) {
                rotate(p, c, s, i, k, i, l);
            }
        } while (max >= 1e-9);
        return [this.diagonal(), p];
    }
};

},{"../util":130,"./":78,"nlapack":2}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.equals = function (x, y) {
    return _1.NDArray.array(x).equals(_1.NDArray.array(y));
};
_1.NDArray.prototype.equals = function (x) {
    this.equilateral(x);
    this.equidimensional(x);
    var _a = this, d1 = _a.data, l1 = _a.length;
    var d2 = x.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        if (d1[i] !== d2[i]) {
            return false;
        }
    }
    return true;
};

},{"./":78}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.equidimensional = function (x, y) {
    _1.NDArray.array(x).equidimensional(_1.NDArray.array(y));
};
_1.NDArray.prototype.equidimensional = function (x) {
    var s1 = this.shape;
    var s2 = x.shape;
    if (!s1.every(function (dim, i) { return dim === s2[i]; })) {
        throw new Error("shapes " + s1 + " and " + s2 + " do not match");
    }
};

},{"./":78}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.equilateral = function (x, y) {
    _1.NDArray.array(x).equilateral(_1.NDArray.array(y));
};
_1.NDArray.prototype.equilateral = function (x) {
    var l1 = this.length;
    var l2 = x.length;
    if (l1 !== l2) {
        throw new Error("lengths " + l1 + " and " + l2 + " do not match");
    }
};

},{"./":78}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.exp = function (x) { return _1.NDArray.array(x).exp(); };
_1.NDArray.prototype.exp = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.exp(d1[i]);
    }
    return this;
};

},{"./":78}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.expm1 = function (x) { return _1.NDArray.array(x).expm1(); };
_1.NDArray.prototype.expm1 = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.expm1(d1[i]);
    }
    return this;
};

},{"./":78}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.eye = function (n) {
    var x = new this(new Float32Array(n * n), { shape: [n, n] });
    var d1 = x.data;
    var i;
    var j;
    for (i = 0; i < n; i += 1) {
        for (j = 0; j < n; j += 1) {
            d1[i * n + j] = i === j ? 1 : 0;
        }
    }
    return x;
};

},{"./":78}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.fill = function (x, value) {
    if (value === void 0) { value = 0; }
    return _1.NDArray.array(x).fill(value);
};
_1.NDArray.prototype.fill = function (value) {
    if (value === void 0) { value = 0; }
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = value instanceof Function ? value(i) : value;
    }
    return this;
};

},{"./":78}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.floor = function (x) { return _1.NDArray.array(x).floor(); };
_1.NDArray.prototype.floor = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.floor(d1[i]);
    }
    return this;
};

},{"./":78}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.forEach = function (x, f) {
    x.forEach(f);
};
_1.NDArray.prototype.forEach = function (f) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        f.call(this, d1[i], i, d1);
    }
};

},{"./":78}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.fround = function (x) { return _1.NDArray.array(x).fround(); };
_1.NDArray.prototype.fround = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.fround(d1[i]);
    }
    return this;
};

},{"./":78}],76:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.gauss = function (x) { return _1.NDArray.array(x).gauss(); };
_1.NDArray.prototype.gauss = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var lead = 0;
    var leadValue;
    var pivot;
    var i;
    var j;
    var k;
    for (i = 0; i < r; i += 1) {
        if (c <= lead) {
            return this;
        }
        j = i;
        while (d1[j * c + lead] === 0) {
            j += 1;
            if (r === j) {
                j = i;
                lead += 1;
                if (c === lead) {
                    return this;
                }
            }
        }
        if (i !== j) {
            this.swap(i, j);
        }
        pivot = d1[i * c + lead];
        if (pivot !== 0) {
            for (k = 0; k < c; k += 1) {
                d1[i * c + k] /= pivot;
            }
        }
        for (j = 0; j < r; j += 1) {
            leadValue = d1[j * c + lead];
            if (j !== i) {
                for (k = 0; k < c; k += 1) {
                    d1[j * c + k] -= d1[i * c + k] * leadValue;
                }
            }
        }
        lead += 1;
    }
    for (i = 0; i < r; i += 1) {
        pivot = 0;
        for (j = 0; j < c; j += 1) {
            if (pivot === 0) {
                pivot = d1[i * c + j];
            }
        }
        if (pivot === 0) {
            for (k = 0; k < c; k += 1) {
                d1[i * c + k] /= pivot;
            }
        }
    }
    return this;
};

},{"./":78}],77:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.get = function (x) {
    var _a;
    var indices = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        indices[_i - 1] = arguments[_i];
    }
    return (_a = _1.NDArray.array(x)).get.apply(_a, __spread(indices));
};
_1.NDArray.prototype.get = function () {
    var indices = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        indices[_i] = arguments[_i];
    }
    this.check.apply(this, __spread(indices));
    var _a = this, d1 = _a.data, s1 = _a.shape;
    var ndim = s1.length;
    var index = indices[ndim - 1];
    var i;
    var j;
    for (i = 0; i < ndim - 1; i += 1) {
        var p = 1;
        for (j = i + 1; j < ndim; j += 1) {
            p *= s1[j];
        }
        index += indices[i] * p;
    }
    return d1[index];
};

},{"./":78}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
exports.inspectSymbol = Symbol.for('nodejs.util.inspect.custom');
var NDArray = (function () {
    function NDArray(data, options) {
        this.data = new Float32Array(0);
        this.dtype = 'float32';
        this.length = 0;
        this.shape = [0];
        if (util_1.is_typed_array(data)) {
            this.data = data;
            this.shape = typeof options === 'object' && options.hasOwnProperty('shape') ? options.shape : [this.data.length];
            this.length = this.data.length;
            this.dtype = typeof options === 'object' && options.hasOwnProperty('dtype') ? options.dtype : util_1.get_dtype(data);
        }
        else if (data instanceof Array) {
            this.data = new (util_1.get_type(this.dtype))(util_1.flatten(data));
            this.shape = util_1.get_shape(data);
            this.length = this.data.length;
        }
        else if (data instanceof NDArray) {
            return data.copy();
        }
    }
    Object.defineProperty(NDArray.prototype, "x", {
        get: function () {
            return this.get(0);
        },
        set: function (value) {
            this.set(0, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "y", {
        get: function () {
            return this.get(1);
        },
        set: function (value) {
            this.set(1, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "z", {
        get: function () {
            return this.get(2);
        },
        set: function (value) {
            this.set(2, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "w", {
        get: function () {
            return this.get(3);
        },
        set: function (value) {
            this.set(3, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "T", {
        get: function () {
            return this.transpose();
        },
        enumerable: true,
        configurable: true
    });
    return NDArray;
}());
exports.NDArray = NDArray;
require("./abs");
require("./acos");
require("./acosh");
require("./add");
require("./angle");
require("./array");
require("./asin");
require("./asinh");
require("./atan");
require("./atanh");
require("./augment");
require("./binOp");
require("./cbrt");
require("./ceil");
require("./check");
require("./combine");
require("./copy");
require("./cos");
require("./cosh");
require("./cross");
require("./det");
require("./diagonal");
require("./dot");
require("./eig");
require("./equals");
require("./equidimensional");
require("./equilateral");
require("./exp");
require("./expm1");
require("./eye");
require("./fill");
require("./floor");
require("./forEach");
require("./fround");
require("./gauss");
require("./get");
require("./inv");
require("./log");
require("./log10");
require("./log1p");
require("./log2");
require("./lu");
require("./lu_factor");
require("./magic");
require("./map");
require("./matrix");
require("./max");
require("./mean");
require("./min");
require("./multiply");
require("./norm");
require("./normalize");
require("./ones");
require("./pow");
require("./prod");
require("./product");
require("./project");
require("./push");
require("./random");
require("./range");
require("./rank");
require("./reciprocal");
require("./reduce");
require("./reshape");
require("./round");
require("./row_add");
require("./scale");
require("./set");
require("./sign");
require("./sin");
require("./sinh");
require("./slice");
require("./solve");
require("./sqrt");
require("./square");
require("./subtract");
require("./sum");
require("./swap");
require("./tan");
require("./tanh");
require("./toArray");
require("./toString");
require("./trace");
require("./transpose");
require("./trunc");
require("./zeros");
try {
    window.v = NDArray;
}
catch (error) { }

},{"../util":130,"./abs":42,"./acos":43,"./acosh":44,"./add":45,"./angle":46,"./array":47,"./asin":48,"./asinh":49,"./atan":50,"./atanh":51,"./augment":52,"./binOp":53,"./cbrt":54,"./ceil":55,"./check":56,"./combine":57,"./copy":58,"./cos":59,"./cosh":60,"./cross":61,"./det":62,"./diagonal":63,"./dot":64,"./eig":65,"./equals":66,"./equidimensional":67,"./equilateral":68,"./exp":69,"./expm1":70,"./eye":71,"./fill":72,"./floor":73,"./forEach":74,"./fround":75,"./gauss":76,"./get":77,"./inv":79,"./log":80,"./log10":81,"./log1p":82,"./log2":83,"./lu":84,"./lu_factor":85,"./magic":86,"./map":87,"./matrix":88,"./max":89,"./mean":90,"./min":91,"./multiply":92,"./norm":93,"./normalize":94,"./ones":95,"./pow":96,"./prod":97,"./product":98,"./project":99,"./push":100,"./random":101,"./range":102,"./rank":103,"./reciprocal":104,"./reduce":105,"./reshape":106,"./round":107,"./row_add":108,"./scale":109,"./set":110,"./sign":111,"./sin":112,"./sinh":113,"./slice":114,"./solve":115,"./sqrt":116,"./square":117,"./subtract":118,"./sum":119,"./swap":120,"./tan":121,"./tanh":122,"./toArray":123,"./toString":124,"./trace":125,"./transpose":126,"./trunc":127,"./zeros":128}],79:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
_1.NDArray.inv = function (x) { return _1.NDArray.array(x).inv(); };
_1.NDArray.prototype.inv = function () {
    this.square();
    var _a = __read(this.shape, 1), n = _a[0];
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var ipiv = new Int32Array(n);
        if (this.dtype === 'float64') {
            nlapack.dgetrf(n, n, d1, n, ipiv);
            nlapack.dgetri(n, d1, n, ipiv);
        }
        else if (this.dtype === 'float32') {
            nlapack.sgetrf(n, n, d1, n, ipiv);
            nlapack.sgetri(n, d1, n, ipiv);
        }
        return this;
    }
    catch (err) {
        var eye = _1.NDArray.eye(n);
        var rref = _1.NDArray.augment(this, eye).gauss();
        var left = _1.NDArray.zeros(n, n);
        var right = _1.NDArray.zeros(n, n);
        var d1 = rref.data;
        var d2 = left.data;
        var d3 = right.data;
        var i = void 0;
        var j = void 0;
        for (i = 0; i < n; i += 1) {
            for (j = 0; j < n + n; j += 1) {
                if (j < n) {
                    d2[i * n + j] = d1[i * (n + n) + j];
                }
                else {
                    d3[i * n + (j - n)] = d1[i * (n + n) + j];
                }
            }
        }
        if (!left.equals(eye)) {
            throw new Error('matrix is not invertible');
        }
        return right;
    }
};

},{"../util":130,"./":78,"nlapack":2}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log = function (x) { return _1.NDArray.array(x).log(); };
_1.NDArray.prototype.log = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log(d1[i]);
    }
    return this;
};

},{"./":78}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log10 = function (x) { return _1.NDArray.array(x).log10(); };
_1.NDArray.prototype.log10 = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log10(d1[i]);
    }
    return this;
};

},{"./":78}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log1p = function (x) { return _1.NDArray.array(x).log1p(); };
_1.NDArray.prototype.log1p = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log1p(d1[i]);
    }
    return this;
};

},{"./":78}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log2 = function (x) { return _1.NDArray.array(x).log2(); };
_1.NDArray.prototype.log2 = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log2(d1[i]);
    }
    return this;
};

},{"./":78}],84:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.lu = function (x) {
    return _1.NDArray.array(x).lu();
};
_1.NDArray.prototype.lu = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var _b = __read(this.copy().lu_factor(), 2), LU = _b[0], ipiv = _b[1];
    var L = LU.copy();
    var T = LU.copy();
    var d1 = L.data;
    var d2 = T.data;
    var i;
    var j;
    for (i = 0; i < r; i += 1) {
        for (j = i; j < c; j += 1) {
            d1[i * c + j] = i === j ? 1 : 0;
        }
    }
    for (i = 0; i < r; i += 1) {
        for (j = 0; j < i && j < c; j += 1) {
            d2[i * c + j] = 0;
        }
    }
    return [L, T, ipiv];
};

},{"./":78}],85:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
_1.NDArray.lu_factor = function (x) {
    return _1.NDArray.array(x).lu_factor();
};
_1.NDArray.prototype.lu_factor = function () {
    var _a = __read(this.shape, 1), n = _a[0];
    var ipiv = new Int32Array(n);
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            nlapack.dgetrf(n, n, d1, n, ipiv);
        }
        else if (this.dtype === 'float32') {
            nlapack.sgetrf(n, n, d1, n, ipiv);
        }
    }
    catch (err) {
        var d1 = this.data;
        var max = void 0;
        var abs = void 0;
        var diag = void 0;
        var p = void 0;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        for (k = 0; k < n; k += 1) {
            p = k;
            max = Math.abs(d1[k * n + k]);
            for (j = k + 1; j < n; j += 1) {
                abs = Math.abs(d1[j * n + k]);
                if (max < abs) {
                    max = abs;
                    p = j;
                }
            }
            ipiv[k] = p + 1;
            if (p !== k) {
                this.swap(k, p);
            }
            diag = d1[k * n + k];
            for (i = k + 1; i < n; i += 1) {
                d1[i * n + k] /= diag;
            }
            for (i = k + 1; i < n; i += 1) {
                for (j = k + 1; j < n - 1; j += 2) {
                    d1[i * n + j] -= d1[i * n + k] * d1[k * n + j];
                    d1[i * n + j + 1] -= d1[i * n + k] * d1[k * n + j + 1];
                }
                if (j === n - 1) {
                    d1[i * n + j] -= d1[i * n + k] * d1[k * n + j];
                }
            }
        }
    }
    return [this, ipiv];
};

},{"../util":130,"./":78,"nlapack":2}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
var magicHelper = function (n, x, y) {
    return (x + y * 2 + 1) % n;
};
_1.NDArray.magic = function (size) {
    if (size < 0) {
        throw new Error('invalid size');
    }
    var d1 = new Float32Array(size * size);
    var i;
    var j;
    for (i = 0; i < size; i += 1) {
        for (j = 0; j < size; j += 1) {
            d1[(size - i - 1) * size + (size - j - 1)] =
                magicHelper(size, size - j - 1, i) * size + magicHelper(size, j, i) + 1;
        }
    }
    return new this(d1, { shape: [size, size] });
};

},{"./":78}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.map = function (x, f) { return _1.NDArray.array(x).map(f); };
_1.NDArray.prototype.map = function (f) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var mapped = this.copy();
    var d2 = mapped.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        d2[i] = f.call(mapped, d1[i], i, d1);
    }
    return mapped;
};

},{"./":78}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.matrix = function (r, c) {
    return new this(new Float32Array(r * c), { shape: [r, c] });
};

},{"./":78}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.max = function (x) { return _1.NDArray.array(x).max(); };
_1.NDArray.prototype.max = function () {
    var l1 = this.length;
    var result = Number.NEGATIVE_INFINITY;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            result = d1[nblas.idamax(l1, d1, 1)];
        }
        if (this.dtype === 'float32') {
            result = d1[nblas.isamax(l1, d1, 1)];
        }
    }
    catch (err) {
        var d1 = this.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            var value = d1[i];
            result = result < value ? value : result;
        }
    }
    return result;
};

},{"../util":130,"./":78,"nblas":2}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.mean = function (x) { return _1.NDArray.array(x).mean(); };
_1.NDArray.prototype.mean = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    var mean = 0;
    for (i = 0; i < l1; i += 1) {
        mean += d1[i];
    }
    return mean / l1;
};

},{"./":78}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.min = function (x) { return _1.NDArray.array(x).min(); };
_1.NDArray.prototype.min = function () {
    var _a = this, data = _a.data, length = _a.length;
    var result = Number.POSITIVE_INFINITY;
    var i;
    for (i = 0; i < length; i += 1) {
        result = result < data[i] ? result : data[i];
    }
    return result;
};

},{"./":78}],92:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.multiply = function (x, y) {
    return _1.NDArray.array(x).multiply(_1.NDArray.array(y));
};
_1.NDArray.prototype.multiply = function (x) {
    var _a = __read(this.shape, 2), r1 = _a[0], c1 = _a[1];
    var _b = __read(x.shape, 2), r2 = _b[0], c2 = _b[1];
    if (c1 !== r2) {
        throw new Error('sizes do not match');
    }
    var y = _1.NDArray.matrix(r1, c2);
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        var d3 = y.data;
        if (this.dtype === 'float64') {
            nblas.dgemm(nblas.NoTrans, nblas.NoTrans, r1, c2, c1, 1, d1, c1, d2, c2, 0, d3, c2);
        }
        else if (this.dtype === 'float32') {
            nblas.sgemm(nblas.NoTrans, nblas.NoTrans, r1, c2, c1, 1, d1, c1, d2, c2, 0, d3, c2);
        }
    }
    catch (err) {
        var d1 = this.data;
        var d2 = x.data;
        var d3 = y.data;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        var sum = void 0;
        for (i = 0; i < r1; i += 1) {
            for (j = 0; j < c2; j += 1) {
                sum = 0;
                for (k = 0; k < c1; k += 1) {
                    sum += d1[i * c1 + k] * d2[k * c2 + j];
                }
                d3[i * c2 + j] = sum;
            }
        }
    }
    return y;
};

},{"../util":130,"./":78,"nblas":2}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.norm = function (x) { return _1.NDArray.array(x).norm(); };
_1.NDArray.prototype.norm = function () {
    var l1 = this.length;
    var result = 0;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            result = nblas.dnrm2(l1, d1, 1);
        }
        if (this.dtype === 'float32') {
            result = nblas.snrm2(l1, d1, 1);
        }
    }
    catch (err) {
        result = Math.sqrt(this.dot(this));
    }
    return result;
};

},{"../util":130,"./":78,"nblas":2}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.normalize = function (x) {
    return _1.NDArray.array(x).normalize();
};
_1.NDArray.prototype.normalize = function () {
    return this.scale(1 / this.norm());
};

},{"./":78}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.ones = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    return new this(new Float32Array(shape.reduce(function (sum, dim) { return sum * dim; }, 1)), { shape: shape }).fill(1);
};

},{"./":78}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.pow = function (x, exponent) {
    return _1.NDArray.array(x).pow(exponent);
};
_1.NDArray.prototype.pow = function (exponent) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.pow(d1[i], exponent);
    }
    return this;
};

},{"./":78}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.prod = function (x) { return _1.NDArray.array(x).prod(); };
_1.NDArray.prototype.prod = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    var prod = 1;
    for (i = 0; i < l1; i += 1) {
        prod *= d1[i];
    }
    return prod;
};

},{"./":78}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.product = function (x, y) {
    return _1.NDArray.array(x).product(_1.NDArray.array(y));
};
_1.NDArray.prototype.product = function (x) {
    this.equilateral(x);
    this.equidimensional(x);
    var _a = this, d1 = _a.data, l1 = _a.length;
    var d2 = x.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] *= d2[i];
    }
    return this;
};

},{"./":78}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.project = function (x, y) {
    return _1.NDArray.array(x).project(_1.NDArray.array(y));
};
_1.NDArray.prototype.project = function (x) {
    return x.scale(this.dot(x) / x.dot(x));
};

},{"./":78}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.push = function (x, value) {
    return _1.NDArray.array(x).push(value);
};
_1.NDArray.prototype.push = function (value) {
    if (this.shape.length !== 1) {
        throw new Error('push operation not permitted for multidimensional arrays');
    }
    var _a = this, d1 = _a.data, l1 = _a.length;
    var l2 = l1 + 1;
    var d2 = new (util_1.get_type(this.dtype))(l2);
    d2.set(d1);
    d2[l1] = value;
    this.data = d2;
    this.length = l2;
    this.shape = [l2];
    return this;
};

},{"../util":130,"./":78}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.random = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    return new this(new Float32Array(shape.reduce(function (sum, dim) { return sum * dim; }, 1)), { shape: shape }).map(function () { return Math.random(); });
};

},{"./":78}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.range = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var type = Float32Array;
    var backwards = false;
    var start;
    var step;
    var end;
    switch (args.length) {
        case 2:
            end = args.pop();
            step = 1;
            start = args.pop();
            break;
        case 3:
            end = args.pop();
            step = args.pop();
            start = args.pop();
            break;
        default:
            throw new Error('invalid range');
    }
    if (end - start < 0) {
        var copy = end;
        end = start;
        start = copy;
        backwards = true;
    }
    if (step > end - start) {
        throw new Error('invalid range');
    }
    var data = new type(Math.ceil((end - start) / step));
    var i = start;
    var j = 0;
    if (backwards) {
        for (; i < end; i += step, j += 1) {
            data[j] = end - i + start;
        }
    }
    else {
        for (; i < end; i += step, j += 1) {
            data[j] = i;
        }
    }
    return new this(data);
};

},{"./":78}],103:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.rank = function (x) { return _1.NDArray.array(x).rank(); };
_1.NDArray.prototype.rank = function () {
    this.gauss();
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var rk = 0;
    var i;
    var j;
    for (i = 0; i < r; i += 1) {
        for (j = i; j < c; j += 1) {
            if (rk <= i && d1[i * c + j] !== 0) {
                rk += 1;
                continue;
            }
        }
    }
    return rk;
};

},{"./":78}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.reciprocal = function (x) {
    return _1.NDArray.array(x).reciprocal();
};
_1.NDArray.prototype.reciprocal = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = 1 / d1[i];
    }
    return this;
};

},{"./":78}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.reduce = function (x, f, initialValue) { return _1.NDArray.array(x).reduce(f, initialValue); };
_1.NDArray.prototype.reduce = function (f, initialValue) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    if (l1 === 0 && typeof initialValue === 'undefined') {
        throw new Error('Reduce of empty matrix with no initial value.');
    }
    var i;
    var value;
    if (typeof initialValue === 'undefined') {
        value = d1[0];
        i = 1;
    }
    else {
        value = initialValue;
        i = 0;
    }
    for (; i < l1; i += 1) {
        value = f.call(this, value, d1[i], i, d1);
    }
    return value;
};

},{"./":78}],106:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.reshape = function (x) {
    var _a;
    var shape = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        shape[_i - 1] = arguments[_i];
    }
    return (_a = _1.NDArray.array(x)).reshape.apply(_a, __spread(shape));
};
_1.NDArray.prototype.reshape = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    var length = this.length;
    if (shape.reduce(function (sum, dim) { return sum * dim; }, 1) !== length) {
        throw new Error("shape " + shape + " does not match length " + length);
    }
    this.shape = shape;
    return this;
};

},{"./":78}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.round = function (x) { return _1.NDArray.array(x).round(); };
_1.NDArray.prototype.round = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.round(d1[i]);
    }
    return this;
};

},{"./":78}],108:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.row_add = function (x, dest, source, scalar) {
    if (scalar === void 0) { scalar = 1; }
    return _1.NDArray.array(x).row_add(dest, source, scalar);
};
_1.NDArray.prototype.row_add = function (dest, source, scalar) {
    if (scalar === void 0) { scalar = 1; }
    this.check(dest, 0);
    this.check(source, 0);
    var _a = __read(this.shape, 2), c = _a[1];
    var d1 = this.data;
    var j;
    for (j = 0; j < c; j += 1) {
        d1[dest * c + j] += d1[source * c + j] * scalar;
    }
    return this;
};

},{"./":78}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.scale = function (x, scalar) {
    return _1.NDArray.array(x).scale(scalar);
};
_1.NDArray.prototype.scale = function (scalar) {
    var l1 = this.length;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            nblas.dscal(l1, scalar, d1, 1);
        }
        else if (this.dtype === 'float32') {
            nblas.sscal(l1, scalar, d1, 1);
        }
    }
    catch (err) {
        var d1 = this.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            d1[i] *= scalar;
        }
    }
    return this;
};

},{"../util":130,"./":78,"nblas":2}],110:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.set = function (x) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    x.set.apply(x, __spread(args));
};
_1.NDArray.prototype.set = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var indices = args.slice(0, -1);
    var value = args[args.length - 1];
    this.check.apply(this, __spread(indices));
    var s1 = this.shape;
    var index = indices[indices.length - 1];
    var i;
    for (i = 0; i < indices.length - 1; i += 1) {
        index += indices[i] * s1[i + 1];
    }
    this.data[index] = value;
};

},{"./":78}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sign = function (x) { return _1.NDArray.array(x).sign(); };
_1.NDArray.prototype.sign = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sign(d1[i]);
    }
    return this;
};

},{"./":78}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sin = function (x) { return _1.NDArray.array(x).sin(); };
_1.NDArray.prototype.sin = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sin(d1[i]);
    }
    return this;
};

},{"./":78}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sinh = function (x) { return _1.NDArray.array(x).sinh(); };
_1.NDArray.prototype.sinh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sinh(d1[i]);
    }
    return this;
};

},{"./":78}],114:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.slice = function (x, start, step, end) {
    return _1.NDArray.array(x).slice(start, step, end);
};
_1.NDArray.prototype.slice = function (begin, end, step) {
    if (begin === void 0) { begin = 0; }
    if (end === void 0) { end = this.shape[0]; }
    if (step === void 0) { step = 1; }
    var _a = this, d1 = _a.data, s1 = _a.shape;
    var ndim = s1.length;
    if (begin < 0 || end < 0) {
        return this.slice(begin < 0 ? ndim + begin : begin, end < 0 ? ndim + end : end);
    }
    if (step === 0) {
        throw new Error('step argument cannot be 0');
    }
    var s2 = __spread([Math.ceil((end - begin) / step)], s1.slice(1));
    var l2 = s2.reduce(function (sum, dim) { return sum * dim; }, 1);
    var d2 = new (util_1.get_type(this.dtype))(l2);
    var i;
    for (i = 0; i < l2; i += 1) {
        d2[i] = d1[begin + i * step];
    }
    this.length = l2;
    this.data = d2;
    this.reshape.apply(this, __spread(s2));
    return this;
};

},{"../util":130,"./":78}],115:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
_1.NDArray.solve = function (x, y) {
    return _1.NDArray.array(x).solve(_1.NDArray.array(y));
};
_1.NDArray.prototype.solve = function (x) {
    var _a = __read(x.shape, 2), n = _a[0], nrhs = _a[1];
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        var ipiv = new Int32Array(n);
        if (this.dtype === 'float64') {
            nlapack.dgesv(n, nrhs, d1, n, ipiv, d2, nrhs);
        }
        else if (this.dtype === 'float32') {
            nlapack.sgesv(n, nrhs, d1, n, ipiv, d2, nrhs);
        }
    }
    catch (err) {
        var _b = __read(this.lu_factor(), 2), LU = _b[0], ipiv = _b[1];
        var d1 = LU.data;
        var d2 = x.data;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        for (i = 0; i < ipiv.length; i += 1) {
            if (i !== ipiv[i] - 1) {
                x.swap(i, ipiv[i] - 1);
            }
        }
        for (k = 0; k < nrhs; k += 1) {
            for (i = 0; i < n; i += 1) {
                for (j = 0; j < i; j += 1) {
                    d2[i * nrhs + k] -= d1[i * n + j] * d2[j * nrhs + k];
                }
            }
            for (i = n - 1; i >= 0; i -= 1) {
                for (j = i + 1; j < n; j += 1) {
                    d2[i * nrhs + k] -= d1[i * n + j] * d2[j * nrhs + k];
                }
                d2[i * nrhs + k] /= d1[i * n + i];
            }
        }
    }
    return x;
};

},{"../util":130,"./":78,"nlapack":2}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sqrt = function (x) { return _1.NDArray.array(x).sqrt(); };
_1.NDArray.prototype.sqrt = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sqrt(d1[i]);
    }
    return this;
};

},{"./":78}],117:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.square = function (x) {
    _1.NDArray.array(x).square();
};
_1.NDArray.prototype.square = function () {
    var length = this.shape.length;
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    if (length !== 2 || r !== c) {
        throw new Error('matrix is not square');
    }
};

},{"./":78}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.subtract = function (x, y) {
    return _1.NDArray.array(x).subtract(_1.NDArray.array(y));
};
_1.NDArray.prototype.subtract = function (x) {
    return this.add(x, -1);
};

},{"./":78}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sum = function (x) { return _1.NDArray.array(x).sum(); };
_1.NDArray.prototype.sum = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    var sum = 0;
    for (i = 0; i < l1; i += 1) {
        sum += d1[i];
    }
    return sum;
};

},{"./":78}],120:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.swap = function (x, i, j) {
    return _1.NDArray.array(x).swap(i, j);
};
_1.NDArray.prototype.swap = function (i, j) {
    this.check(i, 0);
    this.check(j, 0);
    var d1 = this.data;
    var _a = __read(this.shape, 2), c = _a[1];
    var d2 = d1.slice(i * c, (i + 1) * c);
    d1.copyWithin(i * c, j * c, (j + 1) * c);
    d1.set(d2, j * c);
    return this;
};

},{"./":78}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.tan = function (x) { return _1.NDArray.array(x).tan(); };
_1.NDArray.prototype.tan = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.tan(d1[i]);
    }
    return this;
};

},{"./":78}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.tanh = function (x) { return _1.NDArray.array(x).tanh(); };
_1.NDArray.prototype.tanh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.tanh(d1[i]);
    }
    return this;
};

},{"./":78}],123:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.toArray = function (x) { return _1.NDArray.array(x).toArray(); };
_1.NDArray.prototype.toArray = function () {
    var _a = this, l1 = _a.length, s1 = _a.shape;
    var ndim = s1.length;
    var i;
    var j;
    var k;
    var res = [];
    for (i = 0; i < l1; i += 1) {
        var indices = [];
        for (j = 0; j < ndim; j += 1) {
            var p = 1;
            for (k = j + 1; k < ndim; k += 1) {
                p *= s1[k];
            }
            var index = Math.floor(i / p);
            if (j > 0) {
                index %= s1[j];
            }
            indices.push(index);
        }
        var node = res;
        for (j = 0; j < ndim; j += 1) {
            var index = indices[j];
            if (j < ndim - 1) {
                if (!node[index]) {
                    node[index] = [];
                }
                node = node[index];
            }
            else {
                node[index] = this.get.apply(this, __spread(indices));
            }
        }
    }
    return res;
};

},{"./":78}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("util");
var _1 = require("./");
_1.NDArray.toString = function (x) { return x.toString(); };
_1.NDArray.prototype.toString = function () {
    return "array(" + util_1.inspect(this.toArray(), { depth: 10, breakLength: 40 }) + ", dtype=" + this.dtype + ")";
};
_1.NDArray.prototype[_1.inspectSymbol] = _1.NDArray.prototype.toString;

},{"./":78,"util":41}],125:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.trace = function (x) { return _1.NDArray.array(x).trace(); };
_1.NDArray.prototype.trace = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var n = Math.min(r, c);
    var result = 0;
    var j;
    for (j = 0; j < n; j += 1) {
        result += d1[j * c + j];
    }
    return result;
};

},{"./":78}],126:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.transpose = function (x) {
    return _1.NDArray.array(x).transpose();
};
_1.NDArray.prototype.transpose = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var x = this.copy().reshape(c, r);
    var d2 = x.data;
    var i;
    var j;
    for (i = 0; i < r; i += 1) {
        for (j = 0; j < c; j += 1) {
            d2[j * r + i] = d1[i * c + j];
        }
    }
    return x;
};

},{"./":78}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.trunc = function (x) { return _1.NDArray.array(x).trunc(); };
_1.NDArray.prototype.trunc = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.trunc(d1[i]);
    }
    return this;
};

},{"./":78}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.zeros = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    return new this(new Float32Array(shape.reduce(function (sum, dim) { return sum * dim; }, 1)), { shape: shape }).fill(0);
};

},{"./":78}],129:[function(require,module,exports){
"use strict";
var core_1 = require("./core");
module.exports = core_1.NDArray;

},{"./core":78}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = function (input) {
    return input.reduce(function (acc, next) { return acc.concat(Array.isArray(next) ? exports.flatten(next) : next); }, []);
};
exports.get_shape = function (input) { return Array.isArray(input)
    ? [input.length].concat(exports.get_shape(input[0]))
    : []; };
exports.get_dtype = function (input) {
    switch (input.constructor.name) {
        case 'Int8Array': return 'int8';
        case 'Uint8Array': return 'uint8';
        case 'Int16Array': return 'int16';
        case 'Uint16Array': return 'uint16';
        case 'Int32Array': return 'int32';
        case 'Uint32Array': return 'uint32';
        case 'Uint8ClampedArray': return 'uint8c';
        case 'Float64Array': return 'float64';
        default: return 'float32';
    }
};
exports.get_type = function (input) {
    switch (input) {
        case 'int8': return Int8Array;
        case 'uint8': return Uint8Array;
        case 'int16': return Int16Array;
        case 'uint16': return Uint16Array;
        case 'int32': return Int32Array;
        case 'uint32': return Uint32Array;
        case 'uint8c': return Uint8ClampedArray;
        case 'float64': return Float64Array;
        default: return Float32Array;
    }
};
exports.is_typed_array = function (input) {
    return !!(input && input.buffer instanceof ArrayBuffer && input.BYTES_PER_ELEMENT);
};

},{}],"agentmodel":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentModel;

  module.exports = AgentModel = (function() {
    var mergeObjectInto;

    class AgentModel {
      // () => AgentModel
      constructor() {
        this.turtles = {};
        this.patches = {};
        this.links = {};
        this.observer = {};
        this.world = {};
        this.drawingEvents = [];
      }

      // (Array[Updater.Update]) => Unit
      updates(modelUpdates) {
        var i, len, u;
        for (i = 0, len = modelUpdates.length; i < len; i++) {
          u = modelUpdates[i];
          this.update(u);
        }
      }

      // (Updater.Update) => Unit
      update({links, observer, patches, turtles, world, drawingEvents}) {
        var coll, i, id, len, linkBundle, patchBundle, ref, turtleBundle, typeCanDie, updates, varUpdates;
        turtleBundle = {
          updates: turtles,
          coll: this.turtles,
          typeCanDie: true
        };
        patchBundle = {
          updates: patches,
          coll: this.patches,
          typeCanDie: false
        };
        linkBundle = {
          updates: links,
          coll: this.links,
          typeCanDie: true
        };
        ref = [turtleBundle, patchBundle, linkBundle];
        for (i = 0, len = ref.length; i < len; i++) {
          ({coll, typeCanDie, updates} = ref[i]);
          for (id in updates) {
            varUpdates = updates[id];
            if (typeCanDie && varUpdates.WHO === -1) {
              delete coll[id];
            } else {
              mergeObjectInto(varUpdates, this._itemById(coll, id));
            }
          }
        }
        if ((observer != null ? observer[0] : void 0) != null) {
          mergeObjectInto(observer[0], this.observer);
        }
        if ((world != null ? world[0] : void 0) != null) {
          mergeObjectInto(world[0], this.world);
        }
        if (drawingEvents != null) {
          this.drawingEvents = this.drawingEvents.concat(drawingEvents);
        }
      }

      // (Object, String) => Object
      _itemById(coll, id) {
        if (coll[id] == null) {
          coll[id] = {};
        }
        return coll[id];
      }

    };

    // (Object, Object) => Unit
    mergeObjectInto = function(updatedObject, targetObject) {
      var value, variable;
      for (variable in updatedObject) {
        value = updatedObject[variable];
        targetObject[variable.toLowerCase()] = value;
      }
    };

    return AgentModel;

  }).call(this);

}).call(this);

},{}],"bootstrap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  /*
    `Workspace` is needed to do anything.  If you want the core of Tortoise, do `require('engine/workspace')`.
    If you want the peripheral stuff (i.e. because you're a compiler or test infrastructure),
    the other things you might want ought to get initialized by RequireJS here. --JAB (5/7/14)
  */
  require('./agentmodel');

  require('./engine/workspace');

  require('./engine/prim/prims');

  require('./engine/prim/tasks');

  require('./extensions/all');

  require('./util/notimplemented');

  module.exports = function() {};

}).call(this);

},{"./agentmodel":"agentmodel","./engine/prim/prims":"engine/prim/prims","./engine/prim/tasks":"engine/prim/tasks","./engine/workspace":"engine/workspace","./extensions/all":"extensions/all","./util/notimplemented":"util/notimplemented"}],"brazier/array":[function(require,module,exports){
(function() {
  var None, Something, arrayOps, eq, isArray, maybe, ref;

  eq = require('./equals').eq;

  ref = require('./maybe'), maybe = ref.maybe, None = ref.None, Something = ref.Something;

  isArray = require('./type').isArray;

  arrayOps = {
    all: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (!f(x)) {
            return false;
          }
        }
        return true;
      };
    },
    concat: function(xs) {
      return function(ys) {
        return xs.concat(ys);
      };
    },
    contains: function(x) {
      return function(arr) {
        var item, j, len;
        for (j = 0, len = arr.length; j < len; j++) {
          item = arr[j];
          if (eq(x)(item)) {
            return true;
          }
        }
        return false;
      };
    },
    countBy: function(f) {
      return function(arr) {
        var acc, j, key, len, ref1, value, x;
        acc = {};
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          key = f(x);
          value = (ref1 = acc[key]) != null ? ref1 : 0;
          acc[key] = value + 1;
        }
        return acc;
      };
    },
    difference: function(xs) {
      return function(arr) {
        var acc, badBoys, j, len, x;
        acc = [];
        badBoys = arrayOps.unique(arr);
        for (j = 0, len = xs.length; j < len; j++) {
          x = xs[j];
          if (!arrayOps.contains(x)(badBoys)) {
            acc.push(x);
          }
        }
        return acc;
      };
    },
    exists: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (f(x)) {
            return true;
          }
        }
        return false;
      };
    },
    filter: function(f) {
      return function(arr) {
        var j, len, results, x;
        results = [];
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (f(x)) {
            results.push(x);
          }
        }
        return results;
      };
    },
    find: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (f(x)) {
            return Something(x);
          }
        }
        return None;
      };
    },
    findIndex: function(f) {
      return function(arr) {
        var i, j, len, x;
        for (i = j = 0, len = arr.length; j < len; i = ++j) {
          x = arr[i];
          if (f(x)) {
            return Something(i);
          }
        }
        return None;
      };
    },
    flatMap: function(f) {
      return function(arr) {
        var arrs, ref1, x;
        arrs = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = arr.length; j < len; j++) {
            x = arr[j];
            results.push(f(x));
          }
          return results;
        })();
        return (ref1 = []).concat.apply(ref1, arrs);
      };
    },
    flattenDeep: function(arr) {
      var acc, j, len, x;
      acc = [];
      for (j = 0, len = arr.length; j < len; j++) {
        x = arr[j];
        if (isArray(x)) {
          acc = acc.concat(arrayOps.flattenDeep(x));
        } else {
          acc.push(x);
        }
      }
      return acc;
    },
    foldl: function(f) {
      return function(acc) {
        return function(arr) {
          var j, len, out, x;
          out = acc;
          for (j = 0, len = arr.length; j < len; j++) {
            x = arr[j];
            out = f(out, x);
          }
          return out;
        };
      };
    },
    forEach: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          f(x);
        }
      };
    },
    head: function(arr) {
      return arrayOps.item(0)(arr);
    },
    isEmpty: function(arr) {
      return arr.length === 0;
    },
    item: function(index) {
      return function(xs) {
        if ((0 <= index && index < xs.length)) {
          return Something(xs[index]);
        } else {
          return None;
        }
      };
    },
    last: function(arr) {
      return arr[arr.length - 1];
    },
    length: function(arr) {
      return arr.length;
    },
    map: function(f) {
      return function(arr) {
        var j, len, results, x;
        results = [];
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          results.push(f(x));
        }
        return results;
      };
    },
    maxBy: function(f) {
      return function(arr) {
        var j, len, maxX, maxY, x, y;
        maxX = void 0;
        maxY = -Infinity;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          y = f(x);
          if (y > maxY) {
            maxX = x;
            maxY = y;
          }
        }
        return maybe(maxX);
      };
    },
    reverse: function(xs) {
      return xs.slice(0).reverse();
    },
    singleton: function(x) {
      return [x];
    },
    sortBy: function(f) {
      return function(arr) {
        var g;
        g = function(x, y) {
          var fx, fy;
          fx = f(x);
          fy = f(y);
          if (fx < fy) {
            return -1;
          } else if (fx > fy) {
            return 1;
          } else {
            return 0;
          }
        };
        return arr.slice(0).sort(g);
      };
    },
    sortedIndexBy: function(f) {
      return function(arr) {
        return function(x) {
          var i, item, j, len, y;
          y = f(x);
          for (i = j = 0, len = arr.length; j < len; i = ++j) {
            item = arr[i];
            if (y <= f(item)) {
              return i;
            }
          }
          return arr.length;
        };
      };
    },
    tail: function(arr) {
      return arr.slice(1);
    },
    toObject: function(arr) {
      var a, b, j, len, out, ref1;
      out = {};
      for (j = 0, len = arr.length; j < len; j++) {
        ref1 = arr[j], a = ref1[0], b = ref1[1];
        out[a] = b;
      }
      return out;
    },
    unique: function(arr) {
      var acc, j, len, x;
      acc = [];
      for (j = 0, len = arr.length; j < len; j++) {
        x = arr[j];
        if (!arrayOps.contains(x)(acc)) {
          acc.push(x);
        }
      }
      return acc;
    },
    uniqueBy: function(f) {
      return function(arr) {
        var acc, j, len, seen, x, y;
        acc = [];
        seen = [];
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          y = f(x);
          if (!arrayOps.contains(y)(seen)) {
            seen.push(y);
            acc.push(x);
          }
        }
        return acc;
      };
    },
    zip: function(xs) {
      return function(arr) {
        var i, j, length, out, ref1;
        out = [];
        length = Math.min(xs.length, arr.length);
        for (i = j = 0, ref1 = length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          out.push([xs[i], arr[i]]);
        }
        return out;
      };
    }
  };

  module.exports = arrayOps;

}).call(this);

},{"./equals":"brazier/equals","./maybe":"brazier/maybe","./type":"brazier/type"}],"brazier/equals":[function(require,module,exports){
(function() {
  var arrayEquals, booleanEquals, eq, isArray, isBoolean, isNumber, isObject, isString, numberEquals, objectEquals, ref, stringEquals;

  ref = require('./type'), isArray = ref.isArray, isBoolean = ref.isBoolean, isNumber = ref.isNumber, isObject = ref.isObject, isString = ref.isString;

  arrayEquals = function(x) {
    return function(y) {
      var helper;
      helper = function(a, b) {
        var index, item, j, len;
        for (index = j = 0, len = a.length; j < len; index = ++j) {
          item = a[index];
          if (!eq(item)(b[index])) {
            return false;
          }
        }
        return true;
      };
      return (x === y) || (x.length === y.length && helper(x, y));
    };
  };

  booleanEquals = function(x) {
    return function(y) {
      return x === y;
    };
  };

  eq = function(x) {
    return function(y) {
      return (x === y) || (x === void 0 && y === void 0) || (x === null && y === null) || (isNumber(x) && isNumber(y) && ((isNaN(x) && isNaN(y)) || numberEquals(x)(y))) || (isBoolean(x) && isBoolean(y) && booleanEquals(x)(y)) || (isString(x) && isString(y) && stringEquals(x)(y)) || (isObject(x) && isObject(y) && objectEquals(x)(y)) || (isArray(x) && isArray(y) && arrayEquals(x)(y));
    };
  };

  numberEquals = function(x) {
    return function(y) {
      return x === y;
    };
  };

  objectEquals = function(x) {
    return function(y) {
      var helper, xKeys;
      xKeys = Object.keys(x);
      helper = function(a, b) {
        var i, j, key, ref1;
        for (i = j = 0, ref1 = xKeys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          key = xKeys[i];
          if (!eq(x[key])(y[key])) {
            return false;
          }
        }
        return true;
      };
      return (x === y) || (xKeys.length === Object.keys(y).length && helper(x, y));
    };
  };

  stringEquals = function(x) {
    return function(y) {
      return x === y;
    };
  };

  module.exports = {
    arrayEquals: arrayEquals,
    booleanEquals: booleanEquals,
    eq: eq,
    numberEquals: numberEquals,
    objectEquals: objectEquals,
    stringEquals: stringEquals
  };

}).call(this);

},{"./type":"brazier/type"}],"brazier/function":[function(require,module,exports){
(function() {
  var slice = [].slice;

  module.exports = {
    apply: function(f) {
      return function(x) {
        return f(x);
      };
    },
    constantly: function(x) {
      return function() {
        return x;
      };
    },
    curry: function(f) {
      var argsToArray, curryMaster;
      argsToArray = function(args) {
        return Array.prototype.slice.call(args, 0);
      };
      curryMaster = function() {
        var argsThusFar;
        argsThusFar = argsToArray(arguments);
        if (argsThusFar.length >= f.length) {
          return f.apply(null, argsThusFar);
        } else {
          return function() {
            var nextTierArgs;
            nextTierArgs = argsToArray(arguments);
            return curryMaster.apply(null, argsThusFar.concat(nextTierArgs));
          };
        }
      };
      return curryMaster;
    },
    flip: function(f) {
      return function(x) {
        return function(y) {
          return f(y)(x);
        };
      };
    },
    id: function(x) {
      return x;
    },
    pipeline: function() {
      var functions;
      functions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return function() {
        var args, f, fs, h, i, len, out;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        h = functions[0], fs = 2 <= functions.length ? slice.call(functions, 1) : [];
        out = h.apply(null, args);
        for (i = 0, len = fs.length; i < len; i++) {
          f = fs[i];
          out = f(out);
        }
        return out;
      };
    },
    tee: function(f) {
      return function(g) {
        return function(x) {
          return [f(x), g(x)];
        };
      };
    },
    uncurry: function(f) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return args.reduce((function(acc, arg) {
          return acc(arg);
        }), f);
      };
    }
  };

}).call(this);

},{}],"brazier/maybe":[function(require,module,exports){
(function() {
  var maybeOps;

  maybeOps = {
    None: {},
    Something: function(x) {
      return {
        _type: "something",
        _value: x
      };
    },
    filter: function(f) {
      return function(maybe) {
        return maybeOps.flatMap(function(x) {
          if (f(x)) {
            return maybeOps.Something(x);
          } else {
            return maybeOps.None;
          }
        })(maybe);
      };
    },
    flatMap: function(f) {
      return function(maybe) {
        return maybeOps.fold(function() {
          return maybeOps.None;
        })(f)(maybe);
      };
    },
    fold: function(ifNone) {
      return function(ifSomething) {
        return function(maybe) {
          if (maybeOps.isSomething(maybe)) {
            return ifSomething(maybe._value);
          } else {
            return ifNone();
          }
        };
      };
    },
    isSomething: function(arg) {
      var _type;
      _type = arg._type;
      return _type === "something";
    },
    map: function(f) {
      return function(maybe) {
        return maybeOps.fold(function() {
          return maybeOps.None;
        })(function(x) {
          return maybeOps.Something(f(x));
        })(maybe);
      };
    },
    maybe: function(x) {
      if (x != null) {
        return maybeOps.Something(x);
      } else {
        return maybeOps.None;
      }
    },
    toArray: function(maybe) {
      return maybeOps.fold(function() {
        return [];
      })(function(x) {
        return [x];
      })(maybe);
    }
  };

  module.exports = maybeOps;

}).call(this);

},{}],"brazier/number":[function(require,module,exports){
(function() {
  module.exports = {
    multiply: function(x) {
      return function(y) {
        return x * y;
      };
    },
    plus: function(x) {
      return function(y) {
        return x + y;
      };
    },
    rangeTo: function(start) {
      return function(end) {
        var i, results;
        if (start <= end) {
          return (function() {
            results = [];
            for (var i = start; start <= end ? i <= end : i >= end; start <= end ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this);
        } else {
          return [];
        }
      };
    },
    rangeUntil: function(start) {
      return function(end) {
        var i, results;
        if (start < end) {
          return (function() {
            results = [];
            for (var i = start; start <= end ? i < end : i > end; start <= end ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this);
        } else {
          return [];
        }
      };
    }
  };

}).call(this);

},{}],"brazier/object":[function(require,module,exports){
(function() {
  var None, Something, ref;

  ref = require('./maybe'), None = ref.None, Something = ref.Something;

  module.exports = {
    clone: function(obj) {
      var acc, i, j, key, keys, ref1;
      acc = {};
      keys = Object.keys(obj);
      for (i = j = 0, ref1 = keys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        key = keys[i];
        acc[key] = obj[key];
      }
      return acc;
    },
    keys: function(obj) {
      return Object.keys(obj);
    },
    lookup: function(key) {
      return function(obj) {
        if (obj.hasOwnProperty(key)) {
          return Something(obj[key]);
        } else {
          return None;
        }
      };
    },
    pairs: function(obj) {
      var i, j, key, keys, ref1, results;
      keys = Object.keys(obj);
      results = [];
      for (i = j = 0, ref1 = keys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        key = keys[i];
        results.push([key, obj[key]]);
      }
      return results;
    },
    values: function(obj) {
      var i, j, keys, ref1, results;
      keys = Object.keys(obj);
      results = [];
      for (i = j = 0, ref1 = keys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        results.push(obj[keys[i]]);
      }
      return results;
    }
  };

}).call(this);

},{"./maybe":"brazier/maybe"}],"brazier/type":[function(require,module,exports){
(function() {
  module.exports = {
    isArray: function(x) {
      return Array.isArray(x);
    },
    isBoolean: function(x) {
      return typeof x === "boolean";
    },
    isFunction: function(x) {
      return typeof x === "function";
    },
    isNumber: function(x) {
      return typeof x === "number" && !isNaN(x);
    },
    isObject: function(x) {
      return typeof x === "object" && x !== null && !Array.isArray(x);
    },
    isString: function(x) {
      return typeof x === "string";
    }
  };

}).call(this);

},{}],"engine/core/abstractagentset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Death, Iterator, Shufflerator, checks, foldl, keys, map, pipeline, stableSort;

  ({checks} = require('./typechecker'));

  Iterator = require('util/iterator');

  Shufflerator = require('util/shufflerator');

  stableSort = require('util/stablesort');

  ({foldl, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({keys} = require('brazierjs/object'));

  ({
    DeathInterrupt: Death
  } = require('util/exception'));

  // Never instantiate this class directly --JAB (5/7/14)
  module.exports = AbstractAgentSet = class AbstractAgentSet {
    // (Array[T], World, String, String) => AbstractAgentSet
    constructor(_agentArr, _world, _agentTypeName, _specialName) {
      this._agentArr = _agentArr;
      this._world = _world;
      this._agentTypeName = _agentTypeName;
      this._specialName = _specialName;
    }

    // (() => Boolean) => AbstractAgentSet[T]
    agentFilter(f) {
      return this.filter(this._world.selfManager.askAgent(f));
    }

    // (() => Boolean) => Boolean
    agentAll(f) {
      return this._unsafeIterator().all(this._world.selfManager.askAgent(f));
    }

    // (() => Any, Boolean) => Unit
    ask(f, shouldShuffle) {
      var base, iter;
      iter = shouldShuffle ? this.shufflerator() : this.iterator();
      iter.forEach(this._world.selfManager.askAgent(f));
      if (typeof (base = this._world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
        throw new Death;
      }
    }

    // (Array[(Number, Number)]) => AbstractAgentSet[T]
    atPoints(points) {
      var getPatchAt, getSelf;
      getSelf = () => {
        return this._world.selfManager.self();
      };
      getPatchAt = (x, y) => {
        return this._world.getPatchAt(x, y);
      };
      return require('./agentset/atpoints')(getSelf, getPatchAt).call(this, points);
    }

    // (T) => Boolean
    contains(item) {
      return this._unsafeIterator().contains(item);
    }

    // (Array[T]) => AbstractAgentSet[T]
    copyWithNewAgents(agents) {
      return this._generateFrom(agents);
    }

    // ((T) => Boolean) => Boolean
    exists(pred) {
      return this._unsafeIterator().exists(pred);
    }

    // ((T) => Boolean) => Seq[T]
    filter(pred) {
      return this._generateFrom(this._unsafeIterator().filter(pred));
    }

    // ((T) => Unit) => Unit
    forEach(f) {
      this.iterator().forEach(f);
    }

    // () => String
    getSpecialName() {
      return this._specialName;
    }

    // () => Boolean
    isEmpty() {
      return this.size() === 0;
    }

    // () => Iterator[T]
    iterator() {
      return new Iterator(this._agentArr.slice(0));
    }

    // This is marked "private" and named "unsafe" for a reason.  Since it does not copy the underlying agent array
    // it should only be used internally by the agent set when the resulting Iterator will immediately calculate or
    // tranform to a new value for the consumer.  --JMB, August 2018

    // () => Iterator[T]
    _unsafeIterator() {
      return new Iterator(this._agentArr);
    }

    // (() => Number) => AbstractAgentSet[T]
    maxesBy(f) {
      return this.copyWithNewAgents(this._findMaxesBy(f));
    }

    // (Number, () => Number) => AbstractAgentSet[T]
    maxNOf(n, f) {
      return this._findBestNOf(n, f, function(x, y) {
        if (x === y) {
          return 0;
        } else if (x > y) {
          return -1;
        } else {
          return 1;
        }
      });
    }

    // (() => Number) => T
    maxOneOf(f) {
      return this._randomOneOf(this._findMaxesBy(f));
    }

    // (Number, () => Number) => AbstractAgentSet[T]
    minNOf(n, f) {
      return this._findBestNOf(n, f, function(x, y) {
        if (x === y) {
          return 0;
        } else if (x < y) {
          return -1;
        } else {
          return 1;
        }
      });
    }

    // (() => Number) => T
    minOneOf(f) {
      return this._randomOneOf(this._findMinsBy(f));
    }

    // (() => Number) => AbstractAgentSet[T]
    minsBy(f) {
      return this.copyWithNewAgents(this._findMinsBy(f));
    }

    // [Result] @ (() => Result) => Array[Result]
    projectionBy(f) {
      return this.shufflerator().map(this._world.selfManager.askAgent(f));
    }

    // () => T
    randomAgent() {
      var choice, count, iter;
      iter = this._unsafeIterator();
      count = iter.size();
      if (count === 0) {
        return Nobody;
      } else {
        choice = this._world.rng.nextInt(count);
        return iter.nthItem(choice);
      }
    }

    // () => AbstractAgentSet[T]
    shuffled() {
      return this.copyWithNewAgents(this.shufflerator().toArray());
    }

    // () => Shufflerator[T]
    shufflerator() {
      return new Shufflerator(this.toArray(), (function(agent) {
        return (agent != null ? agent.id : void 0) >= 0;
      }), this._world.rng.nextInt);
    }

    // () => Number
    size() {
      return this._unsafeIterator().size();
    }

    // () => Array[T]
    sort() {
      if (this.isEmpty()) {
        return this.toArray();
      } else {
        return stableSort(this._unsafeIterator().toArray())(function(x, y) {
          return x.compare(y).toInt;
        });
      }
    }

    // [U] @ ((T) => U, (U, U) => Int) => Array[T]
    sortOn(f, sortingFunc) {
      var agentValuePairs;
      if (this.isEmpty()) {
        return [];
      } else {
        agentValuePairs = this.shufflerator().toArray().map(function(agent) {
          return [agent, agent.projectionBy(f)];
        });
        return stableSort(agentValuePairs)(sortingFunc).map(function([a, _]) {
          return a;
        });
      }
    }

    // () => Array[T]
    toArray() {
      this._agentArr = this._unsafeIterator().toArray(); // Prune out dead agents --JAB (7/21/14)
      return this._agentArr.slice(0);
    }

    // () => String
    toString() {
      var ref, ref1;
      return (ref = (ref1 = this._specialName) != null ? ref1.toLowerCase() : void 0) != null ? ref : `(agentset, ${this.size()} ${this._agentTypeName})`;
    }

    // (Number, () => Number, (Number, Number) => Number) => AbstractAgentSet[T]
    _findBestNOf(n, f, cStyleComparator) {
      var appendAgent, ask, best, collectWinners, groupByValue, ref, valueToAgentsMap;
      ask = this._world.selfManager.askAgent(f);
      groupByValue = function(acc, agent) {
        var entry, result;
        result = ask(agent);
        if (checks.isNumber(result)) {
          entry = acc[result];
          if (entry != null) {
            entry.push(agent);
          } else {
            acc[result] = [agent];
          }
        }
        return acc;
      };
      appendAgent = function([winners, numAdded], agent) {
        if (numAdded < n) {
          winners.push(agent);
          return [winners, numAdded + 1];
        } else {
          return [winners, numAdded];
        }
      };
      collectWinners = function([winners, numAdded], agents) {
        if (numAdded < n) {
          return foldl(appendAgent)([winners, numAdded])(agents);
        } else {
          return [winners, numAdded];
        }
      };
      valueToAgentsMap = foldl(groupByValue)({})(this.shufflerator().toArray());
      ref = pipeline(keys, map(parseFloat), (function(x) {
        return x.sort(cStyleComparator);
      }), map(function(value) {
        return valueToAgentsMap[value];
      }), foldl(collectWinners)([[], 0]))(valueToAgentsMap), best = ref[0], ref[1];
      return this._generateFrom(best);
    }

    // (Array[T]) => T
    _randomOneOf(agents) {
      if (agents.length === 0) {
        return Nobody;
      } else {
        return agents[this._world.rng.nextInt(agents.length)];
      }
    }

    // (Number, (Number, Number) => Boolean, () => Number) => Array[T]
    _findBestOf(worstPossible, findIsBetter, f) {
      var foldFunc, ref, winners;
      foldFunc = ([currentBest, currentWinners], agent) => {
        var result;
        result = this._world.selfManager.askAgent(f)(agent);
        if (result === currentBest) {
          currentWinners.push(agent);
          return [currentBest, currentWinners];
        } else if (checks.isNumber(result) && findIsBetter(result, currentBest)) {
          return [result, [agent]];
        } else {
          return [currentBest, currentWinners];
        }
      };
      ref = foldl(foldFunc)([worstPossible, []])(this._unsafeIterator().toArray()), ref[0], winners = ref[1];
      return winners;
    }

    // [U] @ (() => U) => Array[T]
    _findMaxesBy(f) {
      return this._findBestOf(-2e308, (function(result, currentBest) {
        return result > currentBest;
      }), f);
    }

    // [U] @ (() => U) => Array[T]
    _findMinsBy(f) {
      return this._findBestOf(2e308, (function(result, currentBest) {
        return result < currentBest;
      }), f);
    }

    // (Array[T]) => This[T]
    _generateFrom(newAgentArr) {
      return new this.constructor(newAgentArr, this._world);
    }

    // (() => Boolean) => AgentSet
    _optimalOtherWith(f) {
      var filterer, self;
      self = this._world.selfManager.self();
      filterer = function(x) {
        return x !== self && x.projectionBy(f);
      };
      return this.copyWithNewAgents(this._unsafeIterator().filter(filterer));
    }

    // (() => Boolean) => Agent
    _optimalOneOfWith(f) {
      var finder;
      finder = function(x) {
        return x.projectionBy(f);
      };
      return this.shufflerator().find(finder, Nobody);
    }

    // (() => Boolean) => Boolean
    _optimalAnyWith(f) {
      return this.exists(this._world.selfManager.askAgent(f));
    }

    // (() => Boolean) => Boolean
    _optimalAnyOtherWith(f) {
      var checker, self;
      self = this._world.selfManager.self();
      checker = function(x) {
        return x !== self && x.projectionBy(f);
      };
      return this.exists(checker);
    }

    // (() => Boolean) => Number
    _optimalCountOtherWith(f) {
      var filterer, self;
      self = this._world.selfManager.self();
      filterer = function(x) {
        return x !== self && x.projectionBy(f);
      };
      return this._unsafeIterator().filter(filterer).length;
    }

    // (() => Boolean) => Number
    _optimalCountWith(f) {
      var filterer;
      filterer = function(x) {
        return x.projectionBy(f);
      };
      return this._unsafeIterator().filter(filterer).length;
    }

    // (Number, (Number, Number) => Boolean) => Boolean
    _optimalCheckCount(n, operator) {
      return this._unsafeIterator().checkCount(n, operator);
    }

  };

}).call(this);

},{"./agentset/atpoints":"engine/core/agentset/atpoints","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object","util/exception":"util/exception","util/iterator":"util/iterator","util/shufflerator":"util/shufflerator","util/stablesort":"util/stablesort"}],"engine/core/agentset/atpoints":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var checks, filter, flatMap, genPatchGrabber, getPatchesAtPoints, map, pipeline, unique;

  ({checks} = require('../typechecker'));

  ({filter, flatMap, map, unique} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  // In this file: `this.type` is `AbstractAgentSet[T]`

  // (SelfType, (Number, Number) => Patch) => (Number, Number) => Patch
  genPatchGrabber = function(self, worldPatchAt) {
    if (self === 0) {
      return worldPatchAt;
    } else if (checks.isTurtle(self) || checks.isPatch(self)) {
      return self.patchAt;
    } else {
      return function() {
        return Nobody;
      };
    }
  };

  // ((Any) => String, (Number, Number) => Patch, Array[(Number, Number)]) => Array[Patch]
  getPatchesAtPoints = function(patchAt, points) {
    var f;
    f = function(point) {
      return patchAt(...point);
    };
    return pipeline(map(f), filter(function(x) {
      return x !== Nobody;
    }))(points);
  };

  // ((Any) => String, () => Agent, (Number, Number) => Patch) => (Array[Any]) => AbstractAgentSet[T]
  module.exports = function(getSelf, getPatchAt) {
    return function(points) {
      var breedName, copyThatFloppy, filterContaining, newAgents, patchAt, patches, turtlesOnPatches, upperBreedName;
      filterContaining = filter((x) => {
        return this.contains(x);
      });
      breedName = this.getSpecialName();
      patchAt = genPatchGrabber(getSelf(), getPatchAt);
      patches = getPatchesAtPoints(patchAt, points);
      newAgents = checks.isPatchSet(this) ? breedName === "patches" ? patches : filterContaining(patches) : checks.isTurtleSet(this) ? (turtlesOnPatches = pipeline(flatMap(function(p) {
        return p.turtlesHere().toArray();
      }), unique)(patches), breedName === "turtles" ? turtlesOnPatches : breedName != null ? (upperBreedName = breedName.toUpperCase(), filter(function(x) {
        return upperBreedName === x.getBreedName();
      })(turtlesOnPatches)) : filterContaining(turtlesOnPatches)) : []; // Breed set
      copyThatFloppy = (x) => {
        return this.copyWithNewAgents.call(this, x);
      };
      return pipeline(unique, copyThatFloppy)(newAgents);
    };
  };

}).call(this);

},{"../typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function"}],"engine/core/agenttoint":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var checks;

  ({checks} = require('./typechecker'));

  module.exports = function(agent) {
    if (checks.isTurtle(agent)) {
      return 1;
    } else if (checks.isPatch(agent)) {
      return 2;
    } else if (checks.isLink(agent)) {
      return 3;
    } else {
      return 0;
    }
  };

}).call(this);

},{"./typechecker":"engine/core/typechecker"}],"engine/core/breedmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Breed, BreedManager, count, foldl, getNextOrdinal, isEmpty, last, map, pipeline, sortedIndexBy, toObject, values;

  ({foldl, isEmpty, last, map, sortedIndexBy, toObject} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({values} = require('brazierjs/object'));

  count = 0;

  getNextOrdinal = function() {
    return count++;
  };

  Breed = (function() {
    class Breed {
      
      // (String, String, BreedManager, Array[String], Boolean, String, Array[Agent]) => Breed
      constructor(originalName, originalSingular, _manager, varNames = [], _isDirectedLinkBreed, _shape = void 0, members = []) {
        this.originalName = originalName;
        this.originalSingular = originalSingular;
        this._manager = _manager;
        this.varNames = varNames;
        this._isDirectedLinkBreed = _isDirectedLinkBreed;
        this._shape = _shape;
        this.members = members;
        this.name = this.originalName.toUpperCase();
        this.singular = this.originalSingular.toLowerCase();
        this.ordinal = getNextOrdinal();
      }

      // We can't just set this in the constructor, because people can swoop into the manager and change the turtles'
      // default shape --JAB (5/27/14)
      // () => String
      getShape() {
        var ref;
        return (ref = this._shape) != null ? ref : (this.isLinky() ? this._manager.links()._shape : this._manager.turtles()._shape);
      }

      // (String) => Unit
      setShape(newShape) {
        this._shape = newShape;
      }

      // (Agent) => Unit
      add(newAgent) {
        var howManyToThrowOut, whatToInsert;
        if (isEmpty(this.members) || last(this.members).id < newAgent.id) {
          this.members.push(newAgent);
        } else {
          this.members.splice(this._getAgentIndex(newAgent), howManyToThrowOut = 0, whatToInsert = newAgent);
        }
      }

      // Agent -> Boolean
      contains(agent) {
        return this.members.includes(agent);
      }

      // (Agent) => Unit
      remove(agent) {
        var howManyToThrowOut;
        this.members.splice(this._getAgentIndex(agent), howManyToThrowOut = 1);
        if (this.isLinky() && this.name !== "LINKS") {
          this._manager.links().remove(agent);
        }
        if (!this.isLinky() && this.name !== "TURTLES") {
          this._manager.turtles().remove(agent);
        }
      }

      // () => Boolean
      isLinky() {
        return this._isDirectedLinkBreed != null;
      }

      // () => Boolean
      isUndirected() {
        return this._isDirectedLinkBreed === false;
      }

      // () => Boolean
      isDirected() {
        return this._isDirectedLinkBreed === true;
      }

      // (Agent) => Number
      _getAgentIndex(agent) {
        return sortedIndexBy(function(a) {
          return a.id;
        })(this.members)(agent);
      }

    };

    Breed.prototype.ordinal = void 0; // Number

    return Breed;

  }).call(this);

  module.exports = BreedManager = (function() {
    class BreedManager {
      
      // (Array[BreedObj], Array[String], Array[String]) => BreedManager
      constructor(breedObjs, turtlesOwns = [], linksOwns = []) {
        var defaultBreeds;
        defaultBreeds = {
          TURTLES: new Breed("turtles", "turtle", this, turtlesOwns, void 0, "default"),
          LINKS: new Breed("links", "link", this, linksOwns, false, "default")
        };
        this._breeds = foldl((acc, breedObj) => {
          var breed, ref, trueVarNames;
          trueVarNames = (ref = breedObj.varNames) != null ? ref : [];
          breed = new Breed(breedObj.name, breedObj.singular, this, trueVarNames, breedObj.isDirected);
          acc[breed.name] = breed;
          return acc;
        })(defaultBreeds)(breedObjs);
        this._singularBreeds = pipeline(values, map(function(b) {
          return [b.singular, b];
        }), toObject)(this._breeds);
      }

      // () => Object[Breed]
      breeds() {
        return this._breeds;
      }

      orderedBreeds() {
        if (this._orderedBreeds == null) {
          this._orderedBreeds = Object.getOwnPropertyNames(this._breeds).sort((a, b) => {
            return this._breeds[a].ordinal - this._breeds[b].ordinal;
          });
        }
        return this._orderedBreeds;
      }

      orderedLinkBreeds() {
        if (this._orderedLinkBreeds == null) {
          this._orderedLinkBreeds = this.orderedBreeds().filter((b) => {
            return this._breeds[b].isLinky();
          });
        }
        return this._orderedLinkBreeds;
      }

      orderedTurtleBreeds() {
        if (this._orderedTurtleBreeds == null) {
          this._orderedTurtleBreeds = this.orderedBreeds().filter((b) => {
            return !this._breeds[b].isLinky();
          });
        }
        return this._orderedTurtleBreeds;
      }

      // (String) => Breed
      get(name) {
        return this._breeds[name.toUpperCase()];
      }

      // (String) => Breed
      getSingular(name) {
        return this._singularBreeds[name.toLowerCase()];
      }

      // (String, String) => Unit
      setDefaultShape(breedName, shape) {
        this.get(breedName).setShape(shape.toLowerCase());
      }

      // () => Unit
      setUnbreededLinksUndirected() {
        this.links()._isDirectedLinkBreed = false;
      }

      // () => Unit
      setUnbreededLinksDirected() {
        this.links()._isDirectedLinkBreed = true;
      }

      // () => Breed
      turtles() {
        return this.get("TURTLES");
      }

      // () => Breed
      links() {
        return this.get("LINKS");
      }

    };

    // type BreedObj = { name: String, singular: String, varNames: Array[String], isDirected: Boolean }
    BreedManager.prototype._breeds = void 0; // Object[Breed]

    BreedManager.prototype._singularBreeds = void 0; // Object[Breed]

    return BreedManager;

  }).call(this);

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object"}],"engine/core/colormodel":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BaseColors, BaseRGBs, ColorMax, JSType, NLMath, NamesToIndicesMap, RGBCache, RGBMap, StrictMath, attenuate, attenuateRGB, componentsToKey, foldl, keyToComponents, map, pairs, pipeline, rangeUntil;

  NLMath = require('util/nlmath');

  JSType = require('util/jstype');

  StrictMath = require('shim/strictmath');

  ({foldl, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({rangeUntil} = require('brazierjs/number'));

  ({pairs} = require('brazierjs/object'));

  // type ColorNumber = Number
  // type ColorName   = String
  // type HSB         = (Number, Number, Number)
  // type RGB         = (Number, Number, Number)

  // (Number, Number) => (Number) => Number
  attenuate = function(lowerBound, upperBound) {
    return function(x) {
      if (x < lowerBound) {
        return lowerBound;
      } else if (x > upperBound) {
        return upperBound;
      } else {
        return x;
      }
    };
  };

  // (Number) => Number
  attenuateRGB = attenuate(0, 255);

  // (RGB...) => String
  componentsToKey = function(r, g, b) {
    return `${r}_${g}_${b}`;
  };

  // (String) => RGB
  keyToComponents = function(key) {
    return key.split('_').map(parseFloat);
  };

  ColorMax = 140;

  // Array[ColorNumber]
  BaseColors = map(function(n) {
    return (n * 10) + 5;
  })(rangeUntil(0)(ColorMax / 10));

  // Object[ColorName, Number]
  NamesToIndicesMap = (function() {
    var color, i, j, len, ref, temp;
    temp = {};
    ref = ['gray', 'red', 'orange', 'brown', 'yellow', 'green', 'lime', 'turqoise', 'cyan', 'sky', 'blue', 'violet', 'magenta', 'pink', 'black', 'white'];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      color = ref[i];
      temp[color] = i;
    }
    return temp;
  })();

  // copied from api/Color.scala. note these aren't the same numbers as
  // `map extract-rgb base-colors` gives you; see comments in Scala source --BH
  // Array[RGB]
  BaseRGBs = [
    [
      140,
      140,
      140 // gray       (5)
    ],
    [
      215,
      48,
      39 // red       (15)
    ],
    [
      241,
      105,
      19 // orange    (25)
    ],
    [
      156,
      109,
      70 // brown     (35)
    ],
    [
      237,
      237,
      47 // yellow    (45)
    ],
    [
      87,
      176,
      58 // green     (55)
    ],
    [
      42,
      209,
      57 // lime      (65)
    ],
    [
      27,
      158,
      119 // turquoise (75)
    ],
    [
      82,
      196,
      196 // cyan      (85)
    ],
    [
      43,
      140,
      190 // sky       (95)
    ],
    [
      50,
      92,
      168 // blue     (105)
    ],
    [
      123,
      78,
      163 // violet   (115)
    ],
    [
      166,
      25,
      105 // magenta  (125)
    ],
    [
      224,
      126,
      149 // pink     (135)
    ],
    [
      0,
      0,
      0 // black
    ],
    [
      255,
      255,
      255 // white
    ]
  ];

  // (Array[RGB], Object[String, RGB])
  [RGBCache, RGBMap] = (function() {
    var baseIndex, clamp, colorTimesTen, finalRGB, rgb, rgbCache, rgbMap, step;
    rgbMap = {};
    rgbCache = (function() {
      var j, ref, results;
      results = [];
      for (colorTimesTen = j = 0, ref = ColorMax * 10; (0 <= ref ? j < ref : j > ref); colorTimesTen = 0 <= ref ? ++j : --j) {
        // We do this branching to make sure that the right color
        // is used for white and black, which appear multiple times
        // in NetLogo's nonsensical color space --JAB (9/24/15)
        finalRGB = colorTimesTen === 0 ? [0, 0, 0] : colorTimesTen === 99 ? [255, 255, 255] : (baseIndex = StrictMath.floor(colorTimesTen / 100), rgb = BaseRGBs[baseIndex], step = (colorTimesTen % 100 - 50) / 50.48 + 0.012, clamp = step <= 0 ? function(x) {
          return x;
        } : function(x) {
          return 0xFF - x;
        }, rgb.map(function(x) {
          return x + StrictMath.trunc(clamp(x) * step);
        }));
        rgbMap[componentsToKey(...finalRGB)] = colorTimesTen / 10;
        results.push(finalRGB);
      }
      return results;
    })();
    return [rgbCache, rgbMap];
  })();

  module.exports = {
    COLOR_MAX: ColorMax, // ColorNumber
    BASE_COLORS: BaseColors, // Array[ColorNumber]
    
    // (ColorNumber, ColorNumber) => Boolean
    areRelatedByShade: function(color1, color2) {
      return this._colorIntegral(color1) === this._colorIntegral(color2);
    },
    // [T <: ColorNumber|RGB|ColorName] @ (T) => RGB
    colorToRGB: function(color) {
      var type;
      type = JSType(color);
      if (type.isNumber()) {
        return RGBCache[StrictMath.floor(this.wrapColor(color) * 10)];
      } else if (type.isArray()) {
        return color.map(StrictMath.round);
      } else if (type.isString()) {
        return this._nameToRGB(color);
      } else {
        throw new Error(`Unrecognized color format: ${color}`);
      }
    },
    // [T <: ColorNumber|RGB] @ (T) => HSB
    colorToHSB: function(color) {
      var b, g, r, type;
      type = JSType(color);
      [r, g, b] = (function() {
        if (type.isNumber()) {
          return this.colorToRGB(color);
        } else if (type.isArray()) {
          return color;
        } else {
          throw new Error(`Unrecognized color format: ${color}`);
        }
      }).call(this);
      return this.rgbToHSB(r, g, b);
    },
    // (RGB...) => RGB
    genRGBFromComponents: function(r, g, b) {
      return [r, g, b].map(attenuateRGB);
    },
    // Courtesy of Paul S. at http://stackoverflow.com/a/17243070/1116979 --JAB (9/23/15)
    // (HSB...) => RGB
    hsbToRGB: function(rawH, rawS, rawB) {
      var b, f, h, i, p, q, rgb, s, t;
      h = attenuate(0, 360)(rawH) / 360;
      s = attenuate(0, 100)(rawS) / 100;
      b = attenuate(0, 100)(rawB) / 100;
      i = StrictMath.floor(h * 6);
      f = h * 6 - i;
      p = b * (1 - s);
      q = b * (1 - f * s);
      t = b * (1 - (1 - f) * s);
      rgb = (function() {
        switch (i % 6) {
          case 0:
            return [b, t, p];
          case 1:
            return [q, b, p];
          case 2:
            return [p, b, t];
          case 3:
            return [p, q, b];
          case 4:
            return [t, p, b];
          case 5:
            return [b, p, q];
        }
      })();
      return rgb.map(function(x) {
        return StrictMath.round(x * 255);
      });
    },
    // (HSB...) => ColorNumber
    nearestColorNumberOfHSB: function(h, s, b) {
      return this.nearestColorNumberOfRGB(...this.hsbToRGB(h, s, b));
    },
    // (RGB...) => ColorNumber
    nearestColorNumberOfRGB: function(r, g, b) {
      var blue, colorNumber, green, red, ref;
      red = attenuateRGB(r);
      green = attenuateRGB(g);
      blue = attenuateRGB(b);
      colorNumber = (ref = RGBMap[componentsToKey(red, green, blue)]) != null ? ref : this._estimateColorNumber(red, green, blue);
      return colorNumber;
    },
    // (Number) => ColorNumber
    nthColor: function(n) {
      var index;
      index = n % BaseColors.length;
      return BaseColors[index];
    },
    // ((Number) => Number) => ColorNumber
    randomColor: function(nextInt) {
      var index;
      index = nextInt(BaseColors.length);
      return BaseColors[index];
    },
    // (Array[Number]) => RGB
    rgbList: function(components) {
      return components.map(function(c) {
        return attenuateRGB(StrictMath.ceil(c));
      }).slice(0, 3);
    },
    // Courtesy of Paul S. at http://stackoverflow.com/a/17243070/1116979 --JAB (9/23/15)
    // (RGB...) => HSB
    rgbToHSB: function(rawR, rawG, rawB) {
      var b, brightness, difference, g, hue, max, min, r, saturation;
      r = attenuateRGB(rawR);
      g = attenuateRGB(rawG);
      b = attenuateRGB(rawB);
      max = NLMath.max(r, g, b);
      min = NLMath.min(r, g, b);
      difference = max - min;
      hue = (function() {
        switch (max) {
          case min:
            return 0;
          case r:
            return ((g - b) + difference * (g < b ? 6 : 0)) / (6 * difference);
          case g:
            return ((b - r) + difference * 2) / (6 * difference);
          case b:
            return ((r - g) + difference * 4) / (6 * difference);
        }
      })();
      saturation = max === 0 ? 0 : difference / max;
      brightness = max / 255;
      return [hue * 360, saturation * 100, brightness * 100].map(function(x) {
        return NLMath.precision(x, 3);
      });
    },
    // [T <: ColorNumber|RGB] @ (T) => T
    wrapColor: function(color) {
      var modColor;
      if (JSType(color).isArray()) {
        return color; // Bah!  This branch ought to be equivalent to `color %% ColorMax`, but that causes floating-point discrepancies. --JAB (7/30/14)
      } else {
        modColor = color % ColorMax;
        if (modColor >= 0) {
          return modColor;
        } else {
          return ColorMax + modColor;
        }
      }
    },
    // (ColorNumber, Number, Number, Number) => Number
    scaleColor: function(color, number, min, max) {
      var finalPercent, percent, percent10, tempmax, tempval;
      percent = min > max ? number < max ? 1.0 : number > min ? 0.0 : (tempval = min - number, tempmax = min - max, tempval / tempmax) : number > max ? 1.0 : number < min ? 0.0 : (tempval = number - min, tempmax = max - min, tempval / tempmax);
      percent10 = percent * 10;
      finalPercent = percent10 >= 9.9999 ? 9.9999 : percent10 < 0 ? 0 : percent10;
      return this._colorIntegral(color) * 10 + finalPercent;
    },
    // (ColorNumber) => Number
    _colorIntegral: function(color) {
      return StrictMath.floor(this.wrapColor(color) / 10);
    },
    // (ColorName) => RGB
    _nameToRGB: function(name) {
      return BaseRGBs[NamesToIndicesMap[name]];
    },
    // (RGB...) => ColorNumber
    _estimateColorNumber: function(r, g, b) {
      var f;
      f = (acc, [k, v]) => {
        var cb, cg, cr, dist;
        [cr, cg, cb] = keyToComponents(k);
        dist = this._colorDistance(r, g, b, cr, cg, cb);
        if (dist < acc[1]) {
          return [v, dist];
        } else {
          return acc;
        }
      };
      return pipeline(pairs, foldl(f)([0, Number.MAX_VALUE]))(RGBMap)[0];
    },
    // CoffeeScript code from the Scala code in Headless' './parser-core/src/main/core/Color.scala',
    // which was translated from Java code that came from a C snippet at www.compuphase.com/cmetric.htm
    // Dealwithit --JAB (9/24/15)
    // (Number, Number, Number, Number, Number, Number) => Number
    _colorDistance: function(r1, g1, b1, r2, g2, b2) {
      var bDiff, gDiff, rDiff, rMean;
      rMean = r1 + StrictMath.floor(r2 / 2);
      rDiff = r1 - r2;
      gDiff = g1 - g2;
      bDiff = b1 - b2;
      return (((512 + rMean) * rDiff * rDiff) >> 8) + 4 * gDiff * gDiff + (((767 - rMean) * bDiff * bDiff) >> 8);
    }
  };

  // I don't know what this code means.
// Leave a comment on this webzone if you know what this code means --JAB (9/24/15)

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/number":"brazier/number","brazierjs/object":"brazier/object","shim/strictmath":"shim/strictmath","util/jstype":"util/jstype","util/nlmath":"util/nlmath"}],"engine/core/link/linkvariables":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, ImmutableVariableSpec, MutableVariableSpec, Setters, VariableSpecs, checks, setBreed, setColor, setEnd1, setEnd2, setIsHidden, setLabel, setLabelColor, setShape, setThickness, setTieMode;

  ColorModel = require('engine/core/colormodel');

  ({checks} = require('engine/core/typechecker'));

  ({ImmutableVariableSpec, MutableVariableSpec} = require('../structure/variablespec'));

  // In this file: `this.type` is `Link`

  // (String) => Unit
  setShape = function(shape) {
    this._shape = shape.toLowerCase();
    this._genVarUpdate("shape");
  };

  // (AbstractAgentSet|Breed|String) => Unit
  setBreed = function(breed) {
    var newNames, oldNames, ref, ref1, ref2, specialName, trueBreed;
    trueBreed = (function() {
      if (checks.isString(breed)) {
        return this.world.breedManager.get(breed);
      } else if (checks.isAgentSet(breed)) {
        specialName = breed.getSpecialName();
        if ((specialName != null) && this.world.breedManager.get(specialName).isLinky()) {
          return this.world.breedManager.get(specialName);
        } else {
          throw new Error("You can't set BREED to a non-link-breed agentset.");
        }
      } else {
        return breed;
      }
    }).call(this);
    this.world.linkManager.trackBreedChange(this, trueBreed, (ref = (ref1 = this._breed) != null ? ref1.name : void 0) != null ? ref : "");
    if (this._breed !== trueBreed) {
      trueBreed.add(this);
      if ((ref2 = this._breed) != null) {
        ref2.remove(this);
      }
      newNames = this._varNamesForBreed(trueBreed);
      oldNames = this._varNamesForBreed(this._breed);
      this._varManager.refineBy(oldNames, newNames);
    }
    this._breed = trueBreed;
    this._genVarUpdate("breed");
    setShape.call(this, trueBreed.getShape());
    this._refreshName();
    if (!this.world.breedManager.links().contains(this)) {
      this.world.breedManager.links().add(this);
    }
  };

  // (Number) => Unit
  setColor = function(color) {
    this._color = ColorModel.wrapColor(color);
    this._genVarUpdate("color");
  };

  // (Turtle) => Unit
  setEnd1 = function(turtle) {
    this.end1 = turtle;
    this._genVarUpdate("end1");
  };

  // (Turtle) => Unit
  setEnd2 = function(turtle) {
    this.end2 = turtle;
    this._genVarUpdate("end2");
  };

  // (Boolean) => Unit
  setIsHidden = function(isHidden) {
    this._isHidden = isHidden;
    this._genVarUpdate("hidden?");
  };

  // (String) => Unit
  setLabel = function(label) {
    this._label = label;
    this._genVarUpdate("label");
  };

  // (Number) => Unit
  setLabelColor = function(color) {
    this._labelcolor = ColorModel.wrapColor(color);
    this._genVarUpdate("label-color");
  };

  // (Number) => Unit
  setThickness = function(thickness) {
    this._thickness = thickness;
    this._genVarUpdate("thickness");
  };

  // (String) => Unit
  setTieMode = function(mode) {
    this.tiemode = mode;
    this._genVarUpdate("tie-mode");
  };

  Setters = {setBreed, setColor, setEnd1, setEnd2, setIsHidden, setLabel, setLabelColor, setShape, setThickness, setTieMode};

  VariableSpecs = [
    new MutableVariableSpec('breed',
    (function() {
      return this._getLinksByBreedName(this._breed.name);
    }),
    setBreed),
    new MutableVariableSpec('color',
    (function() {
      return this._color;
    }),
    setColor),
    new MutableVariableSpec('end1',
    (function() {
      return this.end1;
    }),
    setEnd1),
    new MutableVariableSpec('end2',
    (function() {
      return this.end2;
    }),
    setEnd2),
    new MutableVariableSpec('hidden?',
    (function() {
      return this._isHidden;
    }),
    setIsHidden),
    new MutableVariableSpec('label',
    (function() {
      return this._label;
    }),
    setLabel),
    new MutableVariableSpec('label-color',
    (function() {
      return this._labelcolor;
    }),
    setLabelColor),
    new MutableVariableSpec('shape',
    (function() {
      return this._shape;
    }),
    setShape),
    new MutableVariableSpec('thickness',
    (function() {
      return this._thickness;
    }),
    setThickness),
    new MutableVariableSpec('tie-mode',
    (function() {
      return this.tiemode;
    }),
    setTieMode)
  ];

  module.exports = {Setters, VariableSpecs};

}).call(this);

},{"../structure/variablespec":"engine/core/structure/variablespec","engine/core/colormodel":"engine/core/colormodel","engine/core/typechecker":"engine/core/typechecker"}],"engine/core/linkset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, DeadSkippingIterator, JSType, LinkSet;

  AbstractAgentSet = require('./abstractagentset');

  DeadSkippingIterator = require('./structure/deadskippingiterator');

  JSType = require('util/jstype');

  module.exports = LinkSet = class LinkSet extends AbstractAgentSet {
    // [T <: Turtle] @ ((() => Array[T])|Array[T], World, String) => LinkSet
    constructor(agents, world, specialName) {
      super(LinkSet._unwrap(agents, false), world, "links", specialName);
      this._agents = agents;
    }

    // () => Iterator[T]
    iterator() {
      return new DeadSkippingIterator(LinkSet._unwrap(this._agents, true));
    }

    // () => Iterator[T]
    _unsafeIterator() {
      return new DeadSkippingIterator(LinkSet._unwrap(this._agents, false));
    }

    // I know, I know, this is insane, right?  "Why would you do this?!", you demand.  I don't blame you.  I don't like
    // it, either.  But, look... we have a problem on our hands.  Special agentsets are a thing.  They can be stored
    // into variables and then change from some code changing the special agentset.  With turtles, this works out fine,
    // because turtles are ordered by `who` number, and `who` numbers are a function of time, so we can just give a
    // `TurtleSet` a reference to the turtle array and grow it as we see fit.  Unfortunately, links are not quantally
    // ordered; they're ordered based on their properties, so we either need to provide a thunk for getting the latest
    // array, or we need to use a good sorting structure that represents the data as an array under the hood, and then
    // we can pass around that array.  Passing thunks seems to be the better option to me.  --JAB (9/7/14)
    // [T] @ ((() => Array[T])|Array[T]) => Array[T]
    static _unwrap(agents, copy) {
      if (JSType(agents).isFunction()) {
        return agents();
      } else if (copy) {
        return agents.slice(0);
      } else {
        return agents;
      }
    }

  };

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./structure/deadskippingiterator":"engine/core/structure/deadskippingiterator","util/jstype":"util/jstype"}],"engine/core/link":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, AgentException, ColorModel, Death, EQ, ExtraVariableSpec, GT, LT, Link, Setters, Stamp, StampErase, StampMode, TurtleSet, VariableManager, VariableSpecs, linkCompare;

  AbstractAgentSet = require('./abstractagentset');

  ColorModel = require('./colormodel');

  linkCompare = require('./structure/linkcompare');

  VariableManager = require('./structure/variablemanager');

  TurtleSet = require('./turtleset');

  ({
    EQUALS: EQ,
    GREATER_THAN: GT,
    LESS_THAN: LT
  } = require('util/comparator'));

  ({
    AgentException,
    DeathInterrupt: Death
  } = require('util/exception'));

  ({Setters, VariableSpecs} = require('./link/linkvariables'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  StampMode = class StampMode {
    constructor(name1) { // (String) => StampMode
      this.name = name1;
    }

  };

  Stamp = new StampMode("normal");

  StampErase = new StampMode("erase");

  module.exports = Link = (function() {
    class Link {
      
      // The type signatures here can be found to the right of the parameters. --JAB (4/21/15)
      constructor(id, isDirected, end1, end2, world, genUpdate, _registerDeath, _registerRemoval, _registerLinkStamp, _getLinksByBreedName, breed = this.world.breedManager.links(), _color = 5, _isHidden = false, _label = "", _labelcolor = 9.9, _shape = "default", _thickness = 0, tiemode = "none") { // RegLinkStampFunc, (String) => LinkSet, Breed, Number // Boolean, String, Number, String, Number // String
        var varNames;
        this.id = id;
        this.isDirected = isDirected;
        this.end1 = end1;
        this.end2 = end2;
        this.world = world;
        this._registerDeath = _registerDeath;
        this._registerRemoval = _registerRemoval; // Number, Boolean, Turtle, Turtle, World, (Updatable) => (String*) => Unit, (Number) => Unit, (Link) => Unit
        this._registerLinkStamp = _registerLinkStamp;
        this._getLinksByBreedName = _getLinksByBreedName;
        this._color = _color;
        this._isHidden = _isHidden;
        this._label = _label;
        this._labelcolor = _labelcolor;
        this._shape = _shape;
        this._thickness = _thickness;
        this.tiemode = tiemode;
        this._updateVarsByName = genUpdate(this);
        varNames = this._varNamesForBreed(breed);
        this._varManager = this._genVarManager(varNames);
        Setters.setBreed.call(this, breed);
        this.end1.linkManager.add(this);
        this.end2.linkManager.add(this);
        this.updateEndRelatedVars();
        this._updateVarsByName("directed?");
      }

      // () => String
      getBreedName() {
        return this._breed.name;
      }

      // () => String
      getBreedNameSingular() {
        return this._breed.singular;
      }

      // Tragically needed by `LinkCompare` for compliance with NetLogo's insane means of sorting links --JAB (9/6/14)
      // () => Number
      getBreedOrdinal() {
        return this._breed.ordinal;
      }

      // Unit -> String
      getName() {
        return this._name;
      }

      // (String) => Any
      getVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // () => Nothing
      die() {
        this._breed.remove(this);
        if (!this.isDead()) {
          this.end1.linkManager.remove(this);
          this.end2.linkManager.remove(this);
          this._registerRemoval(this);
          this._seppuku();
          this.id = -1;
        }
        throw new Death("Call only from inside an askAgent block");
      }

      // () => Unit
      stamp() {
        this._drawStamp(Stamp);
      }

      // () => Unit
      stampErase() {
        this._drawStamp(StampErase);
      }

      // () => TurtleSet
      bothEnds() {
        return new TurtleSet([this.end1, this.end2], this.world);
      }

      // () => Turtle
      otherEnd() {
        if (this.end1 === this.world.selfManager.myself()) {
          return this.end2;
        } else {
          return this.end1;
        }
      }

      // () => Unit
      tie() {
        Setters.setTieMode.call(this, "fixed");
      }

      // () => Unit
      untie() {
        Setters.setTieMode.call(this, "none");
      }

      // () => Unit
      updateEndRelatedVars() {
        this._updateVarsByName("heading", "size", "midpointx", "midpointy");
      }

      // () => String
      toString() {
        if (!this.isDead()) {
          return `(${this.getName()})`;
        } else {
          return "nobody";
        }
      }

      // () => (Number, Number)
      getCoords() {
        return [this.getMidpointX(), this.getMidpointY()];
      }

      // () => Number
      getHeading() {
        var error;
        try {
          return this.world.topology.towards(this.end1.xcor, this.end1.ycor, this.end2.xcor, this.end2.ycor);
        } catch (error1) {
          error = error1;
          if (error instanceof AgentException) {
            throw new Error("there is no heading of a link whose endpoints are in the same position");
          } else {
            throw error;
          }
        }
      }

      // () => Number
      getMidpointX() {
        return this.world.topology.midpointx(this.end1.xcor, this.end2.xcor);
      }

      // () => Number
      getMidpointY() {
        return this.world.topology.midpointy(this.end1.ycor, this.end2.ycor);
      }

      // () => Number
      getSize() {
        return this.world.topology.distanceXY(this.end1.xcor, this.end1.ycor, this.end2.xcor, this.end2.ycor);
      }

      // (String) => Boolean
      isBreed(breedName) {
        return this._breed.name.toUpperCase() === breedName.toUpperCase();
      }

      // () => Boolean
      isDead() {
        return this.id === -1;
      }

      // (() => Any) => Unit
      ask(f) {
        var base;
        if (!this.isDead()) {
          this.world.selfManager.askAgent(f)(this);
          if (typeof (base = this.world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
            throw new Death;
          }
        } else {
          throw new Error(`That ${this.getBreedNameSingular()} is dead.`);
        }
      }

      // [Result] @ (() => Result) => Result
      projectionBy(f) {
        if (!this.isDead()) {
          return this.world.selfManager.askAgent(f)(this);
        } else {
          throw new Error(`That ${this._breed.singular} is dead.`);
        }
      }

      // (Any) => { toInt: Number }
      compare(x) {
        switch (linkCompare(this, x)) {
          case -1:
            return LT;
          case 0:
            return EQ;
          case 1:
            return GT;
          default:
            throw new Error("Comparison should only yield an integer within the interval [-1,1]");
        }
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // (StampMode) => Unit
      _drawStamp(mode) {
        var color, e1x, e1y, e2x, e2y, error, midX, midY, stampHeading;
        ({
          xcor: e1x,
          ycor: e1y
        } = this.end1);
        ({
          xcor: e2x,
          ycor: e2y
        } = this.end2);
        stampHeading = (function() {
          try {
            return this.world.topology.towards(e1x, e1y, e2x, e2y);
          } catch (error1) {
            error = error1;
            if (error instanceof AgentException) {
              return 0;
            } else {
              throw error;
            }
          }
        }).call(this);
        color = ColorModel.colorToRGB(this._color);
        midX = this.getMidpointX();
        midY = this.getMidpointY();
        this._registerLinkStamp(e1x, e1y, e2x, e2y, midX, midY, stampHeading, color, this._shape, this._thickness, this.isDirected, this.getSize(), this._isHidden, mode.name);
      }

      // Unit -> Unit
      _refreshName() {
        this._name = `${this._breed.singular} ${this.end1.id} ${this.end2.id}`;
      }

      // (Breed) => Array[String]
      _varNamesForBreed(breed) {
        var linksBreed;
        linksBreed = this.world.breedManager.links();
        if (breed === linksBreed || (breed == null)) {
          return linksBreed.varNames;
        } else {
          return linksBreed.varNames.concat(breed.varNames);
        }
      }

      // () => Unit
      _seppuku() {
        this._registerDeath(this.id);
      }

      // (Array[String]) => VariableManager
      _genVarManager(extraVarNames) {
        var allSpecs, extraSpecs;
        extraSpecs = extraVarNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        allSpecs = VariableSpecs.concat(extraSpecs);
        return new VariableManager(this, allSpecs);
      }

      // (String) => Unit
      _genVarUpdate(varName) {
        this._updateVarsByName(varName);
      }

    };

    // type RegLinkStampFunc = (Number, Number, Number, Number, Number, Number, Number, RGB, String, Number, String) => Unit
    Link.prototype._breed = void 0; // Breed

    Link.prototype._name = void 0; // String

    Link.prototype._updateVarsByName = void 0; // (String*) => Unit

    Link.prototype._varManager = void 0; // VariableManager

    return Link;

  }).call(this);

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./colormodel":"engine/core/colormodel","./link/linkvariables":"engine/core/link/linkvariables","./structure/linkcompare":"engine/core/structure/linkcompare","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./turtleset":"engine/core/turtleset","util/comparator":"util/comparator","util/exception":"util/exception"}],"engine/core/observer":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // data Perspective =
  var ExtraVariableSpec, Follow, Observe, Observer, Ride, VariableManager, Watch, agentToInt, checks, difference, forEach, perspectiveFromNum, perspectiveFromString, perspectiveToNum, perspectiveToString;

  Observe = {};

  Ride = {};

  Follow = {};

  Watch = {};

  agentToInt = require('./agenttoint');

  ({checks} = require('./typechecker'));

  VariableManager = require('./structure/variablemanager');

  ({difference, forEach} = require('brazierjs/array'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  perspectiveFromNum = function(num) {
    switch (num) {
      case 0:
        return Observe;
      case 1:
        return Ride;
      case 2:
        return Follow;
      case 3:
        return Watch;
      default:
        throw new Error(`Invalid perspective number: ${num}`);
    }
  };

  perspectiveToNum = function(p) {
    switch (p) {
      case Observe:
        return 0;
      case Ride:
        return 1;
      case Follow:
        return 2;
      case Watch:
        return 3;
      default:
        throw new Error(`Invalid perspective: ${p}`);
    }
  };

  perspectiveFromString = function(str) {
    switch (str) {
      case 'observe':
        return Observe;
      case 'ride':
        return Ride;
      case 'follow':
        return Follow;
      case 'watch':
        return Watch;
      default:
        throw new Error(`Invalid perspective string: ${str}`);
    }
  };

  perspectiveToString = function(p) {
    switch (p) {
      case Observe:
        return 'observe';
      case Ride:
        return 'ride';
      case Follow:
        return 'follow';
      case Watch:
        return 'watch';
      default:
        throw new Error(`Invalid perspective: ${p}`);
    }
  };

  module.exports.Perspective = {Observe, Ride, Follow, Watch, perspectiveFromNum, perspectiveToNum, perspectiveFromString, perspectiveToString};

  module.exports.Observer = Observer = (function() {
    class Observer {
      
      // ((Updatable) => (String*) => Unit, Array[String], Array[String]) => Observer
      constructor(genUpdate, _globalNames, _interfaceGlobalNames) {
        var globalSpecs;
        this._globalNames = _globalNames;
        this._interfaceGlobalNames = _interfaceGlobalNames;
        this._updateVarsByName = genUpdate(this);
        this.resetPerspective();
        globalSpecs = this._globalNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        this._varManager = new VariableManager(this, globalSpecs);
        this._codeGlobalNames = difference(this._globalNames)(this._interfaceGlobalNames);
      }

      // () => Unit
      clearCodeGlobals() {
        forEach((name) => {
          this._varManager[name] = 0;
        })(this._codeGlobalNames);
      }

      // (Turtle) => Unit
      follow(turtle) {
        this._perspective = Follow;
        this._targetAgent = turtle;
        this._updatePerspective();
      }

      // (String) => Any
      getGlobal(varName) {
        return this._varManager[varName];
      }

      // (String) => Any
      getVariable(varName) {
        return this.getGlobal(varName);
      }

      // () => Perspective
      getPerspective() {
        return this._perspective;
      }

      // (Perspective, Agent) => Unit
      setPerspective(perspective, subject) {
        this._perspective = perspective;
        this._targetAgent = subject;
        this._updatePerspective();
      }

      // () => Unit
      resetPerspective() {
        this._perspective = Observe;
        this._targetAgent = null;
        this._updatePerspective();
      }

      // (Turtle) => Unit
      ride(turtle) {
        this._perspective = Ride;
        this._targetAgent = turtle;
        this._updatePerspective();
      }

      // (String, Any) => Unit
      setGlobal(varName, value) {
        this._varManager[varName] = value;
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this.setGlobal(varName, value);
      }

      // () => Agent
      subject() {
        var ref;
        return (ref = this._targetAgent) != null ? ref : Nobody;
      }

      // (Turtle) => Unit
      unfocus(turtle) {
        if (this._targetAgent === turtle) {
          this.resetPerspective();
        }
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // (Agent) => Unit
      watch(agent) {
        this._perspective = Watch;
        this._targetAgent = checks.isTurtle(agent) || checks.isPatch(agent) ? agent : Nobody;
        this._updatePerspective();
      }

      // () => Unit
      _updatePerspective() {
        this._updateVarsByName("perspective", "targetAgent");
      }

      // Used by `Updater` --JAB (9/4/14)
      // () => (Number, Number)
      _getTargetAgentUpdate() {
        if (this._targetAgent != null) {
          return [agentToInt(this._targetAgent), this._targetAgent.id];
        } else {
          return null;
        }
      }

    };

    Observer.prototype.id = 0; // Number

    Observer.prototype._varManager = void 0; // VariableManager

    Observer.prototype._perspective = void 0; // Perspective

    Observer.prototype._targetAgent = void 0; // Agent

    Observer.prototype._codeGlobalNames = void 0; // Array[String]

    Observer.prototype._updateVarsByName = void 0; // (String*) => Unit

    return Observer;

  }).call(this);

}).call(this);

},{"./agenttoint":"engine/core/agenttoint","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array"}],"engine/core/patch/patchvariables":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, ImmutableVariableSpec, MutableVariableSpec, Setters, VariableSpecs, all, isArray, isNumber, setPcolor, setPlabel, setPlabelColor;

  ColorModel = require('engine/core/colormodel');

  ({ImmutableVariableSpec, MutableVariableSpec} = require('../structure/variablespec'));

  ({all} = require('brazierjs/array'));

  ({isArray, isNumber} = require('brazierjs/type'));

  // In this file: `this.type` is `Patch`

  // (Number|(Number, Number, Number)) => Unit
  setPcolor = function(color) {
    var wrappedColor;
    wrappedColor = ColorModel.wrapColor(color);
    if (this._pcolor !== wrappedColor) {
      this._pcolor = wrappedColor;
      this._genVarUpdate("pcolor");
      if ((isNumber(wrappedColor) && wrappedColor !== 0) || (isArray(wrappedColor) && !all(function(n) {
        return n % 10 === 0;
      })(wrappedColor))) {
        this._declareNonBlackPatch();
      }
    }
  };

  // (String) => Unit
  setPlabel = function(label) {
    var isEmpty, wasEmpty;
    wasEmpty = this._plabel === "";
    isEmpty = label === "";
    this._plabel = label;
    this._genVarUpdate("plabel");
    if (isEmpty && !wasEmpty) {
      this._decrementPatchLabelCount();
    } else if (!isEmpty && wasEmpty) {
      this._incrementPatchLabelCount();
    }
  };

  // (Number) => Unit
  setPlabelColor = function(color) {
    this._plabelcolor = ColorModel.wrapColor(color);
    this._genVarUpdate("plabel-color");
  };

  Setters = {setPcolor, setPlabel, setPlabelColor};

  VariableSpecs = [
    new ImmutableVariableSpec('pxcor',
    function() {
      return this.pxcor;
    }),
    new ImmutableVariableSpec('pycor',
    function() {
      return this.pycor;
    }),
    new MutableVariableSpec('pcolor',
    (function() {
      return this._pcolor;
    }),
    setPcolor),
    new MutableVariableSpec('plabel',
    (function() {
      return this._plabel;
    }),
    setPlabel),
    new MutableVariableSpec('plabel-color',
    (function() {
      return this._plabelcolor;
    }),
    setPlabelColor)
  ];

  module.exports = {Setters, VariableSpecs};

}).call(this);

},{"../structure/variablespec":"engine/core/structure/variablespec","brazierjs/array":"brazier/array","brazierjs/type":"brazier/type","engine/core/colormodel":"engine/core/colormodel"}],"engine/core/patchset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Iterator, PatchSet;

  AbstractAgentSet = require('./abstractagentset');

  Iterator = require('util/iterator');

  module.exports = PatchSet = class PatchSet extends AbstractAgentSet {
    // [T <: Patch] @ (Array[T], World, String) => PatchSet
    constructor(agents, world, specialName) {
      super(agents, world, "patches", specialName);
    }

  };

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","util/iterator":"util/iterator"}],"engine/core/patch":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Comparator, Death, ExtraVariableSpec, Patch, Setters, TopologyInterrupt, TurtleSet, VariableManager, VariableSpecs, checks, filter, foldl;

  TurtleSet = require('./turtleset');

  ({checks} = require('./typechecker'));

  VariableManager = require('./structure/variablemanager');

  Comparator = require('util/comparator');

  ({filter, foldl} = require('brazierjs/array'));

  ({
    DeathInterrupt: Death,
    TopologyInterrupt
  } = require('util/exception'));

  ({Setters, VariableSpecs} = require('./patch/patchvariables'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  module.exports = Patch = (function() {
    class Patch {
      
      // (Number, Number, Number, World, (Updatable) => (String*) => Unit, () => Unit, () => Unit, () => Unit, (String) => LinkSet, Number, String, Number) => Patch
      constructor(id, pxcor, pycor, world, _genUpdate, _declareNonBlackPatch, _decrementPatchLabelCount, _incrementPatchLabelCount, _pcolor = 0.0, _plabel = "", _plabelcolor = 9.9) {
        // (Number, Number) => Agent
        this.patchAt = this.patchAt.bind(this);
        this.id = id;
        this.pxcor = pxcor;
        this.pycor = pycor;
        this.world = world;
        this._genUpdate = _genUpdate;
        this._declareNonBlackPatch = _declareNonBlackPatch;
        this._decrementPatchLabelCount = _decrementPatchLabelCount;
        this._incrementPatchLabelCount = _incrementPatchLabelCount;
        this._pcolor = _pcolor;
        this._plabel = _plabel;
        this._plabelcolor = _plabelcolor;
        this._turtles = [];
        this._varManager = this._genVarManager(this.world.patchesOwnNames);
      }

      getName() {
        return `patch ${this.pxcor} ${this.pycor}`;
      }

      // (String) => Any
      getVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // (String) => Any
      getPatchVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setPatchVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // (Turtle) => Unit
      untrackTurtle(turtle) {
        this._turtles.splice(this._turtles.indexOf(turtle, 0), 1);
      }

      // (Turtle) => Unit
      trackTurtle(turtle) {
        this._turtles.push(turtle);
      }

      // () => (Number, Number)
      getCoords() {
        return [this.pxcor, this.pycor];
      }

      // (Agent) => Number
      distance(agent) {
        return this.world.topology.distance(this.pxcor, this.pycor, agent);
      }

      // (Number, Number) => Number
      distanceXY(x, y) {
        return this.world.topology.distanceXY(this.pxcor, this.pycor, x, y);
      }

      // (Turtle|Patch) => Number
      towards(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        return this.towardsXY(x, y);
      }

      // (Number, Number) => Number
      towardsXY(x, y) {
        return this.world.topology.towards(this.pxcor, this.pycor, x, y);
      }

      // () => TurtleSet
      turtlesHere() {
        return new TurtleSet(this._turtles.slice(0), this.world);
      }

      // (() => Any) => Unit
      ask(f) {
        var base;
        this.world.selfManager.askAgent(f)(this);
        if (typeof (base = this.world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
          throw new Death;
        }
      }

      // [Result] @ (() => Result) => Result
      projectionBy(f) {
        return this.world.selfManager.askAgent(f)(this);
      }

      // () => PatchSet
      getNeighbors() {
        return this.world.getNeighbors(this.pxcor, this.pycor);
      }

      // () => PatchSet
      getNeighbors4() {
        return this.world.getNeighbors4(this.pxcor, this.pycor);
      }

      // (Number, String) => TurtleSet
      sprout(n, breedName) {
        return this.world.turtleManager.createTurtles(n, breedName, this.pxcor, this.pycor);
      }

      // (String) => TurtleSet
      breedHere(breedName) {
        return new TurtleSet(this.breedHereArray(breedName), this.world);
      }

      // (String) => Array[Turtle]
      breedHereArray(breedName) {
        return filter(function(turtle) {
          return turtle.getBreedName() === breedName;
        })(this._turtles);
      }

      // (Number, Number) => TurtleSet
      turtlesAt(dx, dy) {
        return this.patchAt(dx, dy).turtlesHere();
      }

      // (String, Number, Number) => TurtleSet
      breedAt(breedName, dx, dy) {
        return this.patchAt(dx, dy).breedHere(breedName);
      }

      patchAt(dx, dy) {
        return this.patchAtCoords(this.pxcor + dx, this.pycor + dy);
      }

      // (Number, Number) => Agent
      patchAtCoords(x, y) {
        return this.world.patchAtCoords(x, y);
      }

      // (Number, Number) => Agent
      patchAtHeadingAndDistance(angle, distance) {
        return this.world.patchAtHeadingAndDistanceFrom(angle, distance, this.pxcor, this.pycor);
      }

      // () => Unit
      watchMe() {
        this.world.observer.watch(this);
      }

      // [T] @ (AbstractAgentSet[T], Number) => AbstractAgentSet[T]
      inRadius(agents, radius) {
        return this.world.topology.inRadius(this.pxcor, this.pycor, agents, radius);
      }

      // (Patch) => { toInt: Number }
      compare(x) {
        return Comparator.numericCompare(this.id, x.id);
      }

      // Unit -> Unit
      isDead() {
        return false;
      }

      // () => String
      toString() {
        return `(${this.getName()})`;
      }

      // () => Unit
      reset() {
        this._varManager.reset(this.world.patchesOwnNames);
        Setters.setPcolor.call(this, 0);
        Setters.setPlabel.call(this, '');
        Setters.setPlabelColor.call(this, 9.9);
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // Array[String] => VariableManager
      _genVarManager(extraVarNames) {
        var allSpecs, extraSpecs;
        extraSpecs = extraVarNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        allSpecs = VariableSpecs.concat(extraSpecs);
        return new VariableManager(this, allSpecs);
      }

      // (String) => Unit
      _genVarUpdate(varName) {
        this._genUpdate(this)(varName);
      }

      // (PatchSet, String) => Number
      _neighborSum(nbs, varName) {
        var f;
        f = function(acc, neighbor) {
          var x;
          x = neighbor.getVariable(varName);
          if (checks.isNumber(x)) {
            return acc + x;
          } else {
            throw new Exception(`noSumOfListWithNonNumbers, ${x}`);
          }
        };
        return foldl(f)(0)(nbs.iterator().toArray());
      }

      // (String) => Number
      _optimalNSum(varName) {
        return this._neighborSum(this.getNeighbors(), varName);
      }

      // (String) => Number
      _optimalNSum4(varName) {
        return this._neighborSum(this.getNeighbors4(), varName);
      }

      _ifFalse(value, replacement) {
        if (value === false) {
          return replacement;
        } else {
          return value;
        }
      }

      // () => Patch
      _optimalPatchHereInternal() {
        return this;
      }

      _optimalPatchNorth() {
        return this.world.topology._getPatchNorth(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchEast() {
        return this.world.topology._getPatchEast(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchSouth() {
        return this.world.topology._getPatchSouth(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchWest() {
        return this.world.topology._getPatchWest(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchNorthEast() {
        return this.world.topology._getPatchNorthEast(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchSouthEast() {
        return this.world.topology._getPatchSouthEast(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchSouthWest() {
        return this.world.topology._getPatchSouthWest(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchNorthWest() {
        return this.world.topology._getPatchNorthWest(this.pxcor, this.pycor) || Nobody;
      }

    };

    Patch.prototype._turtles = void 0; // Array[Turtle]

    Patch.prototype._varManager = void 0; // VariableManager

    return Patch;

  }).call(this);

}).call(this);

},{"./patch/patchvariables":"engine/core/patch/patchvariables","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./turtleset":"engine/core/turtleset","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","util/comparator":"util/comparator","util/exception":"util/exception"}],"engine/core/structure/builtins":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    turtleBuiltins: ["who", "color", "heading", "xcor", "ycor", "shape", "label", "label-color", "breed", "hidden?", "size", "pen-size", "pen-mode"],
    patchBuiltins: ["pxcor", "pycor", "pcolor", "plabel", "plabel-color"],
    linkBuiltins: ["end1", "end2", "color", "label", "label-color", "hidden?", "breed", "thickness", "shape", "tie-mode"],
    linkExtras: ["heading", "size", "lcolor", "llabel", "llabelcolor", "lhidden", "lbreed", "lshape", "midpointx", "midpointy"]
  };

}).call(this);

},{}],"engine/core/structure/deadskippingiterator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var DeadSkippingIterator, Iterator;

  Iterator = require('util/iterator');

  module.exports = DeadSkippingIterator = (function() {
    class DeadSkippingIterator extends Iterator {
      
      // [T] @ (Array[T]) => DeadSkippingIterator
      constructor(items) {
        super(items);
        this._i = 0;
      }

      all(f) {
        var j, len, ref, x;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (!x.isDead()) {
            if (!f(x)) {
              return false;
            }
          }
        }
        return true;
      }

      contains(x) {
        var j, len, ref, y;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          y = ref[j];
          if (!x.isDead()) {
            if (x === y) {
              return true;
            }
          }
        }
        return false;
      }

      exists(f) {
        var j, len, ref, x;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (!x.isDead()) {
            if (f(x)) {
              return true;
            }
          }
        }
        return false;
      }

      filter(f) {
        var j, len, ref, results, x;
        ref = this._items;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if ((!x.isDead()) && f(x)) {
            results.push(x);
          }
        }
        return results;
      }

      // [U] @ ((T) => U) => Array[U]
      map(f) {
        var acc;
        acc = [];
        while (this._hasNext()) {
          acc.push(f(this._next()));
        }
        return acc;
      }

      // ((T) => Unit) => Unit
      forEach(f) {
        while (this._hasNext()) {
          f(this._next());
        }
      }

      // They're asking for the `n`th not-dead item, so every time we see a dead item, increment the index and the `n`.

      // start           iteration 1     iteration 2     iteration 3     iteration 4
      // [0][X][X][1][2] [0][X][X][1][2] [0][X][X][1][2] [0][X][X][1][2] [0][X][X][1][2]
      // i=0                i=1                i=2                i=3                i=4
      //       n=2             n=2                n=3                n=4             n=4

      // (Int) => T
      nthItem(n) {
        var i;
        i = 0;
        while (i <= n) {
          if (this._items[i].isDead()) {
            n++;
          }
          i++;
        }
        return this._items[n];
      }

      // () => Int
      size() {
        return this._items.reduce(function(acc, item) {
          return acc + (item.isDead() ? 0 : 1);
        }, 0);
      }

      // () => Array[T]
      toArray() {
        var acc;
        acc = [];
        while (this._hasNext()) {
          acc.push(this._next());
        }
        return acc;
      }

      // () => Boolean
      _hasNext() {
        this._skipToNext();
        return this._isntEmpty();
      }

      // () => T
      _next() {
        this._skipToNext();
        return this._items[this._i++];
      }

      // () => Unit
      _skipToNext() {
        while (this._isntEmpty() && this._items[this._i].isDead()) {
          this._i++;
        }
      }

      // () => Boolean
      _isntEmpty() {
        return this._i < this._items.length;
      }

      // (Number, (Number, Number) => Boolean) => Boolean
      checkCount(n, check) {
        var j, len, ref, totalCount, x;
        totalCount = 0;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (!(!x.isDead())) {
            continue;
          }
          totalCount += 1;
          if (totalCount > n) {
            return check(totalCount, n);
          }
        }
        return check(totalCount, n);
      }

    };

    DeadSkippingIterator.prototype._i = void 0; // Number

    return DeadSkippingIterator;

  }).call(this);

}).call(this);

},{"util/iterator":"util/iterator"}],"engine/core/structure/linkcompare":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // (Link, Link) => Number
  module.exports = function(a, b) {
    if (a === b) {
      return 0;
    } else if (a.isDead() && b.isDead()) {
      return 0;
    } else if (a.end1.id < b.end1.id) {
      return -1;
    } else if (a.end1.id > b.end1.id) {
      return 1;
    } else if (a.end2.id < b.end2.id) {
      return -1;
    } else if (a.end2.id > b.end2.id) {
      return 1;
    } else if (a.getBreedName() === b.getBreedName()) {
      return 0;
    } else if (a.getBreedName() === "LINKS") {
      return -1;
    } else if (b.getBreedName() === "LINKS") {
      return 1;
    } else if (a.getBreedOrdinal() < b.getBreedOrdinal()) {
      return -1;
    } else if (a.getBreedOrdinal() > b.getBreedOrdinal()) {
      return 1;
    } else {
      return 0;
    }
  };

}).call(this);

},{}],"engine/core/structure/penmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Down, Erase, PenManager, PenStatus, Up;

  PenStatus = class PenStatus {
    constructor(_name) { // (String) => PenStatus
      this._name = _name;
    }

    toString() {
      return this._name; // () => String
    }

  };

  Up = new PenStatus("up");

  Down = new PenStatus("down");

  Erase = new PenStatus("erase");

  PenManager = class PenManager {
    // ((String*) => Unit, Number, PenStatus) => PenManager
    constructor(_updateFunc, _size = 1.0, _status = Up) {
      this._updateFunc = _updateFunc;
      this._size = _size;
      this._status = _status;
    }

    // () => Number
    getSize() {
      return this._size;
    }

    // () => PenStatus
    getMode() {
      return this._status;
    }

    // This is (tragically) JVM NetLogo's idea of sanity... --JAB (5/26/14)
    // (String) => Unit
    setPenMode(position) {
      if (position === Up.toString()) {
        this.raisePen();
      } else if (position === Erase.toString()) {
        this.useEraser();
      } else {
        this.lowerPen();
      }
    }

    // () => Unit
    raisePen() {
      this._updateStatus(Up);
    }

    // () => Unit
    lowerPen() {
      this._updateStatus(Down);
    }

    // () => Unit
    useEraser() {
      this._updateStatus(Erase);
    }

    // (Number) => Unit
    setSize(size) {
      this._updateSize(size);
    }

    // ((String*) => Unit) => PenManager
    clone(updateFunc) {
      return new PenManager(updateFunc, this._size, this._status);
    }

    // (Number) => Unit
    _updateSize(newSize) {
      this._size = newSize;
      this._updateFunc("pen-size");
    }

    // (PenStatus) => Unit
    _updateStatus(newStatus) {
      this._status = newStatus;
      this._updateFunc("pen-mode");
    }

  };

  module.exports = {
    PenManager,
    PenStatus: {Up, Down, Erase}
  };

}).call(this);

},{}],"engine/core/structure/selfmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var DeathInterrupt, SelfManager, ignorantly, ignoring;

  ({DeathInterrupt, ignoring} = require('util/exception'));

  ignorantly = ignoring(DeathInterrupt);

  module.exports = SelfManager = (function() {
    class SelfManager {
      
      // () => SelfManager
      constructor() {
        // () => SelfType
        this.self = this.self.bind(this);
        // Switch from letting CoffeeScript bind "this" to handling it manually to avoid creating extra anonymous functions
        // They add GC pressure, causing runtime slowdown - JMB 07/2017
        // [T] @ (() => T) => (Agent) => T
        this.askAgent = this.askAgent.bind(this);
        this._self = 0;
        this._myself = 0;
      }

      self() {
        return this._self;
      }

      // () => SelfType
      myself() {
        if (this._myself !== 0) {
          return this._myself;
        } else {
          throw new Error("There is no agent for MYSELF to refer to.");
        }
      }

      askAgent(f) {
        var at;
        at = this;
        return function(agent) {
          var oldAgent, oldMyself;
          oldMyself = at._myself;
          oldAgent = at._self;
          at._myself = at._self;
          at._self = agent;
          try {
            return ignorantly(f);
          } finally {
            at._self = oldAgent;
            at._myself = oldMyself;
          }
        };
      }

    };

    // type SelfType = Number|Agent // The type that `self` or `myself` could be at any time
    SelfManager.prototype._self = void 0; // SelfType

    SelfManager.prototype._myself = void 0; // SelfType

    return SelfManager;

  }).call(this);

}).call(this);

},{"util/exception":"util/exception"}],"engine/core/structure/variablemanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec, VariableManager, difference;

  ({difference} = require('brazierjs/array'));

  ({ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec} = require('./variablespec'));

  module.exports = VariableManager = (function() {
    class VariableManager {
      
      // (Agent, Array[VariableSpec[_]]) => VariableManager
      constructor(agent, varSpecs) {
        var name;
        this.agent = agent;
        this._addVarsBySpec(varSpecs);
        this._names = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = varSpecs.length; i < len; i++) {
            ({name} = varSpecs[i]);
            results.push(name);
          }
          return results;
        })();
      }

      // () => Array[String]
      names() {
        return this._names;
      }

      // (Array[String], Array[String]) => Unit
      refineBy(oldNames, newNames) {
        var freshNames, i, invalidatedSetter, len, name, obsoletedNames, specs;
        invalidatedSetter = function(name) {
          return function(value) {
            throw new Error(`${name} is no longer a valid variable.`);
          };
        };
        obsoletedNames = difference(oldNames)(newNames);
        freshNames = difference(newNames)(oldNames);
        specs = freshNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        for (i = 0, len = obsoletedNames.length; i < len; i++) {
          name = obsoletedNames[i];
          this._defineProperty(name, {
            get: void 0,
            set: invalidatedSetter(name),
            configurable: true
          });
        }
        this._addVarsBySpec(specs);
        this._names = difference(this._names)(obsoletedNames).concat(freshNames);
      }

      // (Array[VariableSpec]) => Unit
      reset(varNames) {
        varNames.forEach((name) => {
          return this[name] = 0;
        });
      }

      // (Array[VariableSpec]) => Unit
      _addVarsBySpec(varSpecs) {
        var get, i, len, obj, set, spec;
        for (i = 0, len = varSpecs.length; i < len; i++) {
          spec = varSpecs[i];
          obj = (function() {
            if (spec instanceof ExtraVariableSpec) {
              return {
                configurable: true,
                value: 0,
                writable: true
              };
            } else if (spec instanceof MutableVariableSpec) {
              get = (function(spec) {
                return function() {
                  return spec.get.call(this.agent);
                };
              })(spec);
              set = (function(spec) {
                return function(x) {
                  return spec.set.call(this.agent, x);
                };
              })(spec);
              return {
                configurable: true,
                get,
                set
              };
            } else if (spec instanceof ImmutableVariableSpec) {
              return {
                value: spec.get.call(this.agent),
                writable: false
              };
            } else {
              throw new Error(`Non-exhaustive spec type match: ${typeof spec}!`);
            }
          }).call(this);
          this._defineProperty(spec.name, obj);
        }
      }

      // (String, Object) => Unit
      _defineProperty(propName, config) {
        Object.defineProperty(this, propName, config);
      }

    };

    VariableManager.prototype._names = void 0; // Array[String]

    return VariableManager;

  }).call(this);

}).call(this);

},{"./variablespec":"engine/core/structure/variablespec","brazierjs/array":"brazier/array"}],"engine/core/structure/variablespec":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec, VariableSpec;

  VariableSpec = class VariableSpec {
    // (String) => VariableSpec[T]
    constructor(name1) {
      this.name = name1;
    }

  };

  ExtraVariableSpec = class ExtraVariableSpec extends VariableSpec {};

  ImmutableVariableSpec = class ImmutableVariableSpec extends VariableSpec {
    // (String, () => T) => ImmutableVariableSpec[T]
    constructor(name, get) {
      super(name);
      this.get = get;
    }

  };

  MutableVariableSpec = class MutableVariableSpec extends VariableSpec {
    //(String, () => T, (T) => Unit) => MutableVariableSpec[T]
    constructor(name, get, set) {
      super(name);
      this.get = get;
      this.set = set;
    }

  };

  module.exports = {ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec, VariableSpec};

}).call(this);

},{}],"engine/core/topology/box":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Box, Topology,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  module.exports = Box = (function() {
    class Box extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
      // (Number) => Number
      wrapX(pos) {
        return this._wrapXCautiously(pos);
      }

      // (Number) => Number
      wrapY(pos) {
        return this._wrapYCautiously(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        return (pycor !== this.maxPycor) && this._getPatchAt(pxcor, pycor + 1);
      }

      _getPatchSouth(pxcor, pycor) {
        return (pycor !== this.minPycor) && this._getPatchAt(pxcor, pycor - 1);
      }

      _getPatchEast(pxcor, pycor) {
        return (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor);
      }

      _getPatchWest(pxcor, pycor) {
        return (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        return (pycor !== this.maxPycor) && (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor + 1);
      }

      _getPatchSouthWest(pxcor, pycor) {
        return (pycor !== this.minPycor) && (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor - 1);
      }

      _getPatchSouthEast(pxcor, pycor) {
        return (pycor !== this.minPycor) && (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor - 1);
      }

      _getPatchNorthEast(pxcor, pycor) {
        return (pycor !== this.maxPycor) && (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor + 1);
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, Box);
        return this._shortestNotWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, Box);
        return this._shortestNotWrapped(y1, y2);
      }

    };

    Box.prototype._wrapInX = false; // Boolean

    Box.prototype._wrapInY = false; // Boolean

    return Box;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology"}],"engine/core/topology/diffuser":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // There are some key things to keep in mind to keep this code in sync with how headless/desktop operates:

  // 1. The calculations must be done from patch perspective - diffusing "into" the patch, not "out to" surrounding patches
  // 2. Changes from an earlier patch diffuse are not considered by later patches during a diffuse operation (hence the scratch array).
  // 3. The patch sums must be done in "cross 4" then "diagonal 4" order to keep floating point math happy.
  // 4. The `sum4` method must match what's used by headless/desktop - the high/low sorting is critical for floating point.

  // -JMB March 2018
  var Diffuser;

  module.exports = Diffuser = (function() {
    class Diffuser {
      constructor(_setPatchVariable, _width, _height, wrapInX, wrapInY) {
        this._setPatchVariable = _setPatchVariable;
        this._width = _width;
        this._height = _height;
        this._wrapWest = wrapInX ? this._width - 1 : Diffuser.CENTER;
        this._wrapEast = wrapInX ? 1 - this._width : Diffuser.CENTER;
        this._wrapNorth = wrapInY ? this._height - 1 : Diffuser.CENTER;
        this._wrapSouth = wrapInY ? 1 - this._height : Diffuser.CENTER;
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse to patches)
      diffuse4(varName, coefficient, scratch) {
        this._center4(varName, coefficient, scratch);
        this._xBorders4(varName, coefficient, scratch);
        this._yBorders4(varName, coefficient, scratch);
        return this._corners4(varName, coefficient, scratch);
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse to patches)
      diffuse8(varName, coefficient, scratch) {
        this._center8(varName, coefficient, scratch);
        this._xBorders8(varName, coefficient, scratch);
        this._yBorders8(varName, coefficient, scratch);
        return this._corners8(varName, coefficient, scratch);
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all non-edge patches)
      _center4(varName, coefficient, scratch) {
        var lastX, lastY, x, y;
        lastX = this._width - 1;
        lastY = this._height - 1;
        x = 1;
        while (x < lastX) {
          y = 1;
          while (y < lastY) {
            this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH);
            y += 1;
          }
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all non-edge patches)
      _center8(varName, coefficient, scratch) {
        var lastX, lastY, x, y;
        lastX = this._width - 1;
        lastY = this._height - 1;
        x = 1;
        while (x < lastX) {
          y = 1;
          while (y < lastY) {
            this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH, Diffuser.EAST_NORTH, Diffuser.WEST_NORTH, Diffuser.EAST_SOUTH, Diffuser.WEST_SOUTH);
            y += 1;
          }
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner y-edge patches)
      _yBorders4(varName, coefficient, scratch) {
        var lastX, x, y;
        lastX = this._width - 1;
        x = 1;
        while (x < lastX) {
          y = 0; // wrap to the north
          this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH);
          y = this._height - 1; // wrap to the south
          this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth);
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner y-edge patches)
      _yBorders8(varName, coefficient, scratch) {
        var eastNorth, eastSouth, lastX, westNorth, westSouth, x, y;
        lastX = this._width - 1;
        eastNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapNorth
        });
        westNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapNorth
        });
        eastSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapSouth
        });
        westSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapSouth
        });
        x = 1;
        while (x < lastX) {
          y = 0; // wrap to the north
          this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH, eastNorth, westNorth, Diffuser.EAST_SOUTH, Diffuser.WEST_SOUTH);
          y = this._height - 1; // wrap to the south
          this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth, Diffuser.EAST_NORTH, Diffuser.WEST_NORTH, eastSouth, westSouth);
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner x-edge patches)
      _xBorders4(varName, coefficient, scratch) {
        var lastY, x, y;
        lastY = this._height - 1;
        y = 1;
        while (y < lastY) {
          x = 0; // wrap to the west
          this._patch4(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH);
          x = this._width - 1; // wrap to the east
          this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, Diffuser.SOUTH);
          y += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner x-edge patches)
      _xBorders8(varName, coefficient, scratch) {
        var eastNorth, eastSouth, lastY, westNorth, westSouth, x, y;
        lastY = this._height - 1;
        eastNorth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: -1
        });
        westNorth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: -1
        });
        eastSouth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: 1
        });
        westSouth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: 1
        });
        y = 1;
        while (y < lastY) {
          x = 0; // wrap to the west
          this._patch8(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH, Diffuser.EAST_NORTH, westNorth, Diffuser.EAST_SOUTH, westSouth);
          x = this._width - 1; // wrap to the east
          this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, Diffuser.SOUTH, eastNorth, Diffuser.WEST_NORTH, eastSouth, Diffuser.WEST_SOUTH);
          y += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all corner patches)
      _corners4(varName, coefficient, scratch) {
        var x, y;
        x = 0; // Wrap west
        y = 0; // Wrap to the north
        this._patch4(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH);
        x = 0; // Wrap to the west
        y = this._height - 1; // Wrap to the south
        this._patch4(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth);
        x = this._width - 1; // Wrap to the east
        y = 0; // Wrap to the north
        this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, this._wrapNorth, Diffuser.SOUTH);
        x = this._width - 1; // Wrap east
        y = this._height - 1; // Wrap south
        this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, this._wrapSouth);
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all corner patches)
      _corners8(varName, coefficient, scratch) {
        var eastNorth, eastSouth, westNorth, westSouth, x, y;
        x = 0; // Wrap west
        y = 0; // Wrap to the north
        eastNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapNorth
        });
        westNorth = (this._wrapWest === 0 || this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: this._wrapNorth
        });
        westSouth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: 1
        });
        this._patch8(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH, eastNorth, westNorth, Diffuser.EAST_SOUTH, westSouth);
        x = 0; // Wrap to the west
        y = this._height - 1; // Wrap to the south
        westNorth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: -1
        });
        eastSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapSouth
        });
        westSouth = (this._wrapWest === 0 || this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: this._wrapSouth
        });
        this._patch8(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth, Diffuser.EAST_NORTH, westNorth, eastSouth, westSouth);
        x = this._width - 1; // Wrap to the east
        y = 0; // Wrap to the north
        eastNorth = (this._wrapEast === 0 || this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: this._wrapNorth
        });
        westNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapNorth
        });
        eastSouth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: 1
        });
        this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, this._wrapNorth, Diffuser.SOUTH, eastNorth, westNorth, eastSouth, Diffuser.WEST_SOUTH);
        x = this._width - 1; // Wrap east
        y = this._height - 1; // Wrap south
        eastNorth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: -1
        });
        eastSouth = (this._wrapEast === 0 || this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: this._wrapSouth
        });
        westSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapSouth
        });
        this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, this._wrapSouth, eastNorth, Diffuser.WEST_NORTH, eastSouth, westSouth);
      }

      // (Number, Number, String, Number, Array[Number], Number, Number, Number, Number) => Unit
      // (side effect: diffuse a single patch)
      _patch4(x, y, varName, coefficient, scratch, west, east, north, south) {
        var cn, cs, ec, newVal, oldVal, wc;
        oldVal = scratch[x][y];
        ec = scratch[x + east][y];
        cn = scratch[x][y + north];
        cs = scratch[x][y + south];
        wc = scratch[x + west][y];
        newVal = this._patchVal4(coefficient, oldVal, ec, cn, cs, wc);
        this._setPatchVariable(x, y, varName, newVal, oldVal);
      }

      // (Number, Number, String, Number, Array[Number],
      //   Number, Number, Number, Number
      //   (Number, Number), (Number, Number), (Number, Number), (Number, Number)) => Unit
      // (side effect: diffuse a single patch)
      _patch8(x, y, varName, coefficient, scratch, west, east, north, south, eastNorth, westNorth, eastSouth, westSouth) {
        var cn, cs, ec, en, es, newVal, oldVal, wc, wn, ws;
        oldVal = scratch[x][y];
        ec = scratch[x + east][y];
        cn = scratch[x][y + north];
        cs = scratch[x][y + south];
        wc = scratch[x + west][y];
        en = scratch[x + eastNorth.x][y + eastNorth.y];
        wn = scratch[x + westNorth.x][y + westNorth.y];
        es = scratch[x + eastSouth.x][y + eastSouth.y];
        ws = scratch[x + westSouth.x][y + westSouth.y];
        newVal = this._patchVal8(coefficient, oldVal, ec, cn, cs, wc, en, wn, es, ws);
        this._setPatchVariable(x, y, varName, newVal, oldVal);
      }

      // (Number, Number, Number, Number) => Number
      _patchVal(coefficient, oldVal, sum, dirCount) {
        return oldVal + coefficient * (sum / dirCount - oldVal);
      }

      // (Number, Number, Number, Number, Number, Number) => Number
      _patchVal4(coefficient, oldVal, a, b, c, d) {
        var sum;
        sum = this._sum4(a, b, c, d);
        return this._patchVal(coefficient, oldVal, sum, 4);
      }

      // (Number, Number, Number, Number, Number, Number, Number, Number, Number, Number) => Number
      _patchVal8(coefficient, oldVal, a, b, c, d, e, f, g, h) {
        var sum;
        sum = this._sum8(a, b, c, d, e, f, g, h);
        return this._patchVal(coefficient, oldVal, sum, 8);
      }

      // (Number, Number, Number, Number, Number, Number, Number, Number) => Number
      _sum8(a, b, c, d, e, f, g, h) {
        var sum;
        sum = this._sum4(a, b, c, d);
        return sum + this._sum4(e, f, g, h);
      }

      // (Number, Number, Number, Number) => Number
      _sum4(a, b, c, d) {
        var high1, high2, low1, low2;
        if (a < b) {
          low1 = a;
          high1 = b;
        } else {
          low1 = b;
          high1 = a;
        }
        if (c < d) {
          low2 = c;
          high2 = d;
        } else {
          low2 = d;
          high2 = c;
        }
        if (low2 < high1 && low1 < high2) {
          return (low1 + low2) + (high1 + high2);
        } else {
          return (low1 + high1) + (low2 + high2);
        }
      }

    };

    Diffuser.CENTER = 0;

    Diffuser.WEST = -1;

    Diffuser.EAST = 1;

    Diffuser.NORTH = -1;

    Diffuser.SOUTH = 1;

    Diffuser.CURRENT = Object.freeze({
      x: 0,
      y: 0
    });

    Diffuser.EAST_NORTH = Object.freeze({
      x: 1,
      y: -1
    });

    Diffuser.WEST_SOUTH = Object.freeze({
      x: -1,
      y: 1
    });

    Diffuser.EAST_SOUTH = Object.freeze({
      x: 1,
      y: 1
    });

    Diffuser.WEST_NORTH = Object.freeze({
      x: -1,
      y: -1
    });

    return Diffuser;

  }).call(this);

}).call(this);

},{}],"engine/core/topology/factory":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Box, HorizCylinder, Torus, VertCylinder;

  Box = require('./box');

  HorizCylinder = require('./horizcylinder');

  Torus = require('./torus');

  VertCylinder = require('./vertcylinder');

  // (Boolean, Boolean, Number, Number, Number, Number, () => PatchSet, (Number, Number) => Patch) => Topology
  module.exports = function(wrapsInX, wrapsInY, minX, maxX, minY, maxY, getPatchesFunc, getPatchAtFunc) {
    var TopoClass;
    TopoClass = wrapsInX && wrapsInY ? Torus : wrapsInX ? VertCylinder : wrapsInY ? HorizCylinder : Box;
    return new TopoClass(minX, maxX, minY, maxY, getPatchesFunc, getPatchAtFunc);
  };

}).call(this);

},{"./box":"engine/core/topology/box","./horizcylinder":"engine/core/topology/horizcylinder","./torus":"engine/core/topology/torus","./vertcylinder":"engine/core/topology/vertcylinder"}],"engine/core/topology/horizcylinder":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var HorizCylinder, Topology,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  module.exports = HorizCylinder = (function() {
    class HorizCylinder extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
      // (Number) => Number
      wrapX(pos) {
        return this._wrapXCautiously(pos);
      }

      // (Number) => Number
      wrapY(pos) {
        return this._wrapYLeniently(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchEast(pxcor, pycor) {
        return (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchWest(pxcor, pycor) {
        return (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor, this.minPycor);
        } else {
          return this._getPatchAt(pxcor, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouth(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return false;
        } else if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor - 1, this.minPycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return false;
        } else if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor - 1, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return false;
        } else if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor + 1, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return false;
        } else if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor + 1, this.minPycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor + 1);
        }
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, HorizCylinder);
        return this._shortestNotWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, HorizCylinder);
        return this._shortestYWrapped(y1, y2);
      }

    };

    HorizCylinder.prototype._wrapInX = false; // Boolean

    HorizCylinder.prototype._wrapInY = true; // Boolean

    return HorizCylinder;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology"}],"engine/core/topology/inradiusorcone":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var NLMath, bottomSplitLimits, checks, distance, distanceRaw, distanceWrap, filterPatchesInRadius, filterTurtlesInRadius, getRadius1Patches, getRadius2APatches, getRadius2BPatches, getRegionsBox, getRegionsHorizontal, getRegionsTorus, getRegionsVertical, getSmallRadiusPatches, inCone, inRadius, initialize, leftSplitLimits, makeDistanceSq, makeInExactRadiusSq, makeInRadiusSq, makePatchGetter, makeRegion, makeRegionGetter, makeTargetChecker, maybeAddPatch, rightSplitLimits, searchPatches, searchRegion, splitHorizontal, splitVertical, theTruth, topSplitLimits, topologyHelpers;

  NLMath = require('util/nlmath');

  ({checks} = require('../typechecker'));

  // This `in-radius` code looks pretty weird, huh?  That is for a few reasons:

  // 1. We need to match how NetLogo desktop handles in-radius, especially for
  //    returning agents in the same order for reproducibility.

  // 2. We do want this to be optimized, so we want to *avoid* the following things:
  //    a. Binding our functions. We want to call them without binding a `this`.
  //    b. Using a class.  It would help organize the code, but we don't want member
  //       accessor calls.
  //    c. Worrying about safety checks where possible, when we can make assumptions.
  //    d. Making intermediate objects during the search loop, like arrays or
  //       `new Class()` that would be immediately discarded and add GC pressure

  // More comments about specific oddities are below.

  // -Jeremy B August 2020
  topologyHelpers = {};

  // (Topology) => Unit
  initialize = function(topology) {
    topologyHelpers.getRegions = makeRegionGetter(topology);
    topologyHelpers.getPatchAt = makePatchGetter(topology);
    topologyHelpers.distanceSq = makeDistanceSq(topology);
    topologyHelpers.inRadiusSq = makeInRadiusSq(topology);
  };

  // (Number, Number) => Number
  distanceRaw = function(p1, p2) {
    return NLMath.abs(p1 - p2);
  };

  // Intentionally take in the full and the half values instead of repeatedly
  // calculating the half.  -Jeremy B August 2020
  // (Int, Number, Number, Number) => Number
  distanceWrap = function(full, half, p1, p2) {
    var d;
    d = distanceRaw(p1, p2);
    if (d > half) {
      return full - d;
    } else {
      return d;
    }
  };

  // (Boolean, Int) => (Number, Number) => Number
  distance = function(wrap, full) {
    var half;
    // We don't want to check if we're wrapped for each distance calculation,
    // so just check once and return the appropriate function at the start.
    // -Jeremy B August 2020
    if (wrap) {
      half = full / 2;
      return function(p1, p2) {
        return distanceWrap(full, half, p1, p2);
      };
    } else {
      return distanceRaw;
    }
  };

  // (Topology) => (Int, Int) => Patch
  makePatchGetter = function(topology) {
    var allPatches, maxPycor, minPxcor, width;
    // The world's version of `getPatchAt()` does rounding and such on the
    // provided values.  We don't need that kind of safety here.
    // -Jeremy B August 2020
    width = topology.width;
    maxPycor = topology.maxPycor;
    minPxcor = topology.minPxcor;
    allPatches = topology._getPatches()._agentArr;
    // (Int, Int) => Patch
    return function(pxcor, pycor) {
      var patchIndex;
      patchIndex = (maxPycor - pycor) * width + (pxcor - minPxcor);
      return allPatches[patchIndex];
    };
  };

  // () => true
  theTruth = function() {
    return true;
  };

  // (Agentset, Agentset) => (Agent) => Boolean
  makeTargetChecker = function(agentset, globalName) {
    var specialName;
    // Instead of iterating over the agentset to find ones that might be in the radius,
    // We iterate over patches and only check agents on patches that could be within
    // the radius.  That's how desktop does it, so that's how we do it, too. But we
    // need an easy way to check if an agent from a patch is, you know, actually one
    // of the ones we're supposed to be looking for.
    // -Jeremy B August 2020
    specialName = agentset.getSpecialName();
    if (specialName === globalName) {
      return theTruth;
    } else if (specialName != null) {
      // Do not use `agent.isBreed()` because it calls `toUpperCase()` on the arguments, and they
      // should already be proper case.  -Jeremy B
      return function(agent) {
        return agent._breed.name === specialName;
      };
    } else {
      return function(agent) {
        return agentset.contains(agent);
      };
    }
  };

  // (Topology) => (Number, Number, Number, Number) => Number
  makeDistanceSq = function(topology) {
    var distanceX, distanceY;
    // (Number, Number) => Number
    distanceX = distance(topology._wrapInX, topology.width);
    // (Number, Number) => Number
    distanceY = distance(topology._wrapInY, topology.height);
    return function(x1, y1, x2, y2) {
      var dx, dy;
      dx = distanceX(x1, x2);
      dy = distanceY(y1, y2);
      return (dx * dx) + (dy * dy);
    };
  };

  // (Topology) => (Number, Number, Number, Number, Number) => Boolean
  makeInRadiusSq = function(topology) {
    // We do not ever take the square root of the distances we calculate, because we
    // can just compare the squared values.  -Jeremy B August 2020
    // (Number, Number, Number, Number, Number) => Boolean
    return function(radiusSq, x1, y1, x2, y2) {
      var distanceSq;
      distanceSq = topologyHelpers.distanceSq(x1, y1, x2, y2);
      return distanceSq <= radiusSq;
    };
  };

  // ((Number, Number, Number, Number, Number) => Boolean, Number, Number, Number) => (Number, Number) => Boolean
  makeInExactRadiusSq = function(inRadiusSq, x, y, radius) {
    var exactRadiusSq;
    exactRadiusSq = radius * radius;
    // (Number, Number) => Boolean
    return function(xcor, ycor) {
      return inRadiusSq(exactRadiusSq, x, y, xcor, ycor);
    };
  };

  // (Array[Patch], Patch | false) => Unit
  maybeAddPatch = function(patches, maybePatch) {
    if (maybePatch && !patches.includes(maybePatch)) {
      patches.push(maybePatch);
    }
  };

  // ((Int, Int) => Patch) => Array[Patch]
  getRadius1Patches = function(centerPatch) {
    var neighbors, patches;
    patches = [];
    patches.push(centerPatch);
    // We rely on `getNeighbors()` returning patches in the same order as desktop,
    // which it does, fortunately.  -Jeremy B August 2020.
    neighbors = centerPatch.getNeighbors()._unsafeIterator();
    neighbors.forEach(function(neighbor) {
      return patches.push(neighbor);
    });
    return patches;
  };

  // (Topology, Array[Patch]) => Array[Patch]
  getRadius2APatches = function(topology, patches) {
    var newPatches;
    newPatches = [];
    patches.forEach(function(p) {
      maybeAddPatch(newPatches, p);
      maybeAddPatch(newPatches, topology._getPatchNorth(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchNorthEast(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchEast(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchSouthEast(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchSouth(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchSouthWest(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchWest(p.pxcor, p.pycor));
      return maybeAddPatch(newPatches, topology._getPatchNorthWest(p.pxcor, p.pycor));
    });
    return newPatches;
  };

  // (Array[Patch]) => Array[Patch]
  getRadius2BPatches = function(patches) {
    var newPatches;
    newPatches = patches.slice(0);
    newPatches.push(patches[1]._optimalPatchNorth());
    newPatches.push(patches[2]._optimalPatchEast());
    newPatches.push(patches[3]._optimalPatchSouth());
    newPatches.push(patches[4]._optimalPatchWest());
    newPatches.push(patches[5]._optimalPatchNorth());
    newPatches.push(patches[5]._optimalPatchNorthEast());
    newPatches.push(patches[5]._optimalPatchEast());
    newPatches.push(patches[6]._optimalPatchEast());
    newPatches.push(patches[6]._optimalPatchSouthEast());
    newPatches.push(patches[6]._optimalPatchSouth());
    newPatches.push(patches[7]._optimalPatchSouth());
    newPatches.push(patches[7]._optimalPatchSouthWest());
    newPatches.push(patches[7]._optimalPatchWest());
    newPatches.push(patches[8]._optimalPatchWest());
    newPatches.push(patches[8]._optimalPatchNorthWest());
    newPatches.push(patches[8]._optimalPatchNorth());
    return newPatches;
  };

  // (Topology, Int, Int, Number, (Int, Int) => Patch) => Array[Patch]
  getSmallRadiusPatches = function(topology, patchX, patchY, radius) {
    var patches, smallWorldCheck;
    patches = getRadius1Patches(topologyHelpers.getPatchAt(patchX, patchY));
    // `radius is 0` is another quirk from desktop.  -Jeremy B August 2020
    if (radius > 1 || radius === 0) {
      smallWorldCheck = (topology._wrapInX && topology.width < 5) || (topology._wrapInY && topology.height < 5) || (!topology._wrapInX && (patchX - topology.minPxcor < 2 || topology.maxPxcor - patchX < 2)) || (!topology._wrapInY && (patchY - topology.minPycor < 2 || topology.maxPycor - patchY < 2));
      // I'm sure all of this makes perfect sense, consult the desktop version if you're curious about what
      // `smallWorldCheck` is doing and why.  The patch order we use here must match the order over there, and the order
      // differs between the two branches of this check.  -Jeremy B August 2020
      if (smallWorldCheck) {
        patches = getRadius2APatches(topology, patches);
      } else {
        patches = getRadius2BPatches(patches);
      }
    }
    return patches;
  };

  // (Topology) => (Int, Int, Int) => Array[Region]
  makeRegionGetter = function(topology) {
    var getRegions;
    getRegions = topology._wrapInX ? topology._wrapInY ? getRegionsTorus : getRegionsHorizontal : topology._wrapInY ? getRegionsVertical : getRegionsBox;
    return function(patchX, patchY, patchRadius) {
      return getRegions(topology, patchX, patchY, patchRadius);
    };
  };

  // (Int, Int, Array[Int]) => Region
  makeRegion = function(top, bottom, ...segmentValues) {
    var i, j, ref, segments;
    segments = [];
    for (i = j = 0, ref = segmentValues.length; j < ref; i = j += 2) {
      segments.push({
        left: segmentValues[i],
        right: segmentValues[i + 1]
      });
    }
    return {top, bottom, segments};
  };

  // The various `getRegions*` functions must return the patch coordinates in desktop order - maxPycor to minPycor outer,
  // mminPxcor to maxPxcor inner.  Hence the weirdness with making sure we get the "upper" and "lower" regions correctly
  // ordered, when they exist.
  // - Jeremy B September 2020

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsBox = function(topology, patchX, patchY, patchRadius) {
    var bottom, doubleRadius, left, right, top;
    doubleRadius = patchRadius * 2;
    left = NLMath.max(patchX - patchRadius, topology.minPxcor);
    right = NLMath.min(patchX + patchRadius, topology.maxPxcor);
    top = NLMath.min(patchY + patchRadius, topology.maxPycor);
    bottom = NLMath.max(patchY - patchRadius, topology.minPycor);
    return [makeRegion(top, bottom, left, right)];
  };

  // (Topology, Int, Int) => { upperTop, upperBottom, lowerTop, lowerBottom }
  topSplitLimits = function(topology, maybeTop, maybeBottom) {
    var lowerBottom, lowerTop, upperBottom, upperTop;
    upperTop = topology.maxPycor;
    upperBottom = maybeBottom;
    lowerTop = topology.minPycor + maybeTop - topology.maxPycor;
    lowerBottom = topology.minPycor;
    return {upperTop, upperBottom, lowerTop, lowerBottom};
  };

  // (Topology, Int, Int) => { upperTop, upperBottom, lowerTop, lowerBottom }
  bottomSplitLimits = function(topology, maybeTop, maybeBottom) {
    var lowerBottom, lowerTop, upperBottom, upperTop;
    upperTop = topology.maxPycor;
    upperBottom = topology.maxPycor + (maybeBottom - topology.minPycor);
    lowerTop = maybeTop;
    lowerBottom = topology.minPycor;
    return {upperTop, upperBottom, lowerTop, lowerBottom};
  };

  // (Topology, Int, Int, Int, Int) => Array[Region]
  splitVertical = function(topology, patchY, patchRadius, left, right) {
    var lower, maybeBottom, maybeTop, upper, vertical;
    maybeTop = patchY + patchRadius;
    maybeBottom = patchY - patchRadius;
    if (maybeTop > topology.maxPycor) {
      // wrap the top off -Jeremy B September 2020
      vertical = topSplitLimits(topology, maybeTop, maybeBottom);
      upper = makeRegion(vertical.upperTop, vertical.upperBottom, left, right);
      lower = makeRegion(vertical.lowerTop, vertical.lowerBottom, left, right);
      return [upper, lower];
    }
    if (maybeBottom < topology.minPycor) {
      // wrap the bottom off -Jeremy B September 2020
      vertical = bottomSplitLimits(topology, maybeTop, maybeBottom);
      upper = makeRegion(vertical.upperTop, vertical.upperBottom, left, right);
      lower = makeRegion(vertical.lowerTop, vertical.lowerBottom, left, right);
      return [upper, lower];
    }
    // else wrap neither! -Jeremy B September 2020
    return [makeRegion(maybeTop, maybeBottom, left, right)];
  };

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsVertical = function(topology, patchX, patchY, patchRadius) {
    var doubleRadius, left, right;
    doubleRadius = patchRadius * 2;
    left = NLMath.max(patchX - patchRadius, topology.minPxcor);
    right = NLMath.min(patchX + patchRadius, topology.maxPxcor);
    // handle the "whole world" case so we don't worry about it below. -Jeremy B September 2020
    if (doubleRadius >= (topology.height - 1)) {
      return [makeRegion(topology.maxPycor, topology.minPycor, left, right)];
    }
    return splitVertical(topology, patchY, patchRadius, left, right);
  };

  // (Topology, Int, Int) => Array[Int]
  leftSplitLimits = function(topology, maybeLeft, maybeRight) {
    var segment1Left, segment1Right, segment2Left, segment2Right;
    segment1Left = topology.minPxcor;
    segment1Right = maybeRight;
    segment2Left = topology.maxPxcor + (maybeLeft - topology.minPxcor);
    segment2Right = topology.maxPxcor;
    return [segment1Left, segment1Right, segment2Left, segment2Right];
  };

  // (Topology, Int, Int) => Array[Int]
  rightSplitLimits = function(topology, maybeLeft, maybeRight) {
    var segment1Left, segment1Right, segment2Left, segment2Right;
    segment1Left = topology.minPxcor;
    segment1Right = topology.minPxcor + (maybeRight - topology.maxPxcor);
    segment2Left = maybeLeft;
    segment2Right = topology.maxPxcor;
    return [segment1Left, segment1Right, segment2Left, segment2Right];
  };

  // (Topology, Int, Int, Int, Int) => Array[Region]
  splitHorizontal = function(topology, patchX, patchRadius, top, bottom) {
    var horizontal, maybeLeft, maybeRight;
    maybeLeft = patchX - patchRadius;
    maybeRight = patchX + patchRadius;
    if (maybeLeft < topology.minPxcor) {
      // wrap the left off -Jeremy B September 2020
      horizontal = leftSplitLimits(topology, maybeLeft, maybeRight);
      return [makeRegion(top, bottom, ...horizontal)];
    }
    if (maybeRight > topology.maxPxcor) {
      // wrap the right off -Jeremy B September 2020
      horizontal = rightSplitLimits(topology, maybeLeft, maybeRight);
      return [makeRegion(top, bottom, ...horizontal)];
    }
    // else wrap neither! -Jeremy B September 2020
    return [makeRegion(top, bottom, maybeLeft, maybeRight)];
  };

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsHorizontal = function(topology, patchX, patchY, patchRadius) {
    var bottom, doubleRadius, top;
    doubleRadius = patchRadius * 2;
    top = NLMath.min(patchY + patchRadius, topology.maxPycor);
    bottom = NLMath.max(patchY - patchRadius, topology.minPycor);
    // handle the "whole world" case so we don't worry about it below. -Jeremy B September 2020
    if (doubleRadius >= (topology.width - 1)) {
      return [makeRegion(top, bottom, topology.minPxcor, topology.maxPxcor)];
    }
    return splitHorizontal(topology, patchX, patchRadius, top, bottom);
  };

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsTorus = function(topology, patchX, patchY, patchRadius) {
    var bottom, doubleRadius, horizontal, isBottomInBounds, isLeftInBounds, isRightInBounds, isTopInBounds, left, lower, maybeBottom, maybeLeft, maybeRight, maybeTop, right, top, upper, vertical;
    doubleRadius = patchRadius * 2;
    // handle the "whole world" cases so we don't worry about it below. -Jeremy B September 2020
    if (doubleRadius >= (topology.width - 1)) {
      if (doubleRadius >= (topology.height - 1)) {
        return [makeRegion(topology.maxPycor, topology.minPycor, topology.minPxcor, topology.maxPxcor)];
      } else {
        // we wrapped the whole world width, so this should be a simple vertical wrapping thing. -Jeremy B September 2020
        left = topology.minPxcor;
        right = topology.maxPxcor;
        return splitVertical(topology, patchY, patchRadius, left, right);
      }
    }
    if (doubleRadius >= (topology.height - 1)) {
      // we wrapped the whole world height, so this should be a simple horizontal wrapping thing. -Jeremy B September 2020
      top = topology.maxPycor;
      bottom = topology.minPycor;
      return splitHorizontal(topology, patchX, patchRadius, top, bottom);
    }
    maybeLeft = patchX - patchRadius;
    maybeRight = patchX + patchRadius;
    maybeTop = patchY + patchRadius;
    maybeBottom = patchY - patchRadius;
    isLeftInBounds = maybeLeft >= topology.minPxcor;
    isRightInBounds = maybeRight <= topology.maxPxcor;
    isTopInBounds = maybeTop <= topology.maxPycor;
    isBottomInBounds = maybeBottom >= topology.minPycor;
    // handle the unwrapped case so we don't have to worry about that below. -Jeremy B September 2020
    if (isLeftInBounds && isRightInBounds && isTopInBounds && isBottomInBounds) {
      return [makeRegion(maybeTop, maybeBottom, maybeLeft, maybeRight)];
    }
    // We aren't "whole world" and we aren't unwrapped, so there are a few scenarios left:

    // - There is a single edge outside the world - a simple two region split like vertical/horizontal
    // - There are two adjacent edges outside the world - a point in a "corner" needing four wrapped regions

    // -Jeremy B September 2020
    if (isTopInBounds && isBottomInBounds) {
      return splitHorizontal(topology, patchX, patchRadius, maybeTop, maybeBottom);
    }
    if (isLeftInBounds && isRightInBounds) {
      return splitVertical(topology, patchY, patchRadius, maybeLeft, maybeRight);
    }
    vertical = !isTopInBounds ? topSplitLimits(topology, maybeTop, maybeBottom) : bottomSplitLimits(topology, maybeTop, maybeBottom);
    horizontal = !isLeftInBounds ? leftSplitLimits(topology, maybeLeft, maybeRight) : rightSplitLimits(topology, maybeLeft, maybeRight);
    upper = makeRegion(vertical.upperTop, vertical.upperBottom, ...horizontal);
    lower = makeRegion(vertical.lowerTop, vertical.lowerBottom, ...horizontal);
    return [upper, lower];
  };

  // (Region, (Int, Int) => Unit) => Unit
  searchRegion = function(region, checkAgentsHere) {
    var j, k, l, len, pxcor, pycor, ref, ref1, ref2, ref3, ref4, segment;
    for (pycor = j = ref = region.top, ref1 = region.bottom; (ref <= ref1 ? j <= ref1 : j >= ref1); pycor = ref <= ref1 ? ++j : --j) {
      ref2 = region.segments;
      for (k = 0, len = ref2.length; k < len; k++) {
        segment = ref2[k];
        for (pxcor = l = ref3 = segment.left, ref4 = segment.right; (ref3 <= ref4 ? l <= ref4 : l >= ref4); pxcor = ref3 <= ref4 ? ++l : --l) {
          checkAgentsHere(pxcor, pycor);
        }
      }
    }
  };

  // (Topology, Int, Int, Number, (Int, Int) => Unit) => Unit
  searchPatches = function(topology, patchX, patchY, radius, checkAgentsHere) {
    var j, len, patchRadius, patches, region, regions;
    // NetLogo desktop special-cases on radius length. -Jeremy B August 2020.
    if (radius <= 2) {
      patches = getSmallRadiusPatches(topology, patchX, patchY, radius);
      patches.forEach(function(patch) {
        return checkAgentsHere(patch.pxcor, patch.pycor);
      });
    } else {
      patchRadius = NLMath.ceil(radius);
      regions = topologyHelpers.getRegions(patchX, patchY, patchRadius);
      for (j = 0, len = regions.length; j < len; j++) {
        region = regions[j];
        searchRegion(region, checkAgentsHere);
      }
    }
  };

  // (Topology, Number, Number, TurtleSet, Number) -> TurtleSet
  filterTurtlesInRadius = function(topology, x, y, turtleset, radius) {
    var checkTurtlesHere, couldBeRadius, couldBeRadiusSq, inExactRadiusSq, isInTargetSet, mustBeRadius, mustBeRadiusSq, patchX, patchY, results;
    patchX = NLMath.round(x);
    patchY = NLMath.round(y);
    isInTargetSet = makeTargetChecker(turtleset, "turtles");
    inExactRadiusSq = makeInExactRadiusSq(topologyHelpers.inRadiusSq, x, y, radius);
    // If the source turtle is in a corner of its patch, the patch distances will be off by sqrt(2) / 2.  We correct
    // for this by "over-sampling" the patches. -Jeremy B September 2020
    couldBeRadius = radius + 0.71;
    couldBeRadiusSq = couldBeRadius * couldBeRadius;
    mustBeRadius = radius < 1.414 ? 0 : radius - 0.71;
    mustBeRadiusSq = mustBeRadius * mustBeRadius;
    results = [];
    // (Int, Int) => Unit
    checkTurtlesHere = function(pxcor, pycor) {
      var distanceSq, patch, patchTurtles;
      // This empty patch check may help with sparser models.  Because the bounding box check
      // should already have filtered out most of the patches, this is worth the expense of
      // getting the patch to check even if the patch might not be in radius, as the size check should
      // be pretty fast and often 0.  -Jeremy B August 2020
      patch = topologyHelpers.getPatchAt(pxcor, pycor);
      // This relies on patches removing their dead turtles, which they should do.  -Jeremy B August 2020
      patchTurtles = patch._turtles;
      if (patchTurtles.length === 0) {
        return;
      }
      distanceSq = topologyHelpers.distanceSq(x, y, pxcor, pycor);
      // We could do a `reduce` or `flatMap` or something over the patches
      // instead of mutating the closed-over `results` variable, but we do not want
      // to generate extra GC pressure from excess arrays getting created then
      // immediately dropped, nor spend time re-iterating over our results to
      // collect them into the final set.  -Jeremy B August 2020
      if (distanceSq < mustBeRadiusSq) {
        patchTurtles.forEach(function(turtle) {
          if (isInTargetSet(turtle)) {
            return results.push(turtle);
          }
        });
        return;
      }
      if (distanceSq <= couldBeRadiusSq) {
        patchTurtles.forEach(function(turtle) {
          if (isInTargetSet(turtle) && inExactRadiusSq(turtle.xcor, turtle.ycor)) {
            results.push(turtle);
          }
        });
      }
    };
    searchPatches(topology, patchX, patchY, radius, checkTurtlesHere);
    return new TurtleSet(results, turtleset._world);
  };

  // (Topology, Number, Number, PatchSet, Number) -> PatchSet
  filterPatchesInRadius = function(topology, x, y, patchset, radius) {
    var checkPatchHere, inExactRadiusSq, isInTarget, patchX, patchY, results;
    patchX = NLMath.round(x);
    patchY = NLMath.round(y);
    isInTarget = makeTargetChecker(patchset, "patches");
    inExactRadiusSq = makeInExactRadiusSq(topologyHelpers.inRadiusSq, x, y, radius);
    results = [];
    // (Int, Int) => Unit
    checkPatchHere = function(pxcor, pycor) {
      var patch;
      patch = topologyHelpers.getPatchAt(pxcor, pycor);
      if (isInTarget(patch) && inExactRadiusSq(patch.pxcor, patch.pycor)) {
        results.push(patch);
      }
    };
    searchPatches(topology, patchX, patchY, radius, checkPatchHere);
    return new PatchSet(results, patchset._world);
  };

  // (Topology, Number, Number, TurtleSet | PatchSet, Number) -> TurtleSet | PatchSet
  inRadius = function(topology, x, y, agentset, radius) {
    initialize(topology);
    switch (agentset._agentTypeName) {
      case "turtles":
        return filterTurtlesInRadius(topology, x, y, agentset, radius);
      case "patches":
        return filterPatchesInRadius(topology, x, y, agentset, radius);
      default:
        throw new Error("Cannot use `in-radius` on this agentset type.");
    }
  };

  /*

  Begin `in-cone` section.

  This code is updated to match the `in-radius` style above and to use some of those optimizations and caching, but it
  hasn't been fully converted or optimized.  Most critically, it gives the same ordering of resulting agents as desktop
  NetLogo.

  -Jeremy B August 2020

  */
  // this.type: Topology
  // [T] @ (Number, Number, Number, AbstractAgents[T], Number, Number) => AbstractAgentSet[T]
  inCone = function(x, y, turtleHeading, agents, distance, angle) {
    var checkAgentsHere, findWrapCount, isInCone, isInSector, isInTargetSet, isInWrappableSector, patchIsGood, pxcor, pycor, results, turtleIsGood, wrapCountInX, wrapCountInY;
    initialize(this);
    // (Number, Number) => Number
    findWrapCount = function(wrapsInDim, dimSize) {
      if (wrapsInDim) {
        return NLMath.ceil(distance / dimSize);
      } else {
        return 0;
      }
    };
    // (Number, Number, Number, Number, Number, Number) => Boolean
    isInSector = (ax, ay, cx, cy, radius, heading) => {
      var isTheSameSpot, isWithinArc, isWithinRange;
      isWithinArc = () => {
        var diff, half, theta;
        theta = this._towardsNotWrapped(cx, cy, ax, ay);
        diff = NLMath.abs(theta - heading);
        half = angle / 2;
        return (diff <= half) || ((360 - diff) <= half);
      };
      isWithinRange = function() {
        return NLMath.distance4_2D(cx, cy, ax, ay) <= radius;
      };
      isTheSameSpot = ax === cx && ay === cy;
      return isTheSameSpot || (isWithinRange() && isWithinArc());
    };
    // (Number, Number, Number, Number) => Boolean
    isInWrappableSector = (agentX, agentY, xBound, yBound) => {
      var j, k, ref, ref1, ref2, ref3, xWrapCoefficient, yWrapCoefficient;
      for (xWrapCoefficient = j = ref = -xBound, ref1 = xBound; (ref <= ref1 ? j <= ref1 : j >= ref1); xWrapCoefficient = ref <= ref1 ? ++j : --j) {
        for (yWrapCoefficient = k = ref2 = -yBound, ref3 = yBound; (ref2 <= ref3 ? k <= ref3 : k >= ref3); yWrapCoefficient = ref2 <= ref3 ? ++k : --k) {
          if (isInSector(agentX + this.width * xWrapCoefficient, agentY + this.height * yWrapCoefficient, x, y, distance, turtleHeading)) {
            return true;
          }
        }
      }
      return false;
    };
    // (Number, Number) => (Patch) => Boolean
    patchIsGood = (wrapCountInX, wrapCountInY) => {
      return (patch) => {
        return isInWrappableSector(patch.pxcor, patch.pycor, wrapCountInX, wrapCountInY);
      };
    };
    // (Number, Number) => (Turtle) => Boolean
    turtleIsGood = (wrapCountInX, wrapCountInY) => {
      return (turtle) => {
        return isInWrappableSector(turtle.xcor, turtle.ycor, wrapCountInX, wrapCountInY);
      };
    };
    ({pxcor, pycor} = this._getPatchAt(x, y));
    wrapCountInX = findWrapCount(this._wrapInX, this.width);
    wrapCountInY = findWrapCount(this._wrapInY, this.height);
    results = [];
    checkAgentsHere = (function() {
      if (checks.isPatchSet(agents)) {
        isInTargetSet = makeTargetChecker(agents, "patches");
        isInCone = patchIsGood(wrapCountInX, wrapCountInY);
        return function(pxcor, pycor) {
          var patch;
          patch = topologyHelpers.getPatchAt(pxcor, pycor);
          if (isInTargetSet(patch) && isInCone(patch)) {
            results.push(patch);
          }
        };
      } else if (checks.isTurtleSet(agents)) {
        isInTargetSet = makeTargetChecker(agents, "turtles");
        isInCone = turtleIsGood(wrapCountInX, wrapCountInY);
        return function(pxcor, pycor) {
          var patch;
          patch = topologyHelpers.getPatchAt(pxcor, pycor);
          patch._turtles.forEach((turtle) => {
            if (isInTargetSet(turtle) && isInCone(turtle)) {
              results.push(turtle);
            }
          });
        };
      } else {
        throw new Error("Cannot use `in-cone` on this agentset type.");
      }
    })();
    searchPatches(this, pxcor, pycor, distance, checkAgentsHere);
    return agents.copyWithNewAgents(results);
  };

  module.exports = {inRadius, inCone};

}).call(this);

},{"../typechecker":"engine/core/typechecker","util/nlmath":"util/nlmath"}],"engine/core/topology/topology":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentException, Diffuser, InRadiusOrCone, StrictMath, Topology, TopologyInterrupt, abstractMethod, filter, pipeline, unique;

  InRadiusOrCone = require('./inradiusorcone');

  Topology = require('./topology');

  Diffuser = require('./diffuser');

  StrictMath = require('shim/strictmath');

  abstractMethod = require('util/abstractmethoderror');

  ({filter, unique} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({AgentException, TopologyInterrupt} = require('util/exception'));

  module.exports = Topology = (function() {
    class Topology {
      // (Number, Number, Number, Number, () => PatchSet, (Number, Number) => Patch) => Topology
      constructor(minPxcor, maxPxcor, minPycor, maxPycor, _getPatches, _getPatchAt) {
        // (Number, Number, String, Number, Number) => Unit
        this._setPatchVariable = this._setPatchVariable.bind(this);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        this._shortestY = this._shortestY.bind(this);
        this.minPxcor = minPxcor;
        this.maxPxcor = maxPxcor;
        this.minPycor = minPycor;
        this.maxPycor = maxPycor;
        this._getPatches = _getPatches;
        this._getPatchAt = _getPatchAt;
        this.height = 1 + this.maxPycor - this.minPycor;
        this.width = 1 + this.maxPxcor - this.minPxcor;
        this.diffuser = new Diffuser(this._setPatchVariable, this.width, this.height, this._wrapInX, this._wrapInY);
        this._neighborCache = {};
        this._neighbor4Cache = {};
      }

      // (String, Number, Boolean) => Unit (side effect: diffuse varName by coeffecient among patches)
      diffuse(varName, coefficient, fourWay) {
        var mapAll, scratch, xx, yy;
        yy = this.height;
        xx = this.width;
        mapAll = function(f) {
          var i, ref, results, x, y;
          results = [];
          for (x = i = 0, ref = xx; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
            results.push((function() {
              var j, ref1, results1;
              results1 = [];
              for (y = j = 0, ref1 = yy; (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
                results1.push(f(x, y));
              }
              return results1;
            })());
          }
          return results;
        };
        scratch = mapAll((x, y) => {
          return this._getPatchAt(x + this.minPxcor, y + this.minPycor).getVariable(varName);
        });
        if (fourWay) {
          this.diffuser.diffuse4(varName, coefficient, scratch);
        } else {
          this.diffuser.diffuse8(varName, coefficient, scratch);
        }
      }

      _setPatchVariable(x, y, varName, newVal, oldVal) {
        if (newVal !== oldVal) {
          return this._getPatchAt(x + this.minPxcor, y + this.minPycor).setVariable(varName, newVal);
        }
      }

      // (Number, Number) => Array[Patch]
      getNeighbors(pxcor, pycor) {
        var key;
        key = `(${pxcor}, ${pycor})`;
        if (this._neighborCache.hasOwnProperty(key)) {
          return this._neighborCache[key];
        } else {
          return this._neighborCache[key] = this._filterNeighbors(this._getNeighbors(pxcor, pycor));
        }
      }

      // (Number, Number) => Array[Patch]
      getNeighbors4(pxcor, pycor) {
        var key;
        key = `(${pxcor}, ${pycor})`;
        if (this._neighbor4Cache.hasOwnProperty(key)) {
          return this._neighbor4Cache[key];
        } else {
          return this._neighbor4Cache[key] = this._filterNeighbors(this._getNeighbors4(pxcor, pycor));
        }
      }

      // Sadly, having topologies give out `false` and filtering it away seems to give the best balance between
      // NetLogo semantics, code clarity, and efficiency.  I tried to kill this `false`-based nonsense, but I
      // couldn't strike a better balance. --JAB (7/30/14)
      // (Array[Patch]) => Array[Patch]
      _filterNeighbors(neighbors) {
        return pipeline(filter(function(patch) {
          return patch !== false;
        }), unique)(neighbors);
      }

      // (Number, Number, Number, Number) => Number
      distanceXY(x1, y1, x2, y2) {
        var a2, b2;
        a2 = StrictMath.pow(this._shortestX(x1, x2), 2);
        b2 = StrictMath.pow(this._shortestY(y1, y2), 2);
        return StrictMath.sqrt(a2 + b2);
      }

      // (Number, Number, Turtle|Patch) => Number
      distance(x1, y1, agent) {
        var x2, y2;
        [x2, y2] = agent.getCoords();
        return this.distanceXY(x1, y1, x2, y2);
      }

      // (Number, Number, Number, Number) => Number
      distanceXYNotWrapped(x1, y1, x2, y2) {
        var a2, b2;
        a2 = StrictMath.pow(this._shortestNotWrapped(x1, x2), 2);
        b2 = StrictMath.pow(this._shortestNotWrapped(y1, y2), 2);
        return StrictMath.sqrt(a2 + b2);
      }

      // Some prims, like `layout-spring`, want the "visual" view distance rather than the wrapped distance, so this
      // lives here even for wrapping topologies. -Jeremy B August 2020
      // (Number, Number, Turtle|Patch) => Number
      distanceNotWrapped(x1, y1, agent) {
        var x2, y2;
        [x2, y2] = agent.getCoords();
        return this.distanceXYNotWrapped(x1, y1, x2, y2);
      }

      // (Number, Number, Number, Number, Number, Number) => Number
      distanceToLine(x1, y1, x2, y2, xcor, ycor) {
        var closestPoint, closestX, closestY, isInBounds, wrappedX1, wrappedX2, wrappedXcor, wrappedY1, wrappedY2, wrappedYcor, xDiff, yDiff;
        closestPoint = function(x1, y1, x2, y2, xDiff, yDiff) {
          var u, x, y;
          // all this math determines a point on the line defined by the endpoints of the
          // link nearest to the given point --??? (??/??/??)
          u = ((x1 - x2) * xDiff + (y1 - y2) * yDiff) / (xDiff * xDiff + yDiff * yDiff);
          x = x2 + u * xDiff;
          y = y2 + u * yDiff;
          return {x, y};
        };
        // since this is a segment not a continuous line we have to check the bounds
        // we know it's a point on the line, so if it's in the bounding box then
        // we're good and just return that point. ev 10/12/06
        isInBounds = function(x1, y1, x2, y2, pointX, pointY) {
          var bottom, left, right, top;
          [bottom, top] = y1 > y2 ? [y2, y1] : [y1, y2];
          [left, right] = x1 > x2 ? [x2, x1] : [x1, x2];
          return pointX <= right && pointX >= left && pointY <= top && pointY >= bottom;
        };
        wrappedX1 = this.wrapX(x1);
        wrappedX2 = this.wrapX(x2);
        wrappedXcor = this.wrapX(xcor);
        wrappedY1 = this.wrapY(y1);
        wrappedY2 = this.wrapY(y2);
        wrappedYcor = this.wrapY(ycor);
        xDiff = wrappedX2 - wrappedX1;
        yDiff = wrappedY2 - wrappedY1;
        ({
          x: closestX,
          y: closestY
        } = closestPoint(wrappedXcor, wrappedYcor, wrappedX1, wrappedY1, xDiff, yDiff));
        if (isInBounds(wrappedX1, wrappedY1, wrappedX2, wrappedY2, closestX, closestY)) {
          return this.distanceXY(closestX, closestY, wrappedXcor, wrappedYcor);
        } else {
          return Math.min(this.distanceXY(x1, y1, xcor, ycor), this.distanceXY(x2, y2, xcor, ycor));
        }
      }

      // (Number, Number, Number, Number) => Number
      towards(x1, y1, x2, y2) {
        return this._towards(x1, y1, x2, y2, this._shortestX, this._shortestY);
      }

      // (Number, Number) => Number
      midpointx(x1, x2) {
        var pos;
        pos = (x1 + (x1 + this._shortestX(x1, x2))) / 2;
        return this._wrap(pos, this.minPxcor - 0.5, this.maxPxcor + 0.5);
      }

      // (Number, Number) => Number
      midpointy(y1, y2) {
        var pos;
        pos = (y1 + (y1 + this._shortestY(y1, y2))) / 2;
        return this._wrap(pos, this.minPycor - 0.5, this.maxPycor + 0.5);
      }

      // [T] @ (Number, Number, Number, AbstractAgents[T], Number, Number) => AbstractAgentSet[T]
      inCone(x, y, heading, agents, distance, angle) {
        return InRadiusOrCone.inCone.call(this, x, y, heading, agents, distance, angle);
      }

      // [T] @ (Number, Number, AbstractAgents[T], Number) => AbstractAgentSet[T]
      inRadius(x, y, agents, radius) {
        return InRadiusOrCone.inRadius(this, x, y, agents, radius);
      }

      // (Number, Number) => Array[Patch]
      _getNeighbors(pxcor, pycor) {
        if (pxcor === this.maxPxcor && pxcor === this.minPxcor) {
          if (pycor === this.maxPycor && pycor === this.minPycor) {
            return [];
          } else {
            return [this._getPatchNorth(pxcor, pycor), this._getPatchSouth(pxcor, pycor)];
          }
        } else if (pycor === this.maxPycor && pycor === this.minPycor) {
          return [this._getPatchEast(pxcor, pycor), this._getPatchWest(pxcor, pycor)];
        } else {
          return [this._getPatchNorth(pxcor, pycor), this._getPatchEast(pxcor, pycor), this._getPatchSouth(pxcor, pycor), this._getPatchWest(pxcor, pycor), this._getPatchNorthEast(pxcor, pycor), this._getPatchSouthEast(pxcor, pycor), this._getPatchSouthWest(pxcor, pycor), this._getPatchNorthWest(pxcor, pycor)];
        }
      }

      // (Number, Number) => Array[Patch]
      _getNeighbors4(pxcor, pycor) {
        if (pxcor === this.maxPxcor && pxcor === this.minPxcor) {
          if (pycor === this.maxPycor && pycor === this.minPycor) {
            return [];
          } else {
            return [this._getPatchNorth(pxcor, pycor), this._getPatchSouth(pxcor, pycor)];
          }
        } else if (pycor === this.maxPycor && pycor === this.minPycor) {
          return [this._getPatchEast(pxcor, pycor), this._getPatchWest(pxcor, pycor)];
        } else {
          return [this._getPatchNorth(pxcor, pycor), this._getPatchEast(pxcor, pycor), this._getPatchSouth(pxcor, pycor), this._getPatchWest(pxcor, pycor)];
        }
      }

      // (Number, Number) => Number
      _shortestNotWrapped(cor1, cor2) {
        return StrictMath.abs(cor1 - cor2) * (cor1 > cor2 ? -1 : 1);
      }

      // (Number, Number, Number) => Number
      _shortestWrapped(cor1, cor2, limit) {
        var absDist;
        absDist = StrictMath.abs(cor1 - cor2);
        if (absDist > limit / 2) {
          return (limit - absDist) * (cor2 > cor1 ? -1 : 1);
        } else {
          return this._shortestNotWrapped(cor1, cor2);
        }
      }

      // (Number, Number) => Number
      _shortestXWrapped(cor1, cor2) {
        return this._shortestWrapped(cor1, cor2, this.width);
      }

      // (Number, Number) => Number
      _shortestYWrapped(cor1, cor2) {
        return this._shortestWrapped(cor1, cor2, this.height);
      }

      // (Number, Number, Number, Number, (Number, Number) => Number, (Number, Number) => Number) => Number
      _towards(x1, y1, x2, y2, findXDist, findYDist) {
        var dx, dy;
        if ((x1 !== x2) || (y1 !== y2)) {
          dx = findXDist(x1, x2);
          dy = findYDist(y1, y2);
          if (dx === 0) {
            if (dy >= 0) {
              return 0;
            } else {
              return 180;
            }
          } else if (dy === 0) {
            if (dx >= 0) {
              return 90;
            } else {
              return 270;
            }
          } else {
            return (270 + StrictMath.toDegrees(StrictMath.PI() + StrictMath.atan2(-dy, dx))) % 360;
          }
        } else {
          throw new AgentException(`No heading is defined from a point (${x1},${x2}) to that same point.`);
        }
      }

      // (Number, Number, Number, Number) => Number
      _towardsNotWrapped(x1, y1, x2, y2) {
        return this._towards(x1, y1, x2, y2, this._shortestNotWrapped, this._shortestNotWrapped);
      }

      // (Number, Number, Number) => Number
      _wrap(pos, min, max) {
        var result;
        if (pos >= max) {
          return min + ((pos - max) % (max - min));
        } else if (pos < min) {
          result = max - ((min - pos) % (max - min));
          if (result < max) {
            return result;
          } else {
            return min;
          }
        } else {
          return pos;
        }
      }

      // (Number) => Number
      _wrapXCautiously(pos) {
        return this._wrapCautiously(this.minPxcor, this.maxPxcor, pos);
      }

      // (Number) => Number
      _wrapXLeniently(pos) {
        return this._wrapLeniently(this.minPxcor, this.maxPxcor, pos);
      }

      // (Number) => Number
      _wrapYCautiously(pos) {
        return this._wrapCautiously(this.minPycor, this.maxPycor, pos);
      }

      // (Number) => Number
      _wrapYLeniently(pos) {
        return this._wrapLeniently(this.minPycor, this.maxPycor, pos);
      }

      // (Number, Number, Number) => Number
      _wrapCautiously(minCor, maxCor, pos) {
        var max, min;
        min = minCor - 0.5;
        max = maxCor + 0.5;
        if ((min <= pos && pos < max)) {
          return pos;
        } else {
          throw new TopologyInterrupt("Cannot move turtle beyond the world's edge.");
        }
      }

      // (Number, Number, Number) => Number
      _wrapLeniently(minCor, maxCor, pos) {
        return this._wrap(pos, minCor - 0.5, maxCor + 0.5);
      }

      // (Number) => Number
      wrapX(pos) {
        return abstractMethod('Topology.wrapX');
      }

      wrapY(pos) {
        return abstractMethod('Topology.wrapY');
      }

      _shortestX(x1, x2) {
        return abstractMethod('Topology._shortestX');
      }

      _shortestY(y1, y2) {
        return abstractMethod('Topology._shortestY');
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(x, y) {
        return abstractMethod('Topology._getPatchNorth');
      }

      _getPatchEast(x, y) {
        return abstractMethod('Topology._getPatchEast');
      }

      _getPatchSouth(x, y) {
        return abstractMethod('Topology._getPatchSouth');
      }

      _getPatchWest(x, y) {
        return abstractMethod('Topology._getPatchWest');
      }

      _getPatchNorthEast(x, y) {
        return abstractMethod('Topology._getPatchNorthEast');
      }

      _getPatchSouthEast(x, y) {
        return abstractMethod('Topology._getPatchSouthEast');
      }

      _getPatchSouthWest(x, y) {
        return abstractMethod('Topology._getPatchSouthWest');
      }

      _getPatchNorthWest(x, y) {
        return abstractMethod('Topology._getPatchNorthWest');
      }

    };

    Topology.prototype._wrapInX = void 0; // Boolean

    Topology.prototype._wrapInY = void 0; // Boolean

    Topology.prototype.height = void 0; // Number

    Topology.prototype.width = void 0; // Number

    Topology.prototype._neighborCache = void 0;

    Topology.prototype._neighbor4Cache = void 0;

    return Topology;

  }).call(this);

}).call(this);

},{"./diffuser":"engine/core/topology/diffuser","./inradiusorcone":"engine/core/topology/inradiusorcone","./topology":"engine/core/topology/topology","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","shim/strictmath":"shim/strictmath","util/abstractmethoderror":"util/abstractmethoderror","util/exception":"util/exception"}],"engine/core/topology/torus":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Topology, Torus, add, foldl, map, pipeline, rangeUntil,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  ({foldl, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({rangeUntil} = require('brazierjs/number'));

  // Why our own custom add function?  To avoid anonymous functions getting created as part
  // of the fold below.  This bad boy will add any two numbers together, no problem.
  // -JMB 07/2017
  add = function(a, b) {
    return a + b;
  };

  module.exports = Torus = (function() {
    class Torus extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
      // (Number) => Number
      wrapX(pos) {
        return this._wrapXLeniently(pos);
      }

      // (Number) => Number
      wrapY(pos) {
        return this._wrapYLeniently(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor, this.minPycor);
        } else {
          return this._getPatchAt(pxcor, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouth(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          if (pxcor === this.minPxcor) {
            return this._getPatchAt(this.maxPxcor, this.minPycor);
          } else {
            return this._getPatchAt(pxcor - 1, this.minPycor);
          }
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthWest(pxcor, pycor) {
        if (pycor === this.minPycor) {
          if (pxcor === this.minPxcor) {
            return this._getPatchAt(this.maxPxcor, this.maxPycor);
          } else {
            return this._getPatchAt(pxcor - 1, this.maxPycor);
          }
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthEast(pxcor, pycor) {
        if (pycor === this.minPycor) {
          if (pxcor === this.maxPxcor) {
            return this._getPatchAt(this.minPxcor, this.maxPycor);
          } else {
            return this._getPatchAt(pxcor + 1, this.maxPycor);
          }
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthEast(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          if (pxcor === this.maxPxcor) {
            return this._getPatchAt(this.minPxcor, this.minPycor);
          } else {
            return this._getPatchAt(pxcor + 1, this.minPycor);
          }
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor + 1);
        }
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, Torus);
        return this._shortestXWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, Torus);
        return this._shortestYWrapped(y1, y2);
      }

    };

    Torus.prototype._wrapInX = true; // Boolean

    Torus.prototype._wrapInY = true; // Boolean

    return Torus;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/number":"brazier/number"}],"engine/core/topology/vertcylinder":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Topology, VertCylinder,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  module.exports = VertCylinder = (function() {
    class VertCylinder extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
      // (Number) => Number
      wrapX(pos) {
        return this._wrapXLeniently(pos);
      }

      // (Number) => Number
      wrapY(pos) {
        return this._wrapYCautiously(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        return (pycor !== this.maxPycor) && this._getPatchAt(pxcor, pycor + 1);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouth(pxcor, pycor) {
        return (pycor !== this.minPycor) && this._getPatchAt(pxcor, pycor - 1);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return false;
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthWest(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return false;
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthEast(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return false;
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthEast(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return false;
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor + 1);
        }
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, VertCylinder);
        return this._shortestXWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, VertCylinder);
        return this._shortestNotWrapped(y1, y2);
      }

    };

    VertCylinder.prototype._wrapInX = true; // Boolean

    VertCylinder.prototype._wrapInY = false; // Boolean

    return VertCylinder;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology"}],"engine/core/turtle/makepenlines":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var NLMath, Trail, distanceFromLegs, lazyWrapValue, makePenLines, makePenLinesHelper, makeTrails;

  NLMath = require('util/nlmath');

  Trail = class Trail {
    constructor(x1, y1, x2, y2, dist) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.dist = dist;
    }

  };

  // Ugh, Model Runs outputs the wrong updates for this
  // Make some simple tests
  lazyWrapValue = function(min, max) {
    return function(value) {
      if (value <= min) {
        return max;
      } else if (value >= max) {
        return min;
      } else {
        return value;
      }
    };
  };

  distanceFromLegs = function(l1, l2) {
    var square;
    square = function(x) {
      return NLMath.pow(x, 2);
    };
    return NLMath.sqrt(square(l1) + square(l2));
  };

  makeTrails = function(heading, minX, maxX, minY, maxY) {
    return function(x, y, jumpDist) {
      var baseTrails, dx, dy, interceptX, interceptY, makeTrailComponent, rawX, rawY, tan, xInterceptTrails, xcomp, yInterceptTrails, ycomp;
      xcomp = NLMath.squash(NLMath.sin(heading));
      ycomp = NLMath.squash(NLMath.cos(heading));
      tan = NLMath.squash(NLMath.tan(heading));
      rawX = x + xcomp * jumpDist;
      rawY = y + ycomp * jumpDist;
      baseTrails = [new Trail(x, y, rawX, rawY, jumpDist < 0 ? jumpDist * -1 : jumpDist)];
      makeTrailComponent = function(endX, endY, dx, dy) {
        return [new Trail(x, y, endX, endY, distanceFromLegs(dx, dy))];
      };
      yInterceptTrails = rawX > maxX ? (dx = maxX - x, dy = dx / tan, interceptY = y + dy, makeTrailComponent(maxX, interceptY, dx, dy)) : rawX < minX ? (dx = x - minX, dy = dx / tan, interceptY = y - dy, makeTrailComponent(minX, interceptY, dx, dy)) : [];
      xInterceptTrails = rawY > maxY ? (dy = maxY - y, dx = dy * tan, interceptX = x + dx, makeTrailComponent(interceptX, maxY, dx, dy)) : rawY < minY ? (dy = y - minY, dx = dy * tan, interceptX = x - dx, makeTrailComponent(interceptX, minY, dx, dy)) : [];
      return baseTrails.concat(xInterceptTrails, yInterceptTrails);
    };
  };

  // (Number, Number, Number, Number, Number, Number, Number, Number) => Array[Trail]
  makePenLines = function(x, y, heading, jumpDist, minX, maxX, minY, maxY) {
    var lazyWrapX, lazyWrapY, makeTrailsBy;
    makeTrailsBy = makeTrails(heading, minX, maxX, minY, maxY);
    lazyWrapX = lazyWrapValue(minX, maxX);
    lazyWrapY = lazyWrapValue(minY, maxY);
    return makePenLinesHelper(makeTrailsBy, lazyWrapX, lazyWrapY)(x, y, jumpDist, []);
  };

  // ((Number, Number, Number) => Array[Trail], (Number) => Number, (Number) => Number) => (Number, Number, Number, Array[Trail]) => Array[Trail]
  makePenLinesHelper = function(makeTrailsBy, lazyWrapX, lazyWrapY) {
    var inner;
    inner = function(x, y, jumpDist, acc) {
      var newAcc, newX, newY, nextJumpDist, trail, trails;
      trails = makeTrailsBy(x, y, jumpDist);
      trail = trails.sort(function({
          dist: distA
        }, {
          dist: distB
        }) {
        if (distA < distB) {
          return -1;
        } else if (distA === distB) {
          return 0;
        } else {
          return 1;
        }
      })[0];
      newAcc = acc.concat([trail]);
      nextJumpDist = jumpDist >= 0 ? jumpDist - trail.dist : jumpDist + trail.dist;
      if (nextJumpDist === 0) {
        return newAcc;
      } else {
        newX = lazyWrapX(trail.x2);
        newY = lazyWrapY(trail.y2);
        return inner(newX, newY, nextJumpDist, newAcc);
      }
    };
    return inner;
  };

  module.exports = makePenLines;

}).call(this);

},{"util/nlmath":"util/nlmath"}],"engine/core/turtle/turtlevariables":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, ImmutableVariableSpec, MutableVariableSpec, NLMath, Setters, StrictMath, TopologyInterrupt, VariableSpecs, _handleTiesForHeadingChange, checks, clone, getBreed, ignorantly, ignoring, setBreed, setBreedShape, setColor, setHeading, setIsHidden, setLabel, setLabelColor, setShape, setSize, setXcor, setYcor;

  ColorModel = require('engine/core/colormodel');

  ({checks} = require('engine/core/typechecker'));

  StrictMath = require('shim/strictmath');

  NLMath = require('util/nlmath');

  ({clone} = require('brazierjs/object'));

  ({ImmutableVariableSpec, MutableVariableSpec} = require('../structure/variablespec'));

  ({ignoring, TopologyInterrupt} = require('util/exception'));

  /*
   "Jason, this is craziness!", you say.  "Not quite," I say.  It _is_ kind of lame, but changing turtle members
   needs to be controlled, so that all changes cause updates to be triggered.  And since the `VariableManager` needs
   to know how to set all of the variables, we may as well declare the code for that in a place where it can be
   easily reused. --JAB (6/2/14, 8/28/15)
  */
  // In this file: `this.type` is `Turtle`
  ignorantly = ignoring(TopologyInterrupt);

  // (Number, IDSet) => Unit
  setXcor = function(newX, seenTurtlesSet = {}) {
    var dx, f, oldX, originPatch;
    originPatch = this.getPatchHere();
    oldX = this.xcor;
    this.xcor = this.world.topology.wrapX(newX);
    this._updateVarsByName("xcor");
    this._drawSetLine(oldX, this.ycor, newX, this.ycor);
    if (originPatch !== this.getPatchHere()) {
      originPatch.untrackTurtle(this);
      this.getPatchHere().trackTurtle(this);
    }
    this.linkManager._refresh();
    dx = newX - oldX;
    f = (seenTurtles) => {
      return (turtle) => {
        return ignorantly(() => {
          return setXcor.call(turtle, turtle.xcor + dx, seenTurtles);
        });
      };
    };
    this._withEachTiedTurtle(f, seenTurtlesSet);
  };

  // (Number, IDSet) => Unit
  setYcor = function(newY, seenTurtlesSet = {}) {
    var dy, f, oldY, originPatch;
    originPatch = this.getPatchHere();
    oldY = this.ycor;
    this.ycor = this.world.topology.wrapY(newY);
    this._updateVarsByName("ycor");
    this._drawSetLine(this.xcor, oldY, this.xcor, newY);
    if (originPatch !== this.getPatchHere()) {
      originPatch.untrackTurtle(this);
      this.getPatchHere().trackTurtle(this);
    }
    this.linkManager._refresh();
    dy = newY - oldY;
    f = (seenTurtles) => {
      return (turtle) => {
        return ignorantly(() => {
          return setYcor.call(turtle, turtle.ycor + dy, seenTurtles);
        });
      };
    };
    this._withEachTiedTurtle(f, seenTurtlesSet);
  };

  // (String) => Unit
  setBreedShape = function(shape) {
    this._breedShape = shape.toLowerCase();
    if (this._givenShape == null) {
      this._genVarUpdate("shape");
    }
  };

  // (AbstractAgentSet|Breed|String) => Unit
  setBreed = function(breed) {
    var newNames, oldNames, ref, specialName, trueBreed;
    trueBreed = (function() {
      if (checks.isString(breed)) {
        return this.world.breedManager.get(breed);
      } else if (checks.isAgentSet(breed)) {
        specialName = breed.getSpecialName();
        if ((specialName != null) && !this.world.breedManager.get(specialName).isLinky()) {
          return this.world.breedManager.get(specialName);
        } else {
          throw new Error("You can't set BREED to a non-breed agentset.");
        }
      } else {
        return breed;
      }
    }).call(this);
    if ((this._breed != null) && this._breed !== trueBreed) {
      this._givenShape = void 0;
    }
    if (this._breed !== trueBreed) {
      trueBreed.add(this);
      if ((ref = this._breed) != null) {
        ref.remove(this);
      }
      newNames = this._varNamesForBreed(trueBreed);
      oldNames = this._varNamesForBreed(this._breed);
      this._varManager.refineBy(oldNames, newNames);
    }
    this._breed = trueBreed;
    this._genVarUpdate("breed");
    setBreedShape.call(this, trueBreed.getShape());
    this._refreshName();
    if (!this.world.breedManager.turtles().contains(this)) {
      this.world.breedManager.turtles().add(this);
    }
  };

  // (Number) => Unit
  setColor = function(color) {
    this._color = ColorModel.wrapColor(color);
    this._genVarUpdate("color");
  };

  // (Number, IDSet) => Unit
  setHeading = function(heading, seenTurtlesSet = {}) {
    var dh, oldHeading;
    oldHeading = this._heading;
    this._heading = NLMath.normalizeHeading(heading);
    this._genVarUpdate("heading");
    dh = NLMath.subtractHeadings(this._heading, oldHeading);
    _handleTiesForHeadingChange.call(this, seenTurtlesSet, dh);
  };

  // (Boolean) => Unit
  setIsHidden = function(isHidden) {
    this._hidden = isHidden;
    this._genVarUpdate("hidden?");
  };

  // (String) => Unit
  setLabel = function(label) {
    this._label = label;
    this._genVarUpdate("label");
  };

  // (Number) => Unit
  setLabelColor = function(color) {
    this._labelcolor = ColorModel.wrapColor(color);
    this._genVarUpdate("label-color");
  };

  // (String) => Unit
  setShape = function(shape) {
    this._givenShape = shape.toLowerCase();
    this._genVarUpdate("shape");
  };

  // (Number) => Unit
  setSize = function(size) {
    this._size = size;
    this._genVarUpdate("size");
  };

  // I have so many apologies for this code, but, hey,
  // it wasn't my idea to embed ties into NetLogo. --JAB (10/26/15)

  // (IDSet, Number) => Unit
  _handleTiesForHeadingChange = function(seenTurtlesSet, dh) {
    var filteredPairs, turtleModePairs, x, y;
    [x, y] = this.getCoords();
    turtleModePairs = this.linkManager.myOutLinks("LINKS").toArray().map(({end1, end2, tiemode}) => {
      return [(end1 === this ? end2 : end1), tiemode];
    });
    seenTurtlesSet[this.id] = true;
    filteredPairs = turtleModePairs.filter(function([{id}, mode]) {
      var result;
      result = (seenTurtlesSet[id] == null) && mode !== "none";
      seenTurtlesSet[id] = true;
      return result;
    });
    filteredPairs.forEach(([turtle, mode]) => {
      var ex, newX, newY, r, theta, wentBoom;
      wentBoom = (function() {
        try {
          r = this.distance(turtle);
          if (r !== 0) {
            theta = this.towards(turtle) + dh;
            newX = x + r * NLMath.squash(NLMath.sin(theta));
            newY = y + r * NLMath.squash(NLMath.cos(theta));
            turtle.setXY(newX, newY, clone(seenTurtlesSet));
          }
          return false;
        } catch (error) {
          ex = error;
          if (ex instanceof TopologyInterrupt) {
            return true;
          } else {
            throw ex;
          }
        }
      }).call(this);
      if (mode === "fixed" && !wentBoom) {
        return turtle.right(dh, clone(seenTurtlesSet));
      }
    });
  };

  Setters = {setXcor, setYcor, setBreed, setColor, setHeading, setIsHidden, setLabel, setLabelColor, setShape, setSize};

  getBreed = (function() {
    return this.world.turtleManager.turtlesOfBreed(this._breed.name);
  });

  VariableSpecs = [
    new ImmutableVariableSpec('who',
    function() {
      return this.id;
    }),
    new MutableVariableSpec('breed',
    getBreed,
    setBreed),
    new MutableVariableSpec('color',
    (function() {
      return this._color;
    }),
    setColor),
    new MutableVariableSpec('heading',
    (function() {
      return this._heading;
    }),
    setHeading),
    new MutableVariableSpec('hidden?',
    (function() {
      return this._hidden;
    }),
    setIsHidden),
    new MutableVariableSpec('label',
    (function() {
      return this._label;
    }),
    setLabel),
    new MutableVariableSpec('label-color',
    (function() {
      return this._labelcolor;
    }),
    setLabelColor),
    new MutableVariableSpec('pen-mode',
    (function() {
      return this.penManager.getMode().toString();
    }),
    (function(x) {
      return this.penManager.setPenMode(x);
    })),
    new MutableVariableSpec('pen-size',
    (function() {
      return this.penManager.getSize();
    }),
    (function(x) {
      return this.penManager.setSize(x);
    })),
    new MutableVariableSpec('shape',
    (function() {
      return this._getShape();
    }),
    setShape),
    new MutableVariableSpec('size',
    (function() {
      return this._size;
    }),
    setSize),
    new MutableVariableSpec('xcor',
    (function() {
      return this.xcor;
    }),
    setXcor),
    new MutableVariableSpec('ycor',
    (function() {
      return this.ycor;
    }),
    setYcor)
  ];

  module.exports = {Setters, VariableSpecs};

}).call(this);

},{"../structure/variablespec":"engine/core/structure/variablespec","brazierjs/object":"brazier/object","engine/core/colormodel":"engine/core/colormodel","engine/core/typechecker":"engine/core/typechecker","shim/strictmath":"shim/strictmath","util/exception":"util/exception","util/nlmath":"util/nlmath"}],"engine/core/turtlelinkmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var All, DeathInterrupt, In, LinkManager, LinkSet, Out, TurtleSet, filter, flatMap, ignorantly, ignoring, linkBreedMatches, map, otherEnd, pipeline, unique;

  LinkSet = require('./linkset');

  TurtleSet = require('./turtleset');

  ({filter, flatMap, map, unique} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({DeathInterrupt, ignoring} = require('util/exception'));

  ignorantly = ignoring(DeathInterrupt);

  // data Directedness
  All = {};

  In = {};

  Out = {};

  // Number -> Link -> Turtle
  otherEnd = function(sourceID) {
    return function({end1, end2}) {
      if (end1.id === sourceID) {
        return end2;
      } else {
        return end1;
      }
    };
  };

  // String -> Directedness -> Number -> Link -> Boolean
  linkBreedMatches = function(breedName) {
    return function(directedness) {
      return function(ownerID) {
        return function(link) {
          return (breedName === "LINKS" || breedName === link.getBreedName()) && ((directedness === All) || (!link.isDirected) || (directedness === In && link.end2.id === ownerID) || (directedness === Out && link.end1.id === ownerID));
        };
      };
    };
  };

  module.exports = LinkManager = (function() {
    class LinkManager {
      
      // (Number, World) => LinkManager
      constructor(_ownerID, _world) {
        this._ownerID = _ownerID;
        this._world = _world;
        this.clear();
      }

      // (Link) => Unit
      add(link) {
        this._links.push(link);
      }

      // () => Unit
      clear() {
        var oldLinks, ref;
        oldLinks = (ref = this._links) != null ? ref : [];
        this._links = [];
        // Purposely done after resetting the array so that calls to `TurtleLinkManager.remove` in `Link.die` don't spend
        // a ton of time iterating through long arrays that are in the process of being wiped out. --JAB (11/24/14)
        oldLinks.forEach(function(link) {
          return ignorantly(() => {
            return link.die();
          });
        });
      }

      // (String, Turtle) => Link
      inLinkFrom(breedName, otherTurtle) {
        return this._findLink(otherTurtle, breedName, In);
      }

      // (String) => TurtleSet
      inLinkNeighbors(breedName) {
        return this._neighbors(breedName, In);
      }

      // (String, Turtle) => Boolean
      isInLinkNeighbor(breedName, turtle) {
        return this.inLinkFrom(breedName, turtle) !== Nobody;
      }

      // (String, Turtle) => Boolean
      isLinkNeighbor(breedName, turtle) {
        return this.isOutLinkNeighbor(breedName, turtle) || this.isInLinkNeighbor(breedName, turtle);
      }

      // (String, Turtle) => Boolean
      isOutLinkNeighbor(breedName, turtle) {
        return this.outLinkTo(breedName, turtle) !== Nobody;
      }

      // (String, Turtle) => Link
      linkWith(breedName, otherTurtle) {
        return this._findLink(otherTurtle, breedName, All);
      }

      // (String) => TurtleSet
      linkNeighbors(breedName) {
        return this._neighbors(breedName, All);
      }

      // (String) => LinkSet
      myInLinks(breedName) {
        return new LinkSet(this._links.filter(linkBreedMatches(breedName)(In)(this._ownerID)), this._world);
      }

      // (String) => LinkSet
      myLinks(breedName) {
        return new LinkSet(this._links.filter(linkBreedMatches(breedName)(All)(this._ownerID)), this._world);
      }

      // (String) => LinkSet
      myOutLinks(breedName) {
        return new LinkSet(this._links.filter(linkBreedMatches(breedName)(Out)(this._ownerID)), this._world);
      }

      // (String) => TurtleSet
      outLinkNeighbors(breedName) {
        return this._neighbors(breedName, Out);
      }

      // (String, Turtle) => Link
      outLinkTo(breedName, otherTurtle) {
        return this._findLink(otherTurtle, breedName, Out);
      }

      // (Link) => Unit
      remove(link) {
        this._links.splice(this._links.indexOf(link), 1);
      }

      // Turtle -> String -> Directedness -> Agent
      _findLink(otherTurtle, breedName, directedness) {
        var linkDoesMatch, links;
        linkDoesMatch = (l) => {
          return otherEnd(this._ownerID)(l) === otherTurtle && linkBreedMatches(breedName)(directedness)(this._ownerID)(l);
        };
        links = this._links.filter(linkDoesMatch);
        if (links.length === 0) {
          return Nobody;
        } else if (links.length === 1) {
          return links[0];
        } else {
          return links[this._world.rng.nextInt(links.length)];
        }
      }

      // (LinkSet) => Array[Turtle]
      neighborsIn(linkSet) {
        var collectOtherEnd;
        collectOtherEnd = ({end1, end2}) => {
          var isEnd1, isEnd2;
          isEnd1 = end1.id === this._ownerID;
          isEnd2 = end2.id === this._ownerID;
          if (isEnd1 && (!isEnd2)) {
            return [end2];
          } else if (isEnd2 && (!isEnd1)) {
            return [end1];
          } else {
            return [];
          }
        };
        return pipeline(flatMap(collectOtherEnd), unique)(linkSet.toArray());
      }

      // String -> Directedness -> TurtleSet
      _neighbors(breedName, directedness) {
        return pipeline(filter(linkBreedMatches(breedName)(directedness)(this._ownerID)), map(otherEnd(this._ownerID)), unique, ((turtles) => {
          return new TurtleSet(turtles, this._world);
        }))(this._links);
      }

      // () => Unit
      _refresh() {
        this._links.forEach(function(link) {
          link.updateEndRelatedVars();
        });
      }

    };

    LinkManager._links = void 0; // Array[(Link, Directedness)]

    return LinkManager;

  }).call(this);

}).call(this);

},{"./linkset":"engine/core/linkset","./turtleset":"engine/core/turtleset","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","util/exception":"util/exception"}],"engine/core/turtleset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, DeadSkippingIterator, TurtleSet;

  AbstractAgentSet = require('./abstractagentset');

  DeadSkippingIterator = require('./structure/deadskippingiterator');

  module.exports = TurtleSet = class TurtleSet extends AbstractAgentSet {
    // [T <: Turtle] @ (Array[T], World, String) => TurtleSet
    constructor(agents, world, specialName) {
      super(agents, world, "turtles", specialName);
      this._agents = agents;
    }

    // () => Iterator[T]
    iterator() {
      return new DeadSkippingIterator(this._agents.slice(0));
    }

    // () => Iterator[T]
    _unsafeIterator() {
      return new DeadSkippingIterator(this._agents);
    }

  };

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./structure/deadskippingiterator":"engine/core/structure/deadskippingiterator"}],"engine/core/turtle":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, ColorModel, Comparator, Death, Down, Erase, ExtraVariableSpec, NLMath, PenManager, Setters, Stamp, StampErase, StampMode, TopologyInterrupt, Turtle, TurtleLinkManager, TurtleSet, VariableManager, VariableSpecs, checks, foldl, forEach, ignorantly, ignoring, makePenLines, map, rangeUntil, uniqueBy;

  AbstractAgentSet = require('./abstractagentset');

  ColorModel = require('engine/core/colormodel');

  TurtleLinkManager = require('./turtlelinkmanager');

  TurtleSet = require('./turtleset');

  ({checks} = require('./typechecker'));

  VariableManager = require('./structure/variablemanager');

  makePenLines = require('./turtle/makepenlines');

  Comparator = require('util/comparator');

  NLMath = require('util/nlmath');

  ({foldl, forEach, map, uniqueBy} = require('brazierjs/array'));

  ({rangeUntil} = require('brazierjs/number'));

  ({
    PenManager,
    PenStatus: {Down, Erase}
  } = require('./structure/penmanager'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  ({
    DeathInterrupt: Death,
    ignoring,
    TopologyInterrupt
  } = require('util/exception'));

  ({Setters, VariableSpecs} = require('./turtle/turtlevariables'));

  ignorantly = ignoring(TopologyInterrupt);

  StampMode = class StampMode {
    constructor(name1) { // (String) => StampMode
      this.name = name1;
    }

  };

  Stamp = new StampMode("normal");

  StampErase = new StampMode("erase");

  module.exports = Turtle = (function() {
    class Turtle {
      
      // The type signatures here can be found to the right of the parameters. --JAB (4/13/15)
      constructor(world, id1, _genUpdate, _registerLineDraw, _registerTurtleStamp, _registerDeath, _createTurtle, _removeTurtle, _color = 0, _heading = 0, xcor1 = 0, ycor1 = 0, breed = null, _label = "", _labelcolor = 9.9, _hidden = false, _size = 1.0, _givenShape, genPenManager = (self) => { // (Number) => Unit, Number, Number, Number, Number // Breed, String, Number, Boolean
          return new PenManager(this._genUpdate(self));
        }) { // Number, Boolean, Number, String, (Updatable) => PenManager
        var varNames;
        // (Number, Number) => Patch
        this.patchAt = this.patchAt.bind(this);
        this.world = world;
        this.id = id1;
        this._genUpdate = _genUpdate;
        this._registerLineDraw = _registerLineDraw;
        this._registerTurtleStamp = _registerTurtleStamp;
        this._registerDeath = _registerDeath;
        this._createTurtle = _createTurtle; // World, Number, (Updatable) => (String*) => Unit, RegLinkDrawFunc, RegTurtleStampFunc, (Number) => Unit, GenTurtleType
        this._removeTurtle = _removeTurtle;
        this._color = _color;
        this._heading = _heading;
        this.xcor = xcor1;
        this.ycor = ycor1;
        this._label = _label;
        this._labelcolor = _labelcolor;
        this._hidden = _hidden;
        this._size = _size;
        this._givenShape = _givenShape;
        breed = breed != null ? breed : this.world.breedManager.turtles();
        this._updateVarsByName = this._genUpdate(this);
        this.penManager = genPenManager(this);
        this.linkManager = new TurtleLinkManager(this.id, this.world);
        varNames = this._varNamesForBreed(breed);
        this._varManager = this._genVarManager(varNames);
        Setters.setBreed.call(this, breed);
        if (this._givenShape != null) {
          Setters.setShape.call(this, this._givenShape);
        }
        this.getPatchHere().trackTurtle(this);
      }

      // () => String
      getBreedName() {
        return this._breed.name;
      }

      // () => String
      getBreedNameSingular() {
        return this._breed.singular;
      }

      // Unit -> String
      getName() {
        return this._name;
      }

      // (Number) => Boolean
      canMove(distance) {
        return this.patchAhead(distance) !== Nobody;
      }

      // (Turtle|Patch) => Number
      distance(agent) {
        return this.world.topology.distance(this.xcor, this.ycor, agent);
      }

      // (Turtle|Patch) => Number
      distanceNotWrapped(agent) {
        return this.world.topology.distanceNotWrapped(this.xcor, this.ycor, agent);
      }

      // (Number, Number) => Number
      distanceXY(x, y) {
        return this.world.topology.distanceXY(this.xcor, this.ycor, x, y);
      }

      // () => (Number, Number)
      getCoords() {
        return [this.xcor, this.ycor];
      }

      // (Turtle|Patch) => Number
      towards(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        return this.towardsXY(x, y);
      }

      // (Number, Number) => Number
      towardsXY(x, y) {
        return this.world.topology.towards(this.xcor, this.ycor, x, y);
      }

      // (Number, Number) => Unit
      faceXY(x, y) {
        if (x !== this.xcor || y !== this.ycor) {
          Setters.setHeading.call(this, this.world.topology.towards(this.xcor, this.ycor, x, y));
        }
      }

      // (Turtle|Patch) => Unit
      face(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        this.faceXY(x, y);
      }

      // [T] @ (AbstractAgentSet[T], Number, Number) => AbstractAgentSet[T]
      inCone(agents, distance, angle) {
        if (distance < 0) {
          throw new Error("IN-CONE cannot take a negative radius.");
        } else if (angle < 0) {
          throw new Error("IN-CONE cannot take a negative angle.");
        } else if (angle > 360) {
          throw new Error("IN-CONE cannot take an angle greater than 360.");
        } else {
          return this.world.topology.inCone(this.xcor, this.ycor, NLMath.normalizeHeading(this._heading), agents, distance, angle);
        }
      }

      // [T] @ (AbstractAgentSet[T], Number) => AbstractAgentSet[T]
      inRadius(agents, radius) {
        return this.world.topology.inRadius(this.xcor, this.ycor, agents, radius);
      }

      patchAt(dx, dy) {
        return this.world.patchAtCoords(this.xcor + dx, this.ycor + dy);
      }

      // (Number, Number) => TurtleSet
      turtlesAt(dx, dy) {
        return this.getPatchHere().turtlesAt(dx, dy);
      }

      // (String, Number, Number) => TurtleSet
      breedAt(breedName, dx, dy) {
        return this.getPatchHere().breedAt(breedName, dx, dy);
      }

      // () => Turtle
      otherEnd() {
        if (this === this.world.selfManager.myself().end1) {
          return this.world.selfManager.myself().end2;
        } else {
          return this.world.selfManager.myself().end1;
        }
      }

      // (Number, Number) => Agent
      patchAtHeadingAndDistance(angle, distance) {
        return this.world.patchAtHeadingAndDistanceFrom(angle, distance, this.xcor, this.ycor);
      }

      // (Number, Number) => Agent
      patchRightAndAhead(angle, distance) {
        return this.patchAtHeadingAndDistance(this._heading + angle, distance);
      }

      // (Number, Number) => Agent
      patchLeftAndAhead(angle, distance) {
        return this.patchRightAndAhead(-angle, distance);
      }

      // (Number) => Agent
      patchAhead(distance) {
        return this.patchRightAndAhead(0, distance);
      }

      // (() => Any) => Unit
      ask(f) {
        var base;
        if (!this.isDead()) {
          this.world.selfManager.askAgent(f)(this);
          if (typeof (base = this.world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
            throw new Death;
          }
        } else {
          throw new Error(`That ${this.getBreedNameSingular()} is dead.`);
        }
      }

      // [Result] @ (() => Result) => Result
      projectionBy(f) {
        if (!this.isDead()) {
          return this.world.selfManager.askAgent(f)(this);
        } else {
          throw new Error(`That ${this._breed.singular} is dead.`);
        }
      }

      // Unfortunately, further attempts to streamline this code are very likely to lead to
      // floating point arithmetic mismatches with JVM NetLogo....  Beware. --JAB (7/28/14)
      // (Number) => Unit
      fd(distance) {
        var increment, remaining;
        increment = distance > 0 ? 1 : -1;
        remaining = distance;
        if (distance > 0) {
          while (remaining >= increment && this.jumpIfAble(increment)) {
            remaining -= increment;
          }
        } else if (distance < 0) {
          while (remaining <= increment && this.jumpIfAble(increment)) {
            remaining -= increment;
          }
        }
        if (remaining !== 0) {
          this.jumpIfAble(remaining);
        }
      }

      // (Number) => Unit
      _optimalFdOne() {
        this.jumpIfAble(1);
      }

      // (Number) => Unit
      _optimalFdLessThan1(distance) {
        this.jumpIfAble(distance);
      }

      // (String) => Number
      _optimalNSum(varName) {
        return this.getPatchHere()._optimalNSum(varName);
      }

      // (String) => Number
      _optimalNSum4(varName) {
        return this.getPatchHere()._optimalNSum4(varName);
      }

      // (Number) => Boolean
      jumpIfAble(distance) {
        var canMove;
        canMove = this.canMove(distance);
        if (canMove) {
          this._jump(distance);
        }
        return canMove;
      }

      // (Number) => Unit
      _jump(distance) {
        this._drawJumpLine(this.xcor, this.ycor, distance, this._heading);
        this._setXandY(this.xcor + distance * this.dx(), this.ycor + distance * this.dy());
      }

      // () => Number
      dx() {
        return NLMath.squash(NLMath.sin(this._heading));
      }

      // () => Number
      dy() {
        return NLMath.squash(NLMath.cos(this._heading));
      }

      // (Number, IDSet) => Unit
      right(angle, seenTurtlesSet = {}) {
        var newHeading;
        newHeading = this._heading + angle;
        Setters.setHeading.call(this, newHeading, seenTurtlesSet);
      }

      // (Number, Number, IDSet) => Unit
      setXY(x, y, seenTurtlesSet = {}) {
        var error, origXcor, origYcor;
        origXcor = this.xcor;
        origYcor = this.ycor;
        try {
          this._setXandY(x, y, seenTurtlesSet);
          this._drawSetLine(origXcor, origYcor, x, y);
        } catch (error1) {
          error = error1;
          this._setXandY(origXcor, origYcor, seenTurtlesSet);
          if (error instanceof TopologyInterrupt) {
            throw new TopologyInterrupt(`The point [ ${x} , ${y} ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.`);
          } else {
            throw error;
          }
        }
      }

      // Handy for when your turtles are drunk --JAB (8/18/15)
      // () => Unit
      goHome() {
        this.setXY(0, 0);
      }

      // (Boolean) => Unit
      hideTurtle(shouldHide) {
        Setters.setIsHidden.call(this, shouldHide);
      }

      // (String) => Boolean
      isBreed(breedName) {
        return this._breed.name.toUpperCase() === breedName.toUpperCase();
      }

      // () => Boolean
      isDead() {
        return this.id === -1;
      }

      // () => Nothing
      die() {
        this._breed.remove(this);
        if (!this.isDead()) {
          this._removeTurtle(this.id);
          this._seppuku();
          this.linkManager.clear();
          this.id = -1;
          this.getPatchHere().untrackTurtle(this);
          this.world.observer.unfocus(this);
        }
        throw new Death("Call only from inside an askAgent block");
      }

      // (String) => Any
      getVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // () => Patch
      getPatchHere() {
        return this.world.getPatchAt(this.xcor, this.ycor);
      }

      // (String) => Any
      getPatchVariable(varName) {
        return this.getPatchHere().getVariable(varName);
      }

      // (String, Any) => Unit
      setPatchVariable(varName, value) {
        this.getPatchHere().setVariable(varName, value);
      }

      // () => PatchSet
      getNeighbors() {
        return this.getPatchHere().getNeighbors();
      }

      // () => PatchSet
      getNeighbors4() {
        return this.getPatchHere().getNeighbors4();
      }

      // () => TurtleSet
      turtlesHere() {
        return this.getPatchHere().turtlesHere();
      }

      // (String) => TurtleSet
      breedHere(breedName) {
        return this.getPatchHere().breedHere(breedName);
      }

      // (Number, String) => TurtleSet
      hatch(n, breedName) {
        var breed, isNameValid, newTurtles, num;
        num = n >= 0 ? n : 0;
        isNameValid = (breedName != null) && breedName !== "";
        breed = isNameValid ? this.world.breedManager.get(breedName) : this._breed;
        newTurtles = map(() => {
          return this._makeTurtleCopy(breed);
        })(rangeUntil(0)(num));
        return new TurtleSet(newTurtles, this.world);
      }

      // (Breed) => Turtle
      _makeTurtleCopy(breed) {
        var shape, turtle, varNames;
        shape = breed === this._breed ? this._givenShape : void 0;
        turtle = this._createTurtle(this._color, this._heading, this.xcor, this.ycor, breed, this._label, this._labelcolor, this._hidden, this._size, shape, (self) => {
          return this.penManager.clone(this._genUpdate(self));
        });
        varNames = this._varNamesForBreed(breed);
        forEach((varName) => {
          var ref;
          turtle.setVariable(varName, (ref = this.getVariable(varName)) != null ? ref : 0);
        })(varNames);
        return turtle;
      }

      // (Breed) => Array[String]
      _varNamesForBreed(breed) {
        var turtlesBreed;
        turtlesBreed = this.world.breedManager.turtles();
        if (breed === turtlesBreed || (breed == null)) {
          return turtlesBreed.varNames;
        } else {
          return turtlesBreed.varNames.concat(breed.varNames);
        }
      }

      // (Turtle|Patch) => Unit
      moveTo(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        this.setXY(x, y);
      }

      // () => Unit
      followMe() {
        this.world.observer.follow(this);
      }

      // () => Unit
      rideMe() {
        this.world.observer.ride(this);
      }

      // () => Unit
      watchMe() {
        this.world.observer.watch(this);
      }

      // () => Unit
      stamp() {
        this._drawStamp(Stamp);
      }

      // () => Unit
      stampErase() {
        this._drawStamp(StampErase);
      }

      // (Any) => Comparator
      compare(x) {
        if (checks.isTurtle(x)) {
          return Comparator.numericCompare(this.id, x.id);
        } else {
          return Comparator.NOT_EQUALS;
        }
      }

      // () => String
      toString() {
        if (!this.isDead()) {
          return `(${this.getName()})`;
        } else {
          return "nobody";
        }
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // (StampMode) => Unit
      _drawStamp(mode) {
        this._registerTurtleStamp(this.xcor, this.ycor, this._size, this._heading, ColorModel.colorToRGB(this._color), this._getShape(), mode.name);
      }

      // (Number, Number, Number) => Unit
      _drawJumpLine(x, y, dist, head) {
        var penMode;
        penMode = this.penManager.getMode();
        if (penMode === Down || penMode === Erase) {
          this._drawLines(x, y, dist, head);
        }
      }

      // (Number, Number, Number, Number) => Unit
      _drawSetLine(oldX, oldY, newX, newY) {
        var jumpDist, jumpHead, maxPxcor, maxPycor, minPxcor, minPycor, penMode, wrappedX, wrappedY;
        penMode = this.penManager.getMode();
        if ((penMode === Down || penMode === Erase) && (oldX !== newX || oldY !== newY)) {
          wrappedX = oldX + this.world.topology._shortestX(oldX, newX);
          wrappedY = oldY + this.world.topology._shortestY(oldY, newY);
          ({minPxcor, maxPxcor, minPycor, maxPycor} = this.world.topology);
          if (minPxcor < wrappedX && wrappedX < maxPxcor && minPycor < wrappedY && wrappedY < maxPycor) {
            this._registerLineDraw(oldX, oldY, wrappedX, wrappedY, ColorModel.colorToRGB(this._color), this.penManager.getSize(), this.penManager.getMode().toString());
          } else {
            jumpDist = NLMath.sqrt(NLMath.pow(oldX - wrappedX, 2) + NLMath.pow(oldY - wrappedY, 2));
            jumpHead = this.world.topology.towards(oldX, oldY, wrappedX, wrappedY);
            this._drawLines(oldX, oldY, jumpDist, jumpHead);
          }
        }
      }

      // (Number, Number, Number) => Unit
      _drawLines(x, y, dist, head) {
        var color, lines, maxPxcor, maxPycor, minPxcor, minPycor, mode, size;
        color = ColorModel.colorToRGB(this._color);
        size = this.penManager.getSize();
        mode = this.penManager.getMode().toString();
        ({minPxcor, maxPxcor, minPycor, maxPycor} = this.world.topology);
        lines = makePenLines(x, y, NLMath.normalizeHeading(head), dist, minPxcor - 0.5, maxPxcor + 0.5, minPycor - 0.5, maxPycor + 0.5);
        forEach(({x1, y1, x2, y2}) => {
          this._registerLineDraw(x1, y1, x2, y2, color, size, mode);
        })(lines);
      }

      // Unfortunately, we can't just throw out `_breedShape` and grab the shape from our
      // `Breed` object.  It would be pretty nice if we could, but the problem is that
      // `set-default-shape` only affects turtles created after its use, so turtles that
      // were using breed shape <X> before `set-default-shape` set the breed's shape to <Y>
      // still need to be using <X>. --JAB (12/5/14)
      // () => String
      _getShape() {
        var ref;
        return (ref = this._givenShape) != null ? ref : this._breedShape;
      }

      // (String) => (Link) => Boolean
      _linkBreedMatches(breedName) {
        return function(link) {
          return breedName === "LINKS" || breedName === link.getBreedName();
        };
      }

      // () => Unit
      _seppuku() {
        this._registerDeath(this.id);
      }

      // () => { "fixeds": Array[Turtle], "others": Array[Turtle] }
      _tiedTurtlesRaw() {
        var f, fixeds, links, others;
        links = this.linkManager.myOutLinks("LINKS").toArray().filter(function(l) {
          return l.tiemode !== "none";
        });
        f = ([fixeds, others], {end1, end2, tiemode}) => {
          var turtle;
          turtle = end1 === this ? end2 : end1;
          if (tiemode === "fixed") {
            return [fixeds.concat([turtle]), others];
          } else {
            return [fixeds, others.concat([turtle])];
          }
        };
        [fixeds, others] = foldl(f)([[], []])(links);
        return {
          fixeds: fixeds,
          others: others
        };
      }

      // () => Array[Turtle]
      _tiedTurtles() {
        var fixeds, others;
        ({fixeds, others} = this._tiedTurtlesRaw());
        return this._uniqueTurtles(fixeds.concat(others));
      }

      // () => Array[Turtle]
      _fixedTiedTurtles() {
        return this._uniqueTurtles(this._tiedTurtlesRaw().fixeds);
      }

      // (Array[Turtle]) => Array[Turtle]
      _uniqueTurtles(turtles) {
        return uniqueBy(function(t) {
          return t.id;
        })(turtles);
      }

      // (Array[String]) => VariableManager
      _genVarManager(extraVarNames) {
        var allSpecs, extraSpecs;
        extraSpecs = extraVarNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        allSpecs = VariableSpecs.concat(extraSpecs);
        return new VariableManager(this, allSpecs);
      }

      // (String) => Unit
      _genVarUpdate(varName) {
        this._updateVarsByName(varName);
      }

      // Unit -> Unit
      _refreshName() {
        this._name = `${this._breed.singular} ${this.id}`;
      }

      // (Number, Number, IDSet) => Unit
      _setXandY(newX, newY, seenTurtlesSet = {}) {
        var dx, dy, f, oldX, oldY, originPatch, xcor, ycor;
        originPatch = this.getPatchHere();
        oldX = this.xcor;
        oldY = this.ycor;
        xcor = this.world.topology.wrapX(newX);
        ycor = this.world.topology.wrapY(newY);
        // DO NOT SET `xcor` AND `ycor` DIRECTLY FROM `wrap*`.  `wrap*` can throw a `TopologyException`.
        // If we set only one of the coordinates and then bail with an exception (and without generating the View update),
        // it causes all sorts of bonkers stuff to happen. --JAB (10/17/17)
        this.xcor = xcor;
        this.ycor = ycor;
        this._updateVarsByName("xcor", "ycor");
        if (originPatch !== this.getPatchHere()) {
          originPatch.untrackTurtle(this);
          this.getPatchHere().trackTurtle(this);
        }
        this.linkManager._refresh();
        // It's important not to use the wrapped coordinates (`@xcor`, `@ycor`) here.
        // Using those will cause floating point arithmetic discrepancies. --JAB (10/22/15)
        dx = newX - oldX;
        dy = newY - oldY;
        f = (seenTurtles) => {
          return (turtle) => {
            return ignorantly(() => {
              return turtle._setXandY(turtle.xcor + dx, turtle.ycor + dy, seenTurtles);
            });
          };
        };
        this._withEachTiedTurtle(f, seenTurtlesSet);
      }

      // ((IDSet) => (Turtle) => Any, IDSet) => Unit
      _withEachTiedTurtle(f, seenTurtlesSet) {
        var turtles;
        seenTurtlesSet[this.id] = true;
        turtles = this._tiedTurtles().filter(function({id}) {
          return seenTurtlesSet[id] == null;
        });
        turtles.forEach(function({id}) {
          return seenTurtlesSet[id] = true;
        });
        turtles.forEach(f(seenTurtlesSet));
      }

      // () => Patch
      _optimalPatchHereInternal() {
        return this.getPatchHere();
      }

      _optimalPatchNorth() {
        return this.getPatchHere()._optimalPatchNorth();
      }

      _optimalPatchEast() {
        return this.getPatchHere()._optimalPatchEast();
      }

      _optimalPatchSouth() {
        return this.getPatchHere()._optimalPatchSouth();
      }

      _optimalPatchWest() {
        return this.getPatchHere()._optimalPatchWest();
      }

      _optimalPatchNorthEast() {
        return this.getPatchHere()._optimalPatchNorthEast();
      }

      _optimalPatchSouthEast() {
        return this.getPatchHere()._optimalPatchSouthEast();
      }

      _optimalPatchSouthWest() {
        return this.getPatchHere()._optimalPatchSouthWest();
      }

      _optimalPatchNorthWest() {
        return this.getPatchHere()._optimalPatchNorthWest();
      }

    };

    // type GenTurtleFunc      = (Number, Number, Number, Number, Breed, String, Number, Boolean, Number, String, PenManager) => Turtle
    // type IDSet              = Object[ID, Boolean]
    // type RegLineDrawFunc    = (Number, Number, Number, Number, Boolean, Boolean, RGB, Number, String, String) => Unit
    // type RegTurtleStampFunc = (Number, Number, Number, Number, RGB, String, String) => Unit
    Turtle.prototype._breed = void 0; // Breed

    Turtle.prototype._breedShape = void 0; // String

    Turtle.prototype._name = void 0; // String

    Turtle.prototype._updateVarsByName = void 0; // (String*) => Unit

    Turtle.prototype._varManager = void 0; // VariableManager

    Turtle.prototype.linkManager = void 0; // TurtleLinkManager

    return Turtle;

  }).call(this);

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./structure/penmanager":"engine/core/structure/penmanager","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./turtle/makepenlines":"engine/core/turtle/makepenlines","./turtle/turtlevariables":"engine/core/turtle/turtlevariables","./turtlelinkmanager":"engine/core/turtlelinkmanager","./turtleset":"engine/core/turtleset","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/number":"brazier/number","engine/core/colormodel":"engine/core/colormodel","util/comparator":"util/comparator","util/exception":"util/exception","util/nlmath":"util/nlmath"}],"engine/core/typechecker":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // There are three basic entry points here:

  // 1. The `nlTypes.checks.*` functions, that check if a value is of a given type.  These are appropriate to use
  //    for primitives like `is-turtle?` and other operations like equality checks or import/export.
  // 2. There are type instances in the `nlTypes.types.*`, which can be used to compose the types that a primitive
  //    accepts as arguments at runtime.
  // 3. The `nlTypes.getTypeOf()` function, which returns a definite type for a value.  This is really only useful
  //    when you need to spit out a runtime type mismatch error message for a value and you want to describe the
  //    value's type accurately.  It'll be slow since it runs checks until it determines the value's type for
  //    certain.

  // -Jeremy B December 2020
  var AbstractAgentSet, AgentSetType, AgentType, BooleanType, CommandLambdaType, Link, LinkSet, LinkSetType, LinkType, ListType, NLType, NobodyType, NumberType, Patch, PatchSet, PatchSetType, PatchType, ReporterLambdaType, StringType, Turtle, TurtleSet, TurtleSetType, TurtleType, WildcardType, checks, getTypeOf, isAgent, isAgentSet, isBoolean, isBreed, isBreedSet, isCommandLambda, isDirectedLink, isFunction, isLink, isLinkSet, isList, isNobody, isNumber, isPatch, isPatchSet, isReporterLambda, isString, isTurtle, isTurtleSet, isUndirectedLink, isValidAgent, isValidDirectedLink, isValidLink, isValidTurtle, isValidUndirectedLink, types, unimplemented;

  getTypeOf = function(x) {
    switch (false) {
      case !isNumber(x):
        return types.Number;
      case !isList(x):
        return types.List;
      case !isString(x):
        return types.String;
      case !isBoolean(x):
        return types.Boolean;
      case !isTurtle(x):
        return types.Turtle;
      case !isPatch(x):
        return types.Patch;
      case !isLink(x):
        return types.Link;
      case !isPatchSet(x):
        return types.PatchSet;
      case !isTurtleSet(x):
        return types.TurtleSet;
      case !isLinkSet(x):
        return types.LinkSet;
      case !isAgentSet(x):
        return types.AgentSet;
      case !isNobody(x):
        return types.Nobody;
      case !isCommandLambda(x):
        return types.CommandLambda;
      case !isReporterLambda(x):
        return types.ReporterLambda;
      default:
        return types.WildcardType;
    }
  };

  // We have to do something wonky to deal with the cyclic dependencies here --JAB (3/2/15)
  // As an example, `turtlevariables.coffee` depends on this file and also `turtle.coffee`, which this file
  // depends on.  So when we call `require()` the `turtle.coffee` is read and it calls `require()` on
  // `turtlevariables.coffee` so when it calls `require()` for us again, it gets an empty object back.
  // So we have to "back-fill" our export to get around that. -Jeremy B December 2020
  types = {};

  checks = {};

  NLType = (function() {
    class NLType {};

    NLType.prototype.isOfType = unimplemented;

    NLType.prototype.niceName = unimplemented;

    return NLType;

  }).call(this);

  module.exports = {types, checks, getTypeOf, NLType};

  AbstractAgentSet = require('./abstractagentset');

  Link = require('./link');

  LinkSet = require('./linkset');

  Patch = require('./patch');

  PatchSet = require('./patchset');

  Turtle = require('./turtle');

  TurtleSet = require('./turtleset');

  isFunction = function(x) {
    return typeof x === "function";
  };

  isCommandLambda = function(x) {
    return isFunction(x) && !x.isReporter;
  };

  isReporterLambda = function(x) {
    return isFunction(x) && x.isReporter;
  };

  // Micro-benchmarks showed this to be mildly faster than `typeof(x) is "boolean"`.
  // This is used in tight loops with `filter` and `sort`, so even a 2.5% increase is
  // worth it.  -Jeremy B December 2020
  isBoolean = function(x) {
    return x === true || x === false;
  };

  isList = function(x) {
    return Array.isArray(x);
  };

  isNumber = function(x) {
    return typeof x === "number";
  };

  isString = function(x) {
    return typeof x === "string";
  };

  isNobody = function(x) {
    return x === Nobody;
  };

  isTurtle = function(x) {
    return x instanceof Turtle;
  };

  isPatch = function(x) {
    return x instanceof Patch;
  };

  isLink = function(x) {
    return x instanceof Link;
  };

  isAgent = function(x) {
    return isTurtle(x) || isPatch(x) || isLink(x);
  };

  isBreed = function(breedName, x) {
    return (isTurtle(x) || isLink(x)) && !x.isDead() && x.isBreed(breedName);
  };

  isDirectedLink = function(x) {
    return isLink(x) && x.isDirected;
  };

  isUndirectedLink = function(x) {
    return isLink(x) && !x.isDirected;
  };

  isAgentSet = function(x) {
    return x instanceof AbstractAgentSet;
  };

  isTurtleSet = function(x) {
    return x instanceof TurtleSet;
  };

  isPatchSet = function(x) {
    return x instanceof PatchSet;
  };

  isLinkSet = function(x) {
    return x instanceof LinkSet;
  };

  isBreedSet = function(breedName, x) {
    return isAgentSet(x) && (x.getSpecialName() != null) && x.getSpecialName() === breedName;
  };

  isValidTurtle = function(x) {
    return isTurtle(x) && !x.isDead();
  };

  isValidLink = function(x) {
    return isLink(x) && !x.isDead();
  };

  isValidAgent = function(x) {
    return isValidTurtle(x) || isPatch(x) || isValidLink(x);
  };

  isValidDirectedLink = function(x) {
    return isValidLink(x) && x.isDirected;
  };

  isValidUndirectedLink = function(x) {
    return isValidLink(x) && !x.isDirected;
  };

  unimplemented = function() {
    throw new Error("Unimplemented abstract method!");
  };

  CommandLambdaType = (function() {
    class CommandLambdaType extends NLType {
      niceName() {
        return "anonymous command";
      }

    };

    CommandLambdaType.prototype.isOfType = isCommandLambda;

    return CommandLambdaType;

  }).call(this);

  ReporterLambdaType = (function() {
    class ReporterLambdaType extends NLType {
      niceName() {
        return "anonymous reporter";
      }

    };

    ReporterLambdaType.prototype.isOfType = isReporterLambda;

    return ReporterLambdaType;

  }).call(this);

  BooleanType = (function() {
    class BooleanType extends NLType {
      niceName() {
        return "TRUE/FALSE";
      }

    };

    BooleanType.prototype.isOfType = isBoolean;

    return BooleanType;

  }).call(this);

  ListType = (function() {
    class ListType extends NLType {
      niceName() {
        return "list";
      }

    };

    ListType.prototype.isOfType = isList;

    return ListType;

  }).call(this);

  NumberType = (function() {
    class NumberType extends NLType {
      niceName() {
        return "number";
      }

    };

    NumberType.prototype.isOfType = isNumber;

    return NumberType;

  }).call(this);

  StringType = (function() {
    class StringType extends NLType {
      niceName() {
        return "string";
      }

    };

    StringType.prototype.isOfType = isString;

    return StringType;

  }).call(this);

  NobodyType = (function() {
    class NobodyType extends NLType {
      niceName() {
        return "nobody";
      }

    };

    NobodyType.prototype.isOfType = isNobody;

    return NobodyType;

  }).call(this);

  AgentType = (function() {
    class AgentType extends NLType {
      niceName() {
        return "agent";
      }

    };

    AgentType.prototype.isOfType = isAgent;

    return AgentType;

  }).call(this);

  TurtleType = (function() {
    class TurtleType extends AgentType {
      niceName() {
        return "turtle";
      }

    };

    TurtleType.prototype.isOfType = isTurtle;

    return TurtleType;

  }).call(this);

  PatchType = (function() {
    class PatchType extends AgentType {
      niceName() {
        return "patch";
      }

    };

    PatchType.prototype.isOfType = isPatch;

    return PatchType;

  }).call(this);

  LinkType = (function() {
    class LinkType extends AgentType {
      niceName() {
        return "link";
      }

    };

    LinkType.prototype.isOfType = isLink;

    return LinkType;

  }).call(this);

  AgentSetType = (function() {
    class AgentSetType extends NLType {
      niceName() {
        return "agentset";
      }

    };

    AgentSetType.prototype.isOfType = isAgentSet;

    return AgentSetType;

  }).call(this);

  TurtleSetType = (function() {
    class TurtleSetType extends AgentSetType {
      niceName() {
        return "turtle agentset";
      }

    };

    TurtleSetType.prototype.isOfType = isTurtleSet;

    return TurtleSetType;

  }).call(this);

  PatchSetType = (function() {
    class PatchSetType extends AgentSetType {
      niceName() {
        return "patch agentset";
      }

    };

    PatchSetType.prototype.isOfType = isPatchSet;

    return PatchSetType;

  }).call(this);

  LinkSetType = (function() {
    class LinkSetType extends AgentSetType {
      niceName() {
        return "link agentset";
      }

    };

    LinkSetType.prototype.isOfType = isLinkSet;

    return LinkSetType;

  }).call(this);

  WildcardType = class WildcardType extends NLType {
    isOfType() {
      return true;
    }

    niceName() {
      return "anything";
    }

  };

  Object.assign(checks, {isAgent, isAgentSet, isBoolean, isBreed, isBreedSet, isCommandLambda, isDirectedLink, isLink, isLinkSet, isList, isNobody, isNumber, isPatch, isPatchSet, isReporterLambda, isString, isTurtle, isTurtleSet, isUndirectedLink, isValidAgent, isValidDirectedLink, isValidLink, isValidTurtle, isValidUndirectedLink});

  Object.assign(types, {
    Boolean: new BooleanType(),
    List: new ListType(),
    Number: new NumberType(),
    String: new StringType(),
    Nobody: new NobodyType(),
    CommandLambda: new CommandLambdaType(),
    ReporterLambda: new ReporterLambdaType(),
    Agent: new AgentType(),
    Turtle: new TurtleType(),
    Patch: new PatchType(),
    Link: new LinkType(),
    AgentSet: new AgentSetType(),
    TurtleSet: new TurtleSetType(),
    PatchSet: new PatchSetType(),
    LinkSet: new LinkSetType(),
    Wildcard: new WildcardType()
  });

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./link":"engine/core/link","./linkset":"engine/core/linkset","./patch":"engine/core/patch","./patchset":"engine/core/patchset","./turtle":"engine/core/turtle","./turtleset":"engine/core/turtleset"}],"engine/core/world/export":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentReference, BreedNamePair, BreedReference, ExportAllPlotsData, ExportPlotData, ExportWorldData, ExportedAgent, ExportedAgentSet, ExportedColorNum, ExportedCommandLambda, ExportedExtension, ExportedGlobals, ExportedLink, ExportedLinkSet, ExportedPatch, ExportedPatchSet, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtle, ExportedTurtleSet, ExtensionsHandler, LinkReference, Metadata, NobodyReference, None, PatchReference, TurtleReference, checks, difference, displayModeToString, exportAgent, exportAgentReference, exportBreedReference, exportColor, exportGlobals, exportLinkReference, exportMetadata, exportMiniGlobals, exportPatchReference, exportPlot, exportPlotManager, exportRawPlot, exportTurtleReference, exportWildcardVar, find, fold, id, isEmpty, linkBuiltins, maybe, patchBuiltins, penModeToBool, perspectiveToString, tee, toObject, turtleBuiltins, version;

  ({version} = require('meta'));

  ({AgentReference, BreedNamePair, BreedReference, ExportAllPlotsData, ExportedAgent, ExportedAgentSet, ExportedColorNum, ExportedCommandLambda, ExportedExtension, ExportedGlobals, ExportedLink, ExportedLinkSet, ExportedPatch, ExportedPatchSet, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedReporterLambda, ExportedRGB, ExportedRGBA, ExportedTurtle, ExportedTurtleSet, ExportPlotData, ExportWorldData, LinkReference, Metadata, NobodyReference, PatchReference, TurtleReference} = require('serialize/exportstructures'));

  ({
    Perspective: {perspectiveToString}
  } = require('../observer'));

  ({linkBuiltins, patchBuiltins, turtleBuiltins} = require('../structure/builtins'));

  ({
    DisplayMode: {displayModeToString},
    PenMode: {penModeToBool}
  } = require('engine/plot/pen'));

  ExtensionsHandler = require('./extensionshandler');

  ({difference, find, isEmpty, toObject} = require('brazierjs/array'));

  ({id, tee} = require('brazierjs/function'));

  ({fold, maybe, None} = require('brazierjs/maybe'));

  ({checks} = require('../typechecker'));

  // Yo!  This file expects that basically all of its functions will be called in the context
  // of the `World` object.  That is, they should be called within methods on `World`, using
  // `<function>.call(this)`. --JAB (12/10/17)

  // (String|(Number, Number, Number)|(Number, Number, Number, Number)) => ExportedColor
  exportColor = function(color) {
    var a, b, g, r;
    if (checks.isNumber(color)) {
      return new ExportedColorNum(color);
    } else if (checks.isList(color)) {
      [r, g, b, a] = color;
      if (a != null) {
        return new ExportedRGBA(r, g, b, a);
      } else {
        return new ExportedRGB(r, g, b);
      }
    } else {
      throw new Error(`Unrecognized color format: ${JSON.stringify(color)}`);
    }
  };

  // (String) => BreedReference
  exportBreedReference = function(breedName) {
    return new BreedReference(breedName.toLowerCase());
  };

  // (Patch) => PatchReference
  exportPatchReference = function(patch) {
    return new PatchReference(patch.pxcor, patch.pycor);
  };

  // (Turtle) => TurtleReference
  exportTurtleReference = function(turtle) {
    var breed;
    breed = new BreedNamePair(turtle.getBreedNameSingular(), turtle.getBreedName().toLowerCase());
    return new TurtleReference(breed, turtle.id);
  };

  // (Link) => LinkReference
  exportLinkReference = function(link) {
    var breed;
    breed = new BreedNamePair(link.getBreedNameSingular(), link.getBreedName().toLowerCase());
    return new LinkReference(breed, link.end1.id, link.end2.id);
  };

  // (Agent) => AgentReference
  exportAgentReference = function(agent) {
    if (checks.isNobody(agent) || agent.isDead()) {
      return NobodyReference;
    } else if (checks.isLink(agent)) {
      return exportLinkReference(agent);
    } else if (checks.isPatch(agent)) {
      return exportPatchReference(agent);
    } else if (checks.isTurtle(agent)) {
      return exportTurtleReference(agent);
    } else {
      throw new Error(`Cannot make agent reference out of: ${JSON.stringify(agent)}`);
    }
  };

  // (Agent, ExtensionsExporter) => (String) => Any
  exportWildcardVar = function(agent, extensionExporter) {
    return function(varName) {
      var exportWildcardValue;
      exportWildcardValue = function(value) {
        if (checks.isAgent(value) || checks.isNobody(value)) {
          return exportAgentReference(value);
        } else if ((typeof value.getSpecialName === "function" ? value.getSpecialName() : void 0) != null) {
          return new BreedReference(value.getSpecialName().toLowerCase());
        } else if (checks.isLinkSet(value)) {
          return new ExportedLinkSet(value.toArray().map(exportLinkReference));
        } else if (checks.isPatchSet(value)) {
          return new ExportedPatchSet(value.toArray().map(exportPatchReference));
        } else if (checks.isTurtleSet(value)) {
          return new ExportedTurtleSet(value.toArray().map(exportTurtleReference));
        } else if (checks.isCommandLambda(value)) {
          return new ExportedCommandLambda(value.nlogoBody);
        } else if (checks.isReporterLambda(value)) {
          return new ExportedReporterLambda(value.nlogoBody);
        } else if (checks.isList(value)) {
          return value.map(exportWildcardValue);
        } else if (extensionExporter.canHandle(value)) {
          return extensionExporter.exportObject(value, exportWildcardValue);
        } else {
          return value;
        }
      };
      return exportWildcardValue(agent.getVariable(varName));
    };
  };

  // () => Object[Any]
  exportMetadata = function() {
    // TODO: Get filename from metadata from compiler, once NetLogo/NetLogo#1547 has been merged --JAB (2/8/18)
    return new Metadata(version, '[IMPLEMENT .NLOGO]', new Date());
  };

  // [T, U <: ExportedAgent[T]] @ (Class[U], Array[(String, (Any) => Any)], String, ExtensionExports) => (T) => U
  exportAgent = function(clazz, builtInsMappings, labelVarName, extensions) {
    return function(agent) {
      var builtInsNames, builtInsValues, extras, extrasNames, wildcard;
      wildcard = exportWildcardVar(agent, extensions);
      builtInsValues = builtInsMappings.map(function([name, f]) {
        if (name === labelVarName) {
          return wildcard(name);
        } else {
          return f(agent.getVariable(name));
        }
      });
      builtInsNames = builtInsMappings.map(function([name]) {
        return name;
      });
      extrasNames = difference(agent.varNames())(builtInsNames);
      extras = toObject(extrasNames.map(tee(id)(wildcard)));
      return new clazz(...builtInsValues, extras);
    };
  };

  // (Plot) => ExportedPlot
  exportPlot = function(plot) {
    var currentPenNameOrNull, exportPen, isAutoplotting, isLegendOpen, name, pens, xMax, xMin, yMax, yMin;
    exportPen = function(pen) {
      var color, exportPoint, interval, isPenDown, mode, name, points, x;
      exportPoint = function({x, y, penMode, color}) {
        return new ExportedPoint(x, y, penModeToBool(penMode), color);
      };
      color = pen.getColor();
      interval = pen.getInterval();
      isPenDown = penModeToBool(pen.getPenMode());
      mode = displayModeToString(pen.getDisplayMode());
      name = pen.name;
      points = pen.getPoints().map(exportPoint);
      x = pen.getPenX();
      return new ExportedPen(color, interval, isPenDown, mode, name, points, x);
    };
    currentPenNameOrNull = fold(function() {
      return null;
    })(function(cp) {
      return cp.name;
    })(plot.getCurrentPenMaybe());
    isAutoplotting = plot.isAutoplotting;
    isLegendOpen = plot.isLegendEnabled;
    name = plot.name;
    pens = plot.getPens().map(exportPen);
    xMax = plot.xMax;
    xMin = plot.xMin;
    yMax = plot.yMax;
    yMin = plot.yMin;
    return new ExportedPlot(currentPenNameOrNull, isAutoplotting, isLegendOpen, name, pens, xMax, xMin, yMax, yMin);
  };

  // (String) => ExportedPlot
  exportRawPlot = function(plotName) {
    var desiredPlotMaybe, exporter, plot;
    desiredPlotMaybe = find(function(x) {
      return x.name === plotName;
    })(this._plotManager.getPlots());
    exporter = function(plot) {
      return exportPlot(plot);
    };
    return plot = fold(function() {
      throw new Error(`no such plot: "${plotName}"`);
    })(exporter)(desiredPlotMaybe);
  };

  // (ExtensionExports) => ExportedPlotManager
  exportPlotManager = function(extensions) {
    var currentPlotNameOrNull, exporter, plots;
    currentPlotNameOrNull = fold(function() {
      return null;
    })(function(cp) {
      return cp.name;
    })(this._plotManager.getCurrentPlotMaybe());
    exporter = function(plot) {
      return exportPlot(plot, extensions);
    };
    plots = this._plotManager.getPlots().map(exporter);
    return new ExportedPlotManager(currentPlotNameOrNull, plots);
  };

  // (ExtensionExports) => Object[Any]
  exportMiniGlobals = function(extensions) {
    var namesNotDeleted;
    namesNotDeleted = this.observer.varNames().filter((name) => {
      return this.observer.getVariable(name) != null;
    }).sort();
    return toObject(namesNotDeleted.map(tee(id)(exportWildcardVar(this.observer, extensions))));
  };

  // (ExtensionExports) => ExportedGlobals
  exportGlobals = function(extensions) {
    var codeGlobals, linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, noUnbreededLinks, perspective, subject, ticks;
    noUnbreededLinks = isEmpty(this.links().toArray().filter(function(l) {
      return l.getBreedName().toUpperCase() === "LINKS";
    }));
    linkDirectedness = noUnbreededLinks ? 'neither' : this.breedManager.links().isDirected() ? 'directed' : 'undirected';
    maxPxcor = this.topology.maxPxcor;
    maxPycor = this.topology.maxPycor;
    minPxcor = this.topology.minPxcor;
    minPycor = this.topology.minPycor;
    nextWhoNumber = this.turtleManager.peekNextID();
    perspective = perspectiveToString(this.observer.getPerspective());
    subject = exportAgentReference(this.observer.subject());
    ticks = this.ticker.ticksAreStarted() ? this.ticker.tickCount() : -1;
    codeGlobals = exportMiniGlobals.call(this, extensions);
    return new ExportedGlobals(linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, perspective, subject, ticks, codeGlobals);
  };

  // () => ExportAllPlotsData
  module.exports.exportAllPlots = function() {
    var extensionExporter, metadata, miniGlobals, plots;
    metadata = exportMetadata.call(this);
    extensionExporter = ExtensionsHandler.makeExporter(this.extensionPorters);
    miniGlobals = exportMiniGlobals.call(this, extensionExporter);
    plots = this._plotManager.getPlots().map(exportPlot);
    return new ExportAllPlotsData(metadata, miniGlobals, plots);
  };

  // (String) => ExportedPlot
  module.exports.exportRawPlot = exportRawPlot;

  // (String) => ExportPlotData
  module.exports.exportPlot = function(plotName) {
    var extensionExporter, metadata, miniGlobals, plot;
    metadata = exportMetadata.call(this);
    extensionExporter = ExtensionsHandler.makeExporter(this.extensionPorters);
    miniGlobals = exportMiniGlobals.call(this, extensionExporter);
    plot = exportRawPlot.call(this, plotName);
    return new ExportPlotData(metadata, miniGlobals, plot);
  };

  // () => ExportWorldData
  module.exports.exportWorld = function() {
    var drawingM, extensionExporter, extensions, globals, labelExporter, linkExport, linkMapper, links, makeMappings, metadata, output, patchExport, patchMapper, patches, plotManager, randomState, turtleExport, turtleMapper, turtles;
    makeMappings = function(builtins) {
      return function(mapper) {
        return builtins.map(tee(id)(mapper));
      };
    };
    extensionExporter = ExtensionsHandler.makeExporter(this.extensionPorters);
    labelExporter = (varName) => {
      return (agent) => {
        return exportWildcardVar(agent, extensionExporter)(varName);
      };
    };
    patchMapper = function(varName) {
      switch (varName) {
        case "pcolor":
        case "plabel-color":
          return function(color) {
            return exportColor(color);
          };
        default:
          return id;
      }
    };
    turtleMapper = function(varName) {
      switch (varName) {
        case "breed":
          return function(breed) {
            return exportBreedReference(breed.toString());
          };
        case "color":
        case "label-color":
          return function(color) {
            return exportColor(color);
          };
        default:
          return id;
      }
    };
    linkMapper = function(varName) {
      switch (varName) {
        case "breed":
          return function(breed) {
            return exportBreedReference(breed.toString());
          };
        case "color":
        case "label-color":
          return function(color) {
            return exportColor(color);
          };
        case "end1":
        case "end2":
          return function(end) {
            return exportTurtleReference(end);
          };
        default:
          return id;
      }
    };
    metadata = exportMetadata.call(this);
    randomState = this.rng.exportState();
    globals = exportGlobals.call(this, extensionExporter);
    patchExport = exportAgent(ExportedPatch, makeMappings(patchBuiltins)(patchMapper), "plabel", extensionExporter);
    turtleExport = exportAgent(ExportedTurtle, makeMappings(turtleBuiltins)(turtleMapper), "label", extensionExporter);
    linkExport = exportAgent(ExportedLink, makeMappings(linkBuiltins)(linkMapper), "llabel", extensionExporter);
    patches = this.patches().toArray().map(patchExport);
    turtles = this.turtleManager.turtles().toArray().map(turtleExport);
    links = this.linkManager.links().toArray().map(linkExport);
    drawingM = !this._updater.drawingWasJustCleared() ? maybe([this.patchSize, this._getViewBase64()]) : None;
    output = this._getOutput();
    plotManager = exportPlotManager.call(this, extensionExporter);
    extensions = extensionExporter.export();
    return new ExportWorldData(metadata, randomState, globals, patches, turtles, links, drawingM, output, plotManager, extensions);
  };

}).call(this);

},{"../observer":"engine/core/observer","../structure/builtins":"engine/core/structure/builtins","../typechecker":"engine/core/typechecker","./extensionshandler":"engine/core/world/extensionshandler","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","engine/plot/pen":"engine/plot/pen","meta":"meta","serialize/exportstructures":"serialize/exportstructures"}],"engine/core/world/extensionshandler":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // type ExtensionPorter[T] = {
  //   canHandle: (Any) => Boolean,

  //   dump: (T, (Any) => String) => String,

  //   exportObject: (T, (Any) => Any) => ExportedExtensionObject,
  //   export:       (Array[ExportedExtensionObject]) => ExportedExtension

  //   format:       (ExportedExtension, (Any) => String) => String
  //   formatObject: (ExportedExtensionObject, (Any) => String) => String

  //   readObject: (String, String, (String) => Any) => ExportedExtensionObject
  //   read:       (String, (String) => Any) => ExportedExtension

  //   import:       (ExportedExtension, (Any) => Any) => Unit
  //   importObject: (ExportedExtension, ExtensionPlaceholder, (Any) => Any)) => T

  // }

  // (ExtensionPorter, Any) => Boolean
  var canHandleCheck, createPlaceholder, eitherCheck, formatPlaceholder, isPlaceholder, makeCanHandle, makeDumper, makeExporter, makeFormatter, makeImporter, makeReader, makeTraverse, placeholderCheck, placeholderRegEx;

  canHandleCheck = function(p, x) {
    return p.canHandle(x);
  };

  // (ExtensionPorter, Any) => Boolean
  placeholderCheck = function(p, x) {
    return isPlaceholder(x) && p.extensionName === x.extensionName;
  };

  // (ExtensionPorter, Any) => Boolean
  eitherCheck = function(p, x) {
    return canHandleCheck(p, x) || placeholderCheck(p, x);
  };

  // (Array[ExtensionPorter], (ExtensionPorter, Any) => Boolean) => (Any) => Boolean
  makeCanHandle = function(extensionPorters, check) {
    return function(x) {
      var applicablePorters;
      applicablePorters = extensionPorters.filter(function(p) {
        return check(p, x);
      });
      if (applicablePorters.length > 1) {
        throw new Error(`Multiple extensions claim to know how to handle this object type: ${JSON.stringify(x)}`);
      }
      return applicablePorters.length === 1;
    };
  };

  // (Array[ExtensionPorter], (ExtensionPorter, Any, (Any) => Any) => Any) => ExtensionsHandler
  makeTraverse = function(extensionPorters, objectHandler, check) {
    var extensionReferences, inProgressMarker, traverse;
    extensionReferences = new Map();
    inProgressMarker = Object.freeze({
      type: "operation-in-progress"
    });
    // (Any, (Any) => Any) => Any
    traverse = function(x, helper) {
      var extensionObject, porter;
      if (!extensionReferences.has(x)) {
        porter = extensionPorters.filter(function(p) {
          return check(p, x);
        })[0];
        extensionReferences.set(x, inProgressMarker);
        extensionObject = objectHandler(porter, x, helper);
        extensionReferences.set(x, extensionObject);
        return extensionObject;
      } else {
        extensionObject = extensionReferences.get(x);
        if (extensionObject === inProgressMarker) {
          throw new Error("Circular references within extension objects are not supported.");
        }
        return extensionObject;
      }
    };
    return {traverse, extensionReferences};
  };

  // (String, String, Int) => ExtensionPlaceholder
  createPlaceholder = function(extensionName, subType, index) {
    return {
      type: "extension-object-placeholder",
      extensionName,
      subType,
      index
    };
  };

  // (Any) => Boolean
  isPlaceholder = function(x) {
    return (x.type != null) && x.type === "extension-object-placeholder";
  };

  // (ExtensionPlaceholder) => String
  formatPlaceholder = function(x) {
    return `{{${x.extensionName}:${x.subType} ${x.index}}}`;
  };

  // (Array[ExtensionPorter]) => ExtensionsDumper
  makeDumper = function(extensionPorters) {
    var dumpPorterObject, traverser;
    dumpPorterObject = function(porter, x, helper) {
      return porter.dump(x, helper);
    };
    traverser = makeTraverse(extensionPorters, dumpPorterObject, canHandleCheck);
    return {
      canHandle: makeCanHandle(extensionPorters, canHandleCheck),
      dump: traverser.traverse,
      reset: function() {
        return traverser.extensionReferences.clear();
      }
    };
  };

  // (Array[ExtensionPorter]) => ExtensionsExporter
  makeExporter = function(extensionPorters) {
    var exportExt, exportObject, extensionObjects;
    // Map[ExtensionPorter, Array[ExportedExtensionObject]]
    extensionObjects = new Map();
    exportObject = function(porter, x, helper) {
      var porterObject, porterObjects, pos;
      porterObjects = !extensionObjects.has(porter) ? (pos = [], extensionObjects.set(porter, pos), pos) : extensionObjects.get(porter);
      porterObject = porter.exportObject(x, helper);
      porterObjects.push(porterObject);
      return createPlaceholder(porter.extensionName, porterObject.subType, porterObjects.length - 1);
    };
    // () => Map[ExtensionPorter, ExportedExtension]
    exportExt = function() {
      var extensionStates;
      extensionStates = new Map();
      extensionPorters.forEach(function(porter) {
        var porterObjects;
        porterObjects = extensionObjects.get(porter);
        return extensionStates.set(porter, porter.export(porterObjects != null ? porterObjects : []));
      });
      return extensionStates;
    };
    return {
      canHandle: makeCanHandle(extensionPorters, canHandleCheck),
      exportObject: makeTraverse(extensionPorters, exportObject, canHandleCheck).traverse,
      export: exportExt
    };
  };

  // (Array[ExtensionPorter]) => ExtensionsFormatter
  makeFormatter = function(extensionPorters) {
    var format, formatPlaceholderObject;
    formatPlaceholderObject = function(_1, x, _2) {
      return formatPlaceholder(x);
    };
    // (Map[ExtensionPorter, ExportedExtension], (Any) => String) => String
    format = function(extensionExports, helper) {
      var porterStrings, porters;
      porters = Array.from(extensionExports.keys());
      // `sort()` to match the order desktop returns the extensions in -Jeremy B September 2020
      porters.sort(function(p1, p2) {
        return p1.extensionName.localeCompare(p2.extensionName);
      });
      porterStrings = porters.map(function(porter) {
        var extensionCSV;
        extensionCSV = porter.format(extensionExports.get(porter), helper);
        if (extensionCSV.trim() === '') {
          return '';
        } else {
          return `"${porter.extensionName}"\n${extensionCSV}`;
        }
      });
      return porterStrings.filter(function(str) {
        return str !== '';
      }).join("\n\n");
    };
    return {
      canHandle: makeCanHandle(extensionPorters, eitherCheck),
      formatPlaceholder: makeTraverse(extensionPorters, formatPlaceholderObject, placeholderCheck).traverse,
      format
    };
  };

  // (Array[ExtensionPorter], Map[ExtensionPorter, ExportedExtension]) => ExtensionsImporter
  makeImporter = function(extensionPorters, extensionExports) {
    var importObject, importState, importedObjects;
    importedObjects = new Map();
    importObject = function(porter, placeholder, helper) {
      var exportedExt, importedObject;
      if (importedObjects.has(placeholder)) {
        return importedObjects.get(placeholder);
      } else {
        exportedExt = extensionExports.get(porter);
        importedObject = porter.importObject(exportedExt, placeholder, helper);
        importedObjects.set(placeholder, importedObject);
        return importedObject;
      }
    };
    importState = function(porter, extensionStates) {
      var ref;
      return porter.importState(extensionStates.get(porter), (ref = extensionObjects.get(porter)) != null ? ref : []);
    };
    return {
      canHandle: makeCanHandle(extensionPorters, placeholderCheck),
      importObject: makeTraverse(extensionPorters, importObject, placeholderCheck).traverse,
      importState: importState
    };
  };

  placeholderRegEx = /{{(.+)\:(.*) (\d+)}}/;

  // (Array[ExtensionPorter]) => ExtensionsReader
  makeReader = function(extensionPorters) {
    var extensionNames, matchesPlaceholder, readExtensions, readPlaceholder;
    matchesPlaceholder = function(x) {
      return x.match(placeholderRegEx);
    };
    readPlaceholder = function(match) {
      return createPlaceholder(match[1], match[2], parseFloat(match[3]));
    };
    extensionNames = extensionPorters.map(function(porter) {
      return porter.extensionName.toUpperCase();
    });
    readExtensions = function(porterSections, parseAny) {
      var extensionExps;
      extensionExps = new Map();
      Object.keys(porterSections).forEach(function(extensionName) {
        var extensionExp, porter, possiblePorters, section;
        possiblePorters = extensionPorters.filter(function(porter) {
          return porter.extensionName === extensionName;
        });
        if (possiblePorters.length === 0) {
          throw new Error("No extension porter found for this thing?");
        }
        if (possiblePorters.length > 1) {
          throw new Error("Multiple extension porters found for this thing?");
        }
        porter = possiblePorters[0];
        section = porterSections[extensionName];
        extensionExp = porter.read(section, parseAny);
        return extensionExps.set(porter, extensionExp);
      });
      return extensionExps;
    };
    return {matchesPlaceholder, readPlaceholder, extensionNames, readExtensions};
  };

  module.exports = {makeDumper, makeExporter, makeFormatter, makeImporter, makeReader};

}).call(this);

},{}],"engine/core/world/idmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var IDManager;

  module.exports = IDManager = (function() {
    class IDManager {
      // () => IDManager
      constructor() {
        this.reset();
      }

      // () => Number
      getCount() {
        return this._count;
      }

      // () => Unit
      reset() {
        this._count = 0;
      }

      // Number
      next() {
        return this._count++;
      }

      // (Number) => Unit
      setCount(_count) {
        this._count = _count;
      }

      // (() => Any) => Unit
      suspendDuring(f) {
        var oldCount;
        oldCount = this._count;
        f();
        this._count = oldCount;
      }

    };

    // Number
    IDManager.prototype._count = void 0;

    return IDManager;

  }).call(this);

}).call(this);

},{}],"engine/core/world/import":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtleSet, ExtensionsHandler, LinkReference, LinkSet, NobodyReference, PatchReference, PatchSet, TurtleReference, TurtleSet, checks, fold, perspectiveFromString, reifyExported,
    indexOf = [].indexOf;

  ({checks} = require('../typechecker'));

  LinkSet = require('../linkset');

  PatchSet = require('../patchset');

  TurtleSet = require('../turtleset');

  ExtensionsHandler = require('./extensionshandler');

  ({
    Perspective: {perspectiveFromString}
  } = require('../observer'));

  ({BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtleSet, LinkReference, NobodyReference, PatchReference, TurtleReference} = require('serialize/exportstructures'));

  ({fold} = require('brazier/maybe'));

  // ( (Number) => Agent
  // , (Number, Number) => Agent
  // , (Number, Number, String) => Agent
  // , () => PatchSet
  // , () => Breed
  // , World
  // , ExtensionsImporter
  // ) => (Any) => Any
  reifyExported = function(getTurtle, getPatch, getLink, getAllPatches, getBreed, world, extensionImporter) {
    var helper;
    return helper = function(x) {
      var fn, links, patches, turtles;
      if (checks.isList(x)) {
        return x.map(helper);
      } else if (checks.isBoolean(x) || checks.isNumber(x) || checks.isString(x)) {
        return x;
      } else if (x === NobodyReference) {
        return Nobody;
      } else if (x instanceof BreedReference) {
        switch (x.breedName) {
          case "PATCHES":
            return getAllPatches();
          default:
            return getBreed(x.breedName);
        }
      } else if (x instanceof LinkReference) {
        return getLink(x.id1, x.id2, x.breed.plural);
      } else if (x instanceof PatchReference) {
        return getPatch(x.pxcor, x.pycor);
      } else if (x instanceof TurtleReference) {
        return getTurtle(x.id);
      } else if (x instanceof ExportedLinkSet) {
        links = x.references.map(function({
            id1,
            id2,
            breed: {plural}
          }) {
          return getLink(id1, id2, plural);
        });
        return new LinkSet(links, world);
      } else if (x instanceof ExportedPatchSet) {
        patches = x.references.map(function({pxcor, pycor}) {
          return getPatch(pxcor, pycor);
        });
        return new PatchSet(patches, world);
      } else if (x instanceof ExportedTurtleSet) {
        turtles = x.references.map(function({id}) {
          return getTurtle(id);
        });
        return new TurtleSet(turtles, world);
      } else if (x instanceof ExportedCommandLambda) {
        fn = (function() {
          throw new Error("Importing and then running lambdas is not supported!");
        });
        fn.isReporter = false;
        fn.nlogoBody = x.source;
        return fn;
      } else if (x instanceof ExportedReporterLambda) {
        fn = (function() {
          throw new Error("Importing and then running lambdas is not supported!");
        });
        fn.isReporter = true;
        fn.nlogoBody = x.source;
        return fn;
      } else if (extensionImporter.canHandle(x)) {
        return extensionImporter.importObject(x, helper);
      } else {
        throw new Error(`Unknown item for reification: ${JSON.stringify(x)}`);
      }
    };
  };

  // (WorldState) => Unit
  module.exports.importWorld = function({
      globals: {
        linkDirectedness: directedLinks,
        maxPxcor,
        maxPycor,
        minPxcor,
        minPycor,
        nextWhoNumber,
        perspective,
        subject,
        ticks,
        codeGlobals
      },
      links,
      patches,
      plotManager,
      randomState,
      turtles,
      patchSize,
      drawingDataMaybe,
      output,
      extensions
    }) {
    var extensionImporter, extractColor, linkFinishFs, patchFinishFs, reify, trueSubject, turtleFinishFs, value, varName;
    extensionImporter = ExtensionsHandler.makeImporter(this.extensionPorters, extensions);
    reify = reifyExported(this.turtleManager.getTurtle.bind(this.turtleManager), this.getPatchAt.bind(this), this.linkManager.getLink.bind(this.linkManager), this.patches.bind(this), this.breedManager.get.bind(this.breedManager), this, extensionImporter);
    this.clearAll();
    if (directedLinks === "DIRECTED") {
      this._setUnbreededLinksDirected();
    } else {
      this._setUnbreededLinksUndirected();
    }
    this._resizeHelper(minPxcor, maxPxcor, minPycor, maxPycor, this.topology._wrapInX, this.topology._wrapInY);
    extractColor = function(color) {
      if (color instanceof ExportedColorNum) {
        return color.value;
      } else if (color instanceof ExportedRGB) {
        return [color.r, color.g, color.b];
      } else if (color instanceof ExportedRGBA) {
        return [color.r, color.g, color.b, color.a];
      } else {
        throw new Error(`Unknown color: ${JSON.stringify(color)}`);
      }
    };
    patchFinishFs = patches.map(({pxcor, pycor, pcolor, plabel, plabelColor, patchesOwns}) => {
      var patch;
      patch = this.patchAtCoords(pxcor, pycor);
      patch.setVariable('pcolor', extractColor(pcolor));
      patch.setVariable('plabel-color', extractColor(plabelColor));
      return function() {
        var results, value, varName;
        patch.setVariable('plabel', reify(plabel));
        results = [];
        for (varName in patchesOwns) {
          value = patchesOwns[varName];
          if (indexOf.call(patch.varNames(), varName) >= 0) {
            results.push(patch.setVariable(varName, reify(value)));
          }
        }
        return results;
      };
    });
    turtleFinishFs = turtles.map(({
        who,
        color,
        heading,
        xcor,
        ycor,
        shape,
        label,
        labelColor,
        breed: {breedName},
        isHidden,
        size,
        penSize,
        penMode,
        breedsOwns
      }) => {
      var args, newTurtle, realBreed, ref;
      realBreed = (ref = this.breedManager.get(breedName)) != null ? ref : this.breedManager.turtles();
      args = [who, extractColor(color), heading, xcor, ycor, realBreed, "", extractColor(labelColor), isHidden, size, shape];
      newTurtle = this.turtleManager._createTurtle(...args);
      newTurtle.penManager.setPenMode(penMode);
      newTurtle.penManager.setSize(penSize);
      return function() {
        var results, value, varName;
        newTurtle.setVariable('label', reify(label));
        results = [];
        for (varName in breedsOwns) {
          value = breedsOwns[varName];
          if (indexOf.call(newTurtle.varNames(), varName) >= 0) {
            results.push(newTurtle.setVariable(varName, reify(value)));
          }
        }
        return results;
      };
    });
    this.turtleManager._idManager.setCount(nextWhoNumber);
    linkFinishFs = links.map(({
        breed: {breedName},
        end1,
        end2,
        color,
        isHidden,
        label,
        labelColor,
        shape,
        thickness,
        tieMode,
        breedsOwns
      }) => {
      var newLink, realBreed, realEnd1, realEnd2, ref;
      realEnd1 = this.turtleManager.getTurtleOfBreed(end1.breed.plural, end1.id);
      realEnd2 = this.turtleManager.getTurtleOfBreed(end2.breed.plural, end2.id);
      realBreed = (ref = this.breedManager.get(breedName)) != null ? ref : this.breedManager.links();
      newLink = this.linkManager._createLink(realBreed.isDirected(), realEnd1, realEnd2, realBreed.name);
      newLink.setVariable('color', extractColor(color));
      newLink.setVariable('hidden?', isHidden);
      newLink.setVariable('label-color', extractColor(labelColor));
      newLink.setVariable('shape', shape);
      newLink.setVariable('thickness', thickness);
      newLink.setVariable('tie-mode', tieMode);
      return function() {
        var results, value, varName;
        newLink.setVariable('label', reify(label));
        results = [];
        for (varName in breedsOwns) {
          value = breedsOwns[varName];
          if (indexOf.call(newLink.varNames(), varName) >= 0) {
            results.push(newLink.setVariable(varName, reify(value)));
          }
        }
        return results;
      };
    });
    // Reification time!  This might seem a bit unintuitive, but, e.g. labels can be agents, link ends
    // are agents, and `*-owns` vars can be agents.  So we need to import all the agents before we can
    // finish importing them.  I'm calling this "second pass" stage the "reification stage", which is
    // when we revisit the things that we couldn't safely import earlier. --JAB (12/14/17)
    [].concat(patchFinishFs, turtleFinishFs, linkFinishFs).forEach(function(f) {
      return f();
    });
    for (varName in codeGlobals) {
      value = codeGlobals[varName];
      if (indexOf.call(this.observer.varNames(), varName) >= 0) {
        this.observer.setGlobal(varName, reify(value));
      }
    }
    trueSubject = reify(subject);
    if (trueSubject !== Nobody) {
      this.observer.setPerspective(perspectiveFromString(perspective), trueSubject);
    }
    // Reification done. --JAB (12/14/17)
    this._plotManager.importState(plotManager);
    this.ticker.importTicks(ticks);
    this.rng.importState(randomState);
    fold(function() {})(([patchSize, drawing]) => {
      this.setPatchSize(patchSize);
      return this.importDrawing(drawing);
    })(drawingDataMaybe);
    if (output != null) {
      this._setOutput(output);
    }
  };

}).call(this);

},{"../linkset":"engine/core/linkset","../observer":"engine/core/observer","../patchset":"engine/core/patchset","../turtleset":"engine/core/turtleset","../typechecker":"engine/core/typechecker","./extensionshandler":"engine/core/world/extensionshandler","brazier/maybe":"brazier/maybe","serialize/exportstructures":"serialize/exportstructures"}],"engine/core/world/linkmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // As far as dependencies and private access go, I'm treating this as if it's a part of `World` --JAB (8/5/14)
  var Builtins, IDManager, Link, LinkManager, LinkSet, SortedLinks, contains, exists, filter, isEmpty, map, pairs, pipeline, stableSort, values;

  Link = require('../link');

  LinkSet = require('../linkset');

  Builtins = require('../structure/builtins');

  IDManager = require('./idmanager');

  SortedLinks = require('./sortedlinks');

  stableSort = require('util/stablesort');

  ({contains, exists, filter, isEmpty, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({pairs, values} = require('brazierjs/object'));

  module.exports = LinkManager = (function() {
    class LinkManager {
      
      // (World, BreedManager, Updater, () => Unit, () => Unit) => LinkManager
      constructor(_world, _breedManager, _updater, _notifyIsDirected, _notifyIsUndirected) {
        // (String) => LinkSet
        this.linksOfBreed = this.linksOfBreed.bind(this);
        // (Link) => Unit
        this._removeLink = this._removeLink.bind(this);
        // ((Turtle) => Link) => (TurtleSet) => LinkSet
        this._createLinksBy = this._createLinksBy.bind(this);
        this._world = _world;
        this._breedManager = _breedManager;
        this._updater = _updater;
        this._notifyIsDirected = _notifyIsDirected;
        this._notifyIsUndirected = _notifyIsUndirected;
        this.clear();
      }

      // () => Unit
      clear() {
        this._linkArrCache = void 0;
        this._links = new SortedLinks;
        this._linksFrom = {};
        this._idManager = new IDManager;
        return this._linksTo = {};
      }

      // (Turtle, Turtle, String) => Link
      createDirectedLink(from, to, breedName) {
        if (breedName.toUpperCase() === "LINKS") {
          this._notifyIsDirected();
        }
        return this._createLink(true, from, to, breedName);
      }

      // (Turtle, TurtleSet, String) => LinkSet
      createDirectedLinks(source, others, breedName) {
        if (breedName.toUpperCase() === "LINKS") {
          this._notifyIsDirected();
        }
        return this._createLinksBy((turtle) => {
          return this._createLink(true, source, turtle, breedName);
        })(others);
      }

      // (Turtle, TurtleSet, String) => LinkSet
      createReverseDirectedLinks(source, others, breedName) {
        if (breedName.toUpperCase() === "LINKS") {
          this._notifyIsDirected();
        }
        return this._createLinksBy((turtle) => {
          return this._createLink(true, turtle, source, breedName);
        })(others);
      }

      // (Turtle, Turtle, String) => Link
      createUndirectedLink(source, other, breedName) {
        return this._createLink(false, source, other, breedName);
      }

      // (Turtle, TurtleSet, String) => LinkSet
      createUndirectedLinks(source, others, breedName) {
        return this._createLinksBy((turtle) => {
          return this._createLink(false, source, turtle, breedName);
        })(others);
      }

      // (Number, Number, String) => Agent
      getLink(fromId, toId, breedName = "LINKS") {
        var findFunc, isDirected, ref;
        isDirected = this._breedManager.get(breedName).isDirected();
        findFunc = function(link) {
          return link.getBreedName().toLowerCase() === breedName.toLowerCase() && ((link.end1.id === fromId && link.end2.id === toId) || (!isDirected && link.end1.id === toId && link.end2.id === fromId));
        };
        return (ref = this._links.find(findFunc)) != null ? ref : Nobody;
      }

      // (Object[Any]) => Unit
      importState(linkState) {
        linkState.forEach(({breed, end1, end2, color, isHidden, labelColor, shape, thickness, tieMode}) => {
          var newLink;
          newLink = this._createLink(breed.isDirected(), end1, end2, breed.name);
          newLink.setVariable('color', color);
          newLink.setVariable('hidden?', isHidden);
          newLink.setVariable('label-color', labelColor);
          newLink.setVariable('shape', shape);
          newLink.setVariable('thickness', thickness);
          newLink.setVariable('tie-mode', tieMode);
        });
      }

      // () => LinkSet
      links() {
        var thunk;
        thunk = (() => {
          return this._linkArray();
        });
        return new LinkSet(thunk, this._world, "links");
      }

      linksOfBreed(breedName) {
        var thunk;
        thunk = (() => {
          return stableSort(this._breedManager.get(breedName).members)(function(x, y) {
            return x.compare(y).toInt;
          });
        });
        return new LinkSet(thunk, this._world, breedName);
      }

      // () => Array[Link]
      _linkArray() {
        if (this._linkArrCache == null) {
          this._linkArrCache = this._links.toArray();
        }
        return this._linkArrCache;
      }

      // Link -> Breed -> String -> Unit
      trackBreedChange(link, breed, oldBreedName) {
        var end1, end2, existingLink, isDirected;
        ({end1, end2, isDirected} = link);
        this._errorIfBreedIsIncompatible(breed.name);
        existingLink = this.getLink(end1.id, end2.id, breed.name);
        if (existingLink !== link && existingLink !== Nobody) {
          throw new Error(`there is already a ${breed.singular.toUpperCase()} with endpoints ${end1.getName()} and ${end2.getName()}`);
        } else {
          this._removeFromSets(end1.id, end2.id, isDirected, oldBreedName);
          this._insertIntoSets(end1.id, end2.id, isDirected, breed.name);
        }
      }

      _removeLink(link) {
        var l;
        l = this._links.find(function({id}) {
          return id === link.id;
        });
        this._links = this._links.remove(l);
        this._linkArrCache = void 0;
        if (this._links.isEmpty()) {
          this._notifyIsUndirected();
        }
        this._removeFromSets(link.end1.id, link.end2.id, link.isDirected, link.getBreedName());
      }

      // (Boolean, Turtle, Turtle, String) => Link
      _createLink(isDirected, from, to, breedName) {
        var breed, end1, end2, link;
        [end1, end2] = from.id < to.id || isDirected ? [from, to] : [to, from];
        if (!this._linkExists(end1.id, end2.id, isDirected, breedName)) {
          breed = this._breedManager.get(breedName);
          link = new Link(this._idManager.next(), isDirected, end1, end2, this._world, this._updater.updated, this._updater.registerDeadLink, this._removeLink, this._updater.registerLinkStamp, this.linksOfBreed, breed);
          this._updater.updated(link)(...Builtins.linkBuiltins);
          this._updater.updated(link)(...Builtins.linkExtras);
          this._links.insert(link);
          this._linkArrCache = void 0;
          return link;
        } else {
          return Nobody;
        }
      }

      _createLinksBy(mkLink) {
        return (turtles) => {
          var isLink, links;
          isLink = function(other) {
            return other !== Nobody;
          };
          links = pipeline(map(mkLink), filter(isLink))(turtles.toArray());
          return new LinkSet(links, this._world);
        };
      }

      // String -> Unit
      _errorIfBreedIsIncompatible(breedName) {
        if ((breedName === "LINKS" && this._hasBreededs()) || (breedName !== "LINKS" && this._hasUnbreededs())) {
          throw new Error("You cannot have both breeded and unbreeded links in the same world.");
        }
      }

      // Unit -> Boolean
      _hasBreededs() {
        var allPairs;
        allPairs = pairs(this._linksTo).concat(pairs(this._linksFrom));
        return exists(function([key, value]) {
          return key !== "LINKS" && exists(function(x) {
            return !isEmpty(x);
          })(values(value));
        })(allPairs);
      }

      // Unit -> Boolean
      _hasUnbreededs() {
        var hasUnbreededs;
        hasUnbreededs = function(bin) {
          var ref;
          return exists(function(x) {
            return !isEmpty(x);
          })(values((ref = bin["LINKS"]) != null ? ref : {}));
        };
        return hasUnbreededs(this._linksFrom) || hasUnbreededs(this._linksTo);
      }

      // (Number, Number, Boolean, String) => Unit
      _insertIntoSets(fromID, toID, isDirected, breedName) {
        var insertIntoSet;
        insertIntoSet = function(set, id1, id2) {
          var neighbors;
          if (set[breedName] == null) {
            set[breedName] = {};
          }
          neighbors = set[breedName][id1];
          if (neighbors != null) {
            return neighbors.push(id2);
          } else {
            return set[breedName][id1] = [id2];
          }
        };
        insertIntoSet(this._linksFrom, fromID, toID);
        if (!isDirected) {
          insertIntoSet(this._linksTo, toID, fromID);
        }
      }

      // (Number, Number, Boolean, String) => Boolean
      _linkExists(id1, id2, isDirected, breedName) {
        var ref, ref1, ref2, ref3, weCanHaz;
        weCanHaz = pipeline(values, contains(id2));
        return weCanHaz((ref = (ref1 = this._linksFrom[breedName]) != null ? ref1[id1] : void 0) != null ? ref : {}) || (!isDirected && weCanHaz((ref2 = (ref3 = this._linksTo[breedName]) != null ? ref3[id1] : void 0) != null ? ref2 : {}));
      }

      // Number -> Number -> Boolean -> String -> Unit
      _removeFromSets(fromID, toID, isDirected, breedName) {
        var remove;
        remove = function(set, id1, id2) {
          if ((set != null ? set[id1] : void 0) != null) {
            return set[id1] = filter(function(x) {
              return x !== id2;
            })(set[id1]);
          }
        };
        remove(this._linksFrom[breedName], fromID, toID);
        if (!isDirected) {
          remove(this._linksTo[breedName], toID, fromID);
        }
      }

    };

    LinkManager.prototype._linkArrCache = void 0; // Array[Link]

    LinkManager.prototype._links = void 0; // SortedLinks

    LinkManager.prototype._linksFrom = void 0; // Object[String, Object[Number, Number]]

    LinkManager.prototype._idManager = void 0; // IDManager

    LinkManager.prototype._linksTo = void 0; // Object[String, Object[Number, Number]]

    return LinkManager;

  }).call(this);

}).call(this);

},{"../link":"engine/core/link","../linkset":"engine/core/linkset","../structure/builtins":"engine/core/structure/builtins","./idmanager":"engine/core/world/idmanager","./sortedlinks":"engine/core/world/sortedlinks","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object","util/stablesort":"util/stablesort"}],"engine/core/world/singleobjectextensionporter":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExportedExtensionObject, ExportedSimpleExtension, SingleObjectExtensionPorter, porterStringRegEx;

  ({ExportedExtensionObject, ExportedSimpleExtension} = require('../../../serialize/exportstructures'));

  porterStringRegEx = /{{(.+)\:(.*) (\d+)\:  ?(.+)}}/;

  SingleObjectExtensionPorter = class SingleObjectExtensionPorter {
    constructor(extensionName1, canHandle, dumpObjectData, exportObjectData, formatObjectData, readObjectData, importObjectData) {
      this.extensionName = extensionName1;
      this.canHandle = canHandle;
      this.dumpObjectData = dumpObjectData;
      this.exportObjectData = exportObjectData;
      this.formatObjectData = formatObjectData;
      this.readObjectData = readObjectData;
      this.importObjectData = importObjectData;
    }

    dump(extObj, dumper) {
      return `{{${this.extensionName}: ${this.dumpObjectData(extObj, dumper)}}}`;
    }

    exportObject(extObj, exportValue) {
      return new ExportedExtensionObject(this.extensionName, "", this.exportObjectData(extObj, exportValue));
    }

    export(objects) {
      return new ExportedSimpleExtension(this.extensionName, objects);
    }

    formatObject(index, exportedObj, formatAny) {
      return `"{{${this.extensionName}: ${index}: ${this.formatObjectData(exportedObj, formatAny)}}}"`;
    }

    format(exportedExt, formatAny) {
      return exportedExt.objects.map((exportedObj, index) => {
        return this.formatObject(index, exportedObj, formatAny);
      }).join("\n");
    }

    readObject(text, parseAny) {
      return new ExportedExtensionObject(this.extensionName, "", this.readObjectData(text, parseAny));
    }

    readObjects(porterStrings, helper) {
      var porterObjects;
      porterObjects = [];
      porterStrings.forEach((porterString) => {
        var extensionName, formattedData, index, match, porterObject, subType;
        match = porterString.match(porterStringRegEx);
        if (match == null) {
          throw new Error(`Cannot read this extension object string: ${porterString}`);
        }
        extensionName = match[1];
        subType = match[2];
        index = parseFloat(match[3]);
        formattedData = match[4];
        if (this.extensionName !== extensionName) {
          throw new Error(`This extension porter (${this.extensionName}) does not match the extension object: ${porterString}`);
        }
        porterObject = this.readObject(formattedData, helper);
        return porterObjects[index] = porterObject;
      });
      return porterObjects;
    }

    read(sectionLines, parseAny) {
      return new ExportedSimpleExtension(this.extensionName, this.readObjects(sectionLines, parseAny));
    }

    importObject(exportedExt, placeholder, reify) {
      var exportedObj;
      exportedObj = exportedExt.objects[placeholder.index];
      return this.importObjectData(exportedObj, reify);
    }

    import(_1, _2) {}

  };

  module.exports = SingleObjectExtensionPorter;

}).call(this);

},{"../../../serialize/exportstructures":"serialize/exportstructures"}],"engine/core/world/sortedlinks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Mori, SortedLinks, linkCompare;

  linkCompare = require('../structure/linkcompare');

  Mori = require('mori');

  module.exports = SortedLinks = (function() {
    class SortedLinks {
      
      // () => SortedLinks
      constructor() {
        this._links = Mori.sortedSetBy(linkCompare);
      }

      // Side-effecting ops
      insert(link) {
        this._links = Mori.conj(this._links, link);
        return this;
      }

      remove(link) {
        this._links = Mori.disj(this._links, link);
        return this;
      }

      
      // Pure ops
      find(pred) {
        return Mori.first(Mori.filter(pred, this._links)); // Mori's `filter` is lazy, so it's all cool --JAB (3/26/14) # ((Link) => Boolean) => Link
      }

      isEmpty() {
        return Mori.isEmpty(this._links); // () => Boolean
      }

      toArray() {
        return Mori.toJs(this._links); // () => Array[Link]
      }

    };

    SortedLinks._links = void 0; // Mori.SortedSet[Link]

    return SortedLinks;

  }).call(this);

}).call(this);

},{"../structure/linkcompare":"engine/core/structure/linkcompare","mori":"mori"}],"engine/core/world/ticker":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var EvilSentinel, Exception, Ticker;

  Exception = require('util/exception');

  EvilSentinel = -1;

  module.exports = Ticker = (function() {
    class Ticker {
      // (() => Unit, () => Unit, (String*) => Unit) => Ticker
      constructor(_onReset, _onTick, _updateFunc) {
        this._onReset = _onReset;
        this._onTick = _onTick;
        this._updateFunc = _updateFunc;
        this._count = EvilSentinel;
      }

      // () => Unit
      reset() {
        this._updateTicks(function() {
          return 0;
        });
        this._onReset();
        this._onTick();
      }

      // () => Unit
      clear() {
        this._updateTicks(function() {
          return EvilSentinel;
        });
      }

      // (Number) => Unit
      importTicks(numTicks) {
        this._updateTicks(function() {
          return numTicks;
        });
      }

      // () => Unit
      tick() {
        if (this.ticksAreStarted()) {
          this._updateTicks(function(counter) {
            return counter + 1;
          });
        } else {
          throw new Error("The tick counter has not been started yet. Use RESET-TICKS.");
        }
        this._onTick();
      }

      // (Number) => Unit
      tickAdvance(n) {
        if (n < 0) {
          throw new Error("Cannot advance the tick counter by a negative amount.");
        } else if (this.ticksAreStarted()) {
          return this._updateTicks(function(counter) {
            return counter + n;
          });
        } else {
          throw new Error("The tick counter has not been started yet. Use RESET-TICKS.");
        }
      }

      // () => Boolean
      ticksAreStarted() {
        return this._count !== EvilSentinel;
      }

      // () => Number
      tickCount() {
        if (this.ticksAreStarted()) {
          return this._count;
        } else {
          throw new Error("The tick counter has not been started yet. Use RESET-TICKS.");
        }
      }

      // ((Number) => Number) => Unit
      _updateTicks(updateCountFunc) {
        this._count = updateCountFunc(this._count);
        this._updateFunc("ticks");
      }

    };

    // Number
    Ticker.prototype._count = void 0;

    return Ticker;

  }).call(this);

}).call(this);

},{"util/exception":"util/exception"}],"engine/core/world/turtlemanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Builtins, ColorModel, DeathInterrupt, IDManager, Turtle, TurtleManager, TurtleSet, ignorantly, ignoring, map, rangeUntil;

  ColorModel = require('engine/core/colormodel');

  Turtle = require('../turtle');

  TurtleSet = require('../turtleset');

  Builtins = require('../structure/builtins');

  IDManager = require('./idmanager');

  ({map} = require('brazierjs/array'));

  ({rangeUntil} = require('brazierjs/number'));

  ({DeathInterrupt, ignoring} = require('util/exception'));

  ignorantly = ignoring(DeathInterrupt);

  module.exports = TurtleManager = (function() {
    class TurtleManager {
      
      // (World, Updater, BreedManager, (Number) => Number) => TurtleManager
      constructor(_world, _breedManager, _updater, _nextInt) {
        // (String) => TurtleSet
        this.turtlesOfBreed = this.turtlesOfBreed.bind(this);
        // (Number, Number, Number, Number, Breed, String, Number, Boolean, Number, String, (Updatable) => PenManager) => Turtle
        this._createNewTurtle = this._createNewTurtle.bind(this);
        // (Number) => Unit
        this._removeTurtle = this._removeTurtle.bind(this);
        this._world = _world;
        this._breedManager = _breedManager;
        this._updater = _updater;
        this._nextInt = _nextInt;
        this._idManager = new IDManager;
        this._turtles = [];
        this._turtlesById = {};
      }

      // () => Unit
      clearTurtles() {
        this.turtles().forEach(function(turtle) {
          return ignorantly(() => {
            return turtle.die();
          });
        });
        this._idManager.reset();
      }

      // (Number, String) => TurtleSet
      createOrderedTurtles(n, breedName) {
        var num, turtles;
        num = n >= 0 ? n : 0;
        turtles = map((index) => {
          var color, heading;
          color = ColorModel.nthColor(index);
          heading = (360 * index) / num;
          return this._createNewTurtle(color, heading, 0, 0, this._breedManager.get(breedName));
        })(rangeUntil(0)(num));
        return new TurtleSet(turtles, this._world);
      }

      // (Number, String, Number, Number) => TurtleSet
      createTurtles(n, breedName, xcor = 0, ycor = 0) {
        var num, turtles;
        num = n >= 0 ? n : 0;
        turtles = map(() => {
          var color, heading;
          color = ColorModel.randomColor(this._nextInt);
          heading = this._nextInt(360);
          return this._createNewTurtle(color, heading, xcor, ycor, this._breedManager.get(breedName));
        })(rangeUntil(0)(num));
        return new TurtleSet(turtles, this._world);
      }

      // (Number) => Agent
      getTurtle(id) {
        var ref;
        return (ref = this._turtlesById[id]) != null ? ref : Nobody;
      }

      // (String, Number) => Agent
      getTurtleOfBreed(breedName, id) {
        var turtle;
        turtle = this.getTurtle(id);
        if (turtle.getBreedName().toUpperCase() === breedName.toUpperCase()) {
          return turtle;
        } else {
          return Nobody;
        }
      }

      // (Object[Any], Number) => Unit
      importState(turtleState, nextIndex) {
        turtleState.forEach(({who, color, heading, xcor, ycor, shape, labelColor, breed, isHidden, size, penSize, penMode}) => {
          var newTurtle;
          newTurtle = this._createTurtle(who, color, heading, xcor, ycor, breed, "", labelColor, isHidden, size, shape);
          newTurtle.penManager.setPenMode(penMode);
          return newTurtle.penManager.setSize(penSize);
        });
        this._idManager.setCount(nextIndex);
      }

      // () => Number
      peekNextID() {
        return this._idManager.getCount();
      }

      // () => TurtleSet
      turtles() {
        return new TurtleSet(this._turtles, this._world, "turtles");
      }

      turtlesOfBreed(breedName) {
        var breed;
        breed = this._breedManager.get(breedName);
        return new TurtleSet(breed.members, this._world, breedName);
      }

      // () => Unit
      _clearTurtlesSuspended() {
        this._idManager.suspendDuring(() => {
          return this.clearTurtles();
        });
      }

      _createNewTurtle(color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager) {
        return this._createTurtle(this._idManager.next(), color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager);
      }

      // (Number, Number, Number, Number, Number, Breed, String, Number, Boolean, Number, String, (Updatable) => PenManager) => Turtle
      _createTurtle(id, color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager) {
        var turtle;
        turtle = new Turtle(this._world, id, this._updater.updated, this._updater.registerPenTrail, this._updater.registerTurtleStamp, this._updater.registerDeadTurtle, this._createNewTurtle, this._removeTurtle, color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager);
        this._updater.updated(turtle)(...Builtins.turtleBuiltins);
        this._turtles.push(turtle);
        this._turtlesById[id] = turtle;
        return turtle;
      }

      _removeTurtle(id) {
        var turtle;
        turtle = this._turtlesById[id];
        this._turtles.splice(this._turtles.indexOf(turtle), 1);
        delete this._turtlesById[id];
      }

    };

    TurtleManager.prototype._idManager = void 0; // IDManager

    TurtleManager.prototype._turtles = void 0; // Array[Turtle]

    TurtleManager.prototype._turtlesById = void 0; // Object[Number, Turtle]

    return TurtleManager;

  }).call(this);

}).call(this);

},{"../structure/builtins":"engine/core/structure/builtins","../turtle":"engine/core/turtle","../turtleset":"engine/core/turtleset","./idmanager":"engine/core/world/idmanager","brazierjs/array":"brazier/array","brazierjs/number":"brazier/number","engine/core/colormodel":"engine/core/colormodel","util/exception":"util/exception"}],"engine/core/world":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LinkManager, NLMath, Observer, Patch, PatchSet, Ticker, TopologyInterrupt, TurtleManager, World, allPlotsDataToCSV, exportAllPlots, exportPlot, exportRawPlot, exportWorld, filter, flatMap, importWorld, linkBuiltins, patchBuiltins, pipeline, plotDataToCSV, rawPlotToCSV, topologyFactory, turtleBuiltins, values, worldDataToCSV;

  Patch = require('./patch');

  PatchSet = require('./patchset');

  topologyFactory = require('./topology/factory');

  LinkManager = require('./world/linkmanager');

  Ticker = require('./world/ticker');

  TurtleManager = require('./world/turtlemanager');

  NLMath = require('util/nlmath');

  ({filter, flatMap} = require('brazier/array'));

  ({pipeline} = require('brazier/function'));

  ({values} = require('brazier/object'));

  ({Observer} = require('./observer'));

  ({linkBuiltins, patchBuiltins, turtleBuiltins} = require('./structure/builtins'));

  ({allPlotsDataToCSV, plotDataToCSV, rawPlotToCSV, worldDataToCSV} = require('serialize/exportcsv'));

  ({TopologyInterrupt} = require('util/exception'));

  ({exportWorld, exportPlot, exportRawPlot, exportAllPlots} = require('./world/export'));

  ({importWorld} = require('./world/import'));

  module.exports = World = (function() {
    class World {
      
      // (MiniWorkspace, WorldConfig, () => String, () => Unit, () => String, (Any) => String, (String) => Unit, Array[String], Array[String], Array[String], Number, Number, Number, Number, Number, Boolean, Boolean, ShapeMap, ShapeMap, () => Unit) => World
      constructor(miniWorkspace, _config, _getViewBase64, _outputClear, _getOutput, _setOutput, extensionPorters, globalNames, interfaceGlobalNames, patchesOwnNames, minPxcor, maxPxcor, minPycor, maxPycor, patchSize, wrappingAllowedInX, wrappingAllowedInY, turtleShapeMap, linkShapeMap, onTickFunction) {
        var onTick;
        // () => PatchSet
        this.patches = this.patches.bind(this);
        // (Number, Number) => Agent
        this.getPatchAt = this.getPatchAt.bind(this);
        // The wrapping and rounding below is setup to avoid creating extra anonymous functions.
        // We could just use @ and fat arrows => but CoffeeScript uses anon funcs to bind `this`.
        // Those anon funcs cause GC pressure and runtime slowdown, so we have to manually setup
        // the context somehow.  A lot of rounding and wrapping goes on in models.  -JMB 07/2017

        // (Number) => Number
        this._thisWrapX = this._thisWrapX.bind(this);
        // (Number) => Number
        this._thisWrapY = this._thisWrapY.bind(this);
        // () => Unit
        this._incrementPatchLabelCount = this._incrementPatchLabelCount.bind(this);
        // () => Unit
        this._decrementPatchLabelCount = this._decrementPatchLabelCount.bind(this);
        // () => Unit
        this._setUnbreededLinksDirected = this._setUnbreededLinksDirected.bind(this);
        // () => Unit
        this._setUnbreededLinksUndirected = this._setUnbreededLinksUndirected.bind(this);
        // () => Unit
        this._declarePatchesNotAllBlack = this._declarePatchesNotAllBlack.bind(this);
        this._config = _config;
        this._getViewBase64 = _getViewBase64;
        this._outputClear = _outputClear;
        this._getOutput = _getOutput;
        this._setOutput = _setOutput;
        this.extensionPorters = extensionPorters;
        this.patchesOwnNames = patchesOwnNames;
        this.patchSize = patchSize;
        this.turtleShapeMap = turtleShapeMap;
        this.linkShapeMap = linkShapeMap;
        ({
          selfManager: this.selfManager,
          updater: this._updater,
          rng: this.rng,
          breedManager: this.breedManager,
          plotManager: this._plotManager
        } = miniWorkspace);
        this._patchesAllBlack = true;
        this._patchesWithLabels = 0;
        this._updater.collectUpdates();
        this._updater.registerWorldState({
          worldWidth: maxPxcor - minPxcor + 1,
          worldHeight: maxPycor - minPycor + 1,
          minPxcor: minPxcor,
          minPycor: minPycor,
          maxPxcor: maxPxcor,
          maxPycor: maxPycor,
          linkBreeds: this.breedManager.orderedLinkBreeds(),
          linkShapeList: this.linkShapeMap,
          patchSize: this.patchSize,
          patchesAllBlack: this._patchesAllBlack,
          patchesWithLabels: this._patchesWithLabels,
          ticks: -1,
          turtleBreeds: this.breedManager.orderedTurtleBreeds(),
          turtleShapeList: this.turtleShapeMap,
          unbreededLinksAreDirected: false,
          wrappingAllowedInX: wrappingAllowedInX,
          wrappingAllowedInY: wrappingAllowedInY
        });
        onTick = () => {
          this.rng.withAux(onTickFunction);
          return this._plotManager.updatePlots();
        };
        this.linkManager = new LinkManager(this, this.breedManager, this._updater, this._setUnbreededLinksDirected, this._setUnbreededLinksUndirected);
        this.observer = new Observer(this._updater.updated, globalNames, interfaceGlobalNames);
        this.ticker = new Ticker(this._plotManager.setupPlots, onTick, this._updater.updated(this));
        this.topology = null;
        this.turtleManager = new TurtleManager(this, this.breedManager, this._updater, this.rng.nextInt);
        this._patches = [];
        this._resizeHelper(minPxcor, maxPxcor, minPycor, maxPycor, wrappingAllowedInX, wrappingAllowedInY);
      }

      // () => LinkSet
      links() {
        return this.linkManager.links();
      }

      // () => TurtleSet
      turtles() {
        return this.turtleManager.turtles();
      }

      patches() {
        return new PatchSet(this._patches, this, "patches");
      }

      // (Number, Number, Number, Number, Boolean, Boolean) => Unit
      resize(minPxcor, maxPxcor, minPycor, maxPycor, wrapsInX = this.topology._wrapInX, wrapsInY = this.topology._wrapInY) {
        this._resizeHelper(NLMath.trunc(minPxcor), NLMath.trunc(maxPxcor), NLMath.trunc(minPycor), NLMath.trunc(maxPycor), wrapsInX, wrapsInY);
        return this.clearDrawing();
      }

      // (Number, Number, Number, Number, Boolean, Boolean) => Unit
      _resizeHelper(minPxcor, maxPxcor, minPycor, maxPycor, wrapsInX = this.topology._wrapInX, wrapsInY = this.topology._wrapInY) {
        var ref, ref1, ref2, ref3;
        if (!((minPxcor <= 0 && 0 <= maxPxcor) && (minPycor <= 0 && 0 <= maxPycor))) {
          throw new Error("You must include the point (0, 0) in the world.");
        }
        if (minPxcor !== ((ref = this.topology) != null ? ref.minPxcor : void 0) || minPycor !== ((ref1 = this.topology) != null ? ref1.minPycor : void 0) || maxPxcor !== ((ref2 = this.topology) != null ? ref2.maxPxcor : void 0) || maxPycor !== ((ref3 = this.topology) != null ? ref3.maxPycor : void 0)) {
          this._config.resizeWorld();
          // For some reason, JVM NetLogo doesn't restart `who` ordering after `resize-world`; even the test for this is existentially confused. --JAB (4/3/14)
          this.turtleManager._clearTurtlesSuspended();
          this.changeTopology(wrapsInX, wrapsInY, minPxcor, maxPxcor, minPycor, maxPycor);
          this._createPatches();
          this._declarePatchesAllBlack();
          this._resetPatchLabelCount();
          this._updater.updated(this)("width", "height", "minPxcor", "minPycor", "maxPxcor", "maxPycor");
        }
      }

      // (Boolean, Boolean, Number, Number, Number, Number) => Unit
      changeTopology(wrapsInX, wrapsInY, minX = this.topology.minPxcor, maxX = this.topology.maxPxcor, minY = this.topology.minPycor, maxY = this.topology.maxPycor) {
        this.topology = topologyFactory(wrapsInX, wrapsInY, minX, maxX, minY, maxY, this.patches, this.getPatchAt);
        this._updater.updated(this)("wrappingAllowedInX", "wrappingAllowedInY");
      }

      getPatchAt(x, y) {
        var error, index, roundedX, roundedY;
        try {
          roundedX = this._roundXCor(x);
          roundedY = this._roundYCor(y);
          index = (this.topology.maxPycor - roundedY) * this.topology.width + (roundedX - this.topology.minPxcor);
          return this._patches[index];
        } catch (error1) {
          error = error1;
          if (error instanceof TopologyInterrupt) {
            return Nobody;
          } else {
            throw error;
          }
        }
      }

      // (Number, Number) => Agent
      patchAtCoords(x, y) {
        var error, newX, newY;
        try {
          newX = this.topology.wrapX(x);
          newY = this.topology.wrapY(y);
          return this.getPatchAt(newX, newY);
        } catch (error1) {
          error = error1;
          if (error instanceof TopologyInterrupt) {
            return Nobody;
          } else {
            throw error;
          }
        }
      }

      // (Number, Number, Number, Number) => Agent
      patchAtHeadingAndDistanceFrom(angle, distance, x, y) {
        var heading, targetX, targetY;
        heading = NLMath.normalizeHeading(angle);
        targetX = x + distance * NLMath.squash(NLMath.sin(heading));
        targetY = y + distance * NLMath.squash(NLMath.cos(heading));
        return this.patchAtCoords(targetX, targetY);
      }

      // (Number) => Unit
      setPatchSize(patchSize) {
        this.patchSize = patchSize;
        this._updater.updated(this)("patchSize");
        this._updater.rescaleDrawing();
      }

      // () => Unit
      clearAll() {
        this.observer.clearCodeGlobals();
        this.observer.resetPerspective();
        this.turtleManager.clearTurtles();
        this.clearPatches();
        this.clearLinks();
        this._declarePatchesAllBlack();
        this._resetPatchLabelCount();
        this.ticker.clear();
        this._plotManager.clearAllPlots();
        this._outputClear();
        this.clearDrawing();
      }

      // () => Unit
      clearDrawing() {
        this._updater.clearDrawing();
      }

      // (String) => Unit
      importDrawing(imageBase64) {
        this._updater.importDrawing(imageBase64);
      }

      // () => Unit
      clearLinks() {
        this.linkManager.clear();
        this.turtles().ask((function() {
          return SelfManager.self().linkManager.clear();
        }), false);
      }

      // () => Unit
      clearPatches() {
        this.patches().forEach(function(patch) {
          patch.reset();
        });
        this._declarePatchesAllBlack();
        this._resetPatchLabelCount();
      }

      // () => Object[Any]
      exportState() {
        return exportWorld.call(this);
      }

      // () => String
      exportAllPlotsCSV() {
        return allPlotsDataToCSV(exportAllPlots.call(this), this.extensionPorters);
      }

      // (String) => String
      exportPlotCSV(name) {
        return plotDataToCSV(exportPlot.call(this, name), this.extensionPorters);
      }

      // (String) => String
      exportRawPlotCSV(name) {
        return rawPlotToCSV(exportRawPlot.call(this, name), this.extensionPorters);
      }

      // () => String
      exportCSV() {
        var allLinksOwnsNames, allTurtlesOwnsNames, state, varNamesForBreedsMatching;
        varNamesForBreedsMatching = (pred) => {
          return pipeline(values, filter(pred), flatMap(function(x) {
            return x.varNames;
          }))(this.breedManager.breeds());
        };
        allTurtlesOwnsNames = varNamesForBreedsMatching(function(breed) {
          return !breed.isLinky();
        });
        allLinksOwnsNames = varNamesForBreedsMatching(function(breed) {
          return breed.isLinky();
        });
        state = exportWorld.call(this);
        return worldDataToCSV(allTurtlesOwnsNames, allLinksOwnsNames, patchBuiltins, turtleBuiltins, linkBuiltins, this.extensionPorters)(state);
      }

      // (Number, Number) => PatchSet
      getNeighbors(pxcor, pycor) {
        return new PatchSet(this.topology.getNeighbors(pxcor, pycor), this);
      }

      // (Number, Number) => PatchSet
      getNeighbors4(pxcor, pycor) {
        return new PatchSet(this.topology.getNeighbors4(pxcor, pycor), this);
      }

      // (WorldState) => Unit
      importState() {
        return importWorld.apply(this, arguments);
      }

      _thisWrapX(x) {
        return this.topology.wrapX(x);
      }

      _thisWrapY(y) {
        return this.topology.wrapY(y);
      }

      // (Number) => Number
      _roundXCor(x) {
        var wrappedX;
        wrappedX = this._wrapC(x, this._thisWrapX);
        return this._roundCoordinate(wrappedX);
      }

      // (Number) => Number
      _roundYCor(y) {
        var wrappedY;
        wrappedY = this._wrapC(y, this._thisWrapY);
        return this._roundCoordinate(wrappedY);
      }

      // Similarly, using try/catch as an expression creates extra anon funcs, so we get
      // this value manually as well.  -JMB 07/2017

      // (Number, (Number) => Number) => Number
      _wrapC(c, wrapper) {
        var error, trueError, wrappedC;
        wrappedC = void 0;
        try {
          wrappedC = wrapper(c);
        } catch (error1) {
          error = error1;
          trueError = error instanceof TopologyInterrupt ? new TopologyInterrupt("Cannot access patches beyond the limits of current world.") : error;
          throw trueError;
        }
        return wrappedC;
      }

      // Boy, oh, boy!  Headless has only this to say about this code: "floor() is slow so we
      // don't use it".  I have a lot more to say!  This code is kind of nuts, but we can't
      // live without it unless something is done about Headless' uses of `World.roundX` and
      // and `World.roundY`.  The previous Tortoise code was somewhat sensible about patch
      // boundaries, but had to be supplanted by this in order to become compliant with NL
      // Headless, which interprets `0.4999999999999999167333` as being one patch over from
      // `0` (whereas, sensically, we should only do that starting at `0.5`).  But... we
      // don't live in an ideal world, so I'll just replicate Headless' silly behavior here.
      // --JAB (12/6/14)
      // (Number) => Number
      _roundCoordinate(wrappedC) {
        var fractional, integral;
        if (wrappedC > 0) {
          return (wrappedC + 0.5) | 0;
        } else {
          integral = wrappedC | 0;
          fractional = integral - wrappedC;
          if (fractional > 0.5) {
            return integral - 1;
          } else {
            return integral;
          }
        }
      }

      // () => Unit
      _createPatches() {
        var i, id, len, nested, patch, ref, x, y;
        nested = (function() {
          var i, ref, ref1, results;
          results = [];
          for (y = i = ref = this.topology.maxPycor, ref1 = this.topology.minPycor; (ref <= ref1 ? i <= ref1 : i >= ref1); y = ref <= ref1 ? ++i : --i) {
            results.push((function() {
              var j, ref2, ref3, results1;
              results1 = [];
              for (x = j = ref2 = this.topology.minPxcor, ref3 = this.topology.maxPxcor; (ref2 <= ref3 ? j <= ref3 : j >= ref3); x = ref2 <= ref3 ? ++j : --j) {
                id = (this.topology.width * (this.topology.maxPycor - y)) + x - this.topology.minPxcor;
                results1.push(new Patch(id, x, y, this, this._updater.updated, this._declarePatchesNotAllBlack, this._decrementPatchLabelCount, this._incrementPatchLabelCount));
              }
              return results1;
            }).call(this));
          }
          return results;
        }).call(this);
        this._patches = [].concat(...nested);
        ref = this._patches;
        for (i = 0, len = ref.length; i < len; i++) {
          patch = ref[i];
          this._updater.updated(patch)("pxcor", "pycor", "pcolor", "plabel", "plabel-color");
        }
      }

      // (Number) => PatchSet
      _optimalPatchCol(xcor) {
        var maxX, maxY, minX, minY;
        ({
          maxPxcor: maxX,
          maxPycor: maxY,
          minPxcor: minX,
          minPycor: minY
        } = this.topology);
        return this._optimalPatchSequence(xcor, minX, maxX, minY, maxY, (y) => {
          return this.getPatchAt(xcor, y);
        });
      }

      // (Number) => PatchSet
      _optimalPatchRow(ycor) {
        var maxX, maxY, minX, minY;
        ({
          maxPxcor: maxX,
          maxPycor: maxY,
          minPxcor: minX,
          minPycor: minY
        } = this.topology);
        return this._optimalPatchSequence(ycor, minY, maxY, minX, maxX, (x) => {
          return this.getPatchAt(x, ycor);
        });
      }

      // (Number, Number, Number, Number, Number, (Number) => Agent) => PatchSet
      _optimalPatchSequence(cor, boundaryMin, boundaryMax, seqStart, seqEnd, getPatch) {
        var n, ret;
        ret = (boundaryMin <= cor && cor <= boundaryMax) ? [].concat(...(function() {
          var i, ref, ref1, results;
          results = [];
          for (n = i = ref = seqStart, ref1 = seqEnd; (ref <= ref1 ? i <= ref1 : i >= ref1); n = ref <= ref1 ? ++i : --i) {
            results.push(getPatch(n));
          }
          return results;
        })()) : [];
        return new PatchSet(ret, this);
      }

      _incrementPatchLabelCount() {
        this._setPatchLabelCount(function(count) {
          return count + 1;
        });
      }

      _decrementPatchLabelCount() {
        this._setPatchLabelCount(function(count) {
          return count - 1;
        });
      }

      // () => Unit
      _resetPatchLabelCount() {
        this._setPatchLabelCount(function() {
          return 0;
        });
      }

      // ((Number) => Number) => Unit
      _setPatchLabelCount(updateCountFunc) {
        this._patchesWithLabels = updateCountFunc(this._patchesWithLabels);
        this._updater.updated(this)("patchesWithLabels");
      }

      _setUnbreededLinksDirected() {
        this.breedManager.setUnbreededLinksDirected();
        this._updater.updated(this)("unbreededLinksAreDirected");
      }

      _setUnbreededLinksUndirected() {
        this.breedManager.setUnbreededLinksUndirected();
        this._updater.updated(this)("unbreededLinksAreDirected");
      }

      // () => Unit
      _declarePatchesAllBlack() {
        if (!this._patchesAllBlack) {
          this._patchesAllBlack = true;
          this._updater.updated(this)("patchesAllBlack");
        }
      }

      _declarePatchesNotAllBlack() {
        if (this._patchesAllBlack) {
          this._patchesAllBlack = false;
          this._updater.updated(this)("patchesAllBlack");
        }
      }

    };

    // type ShapeMap = Object[Shape]
    World.prototype.id = 0; // Number

    World.prototype.breedManager = void 0; // BreedManager

    World.prototype.linkManager = void 0; // LinkManager

    World.prototype.observer = void 0; // Observer

    World.prototype.rng = void 0; // RNG

    World.prototype.selfManager = void 0; // SelfManager

    World.prototype.ticker = void 0; // Ticker

    World.prototype.topology = void 0; // Topology

    World.prototype.turtleManager = void 0; // TurtleManager

    World.prototype._patches = void 0; // Array[Patch]

    World.prototype._plotManager = void 0; // PlotManager

    World.prototype._updater = void 0; // Updater

    World.prototype._outputClear = void 0; // () => Unit

    
    // Optimization-related variables
    World.prototype._patchesAllBlack = void 0; // Boolean

    World.prototype._patchesWithLabels = void 0; // Number

    return World;

  }).call(this);

}).call(this);

},{"./observer":"engine/core/observer","./patch":"engine/core/patch","./patchset":"engine/core/patchset","./structure/builtins":"engine/core/structure/builtins","./topology/factory":"engine/core/topology/factory","./world/export":"engine/core/world/export","./world/import":"engine/core/world/import","./world/linkmanager":"engine/core/world/linkmanager","./world/ticker":"engine/core/world/ticker","./world/turtlemanager":"engine/core/world/turtlemanager","brazier/array":"brazier/array","brazier/function":"brazier/function","brazier/object":"brazier/object","serialize/exportcsv":"serialize/exportcsv","util/exception":"util/exception","util/nlmath":"util/nlmath"}],"engine/dump":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExtensionsHandler, Tasks, apply, checks, dump, find, flip, fold, map, pipeline;

  ({checks} = require('./core/typechecker'));

  Tasks = require('./prim/tasks');

  ExtensionsHandler = require('./core/world/extensionshandler');

  ({find, map} = require('brazierjs/array'));

  ({apply, flip, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  // Needs a name here since it's recursive --JAB (4/16/14)
  // (Array[ExtensionPorter]) => (Any, Boolean) => String
  dump = function(extensionPorters) {
    var extensions, helper, startDump;
    extensions = ExtensionsHandler.makeDumper(extensionPorters);
    helper = function(x, isReadable = false) {
      var itemStr;
      if (checks.isList(x)) {
        itemStr = map(function(y) {
          return helper(y, isReadable);
        })(x).join(" ");
        return `[${itemStr}]`;
      } else if (checks.isReporterLambda(x)) {
        return `(anonymous reporter: ${x.nlogoBody})`;
      } else if (checks.isCommandLambda(x)) {
        return `(anonymous command: ${x.nlogoBody})`;
      } else if (checks.isString(x)) {
        if (isReadable) {
          return '"' + x + '"';
        } else {
          return x;
        }
      } else if (checks.isNumber(x)) {
        return String(x).toUpperCase(); // For scientific notation, handles correct casing of the 'E' --JAB (8/28/17)
      } else if (extensions.canHandle(x)) {
        return extensions.dump(x, helper);
      } else {
        return String(x);
      }
    };
    startDump = function(x, isReadable) {
      extensions.reset();
      return helper(x, isReadable);
    };
    return startDump;
  };

  module.exports = dump;

}).call(this);

},{"./core/typechecker":"engine/core/typechecker","./core/world/extensionshandler":"engine/core/world/extensionshandler","./prim/tasks":"engine/prim/tasks","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe"}],"engine/hasher":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Hasher, Link, Turtle, checks, foldl;

  AbstractAgentSet = require('./core/abstractagentset');

  Link = require('./core/link');

  Turtle = require('./core/turtle');

  ({checks} = require('./core/typechecker'));

  ({foldl} = require('brazierjs/array'));

  // Function given a name for the sake of recursion --JAB (7/31/14)
  // (Any) => String
  Hasher = function(x) {
    var f;
    if (checks.isTurtle(x) || checks.isLink(x)) {
      return `${x.constructor.name} | ${x.id}`;
    } else if (checks.isNobody(x)) {
      return "nobody: -1";
    } else if (checks.isList(x)) {
      f = function(acc, x) {
        return "31 *" + acc + (x != null ? Hasher(x) : "0");
      };
      return (foldl(f)(1)(x)).toString();
    } else if (checks.isAgentSet(x)) {
      return `${x.toString()} | ${Hasher(x.sort())}`;
    } else {
      return x.toString();
    }
  };

  module.exports = Hasher;

}).call(this);

},{"./core/abstractagentset":"engine/core/abstractagentset","./core/link":"engine/core/link","./core/turtle":"engine/core/turtle","./core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array"}],"engine/plot/pen":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Bar, ColorModel, Counter, Down, Line, Pen, PlotPoint, Point, State, StrictMath, Up, countBy, displayModeFromNum, displayModeFromString, displayModeToNum, displayModeToString, filter, forEach, id, isNumber, map, pairs, pipeline;

  StrictMath = require('shim/strictmath');

  ({countBy, filter, forEach, map} = require('brazierjs/array'));

  ({id, pipeline} = require('brazierjs/function'));

  ({pairs} = require('brazierjs/object'));

  ({isNumber} = require('brazierjs/type'));

  ColorModel = require('engine/core/colormodel');

  // data PenMode =
  Up = {};

  Down = {};

  module.exports.PenMode = {
    Up,
    Down,
    penModeToBool: function(penDown) {
      if (penDown === Up) {
        return false;
      } else {
        return true;
      }
    }
  };

  // data DisplayMode =
  Line = {};

  Bar = {};

  Point = {};

  // (Number) => DisplayMode
  displayModeFromNum = function(num) {
    switch (num) {
      case 0:
        return Line;
      case 1:
        return Bar;
      case 2:
        return Point;
      default:
        throw new Error(`Pen display mode expected \`0\` (line), \`1\` (bar), or \`2\` (point), but got \`${num}\``);
    }
  };

  // (DisplayMode) => Number
  displayModeToNum = function(mode) {
    switch (mode) {
      case Line:
        return 0;
      case Bar:
        return 1;
      case Point:
        return 2;
      default:
        throw new Error(`Invalid display mode: ${mode}`);
    }
  };

  // (String) => DisplayMode
  displayModeFromString = function(num) {
    switch (num) {
      case 'line':
        return Line;
      case 'bar':
        return Bar;
      case 'point':
        return Point;
      default:
        throw new Error(`Pen display mode expected 'line', 'bar', or 'point', but got \`${num}\``);
    }
  };

  // (DisplayMode) => String
  displayModeToString = function(mode) {
    switch (mode) {
      case Line:
        return 'line';
      case Bar:
        return 'bar';
      case Point:
        return 'point';
      default:
        throw new Error(`Invalid display mode: ${mode}`);
    }
  };

  module.exports.DisplayMode = {Line, Bar, Point, displayModeFromNum, displayModeFromString, displayModeToNum, displayModeToString};

  PlotPoint = class PlotPoint {
    // (Number, Number, PenMode, Number) => PlotPoint
    constructor(x1, y1, penMode1, color1) {
      this.x = x1;
      this.y = y1;
      this.penMode = penMode1;
      this.color = color1;
    }

  };

  Counter = class Counter {
    // Who's at first?  Me, ya punk!  --JAB (10/15/14)
    // I don't even know what that means....  --JAB (12/10/17)
    // (Number, Boolean) => Counter
    constructor(_count = 0, _atFirst = true) {
      this._count = _count;
      this._atFirst = _atFirst;
    }

    // (Number) => Number
    next(interval) {
      if (this._atFirst) {
        this._atFirst = false;
        return 0;
      } else {
        return this._count += interval;
      }
    }

  };

  module.exports.State = State = (function() {
    class State {
      
      // (Number, Number, DisplayMode, PenMode, Boolean) => State
      constructor(color1 = 0, interval1 = 1, displayMode = Line, mode1 = Down) {
        this.color = color1;
        this.interval = interval1;
        this.displayMode = displayMode;
        this.mode = mode1;
        this.resetCounter();
      }

      // () => State
      clone() {
        return new State(this.color, this.interval, this.displayMode, this.mode);
      }

      // (Number) => Unit
      leapCounterTo(x) {
        this._counter = new Counter(x, false);
      }

      // () => Number
      getPenX() {
        return this._counter._count;
      }

      // () => Number
      nextX() {
        return this._counter.next(this.interval);
      }

      // () => State
      partiallyReset() {
        return new State(this.color, this.interval, this.displayMode, Down);
      }

      // () => Unit
      resetCounter() {
        this._counter = new Counter();
      }

    };

    State.prototype._counter = void 0; // Counter

    return State;

  }).call(this);

  module.exports.Pen = Pen = (function() {
    class Pen {
      
      // (String, (Pen) => PenOps, Boolean, State, () => (Unit|Stop), () => (Unit|Stop)) => Pen
      constructor(name, genOps, isTemp = false, _defaultState = new State(), _setupThis = (function() {}), _updateThis = (function() {})) {
        this.name = name;
        this.isTemp = isTemp;
        this._defaultState = _defaultState;
        this._setupThis = _setupThis;
        this._updateThis = _updateThis;
        this._ops = genOps(this);
        this.reset();
      }

      // (Number) => Number
      addValue(y) {
        var nextX;
        nextX = this._state.nextX();
        this._addPoint(nextX, y);
        return nextX;
      }

      // (Number, Number) => Unit
      addXY(x, y) {
        this._addPoint(x, y);
        this._state.leapCounterTo(x);
      }

      // () => (Number, Number, Number, Number)
      bounds() {
        return this._bounds;
      }

      // (Array[Number], Number, Number) => Unit
      drawHistogramFrom(ys, xMin, xMax) {
        var determineBucket, interval, isValid, plotBucket;
        this.reset(true);
        interval = this.getInterval();
        isValid = (x) => {
          return ((xMin / interval) <= x && x <= (xMax / interval));
        };
        determineBucket = function(x) {
          return StrictMath.floor((x / interval) * (1 + 3.2e-15)); // See 'Histogram.scala' in Headless for explanation --JAB (10/21/15)
        };
        plotBucket = (([bucketNum, count]) => {
          this.addXY(Number(bucketNum) * interval, count);
        });
        pipeline(filter(isNumber), map(determineBucket), filter(isValid), countBy(id), pairs, forEach(plotBucket))(ys);
      }

      // () => Number
      getColor() {
        return this._state.color;
      }

      // () => PenMode
      getPenMode() {
        return this._state.mode;
      }

      // () => DisplayMode
      getDisplayMode() {
        return this._state.displayMode;
      }

      // () => Number
      getInterval() {
        return this._state.interval;
      }

      // () => Number
      getPenX() {
        return this._state.getPenX();
      }

      // () => Array[PlotPoint]
      getPoints() {
        return this._points;
      }

      // (ExportedPen) => Unit
      importState({
          color: penColor,
          interval,
          mode,
          isPenDown,
          points,
          x: penX
        }) {
        var xs, ys;
        points.forEach(({
            color,
            isPenDown: isPointVisible,
            x,
            y
          }) => {
          var penMode;
          penMode = isPointVisible ? (this.lower(), Down) : (this.raise(), Up);
          this._points.push(new PlotPoint(x, y, penMode, color));
          this._ops.addPoint(x, y);
        });
        xs = this._points.map(function(p) {
          return p.x;
        });
        ys = this._points.map(function(p) {
          return p.y;
        });
        this._bounds = [Math.min(...xs), Math.max(...xs), Math.min(...ys), Math.max(...ys)];
        if (isPenDown) {
          this.lower();
        } else {
          this.raise();
        }
        this.setColor(penColor);
        this.setInterval(interval);
        this._state.leapCounterTo(penX);
        this.updateDisplayMode(displayModeFromString(mode));
      }

      // () => Unit
      lower() {
        this._state.mode = Down;
      }

      // () => Unit
      raise() {
        this._state.mode = Up;
      }

      // (Boolean) => Unit
      reset(isSoftResetting = false) {
        this._bounds = void 0;
        this._state = (this._state != null) && (isSoftResetting || this.isTemp) ? this._state.partiallyReset() : this._defaultState.clone();
        this._points = [];
        this._ops.reset();
        this._ops.updateMode(this._state.displayMode);
      }

      // (Number|RGB) => Unit
      setColor(color) {
        var trueColor;
        trueColor = isNumber(color) ? color : ColorModel.nearestColorNumberOfRGB(...color);
        this._state.color = trueColor;
        this._ops.updateColor(trueColor);
      }

      // P.S. I find it _hilarious_ that this can take '0' and negative numbers --JAB (9/22/14)
      // (Number) => Unit
      setInterval(interval) {
        this._state.interval = interval;
      }

      // () => Unit
      setup() {
        this._setupThis();
      }

      // () => Unit
      update() {
        this._updateThis();
      }

      // (DisplayMode) => Unit
      updateDisplayMode(newMode) {
        this._state.displayMode = newMode;
        this._ops.updateMode(newMode);
      }

      // (Number, Number) => Unit
      _addPoint(x, y) {
        this._points.push(new PlotPoint(x, y, this._state.mode, this._state.color));
        this._updateBounds(x, y);
        this._ops.addPoint(x, y);
      }

      // (Number, Number) => Unit
      _updateBounds(x, y) {
        var maxX, maxY, minX, minY;
        this._bounds = this._bounds != null ? ([minX, maxX, minY, maxY] = this._bounds, [Math.min(minX, x), Math.max(maxX, x), Math.min(minY, y), Math.max(maxY, y)]) : [x, x, y, y];
      }

    };

    Pen.prototype._bounds = void 0; // (Number, Number, Number, Number)

    Pen.prototype._ops = void 0; // PenOps

    Pen.prototype._points = void 0; // Array[PlotPoint]

    Pen.prototype._state = void 0; // State

    return Pen;

  }).call(this);

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object","brazierjs/type":"brazier/type","engine/core/colormodel":"engine/core/colormodel","shim/strictmath":"shim/strictmath"}],"engine/plot/plotmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var PlotManager, displayModeFromNum, filter, flatMapMaybe, flip, fold, forEach, isNumber, map, mapMaybe, maybe, pipeline, toObject, values, zip;

  ({
    DisplayMode: {displayModeFromNum}
  } = require('./pen'));

  ({filter, forEach, map, toObject, zip} = require('brazierjs/array'));

  ({flip, pipeline} = require('brazierjs/function'));

  ({
    flatMap: flatMapMaybe,
    fold,
    map: mapMaybe,
    maybe
  } = require('brazierjs/maybe'));

  ({values} = require('brazierjs/object'));

  ({isNumber} = require('brazierjs/type'));

  module.exports = PlotManager = (function() {
    class PlotManager {
      
      // (Array[Plot]) => PlotManager
      constructor(plots) {
        var toName;
        // () => Unit
        this.setupPlots = this.setupPlots.bind(this);
        // () => Unit
        this.updatePlots = this.updatePlots.bind(this);
        toName = function(p) {
          return p.name.toUpperCase();
        };
        this._currentPlotMaybe = maybe(plots[plots.length - 1]);
        this._plotMap = pipeline(map(toName), flip(zip)(plots), toObject)(plots);
      }

      // () => Unit
      clearAllPlots() {
        this._forAllPlots(function(plot) {
          return plot.clear();
        });
      }

      // () => Unit
      clearPlot() {
        this._withPlot(function(plot) {
          return plot.clear();
        });
      }

      // (String) => Unit
      createTemporaryPen(name) {
        this._withPlot(function(plot) {
          return plot.createTemporaryPen(name);
        });
      }

      // () => Unit
      disableAutoplotting() {
        this._withPlot(function(plot) {
          return plot.disableAutoplotting();
        });
      }

      // (Array[Any]) => Unit
      drawHistogramFrom(list) {
        this._withPlot(function(plot) {
          var numbers;
          numbers = filter(isNumber)(list);
          return plot.drawHistogramFrom(numbers);
        });
      }

      // () => Unit
      enableAutoplotting() {
        this._withPlot(function(plot) {
          return plot.enableAutoplotting();
        });
      }

      // () => Maybe[Plot]
      getCurrentPlotMaybe() {
        return this._currentPlotMaybe;
      }

      // () => String
      getPlotName() {
        return this._withPlot(function(plot) {
          return plot.name;
        });
      }

      // () => Array[Plot]
      getPlots() {
        return values(this._plotMap);
      }

      // () => Number
      getPlotXMax() {
        return this._withPlot(function(plot) {
          return plot.xMax;
        });
      }

      // () => Number
      getPlotXMin() {
        return this._withPlot(function(plot) {
          return plot.xMin;
        });
      }

      // () => Number
      getPlotYMax() {
        return this._withPlot(function(plot) {
          return plot.yMax;
        });
      }

      // () => Number
      getPlotYMin() {
        return this._withPlot(function(plot) {
          return plot.yMin;
        });
      }

      // (String) => Boolean
      hasPenWithName(name) {
        return this._withPlot(function(plot) {
          return plot.hasPenWithName(name);
        });
      }

      // (ExportedPlotManager) => Unit
      importState({currentPlotNameOrNull, plots}) {
        plots.forEach((plot) => {
          var ref;
          return (ref = this._plotMap[plot.name.toUpperCase()]) != null ? ref.importState(plot) : void 0;
        });
        this._currentPlotMaybe = flatMapMaybe((name) => {
          return maybe(this._plotMap[name.toUpperCase()]);
        })(maybe(currentPlotNameOrNull));
      }

      // () => Boolean
      isAutoplotting() {
        return this._withPlot(function(plot) {
          return plot.isAutoplotting;
        });
      }

      // () => Unit
      lowerPen() {
        this._withPlot(function(plot) {
          return plot.lowerPen();
        });
      }

      plotPoint(x, y) {
        this._withPlot(function(plot) {
          return plot.plotPoint(x, y);
        });
      }

      // (Number) => Unit
      plotValue(value) {
        this._withPlot(function(plot) {
          return plot.plotValue(value);
        });
      }

      // () => Unit
      raisePen() {
        this._withPlot(function(plot) {
          return plot.raisePen();
        });
      }

      // () => Unit
      resetPen() {
        this._withPlot(function(plot) {
          return plot.resetPen();
        });
      }

      // (String) => Unit
      setCurrentPen(name) {
        this._withPlot(function(plot) {
          return plot.setCurrentPen(name);
        });
      }

      // (String) => Unit
      setCurrentPlot(name) {
        var plot;
        plot = this._plotMap[name.toUpperCase()];
        if (plot != null) {
          this._currentPlotMaybe = maybe(plot);
        } else {
          throw new Error(`no such plot: "${name}"`);
        }
      }

      // (Number) => Unit
      setHistogramBarCount(num) {
        if (num > 0) {
          this._withPlot(function(plot) {
            return plot.setHistogramBarCount(num);
          });
        } else {
          throw new Error(`You cannot make a histogram with ${num} bars.`);
        }
      }

      // (Number) => Unit
      setPenColor(color) {
        this._withPlot(function(plot) {
          return plot.setPenColor(color);
        });
      }

      // (Number) => Unit
      setPenInterval(color) {
        this._withPlot(function(plot) {
          return plot.setPenInterval(color);
        });
      }

      // (Number) => Unit
      setPenMode(num) {
        this._withPlot(function(plot) {
          return plot.updateDisplayMode(displayModeFromNum(num));
        });
      }

      setupPlots() {
        this._forAllPlots(function(plot) {
          return plot.setup();
        });
      }

      // (Number, Number) => Unit
      setXRange(min, max) {
        this._withPlot(function(plot) {
          return plot.setXRange(min, max);
        });
      }

      // (Number, Number) => Unit
      setYRange(min, max) {
        this._withPlot(function(plot) {
          return plot.setYRange(min, max);
        });
      }

      updatePlots() {
        this._forAllPlots(function(plot) {
          return plot.update();
        });
      }

      // [T] @ (String, String) => (() => T) => T
      withTemporaryContext(plotName, penName) {
        return (f) => {
          var oldPlotMaybe, result, tempPlotMaybe;
          oldPlotMaybe = this._currentPlotMaybe;
          tempPlotMaybe = maybe(this._plotMap[plotName.toUpperCase()]);
          this._currentPlotMaybe = tempPlotMaybe;
          result = penName != null ? mapMaybe(function(tempPlot) {
            return tempPlot.withTemporaryContext(penName)(f);
          })(tempPlotMaybe) : f();
          this._currentPlotMaybe = oldPlotMaybe;
          return result;
        };
      }

      // ((Plot) => Unit) => Unit
      _forAllPlots(f) {
        pipeline(values, forEach(f))(this._plotMap);
      }

      // [T] @ ((Plot) => T) => T
      _withPlot(f) {
        var error;
        error = new Error("There is no current plot. Please select a current plot using the set-current-plot command.");
        return fold(function() {
          throw error;
        })(f)(this._currentPlotMaybe);
      }

    };

    PlotManager.prototype._currentPlotMaybe = void 0; // Maybe[Plot]

    PlotManager.prototype._plotMap = void 0; // Object[String, Plot]

    return PlotManager;

  }).call(this);

}).call(this);

},{"./pen":"engine/plot/pen","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/object":"brazier/object","brazierjs/type":"brazier/type"}],"engine/plot/plotops":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, PenOps, PlottingOps;

  ColorModel = require('../core/colormodel');

  PenOps = (function() {
    class PenOps {
      constructor(plottingOps, pen) {
        this.addPoint = plottingOps.addPoint(pen);
        this.reset = plottingOps.resetPen(pen);
        this.updateMode = plottingOps.updatePenMode(pen);
        this.updateColor = plottingOps.updatePenColor(pen);
      }

    };

    PenOps.prototype.addPoint = void 0; // (Number, Number) => Unit

    PenOps.prototype.reset = void 0; // () => Unit

    PenOps.prototype.updateMode = void 0; // (Pen.Mode) => Unit

    PenOps.prototype.updateColor = void 0; // (NLColor) => Unit

    return PenOps;

  }).call(this);

  module.exports = PlottingOps = class PlottingOps {
    // ((Number, Number, Number, Number) => Unit, (Plot) => Unit, (Pen) => Unit, (Pen) => () => Unit, (Pen) => (Number, Number) => Unit, (Pen) => (Pen.DisplayMode) => Unit, (Pen) => (NLColor) => Unit) => PlotOps
    constructor(resize, reset, registerPen, resetPen, addPoint, updatePenMode, updatePenColor) {
      // (Pen) => PenOps
      this.makePenOps = this.makePenOps.bind(this);
      this.resize = resize;
      this.reset = reset;
      this.registerPen = registerPen;
      this.resetPen = resetPen;
      this.addPoint = addPoint;
      this.updatePenMode = updatePenMode;
      this.updatePenColor = updatePenColor;
    }

    // (Number) => String
    colorToRGBString(color) {
      var b, g, r;
      [r, g, b] = ColorModel.colorToRGB(color);
      return `rgb(${r}, ${g}, ${b})`;
    }

    makePenOps(pen) {
      return new PenOps(this, pen);
    }

  };

}).call(this);

},{"../core/colormodel":"engine/core/colormodel"}],"engine/plot/plot":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Pen, Plot, Stop, StrictMath, filter, flip, fold, forEach, id, isEmpty, isSomething, lookup, map, maxBy, maybe, pipeline, toObject, values, zip;

  ({Pen} = require('./pen'));

  StrictMath = require('shim/strictmath');

  ({filter, forEach, isEmpty, map, maxBy, toObject, zip} = require('brazierjs/array'));

  ({flip, id, pipeline} = require('brazierjs/function'));

  ({fold, isSomething, maybe} = require('brazierjs/maybe'));

  ({lookup, values} = require('brazierjs/object'));

  ({
    StopInterrupt: Stop
  } = require('util/exception'));

  module.exports = Plot = (function() {
    class Plot {
      
      // (String, Array[Pen], PlotOps, String, String, Boolean, Number, Number, Number, Number, () => (Unit | Stop), () => (Unit | Stop)) => Plot
      constructor(name1, pens = [], _ops, xLabel, yLabel, isLegendEnabled = true, isAutoplotting = true, xMin = 0, xMax = 10, yMin = 0, yMax = 10, _setupThis = (function() {}), _updateThis = (function() {})) {
        var toName;
        this.name = name1;
        this._ops = _ops;
        this.xLabel = xLabel;
        this.yLabel = yLabel;
        this.isLegendEnabled = isLegendEnabled;
        this.isAutoplotting = isAutoplotting;
        this.xMin = xMin;
        this.xMax = xMax;
        this.yMin = yMin;
        this.yMax = yMax;
        this._setupThis = _setupThis;
        this._updateThis = _updateThis;
        toName = function(p) {
          return p.name.toUpperCase();
        };
        this._currentPenMaybe = maybe(pens[0]);
        this._originalBounds = [this.xMin, this.xMax, this.yMin, this.yMax];
        this._penMap = pipeline(map(toName), flip(zip)(pens), toObject)(pens);
        this.clear();
      }

      // () => Unit
      clear() {
        var deletePen, pens, resetPen;
        [this.xMin, this.xMax, this.yMin, this.yMax] = this._originalBounds;
        this._ops.reset(this);
        this._resize();
        pens = this.getPens();
        deletePen = ((x) => {
          delete this._penMap[x.name.toUpperCase()];
        });
        resetPen = ((pen) => {
          pen.reset();
          this._ops.registerPen(pen);
        });
        pipeline(filter(function(x) {
          return x.isTemp;
        }), forEach(deletePen))(pens);
        pipeline(filter(function(x) {
          return !x.isTemp;
        }), forEach(resetPen))(pens);
        if ((this._currentPenMaybe == null) || fold(function() {
          return false;
        })(function(cp) {
          return cp.isTemp;
        })(this._currentPenMaybe)) {
          this._currentPenMaybe = maybe(isEmpty(pens) ? (this._penMap.DEFAULT = new Pen("DEFAULT", this._ops.makePenOps), this._penMap.DEFAULT) : pens[0]);
        }
      }

      // (String) => Unit
      createTemporaryPen(name) {
        this._currentPenMaybe = maybe(this._createAndReturnTemporaryPen(name));
      }

      // () => Unit
      disableAutoplotting() {
        this.isAutoplotting = false;
      }

      // (Array[Number]) => Unit
      drawHistogramFrom(list) {
        this._withPen((pen) => {
          if (pen.getInterval() > 0) {
            pen.drawHistogramFrom(list, this.xMin, this.xMax);
            return this._verifyHistogramSize(pen);
          } else {
            throw new Error(`You cannot histogram with a plot-pen-interval of ${pen.interval}.`);
          }
        });
      }

      // () => Unit
      enableAutoplotting() {
        this.isAutoplotting = true;
      }

      // () => Maybe[Pen]
      getCurrentPenMaybe() {
        return this._currentPenMaybe;
      }

      // () => Array[Pen]
      getPens() {
        return values(this._penMap);
      }

      // (String) => Boolean
      hasPenWithName(name) {
        return pipeline(this._getPenMaybeByName.bind(this), isSomething)(name);
      }

      // (ExportedPlot) => Unit
      importState({
          currentPenNameOrNull,
          isAutoplotting,
          isLegendOpen: isLegendEnabled,
          pens,
          xMax,
          xMin,
          yMax,
          yMin
        }) {
        this.isAutoplotting = isAutoplotting;
        this.isLegendEnabled = isLegendEnabled;
        this.xMax = xMax;
        this.xMin = xMin;
        this.yMax = yMax;
        this.yMin = yMin;
        pens.forEach((pen) => {
          return this._createAndReturnTemporaryPen(pen.name).importState(pen);
        });
        this._currentPenMaybe = this._getPenMaybeByName(currentPenNameOrNull);
        this._resize();
      }

      // () => Unit
      lowerPen() {
        this._withPen(function(pen) {
          return pen.lower();
        });
      }

      // (Number, Number) => Unit
      plotPoint(x, y) {
        this._withPen((pen) => {
          pen.addXY(x, y);
          return this._verifySize(x, y);
        });
      }

      // (Number) => Unit
      plotValue(value) {
        this._withPen((pen) => {
          var x;
          x = pen.addValue(value);
          return this._verifySize(x, value);
        });
      }

      // () => Unit
      raisePen() {
        this._withPen(function(pen) {
          return pen.raise();
        });
      }

      // () => Unit
      resetPen() {
        this._withPen(function(pen) {
          return pen.reset();
        });
      }

      // (String) => Unit
      setCurrentPen(name) {
        var penMaybe;
        penMaybe = this._getPenMaybeByName(name);
        if (isSomething(penMaybe)) {
          this._currentPenMaybe = penMaybe;
        } else {
          throw new Error(`There is no pen named "${name}" in the current plot`);
        }
      }

      // (Number) => Unit
      setHistogramBarCount(num) {
        this._withPen((pen) => {
          var interval;
          if (num >= 1) {
            interval = (this.xMax - this.xMin) / num;
            return pen.setInterval(interval);
          } else {
            throw new Error(`You cannot make a histogram with ${num} bars.`);
          }
        });
      }

      // (Number|RGB) => Unit
      setPenColor(color) {
        this._withPen(function(pen) {
          return pen.setColor(color);
        });
      }

      // (Number) => Unit
      setPenInterval(num) {
        this._withPen(function(pen) {
          return pen.setInterval(num);
        });
      }

      // () => Unit
      setup() {
        var setupResult;
        setupResult = this._setupThis();
        if (!(setupResult instanceof Stop)) {
          this.getPens().forEach(function(pen) {
            return pen.setup();
          });
        }
      }

      // (Number, Number) => Unit
      setXRange(min, max) {
        if (min >= max) {
          throw new Error(`the minimum must be less than the maximum, but ${min} is greater than or equal to ${max}`);
        }
        this.xMin = min;
        this.xMax = max;
        this._resize();
      }

      // (Number, Number) => Unit
      setYRange(min, max) {
        if (min >= max) {
          throw new Error(`the minimum must be less than the maximum, but ${min} is greater than or equal to ${max}`);
        }
        this.yMin = min;
        this.yMax = max;
        this._resize();
      }

      // () => Unit
      update() {
        var updateResult;
        updateResult = this._updateThis();
        if (!(updateResult instanceof Stop)) {
          this.getPens().forEach(function(pen) {
            return pen.update();
          });
        }
      }

      // (DisplayMode) => Unit
      updateDisplayMode(newMode) {
        this._withPen(function(pen) {
          return pen.updateDisplayMode(newMode);
        });
      }

      // (String) => (() => Unit) => Unit
      withTemporaryContext(penName) {
        return (f) => {
          var oldPenMaybe;
          oldPenMaybe = this._currentPenMaybe;
          this._currentPenMaybe = this._getPenMaybeByName(penName);
          f();
          this._currentPenMaybe = oldPenMaybe;
        };
      }

      // (String) => Pen
      _createAndReturnTemporaryPen(name) {
        var makeNew;
        makeNew = () => {
          var pen;
          pen = new Pen(name, this._ops.makePenOps, true);
          this._penMap[pen.name.toUpperCase()] = pen;
          this._ops.registerPen(pen);
          return pen;
        };
        return pipeline(this._getPenMaybeByName.bind(this), fold(makeNew)(id))(name);
      }

      // (String) => Pen
      _getPenMaybeByName(name) {
        if (name == null) {
          return maybe.None;
        } else {
          return lookup(name.toUpperCase())(this._penMap);
        }
      }

      // (Number, Number, Number, Number) => Unit
      _resize() {
        return this._ops.resize(this.xMin, this.xMax, this.yMin, this.yMax);
      }

      // Histograms can only change the size of the plot by increasing the maximum Y value
      // (and only when autoplotting is on). --JAB (2/11/15)

      // (Pen) => Unit
      _verifyHistogramSize(pen) {
        var isWithinBounds, penYMax;
        isWithinBounds = ({x}) => {
          return x >= this.xMin && x <= this.xMax;
        };
        penYMax = pipeline(filter(isWithinBounds), map(function(p) {
          return p.y;
        }), maxBy(id), fold(function() {
          return 0;
        })(id))(pen.getPoints());
        if (penYMax > this.yMax && this.isAutoplotting) {
          this.yMax = penYMax;
        }
        this._resize();
      }

      // (Number, Number) => Unit
      _verifySize(x, y) {
        var bumpMax, bumpMin, newXMax, newXMin, newYMax, newYMin;
        bumpMin = function([newMin, currentMin], currentMax) {
          var expandedRange, newValue, range;
          if (newMin < currentMin) {
            range = currentMax - newMin;
            expandedRange = range * 1.2;
            newValue = currentMax - expandedRange;
            return StrictMath.floor(newValue);
          } else {
            return currentMin;
          }
        };
        bumpMax = function([newMax, currentMax], currentMin) {
          var expandedRange, newValue, range;
          if (newMax > currentMax) {
            range = newMax - currentMin;
            expandedRange = range * 1.2;
            newValue = currentMin + expandedRange;
            return StrictMath.ceil(newValue);
          } else {
            return currentMax;
          }
        };
        newXMin = bumpMin([x, this.xMin], this.xMax);
        newXMax = bumpMax([x, this.xMax], this.xMin);
        newYMin = bumpMin([y, this.yMin], this.yMax);
        newYMax = bumpMax([y, this.yMax], this.yMin);
        // If bounds extended, we must resize, regardless of whether or not autoplotting is enabled, because some
        // libraries force autoscaling, but we only _expand_ the boundaries when autoplotting. --JAB (10/10/14)
        if (newXMin !== this.xMin || newXMax !== this.xMax || newYMin !== this.yMin || newYMax !== this.yMax) {
          if (this.isAutoplotting) {
            this.xMin = newXMin;
            this.xMax = newXMax;
            this.yMin = newYMin;
            this.yMax = newYMax;
          }
          this._resize();
        }
      }

      // [T] @ ((Pen) => T) => T
      _withPen(f) {
        return fold(function() {
          throw new Error(`Plot '${this.name}' has no pens!`);
        })(f)(this._currentPenMaybe);
      }

    };

    Plot.prototype._currentPenMaybe = void 0; // Maybe[Pen]

    Plot.prototype._originalBounds = void 0; // (Number, Number, Number, Number)

    Plot.prototype._penMap = void 0; // Object[String, Pen]

    Plot.prototype.name = void 0; // String

    return Plot;

  }).call(this);

}).call(this);

},{"./pen":"engine/plot/pen","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/object":"brazier/object","shim/strictmath":"shim/strictmath","util/exception":"util/exception"}],"engine/prim-checks/agentset-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentSetChecks, Comparator, checks, getTypeOf, types;

  ({checks, getTypeOf, types} = require('engine/core/typechecker'));

  Comparator = require('util/comparator');

  AgentSetChecks = class AgentSetChecks {
    // `getSelf()` is necessary because the predicates used for `with` and its optimized relatives
    // do not actually take in the agents they check, they assume the `selfManager` on the world
    // will be kept up-to-date for them.  As such this was the best way I could find to get
    // the proper agent to use when those predicates return incorrect values.
    // -Jeremy B February 2021
    constructor(validator, dumper, prims, getSelf) {
      this.validator = validator;
      this.dumper = dumper;
      this.prims = prims;
      this.getSelf = getSelf;
    }

    // (Any) => Boolean
    static isPoint(point) {
      return point.length === 2 && checks.isNumber(point[0]) && checks.isNumber(point[1]);
    }

    // (Any) => Boolean
    static isListOfPoints(points) {
      return points.every(function(point) {
        return checks.isList(point) && AgentSetChecks.isPoint(point);
      });
    }

    // (() => Boolean) => (T) => Boolean
    makeCheckedF(prim, f) {
      return () => {
        var result;
        result = f();
        if (!checks.isBoolean(result)) {
          this.validator.error('_ expected a true/false value from _, but got _ instead.', prim, this.getSelf(), this.dumper(result));
        }
        return result;
      };
    }

    // I think it's a little strange that there are three different error messages for the `*-set` agentset creation prims having bad arguments,
    // but at the moment it doesn't seem worth changing desktop to unify them.  -Jeremy B February 2021

    // (PatchType | TurtleType | LinkType, PatchSetType | TurtleSetType | LinkSetType, Array[Any]) => Unit
    setCreationListCheck(agentType, agentSetType, list) {
      return list.forEach((value) => {
        if (checks.isList(value)) {
          return this.setCreationListCheck(agentType, agentSetType, value);
        } else if (!agentType.isOfType(value) && !agentSetType.isOfType(value) && !checks.isNobody(value)) {
          if (checks.isAgentSet(value)) {
            return this.validator.error('List inputs to _-SET must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.', agentType.niceName().toUpperCase(), agentType.niceName(), this.dumper(list), this.dumper(value));
          } else {
            return this.validator.error('List inputs to _-SET must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.', agentType.niceName().toUpperCase(), agentType.niceName(), this.dumper(list), this.dumper(value));
          }
        }
      });
    }

    // (PatchType | TurtleType | LinkType, PatchSetType | TurtleSetType | LinkSetType, Array[Any]) => Unit
    setCreationArgsCheck(agentType, agentSetType, values) {
      return values.forEach((value) => {
        if (checks.isList(value)) {
          return this.setCreationListCheck(agentType, agentSetType, value);
        } else if (!agentType.isOfType(value) && !agentSetType.isOfType(value) && !checks.isNobody(value)) {
          return this.validator.error('_-SET expected input to be a _ agentset or _ but got _ instead.', agentType.niceName().toUpperCase(), agentType.niceName(), this.validator.valueToString(value));
        }
      });
    }

    // (AgentSet[T]) => Boolean
    any(agentset) {
      return !agentset.isEmpty();
    }

    // (AgentSet[T], () => Boolean) => Boolean
    anyOtherWith(agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", arguments);
      return agentset._optimalAnyOtherWith(this.makeCheckedF("WITH", f));
    }

    // (AgentSet[T], () => Boolean) => Boolean
    anyWith(agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", arguments);
      return agentset._optimalAnyWith(this.makeCheckedF("WITH", f));
    }

    // (AgentSet[T], (T) => Boolean) => Boolean
    all(agentset, f) {
      return agentset.agentAll(this.makeCheckedF("ALL?", f));
    }

    // (AgentSet[T], Array[Array[Number]]) => AgentSet
    atPoints(agentset, coords) {
      if (!AgentSetChecks.isListOfPoints(coords)) {
        this.validator.error('Invalid list of points: _', this.dumper(coords));
      }
      return agentset.atPoints(coords);
    }

    // (String, Patch | Turtle | PatchSet | TurtleSet) => AgentSet
    breedOn(breedName, target) {
      if (checks.isPatch(target)) {
        return this.prims.breedOnPatch(breedName, target);
      } else if (checks.isTurtle(target)) {
        return this.prims.breedOnTurtle(breedName, target);
      } else if (checks.isPatchSet(target)) {
        return this.prims.breedOnPatchSet(breedName, target);
      } else if (checks.isTurtleSet(target)) {
        return this.prims.breedOnTurtleSet(breedName, target);
      }
    }

    // (AgentSet[T]) => Number
    count(agentset) {
      return agentset.size();
    }

    // (AgentSet[T], () => Boolean) => Number
    countOtherWith(agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", arguments);
      return agentset._optimalCountOtherWith(this.makeCheckedF("WITH", f));
    }

    // (AgentSet[T], () => Boolean) => Number
    countWith(agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", arguments);
      return agentset._optimalCountWith(this.makeCheckedF("WITH", f));
    }

    // [T <: (Array[Link]|Link|AbstractAgentSet[Link])] @ (T*) => LinkSet
    linkSet(...values) {
      this.setCreationArgsCheck(types.Link, types.LinkSet, values);
      return this.prims.linkSet(values);
    }

    // (AgentSet[T], Number, (T) => Number) => AgentSet[T]
    maxNOf(agentset, n, f) {
      if (n > agentset.size()) {
        this.validator.error('Requested _ random agents from a set of only _ agents.', n, agentset.size());
      }
      if (n < 0) {
        this.validator.error('First input to _ can_t be negative.', "MAX-N-OF");
      }
      return agentset.maxNOf(n, f);
    }

    // (AgentSet[T], (T) => Number) => AgentSet
    maxOneOf(agentset, f) {
      return agentset.maxOneOf(f);
    }

    // (AgentSet[T], Number, (T) => Number) => AgentSet[T]
    minNOf(agentset, n, f) {
      if (n > agentset.size()) {
        this.validator.error('Requested _ random agents from a set of only _ agents.', n, agentset.size());
      }
      if (n < 0) {
        this.validator.error('First input to _ can_t be negative.', "MIN-N-OF");
      }
      return agentset.minNOf(n, f);
    }

    // (AgentSet[T], (T) => Number) => AgentSet
    minOneOf(agentset, f) {
      return agentset.minOneOf(f);
    }

    // (T | AgentSet[T], (T) => U) => U | List[U]
    of(agentOrAgentset, f) {
      return agentOrAgentset.projectionBy(f);
    }

    // (AgentSet[T], () => Boolean) => T
    oneOfWith(agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", arguments);
      return agentset._optimalOneOfWith(this.makeCheckedF("WITH", f));
    }

    // (AgentSet[T], Number, (Number, Number) => Boolean) => Boolean
    optimizeCount(agentset, n, operator) {
      this.validator.commonArgChecks.agentSet("COUNT", arguments);
      return agentset._optimalCheckCount(n, operator);
    }

    // (AgentSet[T], () => Boolean) => AgentSet[T]
    otherWith(agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", arguments);
      return agentset._optimalOtherWith(this.makeCheckedF("WITH", f));
    }

    // [T <: (Array[Patch]|Patch|AbstractAgentSet[Patch])] @ (T*) => PatchSet
    patchSet(...values) {
      this.setCreationArgsCheck(types.Patch, types.PatchSet, values);
      return this.prims.patchSet(values);
    }

    // (AgentSet[T], () => Number | String | Agent) => AgentSet[T]
    sortOn(agentset, f) {
      var badFirstType, compare, sortingFunc;
      compare = null;
      badFirstType = false;
      sortingFunc = (arg, arg1) => {
        var arg, arg1, name1, name2, o1, o2, type1, type2;
        arg[0], o1 = arg[1];
        arg1[0], o2 = arg1[1];
        // Picking out the compare functions is a little more logic than I'd like in this error checking layer.
        // But it does move some type checks here, which is good, and it's the easiest way to get the error
        // checks to match up with desktop/headless.  -Jeremy B Fabruary 2021
        if (compare === null) {
          compare = checks.isNumber(o1) ? function(n1, n2) {
            return Comparator.numericCompare(n1, n2).toInt;
          } : checks.isString(o1) ? function(s1, s2) {
            return Comparator.stringCompare(s1, s2).toInt;
          } : checks.isAgent(o1) ? function(a1, a2) {
            return a1.compare(a2).toInt;
          } : (badFirstType = true, null);
        }
        type1 = getTypeOf(o1);
        type2 = getTypeOf(o2);
        if (type1 !== type2 || badFirstType) {
          name1 = this.validator.addIndefiniteArticle(type1.niceName());
          name2 = this.validator.addIndefiniteArticle(type2.niceName());
          // The order swap of `name1` and `name2` is intentional to get identical errors to desktop. -Jeremy B February 2021
          this.validator.error('SORT-ON works on numbers, strings, or agents of the same type, but not on _ and _', name2, name1);
        }
        return compare(o1, o2);
      };
      return agentset.sortOn(f, sortingFunc);
    }

    // (Agent | AgentSet) => TurtleSet
    turtlesOn(agentOrAgentset) {
      if (checks.isAgentSet(agentOrAgentset)) {
        return this.prims.turtlesOnAgentSet(agentOrAgentset);
      } else {
        return this.prims.turtlesOnAgent(agentOrAgentset);
      }
    }

    // [T <: (Array[Turtle]|Turtle|AbstractAgentSet[Turtle])] @ (T*) => TurtleSet
    turtleSet(...values) {
      this.setCreationArgsCheck(types.Turtle, types.TurtleSet, values);
      return this.prims.turtleSet(values);
    }

    // (AgentSet[T], () => Boolean) => AgentSet[T]
    with(agentset, f) {
      return agentset.agentFilter(this.makeCheckedF("WITH", f));
    }

    // (AgentSet[T], () => Number) => AgentSet[T]
    withMax(agentset, f) {
      return agentset.maxesBy(f);
    }

    // (AgentSet[T], () => Number) => AgentSet[T]
    withMin(agentset, f) {
      return agentset.minsBy(f);
    }

  };

  module.exports = AgentSetChecks;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker","util/comparator":"util/comparator"}],"engine/prim-checks/checker":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentSetChecks, Checker, ListChecks, MathChecks, Validator;

  Validator = require('./validator');

  AgentSetChecks = require('./agentset-checks');

  ListChecks = require('./list-checks');

  MathChecks = require('./math-checks');

  Checker = class Checker {
    constructor(i18nBundle, dumper, miscPrims, listPrims, randomPrims, stringPrims, getSelf) {
      this.validator = new Validator(i18nBundle, dumper);
      this.agentset = new AgentSetChecks(this.validator, dumper, miscPrims, getSelf);
      this.list = new ListChecks(this.validator, dumper, listPrims, stringPrims);
      this.math = new MathChecks(this.validator, randomPrims);
    }

  };

  module.exports = Checker;

}).call(this);

},{"./agentset-checks":"engine/prim-checks/agentset-checks","./list-checks":"engine/prim-checks/list-checks","./math-checks":"engine/prim-checks/math-checks","./validator":"engine/prim-checks/validator"}],"engine/prim-checks/list-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ListChecks, checks, getTypeOf, types;

  ({checks, getTypeOf, types} = require('engine/core/typechecker'));

  ListChecks = class ListChecks {
    constructor(validator, dumper, listPrims, stringPrims) {
      this.validator = validator;
      this.dumper = dumper;
      this.listPrims = listPrims;
      this.stringPrims = stringPrims;
    }

    // (Number, Array[Any] | String) => Unit
    indexBoundsChecks(index, listOrString, inclusive = true) {
      if (index < 0) {
        this.validator.error('_ isn_t greater than or equal to zero.', index);
      }
      if (index > listOrString.length || (inclusive && index === listOrString.length)) {
        this.validator.error('Can_t find element _ of the _ _, which is only of length _.', index, getTypeOf(listOrString).niceName(), this.dumper(listOrString), listOrString.length);
      }
    }

    // (String, Array | String) => Unit
    checkNotEmpty(prim, listOrString) {
      var argType, primName;
      if (listOrString.length === 0) {
        argType = getTypeOf(listOrString);
        primName = argType === types.String ? prim : prim.toUpperCase();
        return this.validator.error('_ got an empty _ as input.', primName, argType.niceName());
      }
    }

    // (String, Array | String) => Array | String
    butFirst(prim, listOrString) {
      this.checkNotEmpty(prim, listOrString);
      return this.listPrims.butFirst(listOrString);
    }

    // (String) => (Array | String) => Array | String
    butLast(prim, listOrString) {
      this.checkNotEmpty(prim, listOrString);
      return this.listPrims.butLast(listOrString);
    }

    // (Array[Any] | String) => Boolean
    empty(listOrString) {
      return this.listPrims.empty(listOrString);
    }

    // ((T) => Boolean, Array[T]) => Array[T]
    filter(f, list) {
      var checkedF;
      checkedF = (item) => {
        var result;
        result = f(item);
        return this.validator.commonValueChecks.boolean("FILTER", result);
      };
      return this.listPrims.filter(checkedF, list);
    }

    // (Array[Any] | String) => Any | String
    first(listOrString) {
      if (listOrString.length === 0) {
        this.validator.error('List is empty.');
      }
      return this.listPrims.first(listOrString);
    }

    // (Any, Array[Any]) => Array[Any]
    fput(item, list) {
      return this.listPrims.fput(item, list);
    }

    // (Number, Array[Any] | String, Any) => Array[Any] | String
    insertItem(index, listOrString, item) {
      var inclusive;
      this.indexBoundsChecks(index, listOrString, inclusive = false);
      if (checks.isString(listOrString)) {
        if (!checks.isString(item)) {
          this.validator.throwTypeError("INSERT-ITEM", item, types.String);
        }
        return this.stringPrims.insertItem(index, listOrString, item);
      } else {
        return this.listPrims.insertItem(index, listOrString, item);
      }
    }

    // (Number, Array[Any] | String) => Any | String
    item(index, listOrString) {
      this.indexBoundsChecks(index, listOrString);
      return this.listPrims.item(index, listOrString);
    }

    // (Array[Any] | String) => Any | String
    last(listOrString) {
      if (listOrString.length === 0) {
        this.validator.error('List is empty.');
      }
      return this.listPrims.last(listOrString);
    }

    // (Array[Any] | String) => Number
    length(listOrString) {
      return this.listPrims.length(listOrString);
    }

    // (Any, Array[Any]) => Array[Any]
    lput(item, list) {
      return this.listPrims.lput(item, list);
    }

    // Array[Any] => Number
    max(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('Can_t find the _ of a list with no numbers: __', "maximum", this.dumper(values), "");
      }
      return this.listPrims.max(nums);
    }

    // Array[Any] => Number
    mean(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('Can_t find the _ of a list with no numbers: __', "mean", this.dumper(values), ".");
      }
      return this.listPrims.mean(nums);
    }

    // Array[Any] => Number
    median(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('Can_t find the _ of a list with no numbers: __', "median", this.dumper(values), ".");
      }
      return this.validator.checkNumber(this.listPrims.median(nums));
    }

    // (Any, Array[Any] | AbstractAgentSet | String) => Boolean
    member(item, items) {
      if (checks.isList(items)) {
        return this.listPrims.member(item, items);
      } else if (checks.isString(items)) {
        return this.stringPrims.member(item, items); // agentset
      } else {
        return items.exists(function(a) {
          return item === a;
        });
      }
    }

    // (Array[Any]) => Number
    min(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('Can_t find the _ of a list with no numbers: __', "minimum", this.dumper(values), "");
      }
      return this.validator.checkNumber(this.listPrims.min(nums));
    }

    // (Array[Any]) => Array[Any]
    modes(list) {
      return this.listPrims.modes(list);
    }

    // (Number, Array[Any] | AbstractAgentSet) => Array[Any] | AbstractAgentSet
    nOf(count, agentSetOrList) {
      if (count < 0) {
        this.validator.error('First input to _ can_t be negative.', "N-OF");
      }
      if (checks.isList(agentSetOrList)) {
        if (agentSetOrList.length < count) {
          this.validator.error('Requested _ random items from a list of length _.', count, agentSetOrList.length);
        }
        return this.listPrims.nOfList(count, agentSetOrList); // agentset
      } else {
        if (agentSetOrList.size() < count) {
          this.validator.error('Requested _ random agents from a set of only _ agents.', count, agentSetOrList.size());
        }
        return this.listPrims.nOfAgentSet(count, agentSetOrList);
      }
    }

    // (AbstractAgentSet | Array[Any]) => Agent | Any
    oneOf(agentSetOrList) {
      if (checks.isList(agentSetOrList)) {
        if (agentSetOrList.length === 0) {
          this.validator.error('_ got an empty _ as input.', "ONE-OF", types.List.niceName());
        }
        return this.listPrims.oneOf(agentSetOrList); // agentset
      } else {
        return agentSetOrList.randomAgent();
      }
    }

    // (Any, Array[Any] | String) => Number
    position(item, listOrString) {
      if (checks.isList(listOrString)) {
        return this.listPrims.position(item, listOrString); // string
      } else {
        return this.stringPrims.position(item, listOrString);
      }
    }

    reduce(f, list) {
      if (list.length === 0) {
        this.validator.error('The list argument to reduce must not be empty.');
      }
      return this.listPrims.reduce(f, list);
    }

    // (Any | String, Array[Any] | String) => Array[Any] | String
    remove(item, listOrString) {
      if (checks.isString(listOrString)) {
        if (!checks.isString(item)) {
          this.validator.throwTypeError("REMOVE", item, types.String);
        }
        return this.stringPrims.remove(item, listOrString); // list
      } else {
        return this.listPrims.remove(item, listOrString);
      }
    }

    // (Array[Any]) => Array[Any]
    removeDuplicates(list) {
      return this.listPrims.removeDuplicates(list);
    }

    // (Number, Array[Any] | String) => Array[Any] | String
    removeItem(index, listOrString) {
      this.indexBoundsChecks(index, listOrString);
      if (checks.isString(listOrString)) {
        return this.stringPrims.removeItem(index, listOrString); // list
      } else {
        return this.listPrims.removeItem(index, listOrString);
      }
    }

    // (Number, Array[Any] | String, Any | String) => Array[Any] | String
    replaceItem(index, listOrString, item) {
      this.indexBoundsChecks(index, listOrString);
      if (checks.isString(listOrString)) {
        if (!checks.isString(item)) {
          this.validator.throwTypeError("REPLACE-ITEM", item, types.String);
        }
        return this.stringPrims.replaceItem(index, listOrString, item); // list
      } else {
        return this.listPrims.replaceItem(index, listOrString, item);
      }
    }

    // (Array[Any] | String) => Array[Any] | String
    reverse(listOrString) {
      if (checks.isString(listOrString)) {
        return this.stringPrims.reverse(listOrString); // list
      } else {
        return this.listPrims.reverse(listOrString);
      }
    }

    // (Array[Any]) => Array[Any]
    shuffle(list) {
      return this.listPrims.shuffle(list);
    }

    // (Array[Any] | AbstractAgentSet) => Array[Any]
    sort(agentSetOrList) {
      if (checks.isList(agentSetOrList)) {
        return this.listPrims.sort(agentSetOrList); // agentset
      } else {
        return agentSetOrList.sort();
      }
    }

    // ((Any, Any) => Boolean, Array[Any] | AbstractAgentSet) => Array[Any]
    sortBy(f, agentSetOrList) {
      var checkedF;
      checkedF = (a, b) => {
        var result;
        result = f(a, b);
        return this.validator.commonValueChecks.boolean("SORT-BY", result);
      };
      if (checks.isList(agentSetOrList)) {
        return this.listPrims.sortByList(checkedF, agentSetOrList); // agentset
      } else {
        return this.listPrims.sortByAgentSet(checkedF, agentSetOrList);
      }
    }

    // Array[Any] => Number
    standardDeviation(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 2) {
        this.validator.error('Can_t find the _ of a list without at least two numbers: __', "standard deviation", this.dumper(values), "");
      }
      return this.validator.checkNumber(this.listPrims.standardDeviation(nums));
    }

    // (Array[Any], Number, Number) => Array[Any]
    sublist(list, startIndex, endIndex) {
      if (startIndex < 0) {
        this.validator.error('_ is less than zero.', startIndex);
      }
      if (endIndex > list.length) {
        this.validator.error('_ is greater than the length of the input list (_).', endIndex, list.length);
      }
      if (endIndex < startIndex) {
        this.validator.error('_ is less than _.', endIndex, startIndex);
      }
      return this.listPrims.sublist(list, startIndex, endIndex);
    }

    // (String, Number, Number) => String
    substring(text, startIndex, endIndex) {
      return this.stringPrims.substring(text, startIndex, endIndex);
    }

    // Array[Any] => Number
    sum(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      return this.validator.checkNumber(this.listPrims.sum(nums));
    }

    // (Number, Array[Any] | AbstractAgentSet) => Array[Any] | AbstractAgentSet
    upToNOf(count, agentSetOrList) {
      if (count < 0) {
        this.validator.error('First input to _ can_t be negative.', "UP-TO-N-OF");
      }
      if (checks.isList(agentSetOrList)) {
        return this.listPrims.upToNOfList(count, agentSetOrList); // agentset
      } else {
        return this.listPrims.upToNOfAgentSet(count, agentSetOrList);
      }
    }

    // Array[Any] => Number
    variance(values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 2) {
        this.validator.error('Can_t find the _ of a list without at least two numbers: __', "variance", this.dumper(values), ".");
      }
      return this.validator.checkNumber(this.listPrims.variance(nums));
    }

  };

  module.exports = ListChecks;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker"}],"engine/prim-checks/math-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MathChecks, NLMath, formatFloat;

  NLMath = require('util/nlmath');

  formatFloat = require('util/formatfloat');

  MathChecks = class MathChecks {
    constructor(validator, randomPrims) {
      this.validator = validator;
      this.randomPrims = randomPrims;
    }

    // (Number) => Number
    abs(d) {
      return NLMath.abs(d);
    }

    // (Number) => Number
    acos(d) {
      return this.validator.checkNumber(NLMath.acos(d));
    }

    // (Number) => Number
    asin(d) {
      return this.validator.checkNumber(NLMath.asin(d));
    }

    // (Number, Number) => Number
    atan(d1, d2) {
      if (d1 === 0 && d2 === 0) {
        this.validator.error('atan is undefined when both inputs are zero.');
      }
      return NLMath.atan(d1, d2);
    }

    // (Number) => Number
    ceil(d) {
      return NLMath.ceil(d);
    }

    // (Number) => Number
    cos(d) {
      return NLMath.cos(d);
    }

    // (Number, Number) => Number
    div(n, d) {
      if (d === 0) {
        this.validator.error('Division by zero.');
      }
      return n / d;
    }

    // (Number) => Number
    exp(p) {
      return this.validator.checkNumber(NLMath.exp(p));
    }

    // (Number) => Number
    floor(d) {
      return NLMath.floor(d);
    }

    // (Number) => Number
    int(n) {
      return StrictMath.trunc(this.validator.checkLong(n));
    }

    // (Number) => Number
    ln(n) {
      if (n <= 0) {
        this.validator.error('Can_t take logarithm of _.', n);
      }
      return NLMath.ln(n);
    }

    // (Number, Number) => Number
    log(n, b) {
      if (n <= 0) {
        this.validator.error('Can_t take logarithm of _.', n);
      }
      if (b <= 0) {
        this.validator.error('_ isn_t a valid base for a logarithm.', b);
      }
      return NLMath.log(n, b);
    }

    // (Number, Number) => Number
    minus(a, b) {
      return this.validator.checkNumber(a - b);
    }

    // (Number, Number) => Number
    mod(p, q) {
      return NLMath.mod(p, q);
    }

    // (Number, Number) => Number
    mult(a, b) {
      return this.validator.checkNumber(a * b);
    }

    // (Boolean) => Boolean
    not(a) {
      return !a;
    }

    // (Number, Number) => Number
    plus(a, b) {
      return this.validator.checkNumber(a + b);
    }

    // (Number, Number) => Number
    pow(b, p) {
      return this.validator.checkNumber(NLMath.pow(b, p));
    }

    // (Number, Number) => Number
    precision(n, places) {
      return NLMath.precision(n, places);
    }

    // (Number) => Number
    random(n) {
      return this.randomPrims.random(this.validator.checkLong(n));
    }

    // (Number) => Number
    randomExponential(mean) {
      return this.validator.checkNumber(this.randomPrims.randomExponential(mean));
    }

    // (Number) => Number
    randomFloat(n) {
      return this.randomPrims.randomFloat(n);
    }

    // (Number, Number) => Number
    randomGamma(alpha, lambda) {
      if (alpha <= 0 || lambda <= 0) {
        this.validator.error('Both Inputs to RANDOM-GAMMA must be positive.');
      }
      return this.randomPrims.randomGamma(alpha, lambda);
    }

    // (Number, Number) => Number
    randomNormal(mean, stdDev) {
      if (stdDev < 0) {
        this.validator.error('random-normal_s second input can_t be negative.');
      }
      return this.validator.checkNumber(this.randomPrims.randomNormal(mean, stdDev));
    }

    // (Number) => Number
    randomPoisson(mean) {
      return this.randomPrims.randomPoisson(mean);
    }

    // (Number) => Unit
    randomSeed(seed) {
      if (seed < -2147483648 || seed > 2147483647) {
        this.validator.error('_ is not in the allowable range for random seeds (-2147483648 to 2147483647)', formatFloat(seed));
      }
      this.randomPrims.randomSeed(seed);
    }

    // (Number, Number) => Number
    remainder(a, b) {
      return a % b;
    }

    // (Number) => Number
    round(n) {
      return NLMath.round(n);
    }

    // (Number) => Number
    sin(d) {
      return NLMath.sin(d);
    }

    // (Number) => Number
    sqrt(n) {
      if (n < 0) {
        this.validator.error('The square root of _ is an imaginary number.', n);
      }
      return NLMath.sqrt(n);
    }

    // (Number, Number) => Number
    subtractHeadings(h1, h2) {
      return NLMath.subtractHeadings(h1, h2);
    }

    // (Number) => Number
    tan(d) {
      return NLMath.tan(d);
    }

    // (Number) => Number
    unaryminus(a) {
      return -a;
    }

    // (Boolean, Boolean) => Boolean
    xor(a, b) {
      return a !== b;
    }

  };

  module.exports = MathChecks;

}).call(this);

},{"util/formatfloat":"util/formatfloat","util/nlmath":"util/nlmath"}],"engine/prim-checks/syntax":[function(require,module,exports){
(function() {
  var NLType, UnknownType, getTypesFromSyntax, syntaxToTypes, types, unknown;

  ({types, NLType} = require('engine/core/typechecker'));

  UnknownType = class UnknownType extends NLType {
    isOfType(x) {
      throw new Error("should we be checking this?");
    }

    niceName() {
      return "unknown type we can't do anything with";
    }

  };

  unknown = new UnknownType();

  // The third item in these arrays is the "error message order" as copied
  // from `TypeNames.scala` in desktop.  I'm sure there is a better way to
  // handle this.  -Jeremy B February 2021
  syntaxToTypes = [[1, types.Number, 5], [2, types.Boolean, 6], [4, types.String, 7], [8, types.List, 8], [16, types.TurtleSet, 10], [32, types.PatchSet, 11], [64, types.LinkSet, 12], [112, types.AgentSet, 9], [128, types.Nobody, 18], [256, types.Turtle, 13], [512, types.Patch, 14], [1024, types.Link, 15], [1792, types.Agent, 4], [2048, types.CommandLambda, 17], [4096, types.ReporterLambda, 16], [8191, types.Wildcard, 3], [8192, unknown, 99], [16384, unknown, 99], [32768, unknown, 99], [65536, unknown, 99], [131072, unknown, 99], [262144, unknown, 99], [524288, unknown, 99], [1048576, unknown, 99], [2097152, unknown, 99]].reverse(); // The reverse is important so we check syntax values from largest to smallest. -Jeremy B February 2021

  
  // (Int) => Array[NLType]
  getTypesFromSyntax = function(syntax) {
    return syntaxToTypes.filter(function([check, type, _]) {
      var hasType;
      hasType = (syntax >= check) && (syntax & check) !== 0;
      if (hasType) {
        syntax = syntax - check;
      }
      return hasType;
    }).sort(function(a, b) {
      return a[2] - b[2];
    }).map(function([_1, type, _2]) {
      return type;
    });
  };

  module.exports = {getTypesFromSyntax};

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker"}],"engine/prim-checks/validator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var StrictMath, Validator, checks, formatFloat, getTypeOf, getTypesFromSyntax, types;

  StrictMath = require('shim/strictmath');

  formatFloat = require('util/formatfloat');

  ({checks, getTypeOf, types} = require('engine/core/typechecker'));

  ({getTypesFromSyntax} = require('engine/prim-checks/syntax'));

  Validator = (function() {
    class Validator {
      constructor(bundle, dumper) {
        var agentSet, boolean;
        this.bundle = bundle;
        this.dumper = dumper;
        // These arrays of types and the common checks below are pre-computed so that all prims
        // can share them without making loads of extra array instances and extra functions.
        // -Jeremy B December 2020
        // Most of these have gone away in favor of the compiler-based arg type checks.
        // -Jeremy B February 2021
        agentSet = [types.AgentSet];
        boolean = [types.Boolean];
        this.commonArgChecks = {
          agentSet: this.makeArgTypeCheck(agentSet),
          boolean: this.makeArgTypeCheck(boolean)
        };
        this.commonValueChecks = {
          boolean: this.makeValueTypeCheck(...boolean)
        };
      }

      // (Boolean, String, Array[Any]) => Unit
      error(messageKey, ...messageValues) {
        var message;
        message = this.bundle.get(messageKey, ...messageValues.map(function(val) {
          if (typeof val === "function") {
            return val();
          } else {
            return val;
          }
        }));
        throw new Error(message);
      }

      // (Number) => Number
      checkLong(value) {
        if (value > 9007199254740992 || value < -9007199254740992) {
          this.error('_ is too large to be represented exactly as an integer in NetLogo', formatFloat(value));
        }
        return value;
      }

      // (Number) => Number
      checkNumber(result) {
        if (Number.isNaN(result)) {
          this.error('math operation produced a non-number');
        }
        if (result === 2e308) {
          this.error('math operation produced a number too large for NetLogo');
        }
        return result;
      }

      // (String) => String
      addIndefiniteArticle(text) {
        if (['A', 'E', 'I', 'O', 'U'].includes(text.charAt(0).toUpperCase())) {
          return `an ${text}`;
        } else {
          return `a ${text}`;
        }
      }

      // (Array[NLType]) => String
      listTypeNames(typesToName) {
        var nameList, names;
        names = typesToName.map(function(type) {
          return type.niceName();
        });
        nameList = names.join(" or ");
        return this.addIndefiniteArticle(nameList);
      }

      // (Any) => String
      valueToString(value) {
        var valueType;
        valueType = getTypeOf(value);
        if (valueType === types.Nobody) {
          return "NOBODY";
        } else if (valueType === types.Wildcard) {
          return "any value";
        } else {
          return `the ${valueType.niceName()} ${this.dumper(value)}`;
        }
      }

      // (String, Any, Array[NLType]) => String
      typeError(prim, value, expectedTypes) {
        var expectedText, valueText;
        valueText = this.valueToString(value);
        expectedText = this.listTypeNames(expectedTypes);
        return this.bundle.get("_ expected input to be _ but got _ instead.", prim, expectedText, valueText);
      }

      // (String, Any, Array[NLType]) => Unit
      throwTypeError(prim, value, ...expectedTypes) {
        throw new Error(this.typeError(prim, value, expectedTypes));
      }

      // (Array[Array[NLType]]) => (String, Array[Any]) => Unit
      makeArgTypeCheck(...argTypes) {
        return (prim, args) => {
          var i, k, ref;
// We could use `zip()` or `foreach()` or whatever here, but I don't want to use anything that would
// generate extra closures as this code will get called a whole lot.  So we'll leave it ugly but
// hopefully "optimized" -Jeremy B December 2020
          for (i = k = 0, ref = argTypes.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
            this.checkValueTypes(prim, argTypes[i], args[i]);
          }
        };
      }

      // (Array[NLType]) => (String, Any) => Any
      makeValueTypeCheck(...allowedTypes) {
        return (prim, value) => {
          return this.checkValueTypes(prim, allowedTypes, value);
        };
      }

      // (String, Array[NLType], Any) => Any
      checkValueTypes(prim, allowedTypes, value) {
        var j, k, match, ref;
        // And we could use `some()` here, but that also could generate transient closure objects. -Jeremy B December 2020
        match = false;
        for (j = k = 0, ref = allowedTypes.length; (0 <= ref ? k < ref : k > ref); j = 0 <= ref ? ++k : --k) {
          if (allowedTypes[j].isOfType(value)) {
            match = true;
            break;
          }
        }
        if (!match) {
          this.throwTypeError(prim, value, ...allowedTypes);
        }
        return value;
      }

      // (Int) => Array[NLType]
      syntaxTypeToRuntimeTypes(syntax) {
        var allowedTypes;
        if (this._cachedRuntimeTypes.has(syntax)) {
          return this._cachedRuntimeTypes.get(syntax);
        } else {
          allowedTypes = getTypesFromSyntax(syntax);
          this._cachedRuntimeTypes.set(syntax, allowedTypes);
          return allowedTypes;
        }
      }

      // (String, Int, Any) => Any
      checkArg(prim, syntax, argValue) {
        var allowedTypes;
        allowedTypes = this.syntaxTypeToRuntimeTypes(syntax);
        return this.checkValueTypes(prim, allowedTypes, argValue);
      }

    };

    // Map[Int, Array[NLType]]
    Validator.prototype._cachedRuntimeTypes = new Map();

    return Validator;

  }).call(this);

  module.exports = Validator;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker","engine/prim-checks/syntax":"engine/prim-checks/syntax","shim/strictmath":"shim/strictmath","util/formatfloat":"util/formatfloat"}],"engine/prim/evalprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var EvalPrims, evalCache, globalEval, readFromString, scalaJSEvalCode;

  globalEval = eval;

  readFromString = function(str) {
    var ex;
    try {
      return Converter.stringToJSValue(str);
    } catch (error) {
      ex = error;
      throw new Error(ex.message);
    }
  };

  evalCache = {};

  scalaJSEvalCode = function(code, widgets, runString, isRunResult, procVars) {
    var compileParams, fun, js, result, runFun, runKey, varNames, varString;
    varNames = Object.keys(procVars).sort(); // must be sorted as order can vary depending on procedure structure
    varString = varNames.join(' ');
    runKey = `${varString} => ${runString}`;
    runFun = (evalCache[runKey] != null) ? evalCache[runKey] : (compileParams = {
      code: code,
      widgets: widgets,
      commands: [],
      reporters: [],
      turtleShapes: [],
      linkShapes: []
    }, js = Converter.compileRunString(compileParams, runString, isRunResult, varString), fun = globalEval(js), evalCache[runKey] = fun, fun);
    result = runFun(...varNames.map((vn) => {
      return procVars[vn];
    }));
    if (isRunResult) {
      return result;
    } else {

    }
  };

  module.exports = EvalPrims = class EvalPrims {
    // (String, Array[Widget], (String) => Any) => EvalConfig
    constructor(code, widgets, readFromString1 = readFromString) {
      this.readFromString = readFromString1;
      this.runCode = function(runString, isRunResult, procVars) {
        return scalaJSEvalCode(code, widgets, runString, isRunResult, procVars);
      };
    }

  };

}).call(this);

},{}],"engine/prim/gamma":[function(require,module,exports){
(function() {
  var StrictMath, calcQ, calcQ0, calcT, calcVars, calcW, gdsFromAcceptanceRejection, gdsFromDoubleExponential;

  StrictMath = require('shim/strictmath');

  calcQ = function(t, s, ss, q0) {
    var a1, a2, a3, a4, a5, a6, a7, a8, a9, v;
    a1 = 0.333333333;
    a2 = -0.249999949;
    a3 = 0.199999867;
    a4 = -0.166677482;
    a5 = 0.142873973;
    a6 = -0.124385581;
    a7 = 0.110368310;
    a8 = -0.112750886;
    a9 = 0.104089866;
    v = t / (s + s);
    if (StrictMath.abs(v) > 0.25) {
      return q0 - s * t + 0.25 * t * t + (ss + ss) * StrictMath.log(1 + v);
    } else {
      return q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;
    }
  };

  calcQ0 = function(alpha) {
    var q1, q2, q3, q4, q5, q6, q7, q8, q9, r;
    q1 = 0.0416666664;
    q2 = 0.0208333723;
    q3 = 0.0079849875;
    q4 = 0.0015746717;
    q5 = -0.0003349403;
    q6 = 0.0003340332;
    q7 = 0.0006053049;
    q8 = -0.0004701849;
    q9 = 0.0001710320;
    r = 1 / alpha;
    return ((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;
  };

  calcT = function(randomGenerator) {
    var generateVs, v1, v12;
    generateVs = function() {
      var v1, v12, v2;
      v1 = 2 * randomGenerator.nextDouble() - 1;
      v2 = 2 * randomGenerator.nextDouble() - 1;
      v12 = v1 * v1 + v2 * v2;
      if (v12 <= 1) {
        return [v1, v12];
      } else {
        return generateVs();
      }
    };
    [v1, v12] = generateVs();
    return v1 * StrictMath.sqrt(-2 * StrictMath.log(v12) / v12);
  };

  calcVars = function(b, si, randomGenerator) {
    var e, signU, t, u, uTemp;
    e = -StrictMath.log(randomGenerator.nextDouble());
    uTemp = randomGenerator.nextDouble();
    u = uTemp + uTemp - 1;
    signU = u > 0 ? 1 : -1;
    t = b + (e * si) * signU;
    if (t > -0.71874483771719) {
      return [e, signU, u, t];
    } else {
      return calcVars(b, si, randomGenerator);
    }
  };

  calcW = function(q) {
    var e1, e2, e3, e4, e5, e6, e7;
    e1 = 1.000000000;
    e2 = 0.499999994;
    e3 = 0.166666848;
    e4 = 0.041664508;
    e5 = 0.008345522;
    e6 = 0.001353826;
    e7 = 0.000247453;
    if (q > 0.5) {
      return StrictMath.exp(q) - 1.0;
    } else {
      return ((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;
    }
  };

  gdsFromAcceptanceRejection = function(alpha, randomGenerator) {
    var b, generateNumbersUntilHappy;
    b = 1 + 0.36788794412 * alpha;
    generateNumbersUntilHappy = function() {
      var gdsHighP, gdsLowP, logRand, p;
      p = b * randomGenerator.nextDouble();
      logRand = StrictMath.log(randomGenerator.nextDouble());
      gdsLowP = StrictMath.exp(StrictMath.log(p) / alpha);
      gdsHighP = -StrictMath.log((b - p) / alpha);
      if (p <= 1 && logRand <= -gdsLowP) {
        return gdsLowP;
      } else if (p > 1 && logRand <= ((alpha - 1) * StrictMath.log(gdsHighP))) {
        return gdsHighP;
      } else {
        return generateNumbersUntilHappy();
      }
    };
    return generateNumbersUntilHappy();
  };

  gdsFromDoubleExponential = function(b, si, c, s, ss, q0, randomGenerator) {
    var tryAgain;
    tryAgain = function() {
      var e, q, signU, t, u, x;
      [e, signU, u, t] = calcVars(b, si, randomGenerator);
      // Step 12. Hat acceptance
      q = calcQ(t, s, ss, q0);
      if ((q > 0) && (c * u * signU <= calcW(q) * StrictMath.exp(e - 0.5 * t * t))) {
        x = s + 0.5 * t;
        return x * x;
      } else {
        return tryAgain();
      }
    };
    return tryAgain();
  };

  /*

  Gamma Distribution - Acceptance Rejection combined with Acceptance Complement

  See: J.H. Ahrens, U. Dieter (1974): Computer methods for sampling from gamma, beta, Poisson and binomial distributions, Computing 12, 223-246.
  See: J.H. Ahrens, U. Dieter (1982): Generating gamma variates by a modified rejection technique, Communications of the ACM 25, 47-54.

  */
  module.exports = function(randomGenerator, alpha, lambda) {
    var b, c, d, gds, q0, s, si, ss, t, u, x;
    
    // Set-up for hat case
    gds = alpha < 1 ? gdsFromAcceptanceRejection(alpha, randomGenerator) : (ss = alpha - 0.5, s = StrictMath.sqrt(ss), d = 5.656854249 - 12 * s, t = calcT(randomGenerator), x = s + 0.5 * t, t >= 0 ? x * x : (u = randomGenerator.nextDouble(), d * u <= t * t * t ? x * x : (q0 = calcQ0(alpha), (x > 0) && (StrictMath.log(1 - u) <= calcQ(t, s, ss, q0)) ? x * x : ([b, si, c] = alpha > 13.022 ? [1.77, 0.75, 0.1515 / s] : alpha > 3.686 ? [1.654 + 0.0076 * ss, 1.68 / s + 0.275, 0.062 / s + 0.024] : [0.463 + s - 0.178 * ss, 1.235, 0.195 / s - 0.079 + 0.016 * s], gdsFromDoubleExponential(b, si, c, s, ss, q0, randomGenerator))))); // CASE A: Acceptance rejection algorithm gs // CASE B: Acceptance complement algorithm gd (gaussian distribution, box muller transformation) // Squeeze acceptance // Step 7. Quotient acceptance // Step 8. Double exponential deviate t
    return gds / lambda;
  };

}).call(this);

},{"shim/strictmath":"shim/strictmath"}],"engine/prim/importexportprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ImportExportConfig, ImportExportPrims;

  module.exports.Config = ImportExportConfig = class ImportExportConfig {
    constructor(exportFile = (function() {
        return function() {}; // (String) => (String) => Unit
      }), exportBlob = (function() {
        return function() {}; // (Blob) => (String) => Unit
      }), getNlogo = (function() {
        return ""; // () => String
      }), getOutput = (function() {
        return ""; // () => String
      }), getViewBase64 = (function() {
        return "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD/AD/6KKKAP//Z"; // () => String
      }), getViewBlob = (function() {}), importFile1 = (function() { // ((Blob) => Unit) => Unit
        return function() {}; // (String) => ((String) => Unit) => Unit
      })) {
      this.exportFile = exportFile;
      this.exportBlob = exportBlob;
      this.getNlogo = getNlogo;
      this.getOutput = getOutput;
      this.getViewBase64 = getViewBase64;
      this.getViewBlob = getViewBlob;
      this.importFile = importFile1;
    }

  };

  module.exports.Prims = ImportExportPrims = class ImportExportPrims {
    // (ImportExportConfig, () => String, () => String, (String) => String, (String) => Unit, (Boolean) => (String) => Unit, (String) => Unit) => ImportExportPrims
    constructor({
        exportFile: exportFile,
        exportBlob: exportBlob,
        getNlogo: exportNlogoRaw,
        getOutput: exportOutputRaw,
        getViewBase64: exportViewRaw,
        getViewBlob: exportViewBlob,
        importFile
      }, exportWorldRaw, exportAllPlotsRaw, exportPlotRaw, exportPlotNoHeadersRaw, importDrawingRaw, importPColorsRaw, importWorldRaw) {
      this.exportFile = exportFile;
      this.exportBlob = exportBlob;
      this.exportNlogoRaw = exportNlogoRaw;
      this.exportOutputRaw = exportOutputRaw;
      this.exportViewRaw = exportViewRaw;
      this.exportViewBlob = exportViewBlob;
      this.exportWorldRaw = exportWorldRaw;
      this.exportAllPlotsRaw = exportAllPlotsRaw;
      this.exportPlotRaw = exportPlotRaw;
      this.exportPlotNoHeadersRaw = exportPlotNoHeadersRaw;
      this.importDrawingRaw = importDrawingRaw;
      this.importPColorsRaw = importPColorsRaw;
      this.importWorldRaw = importWorldRaw;
      this.exportAllPlots = (filename) => {
        return this.exportFile(this.exportAllPlotsRaw())(filename);
      };
      this.exportOutput = (filename) => {
        return this.exportFile(this.exportOutputRaw())(filename);
      };
      this.exportPlot = (plot, filename) => {
        return this.exportFile(this.exportPlotRaw(plot))(filename);
      };
      this.exportView = (filename) => {
        return this.exportViewBlob((blob) => {
          return this.exportBlob(blob)(filename);
        });
      };
      this.exportWorld = (filename) => {
        return this.exportFile(this.exportWorldRaw())(filename);
      };
      this.importDrawing = (filename) => {
        return importFile(filename)(this.importDrawingRaw);
      };
      this.importPColors = (filename) => {
        return importFile(filename)(this.importPColorsRaw(true));
      };
      this.importPColorsRGB = (filename) => {
        return importFile(filename)(this.importPColorsRaw(false));
      };
      this.importWorld = (filename) => {
        return importFile(filename)(this.importWorldRaw);
      };
    }

  };

}).call(this);

},{}],"engine/prim/importpcolors":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, NLMath, StrictMath, genCoords, genPColorUpdates, id, lookupNLColor, map, pipeline, tee, toObject;

  ColorModel = require('../core/colormodel');

  NLMath = require('util/nlmath');

  StrictMath = require('shim/strictmath');

  ({map, toObject} = require('brazier/array'));

  ({id, pipeline, tee} = require('brazier/function'));

  // type RGBA = (Number, Number, Number, Number)
  lookupNLColor = (function() {
    var cache;
    cache = {};
    return function(rgb) {
      var nlc, value;
      value = cache[rgb];
      if (value != null) {
        return value;
      } else {
        nlc = ColorModel.nearestColorNumberOfRGB(...rgb);
        cache[rgb] = nlc;
        return nlc;
      }
    };
  })();

  // (Number, Number, Number, Number) => (Number, Number, Object[Number, Number])
  genCoords = function(patchSize, ratio, worldDim, imageDim) {
    var dimRatio, endPatch, patchNumToPixel, patchOffset, scaledImageDim, startPatch, startPixels, worldPixelDim;
    worldPixelDim = patchSize * worldDim;
    scaledImageDim = imageDim * ratio;
    patchOffset = (worldPixelDim - scaledImageDim) / patchSize / 2;
    startPatch = StrictMath.floor(patchOffset);
    endPatch = worldDim - StrictMath.ceil(patchOffset);
    dimRatio = imageDim / (endPatch - startPatch);
    patchNumToPixel = function(patchNum) {
      return StrictMath.floor((patchNum - startPatch) * dimRatio);
    };
    startPixels = pipeline(map(tee(id)(patchNumToPixel)), toObject)((function() {
      var results = [];
      for (var j = startPatch; startPatch <= endPatch ? j < endPatch : j > endPatch; startPatch <= endPatch ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this));
    return [startPatch, endPatch, startPixels];
  };

  // (Topology, Number, Array[RGBA], Number, Number) => Array[{ x, y, color }]
  genPColorUpdates = function({
      height: worldHeight,
      minPxcor,
      minPycor,
      width: worldWidth
    }, patchSize, rgbs, imageWidth, imageHeight) {
    var maxX, maxY, minX, minY, pixel, ratio, updates, x, xEnd, xStart, xStarts, xcor, y, yEnd, yStart, yStarts, ycor;
    ratio = NLMath.min(patchSize * worldWidth / imageWidth, patchSize * worldHeight / imageHeight);
    [xStart, xEnd, xStarts] = genCoords(patchSize, ratio, worldWidth, imageWidth);
    [yStart, yEnd, yStarts] = genCoords(patchSize, ratio, worldHeight, imageHeight);
    updates = (function() {
      var j, ref, ref1, results;
      results = [];
      for (xcor = j = ref = xStart, ref1 = xEnd; (ref <= ref1 ? j < ref1 : j > ref1); xcor = ref <= ref1 ? ++j : --j) {
        results.push((function() {
          var k, ref2, ref3, ref4, ref5, results1;
          results1 = [];
          for (ycor = k = ref2 = yStart, ref3 = yEnd; (ref2 <= ref3 ? k < ref3 : k > ref3); ycor = ref2 <= ref3 ? ++k : --k) {
            minX = xStarts[xcor];
            minY = yStarts[ycor];
            maxX = NLMath.max(minX + 1, (ref4 = xStarts[xcor + 1]) != null ? ref4 : imageWidth);
            maxY = NLMath.max(minY + 1, (ref5 = yStarts[ycor + 1]) != null ? ref5 : imageHeight);
            // I just use the color of the center pixel of the bitmap section.
            // I originally tried averaging the pixels in the bitmap section.  That is
            // also not what desktop does.  Desktop does this by scaling down and then
            // scaling back up, using a Java library.  How that library decides which
            // pixel to keep when shrinking a section, I do not know.  It's not
            // something simple like averaging or choosing the center pixel.  But I
            // don't really care to find out what it is.  Averaging would give grays
            // too often, so I went with center pixel. --JAB (11/19/18)
            x = StrictMath.floor((minX + maxX) / 2);
            y = StrictMath.floor((minY + maxY) / 2);
            pixel = rgbs[x + (y * imageWidth)];
            results1.push({
              x: minPxcor + xcor,
              y: minPycor + ((worldHeight - 1) - ycor),
              color: pixel
            });
          }
          return results1;
        })());
      }
      return results;
    })();
    return [].concat(...updates).filter(function({
        color: [r, g, b, a]
      }) {
      return a !== 0;
    });
  };

  // (() => Topology, () => Number, (Number, Number) => Agent, (String) => ImageData) => (Boolean) => (String) => Unit
  module.exports = function(getTopology, getPatchSize, getPatchAt, base64ToImageData) {
    return function(isNetLogoColorspace) {
      return function(base64) {
        var colorGetter, data, height, ref, rgbas, toArray, updates, width;
        ({data, height, width} = base64ToImageData(base64));
        toArray = Array.from != null ? (function(xs) {
          return Array.from(xs);
        }) : (function(xs) {
          return Array.prototype.slice.call(xs);
        });
        rgbas = (function() {
          var results = [];
          for (var j = 0, ref = data.length / 4; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this).map(function(i) {
          return toArray(data.slice(i * 4, (i * 4) + 4));
        });
        updates = genPColorUpdates(getTopology(), getPatchSize(), rgbas, width, height);
        colorGetter = isNetLogoColorspace ? function(x) {
          return lookupNLColor(x);
        } : function(x) {
          return ColorModel.rgbList(x);
        };
        updates.forEach(function({x, y, color}) {
          return getPatchAt(x, y).setVariable('pcolor', colorGetter(color));
        });
      };
    };
  };

}).call(this);

},{"../core/colormodel":"engine/core/colormodel","brazier/array":"brazier/array","brazier/function":"brazier/function","shim/strictmath":"shim/strictmath","util/nlmath":"util/nlmath"}],"engine/prim/inspectionprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var InspectionConfig, InspectionPrims;

  module.exports.Config = InspectionConfig = class InspectionConfig {
    // ((Agent) => Unit, (Agent) => Unit, () => Unit) => InspectionConfig
    constructor(inspect1 = (function() {}), stopInspecting = (function() {}), clearDead = (function() {})) {
      this.inspect = inspect1;
      this.stopInspecting = stopInspecting;
      this.clearDead = clearDead;
    }

  };

  module.exports.Prims = InspectionPrims = class InspectionPrims {
    // (InspectionConfig) => InspectionPrims
    constructor({inspect, stopInspecting, clearDead}) {
      this.stopInspecting = stopInspecting;
      this.clearDead = clearDead;
      this.inspect = function(agent) {
        if (!agent.isDead()) {
          return inspect(agent);
        } else {
          throw new Error(`That ${agent.getBreedNameSingular()} is dead.`);
        }
      };
    }

  };

}).call(this);

},{}],"engine/prim/layoutmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LayoutManager, NLMath, TreeNode, checks, contains, filter, flatMap, fold, foldl, forEach, id, map, maxBy, pipeline, rangeUntil, unique, values, zip;

  NLMath = require('util/nlmath');

  ({checks} = require('../core/typechecker'));

  ({contains, filter, flatMap, foldl, forEach, map, maxBy, unique, zip} = require('brazierjs/array'));

  ({id, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  ({rangeUntil} = require('brazierjs/number'));

  ({values} = require('brazierjs/object'));

  TreeNode = (function() {
    class TreeNode {
      
      // Turtle -> Number -> TreeNode
      constructor(_turtle, _depth) {
        this._turtle = _turtle;
        this._depth = _depth;
        this._angle = 0.0;
        this._children = [];
      }

      // Turtle -> Unit
      addChild(child) {
        this._children.push(child);
      }

      // Unit -> Number
      getAngle() {
        return this._angle;
      }

      // Unit -> Number
      getDepth() {
        return this._depth;
      }

      // Unit -> Turtle
      getTurtle() {
        return this._turtle;
      }

      getWeight() {
        var maxChildWeight;
        maxChildWeight = pipeline(map(function(c) {
          return c.getWeight();
        }), maxBy(id), fold(function() {
          return 0;
        })(id))(this._children);
        return NLMath.max(maxChildWeight * 0.8, this._children.length + 1);
      }

      layoutRadial(arcStart, arcEnd) {
        var f, weightSum;
        this._angle = (arcStart + arcEnd) / 2;
        weightSum = foldl(function(acc, x) {
          return acc + x.getWeight();
        })(0)(this._children);
        f = function(childStart, child) {
          var childEnd;
          childEnd = childStart + (arcEnd - arcStart) * child.getWeight() / weightSum;
          child.layoutRadial(childStart, childEnd);
          return childEnd;
        };
        return foldl(f)(arcStart)(this._children);
      }

    };

    TreeNode.prototype._angle = void 0; // Number

    TreeNode.prototype._children = void 0; // Array[Turtle]

    TreeNode.prototype._depth = void 0; // Number

    TreeNode.prototype._val = void 0; // Turtle

    return TreeNode;

  }).call(this);

  module.exports = LayoutManager = class LayoutManager {
    // (World, () => Number) => LayoutManager
    constructor(_world, _nextDouble) {
      this._world = _world;
      this._nextDouble = _nextDouble;
    }

    // (TurtleSet, Number) => Unit
    layoutCircle(agentsOrList, radius) {
      var midx, midy, n, turtles;
      turtles = checks.isList(agentsOrList) ? agentsOrList : agentsOrList.shufflerator().toArray();
      n = turtles.length;
      midx = this._world.topology.minPxcor + NLMath.floor(this._world.topology.width / 2);
      midy = this._world.topology.minPycor + NLMath.floor(this._world.topology.height / 2);
      return rangeUntil(0)(n).forEach(function(i) {
        var heading, turtle;
        heading = (i * 360) / n;
        turtle = turtles[i];
        turtle.patchAtHeadingAndDistance(heading, radius);
        turtle.setXY(midx, midy);
        turtle.setVariable("heading", heading);
        return turtle.jumpIfAble(radius);
      });
    }

    // (TurtleSet, LinkSet, Number, Number, Number) => Unit
    layoutSpring(nodeSet, linkSet, spr, len, rep) {
      var agt, ax, ay, degCounts, nodeCount, tMap;
      if (!nodeSet.isEmpty()) {
        [ax, ay, tMap, agt] = this._initialize(nodeSet);
        nodeCount = nodeSet.size();
        degCounts = this._calcDegreeCounts(linkSet, tMap, nodeCount);
        this._updateXYArraysForNeighbors(ax, ay, linkSet, tMap, degCounts, spr, len);
        this._updateXYArraysForAll(ax, ay, agt, degCounts, nodeCount, rep);
        this._moveTurtles(ax, ay, agt, nodeCount);
      }
    }

    // (TurtleSet, LinkSet, Number) => Unit
    layoutTutte(nodeSet, linkSet, radius) {
      var anchors, turtleXYTriplets;
      anchors = pipeline(flatMap(function({end1, end2}) {
        return [end1, end2];
      }), unique, filter(function(t) {
        return !nodeSet.contains(t);
      }))(linkSet.toArray());
      this.layoutCircle(anchors, radius);
      turtleXYTriplets = nodeSet.shuffled().toArray().map((turtle) => {
        var allOfMyLinks, compute, computeCor, degree, neighbors, relevantLinks, x, y;
        computeCor = function(turtle, neighbors, degree) {
          return function(getCor, max, min) {
            var adjustedValue, limit, limitedValue, readjustedValue, value;
            value = pipeline(map(getCor), foldl(function(a, b) {
              return a + b;
            })(0))(neighbors);
            adjustedValue = (value / degree) - getCor(turtle);
            limit = 100; // This voodoo magic makes absolutely no sense to me --JAB (11/7/16)
            limitedValue = adjustedValue > limit ? limit : adjustedValue < -limit ? -limit : adjustedValue;
            readjustedValue = limitedValue + getCor(turtle);
            if (readjustedValue > max) {
              return max;
            } else if (readjustedValue < min) {
              return min;
            } else {
              return readjustedValue;
            }
          };
        };
        allOfMyLinks = turtle.linkManager.myLinks("LINKS").toArray();
        relevantLinks = pipeline(unique, filter(function(link) {
          return linkSet.contains(link);
        }))(allOfMyLinks);
        neighbors = relevantLinks.map(function({end1, end2}) {
          if (end1 === turtle) {
            return end2;
          } else {
            return end1;
          }
        });
        degree = relevantLinks.length;
        compute = computeCor(turtle, neighbors, degree);
        x = compute((function(t) {
          return t.xcor;
        }), this._world.topology.maxPxcor, this._world.topology.minPxcor);
        y = compute((function(t) {
          return t.ycor;
        }), this._world.topology.maxPycor, this._world.topology.minPycor);
        return [turtle, x, y];
      });
      turtleXYTriplets.forEach(function([turtle, x, y]) {
        return turtle.setXY(x, y);
      });
    }

    // (TurtleSet, LinkSet, RootAgent) => Unit
    layoutRadial(nodeSet, linkSet, root) {
      var adjustPosition, allowedTurtleIDs, lastNode, layerGap, maxDepth, maxPxcor, maxPycor, minPxcor, minPycor, nodeTable, queue, rootNode, rootX, rootY, turtleIsAllowed, visitNeighbors, xDistToEdge, yDistToEdge;
      ({maxPxcor, maxPycor, minPxcor, minPycor} = this._world.topology);
      rootX = (maxPxcor + minPxcor) / 2;
      rootY = (maxPycor + minPycor) / 2;
      rootNode = new TreeNode(root, 0);
      queue = [rootNode];
      nodeTable = {};
      nodeTable[rootNode.getTurtle().id] = rootNode;
      turtleIsAllowed = linkSet.getSpecialName() == null ? (allowedTurtleIDs = pipeline(flatMap(function({end1, end2}) {
        return [end1, end2];
      }), foldl(function(acc, {id}) {
        acc[id] = true;
        return acc;
      })({}))(linkSet.toArray()), function({id}) {
        return allowedTurtleIDs[id] === true;
      }) : function() {
        return true;
      };
      visitNeighbors = function(queue, last) {
        var node;
        if (queue.length === 0) {
          return last;
        } else {
          node = queue.shift();
          node.getTurtle().linkManager.neighborsIn(linkSet).forEach(function(t) {
            var child;
            if (nodeSet.contains(t) && (nodeTable[t.id] == null) && turtleIsAllowed(t)) {
              child = new TreeNode(t, node.getDepth() + 1);
              node.addChild(child);
              nodeTable[t.id] = child;
              queue.push(child);
            }
          });
          return visitNeighbors(queue, node);
        }
      };
      lastNode = visitNeighbors(queue, rootNode);
      rootNode.layoutRadial(0, 360);
      maxDepth = NLMath.max(1, lastNode.getDepth() + .2);
      xDistToEdge = NLMath.min(maxPxcor - rootX, rootX - minPxcor);
      yDistToEdge = NLMath.min(maxPycor - rootY, rootY - minPycor);
      layerGap = NLMath.min(xDistToEdge, yDistToEdge) / maxDepth;
      adjustPosition = function(node) {
        var turtle;
        turtle = node.getTurtle();
        turtle.setXY(rootX, rootY);
        turtle.setVariable("heading", node.getAngle());
        turtle.jumpIfAble(node.getDepth() * layerGap);
      };
      pipeline(values, forEach(adjustPosition))(nodeTable);
    }

    // (TurtleSet) => (Array[Number], Array[Number], Object[Number, Number], Array[Turtle])
    _initialize(nodeSet) {
      var agt, ax, ay, tMap, turtles;
      ax = [];
      ay = [];
      tMap = [];
      agt = [];
      turtles = nodeSet.shuffled().toArray();
      forEach(function(i) {
        var turtle;
        turtle = turtles[i];
        agt[i] = turtle;
        tMap[turtle.id] = i;
        ax[i] = 0.0;
        ay[i] = 0.0;
      })(rangeUntil(0)(turtles.length));
      return [ax, ay, tMap, agt];
    }

    // (LinkSet, Object[Number, Number], Number) => Array[Number]
    _calcDegreeCounts(links, idToIndexMap, nodeCount) {
      var baseCounts;
      baseCounts = map(function() {
        return 0;
      })(rangeUntil(0)(nodeCount));
      links.forEach(function({
          end1: t1,
          end2: t2
        }) {
        var f;
        f = function(turtle) {
          var index;
          index = idToIndexMap[turtle.id];
          if (index != null) {
            return baseCounts[index]++;
          }
        };
        f(t1);
        f(t2);
      });
      return baseCounts;
    }

    // WARNING: Mutates `ax` and `ay` --JAB (7/28/14)
    // (Array[Number], Array[Number], LinkSet, Object[Number, Number], Array[Number], Number, Number) => Unit
    _updateXYArraysForNeighbors(ax, ay, links, idToIndexMap, degCounts, spr, len) {
      var indexAndCountOf;
      indexAndCountOf = function(turtle) {
        var index;
        index = idToIndexMap[turtle.id];
        if (index != null) {
          return [index, degCounts[index]];
        } else {
          return [-1, 0];
        }
      };
      links.forEach(function({
          end1: t1,
          end2: t2
        }) {
        var degCount1, degCount2, dist, div, dx, dy, f, newDX, newDY, t1Index, t2Index;
        [t1Index, degCount1] = indexAndCountOf(t1);
        [t2Index, degCount2] = indexAndCountOf(t2);
        dist = t1.distanceNotWrapped(t2);
        // links that are connecting high degree nodes should not
        // be as springy, to help prevent "jittering" behavior -FD
        div = NLMath.max((degCount1 + degCount2) / 2.0, 1.0);
        [dx, dy] = dist === 0 ? [
          (spr * len) / div,
          0 // arbitrary x-dir push-off --FD
        ] : (f = spr * (dist - len) / div, newDX = f * (t2.xcor - t1.xcor) / dist, newDY = f * (t2.ycor - t1.ycor) / dist, [newDX, newDY]);
        if (t1Index !== -1) {
          ax[t1Index] += dx;
          ay[t1Index] += dy;
        }
        if (t2Index !== -1) {
          ax[t2Index] -= dx;
          ay[t2Index] -= dy;
        }
      });
    }

    // WARNING: Mutates `ax` and `ay` --JAB (7/28/14)
    // (Array[Number], Array[Number], Array[Turtle], Array[Number], Number, Number) => Unit
    _updateXYArraysForAll(ax, ay, agents, degCounts, nodeCount, rep) {
      var ang, dist, div, dx, dy, f, i, j, k, l, newDX, newDY, ref, ref1, ref2, t1, t2;
      for (i = k = 0, ref = nodeCount; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        t1 = agents[i];
        for (j = l = ref1 = i + 1, ref2 = nodeCount; (ref1 <= ref2 ? l < ref2 : l > ref2); j = ref1 <= ref2 ? ++l : --l) {
          t2 = agents[j];
          div = NLMath.max((degCounts[i] + degCounts[j]) / 2.0, 1.0);
          [dx, dy] = t2.xcor === t1.xcor && t2.ycor === t1.ycor ? (ang = 360 * this._nextDouble(), newDX = -(rep / div * NLMath.squash(NLMath.sin(ang))), newDY = -(rep / div * NLMath.squash(NLMath.cos(ang))), [newDX, newDY]) : (dist = t1.distanceNotWrapped(t2), f = rep / (dist * dist) / div, newDX = -(f * (t2.xcor - t1.xcor) / dist), newDY = -(f * (t2.ycor - t1.ycor) / dist), [newDX, newDY]);
          ax[i] += dx;
          ay[i] += dy;
          ax[j] -= dx;
          ay[j] -= dy;
        }
      }
    }

    // WARNING: Mutates `ax` and `ay` --JAB (7/28/14)
    // (Array[Number], Array[Number], Array[Turtle], Number) => Unit
    _moveTurtles(ax, ay, agt, nodeCount) {
      var bounded, calculateLimit, calculateXCor, calculateYCor, height, limit, maxX, maxY, minX, minY, perturbment, width;
      maxX = this._world.topology.maxPxcor;
      minX = this._world.topology.minPxcor;
      maxY = this._world.topology.maxPycor;
      minY = this._world.topology.minPycor;
      height = this._world.topology.height;
      width = this._world.topology.width;
      // we need to bump some node a small amount, in case all nodes
      // are stuck on a single line --FD
      if (nodeCount > 1) {
        perturbment = (width + height) / 1.0e10;
        ax[0] += this._nextDouble() * perturbment - perturbment / 2.0;
        ay[0] += this._nextDouble() * perturbment - perturbment / 2.0;
      }
      // try to choose something that's reasonable perceptually --
      // for temporal aliasing, don't want to jump too far on any given timestep. --FD
      limit = (width + height) / 50.0;
      bounded = function(min, max) {
        return function(x) {
          if (x < min) {
            return min;
          } else if (x > max) {
            return max;
          } else {
            return x;
          }
        };
      };
      calculateLimit = bounded(-limit, limit);
      calculateXCor = bounded(minX, maxX);
      calculateYCor = bounded(minY, maxY);
      forEach(function(i) {
        var newX, newY, turtle;
        turtle = agt[i];
        newX = calculateXCor(turtle.xcor + calculateLimit(ax[i]));
        newY = calculateYCor(turtle.ycor + calculateLimit(ay[i]));
        turtle.setXY(newX, newY);
      })(rangeUntil(0)(nodeCount));
    }

  };

}).call(this);

},{"../core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/number":"brazier/number","brazierjs/object":"brazier/object","util/nlmath":"util/nlmath"}],"engine/prim/linkprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LinkPrims;

  module.exports = LinkPrims = (function() {
    class LinkPrims {
      
      // (World) => LinkPrims
      constructor({linkManager, selfManager}) {
        this._linkManager = linkManager;
        this._self = selfManager.self;
      }

      // (Turtle, String) => Link
      createLinkFrom(otherTurtle, breedName) {
        return this._linkManager.createDirectedLink(otherTurtle, this._self(), breedName);
      }

      // (TurtleSet, String) => LinkSet
      createLinksFrom(otherTurtles, breedName) {
        return this._linkManager.createReverseDirectedLinks(this._self(), otherTurtles.shuffled(), breedName);
      }

      // (Turtle, String) => Link
      createLinkTo(otherTurtle, breedName) {
        return this._linkManager.createDirectedLink(this._self(), otherTurtle, breedName);
      }

      // (TurtleSet, String) => LinkSet
      createLinksTo(otherTurtles, breedName) {
        return this._linkManager.createDirectedLinks(this._self(), otherTurtles.shuffled(), breedName);
      }

      // (Turtle, String) => Link
      createLinkWith(otherTurtle, breedName) {
        return this._linkManager.createUndirectedLink(this._self(), otherTurtle, breedName);
      }

      // (TurtleSet, String) => LinkSet
      createLinksWith(otherTurtles, breedName) {
        return this._linkManager.createUndirectedLinks(this._self(), otherTurtles.shuffled(), breedName);
      }

      // (String, Turtle) => Boolean
      isInLinkNeighbor(breedName, otherTurtle) {
        return this._self().linkManager.isInLinkNeighbor(breedName, otherTurtle);
      }

      // (String, Turtle) => Boolean
      isLinkNeighbor(breedName, otherTurtle) {
        return this._self().linkManager.isLinkNeighbor(breedName, otherTurtle);
      }

      // (String, Turtle) => Boolean
      isOutLinkNeighbor(breedName, otherTurtle) {
        return this._self().linkManager.isOutLinkNeighbor(breedName, otherTurtle);
      }

      // (String, Turtle) => Link
      inLinkFrom(breedName, otherTurtle) {
        return this._self().linkManager.inLinkFrom(breedName, otherTurtle);
      }

      // (String, Turtle) => Link
      linkWith(breedName, otherTurtle) {
        return this._self().linkManager.linkWith(breedName, otherTurtle);
      }

      // (String, Turtle) => Link
      outLinkTo(breedName, otherTurtle) {
        return this._self().linkManager.outLinkTo(breedName, otherTurtle);
      }

      // (String) => TurtleSet
      inLinkNeighbors(breedName) {
        return this._self().linkManager.inLinkNeighbors(breedName);
      }

      // (String) => TurtleSet
      linkNeighbors(breedName) {
        return this._self().linkManager.linkNeighbors(breedName);
      }

      // (String) => TurtleSet
      outLinkNeighbors(breedName) {
        return this._self().linkManager.outLinkNeighbors(breedName);
      }

      // (String) => LinkSet
      myInLinks(breedName) {
        return this._self().linkManager.myInLinks(breedName);
      }

      // (String) => LinkSet
      myLinks(breedName) {
        return this._self().linkManager.myLinks(breedName);
      }

      // (String) => LinkSet
      myOutLinks(breedName) {
        return this._self().linkManager.myOutLinks(breedName);
      }

    };

    LinkPrims._linkManager = void 0; // LinkManager

    LinkPrims._self = void 0; // () => Turtle

    return LinkPrims;

  }).call(this);

}).call(this);

},{}],"engine/prim/listprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Comparator, Exception, Link, ListPrims, NLMath, Patch, StrictMath, Turtle, all, arrayLength, checks, exists, filter, find, findIndex, fold, foldl, id, isEmpty, last, pipeline, sortBy, stableSort, tail;

  AbstractAgentSet = require('../core/abstractagentset');

  Link = require('../core/link');

  Patch = require('../core/patch');

  Turtle = require('../core/turtle');

  ({checks} = require('../core/typechecker'));

  StrictMath = require('shim/strictmath');

  Comparator = require('util/comparator');

  Exception = require('util/exception');

  NLMath = require('util/nlmath');

  stableSort = require('util/stablesort');

  ({
    all,
    exists,
    filter,
    find,
    findIndex,
    foldl,
    isEmpty,
    length: arrayLength,
    last,
    sortBy,
    tail
  } = require('brazierjs/array'));

  ({id, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  module.exports = ListPrims = class ListPrims {
    // type ListOrSet[T] = AbstractAgentSet|Array[T]

    // (() => String, Hasher, (Any, Any) => Boolean, (Number) => Number) => ListPrims
    constructor(_dump, _hasher, _equality, _nextInt) {
      this._dump = _dump;
      this._hasher = _hasher;
      this._equality = _equality;
      this._nextInt = _nextInt;
    }

    // [T] @ (Array[T]|String) => Array[T]|String
    butFirst(xs) {
      return tail(xs);
    }

    // [T] @ (Array[T]|String) => Array[T]|String
    butLast(xs) {
      return xs.slice(0, xs.length - 1);
    }

    // [T] @ (String|Array[T]) => Boolean
    empty(xs) {
      return isEmpty(xs);
    }

    filter(f, xs) {
      return xs.filter(f);
    }

    // [Item] @ (Array[Item]) => Item
    first(xs) {
      return xs[0];
    }

    // [Item] @ (Item, Array[Item]) => Array[Item]
    fput(x, xs) {
      return [x].concat(xs);
    }

    // [Item] @ (Number, Array[Item], Item) => Array[Item]
    insertItem(n, xs, x) {
      var clone;
      clone = xs.slice(0);
      clone.splice(n, 0, x);
      return clone;
    }

    // [Item] @ (Number, Array[Item]) => Item
    item(n, xs) {
      return xs[NLMath.floor(n)];
    }

    // [Item] @ (Array[Item]) => Item
    last(xs) {
      return last(xs);
    }

    // [T] @ (Array[T]) => Number
    length(xs) {
      return arrayLength(xs);
    }

    // [T] @ (T*) => Array[T]
    list(...xs) {
      return xs;
    }

    // [Item] @ (Item, Array[Item]) => Array[Item]
    lput(x, xs) {
      var result;
      result = xs.slice(0);
      result.push(x);
      return result;
    }

    // (Array[Any]) => Number
    max(xs) {
      return Math.max(...xs);
    }

    // (Array[Any]) => Number
    mean(xs) {
      var sum;
      sum = xs.reduce((function(a, b) {
        return a + b;
      }), 0);
      return sum / xs.length;
    }

    // (Array[Any]) => Number
    median(xs) {
      var length, middleIndex, middleNum, nums, subMiddleNum;
      nums = sortBy(id)(xs);
      length = nums.length;
      middleIndex = StrictMath.floor(length / 2);
      middleNum = nums[middleIndex];
      if (length % 2 === 1) {
        return middleNum;
      } else {
        subMiddleNum = nums[middleIndex - 1];
        return (middleNum + subMiddleNum) / 2;
      }
    }

    // (Array[Item], Item) => Boolean
    member(x, xs) {
      return exists((y) => {
        return this._equality(x, y);
      })(xs);
    }

    // (Array[Any]) => Number
    min(xs) {
      return Math.min(...xs);
    }

    // [T] @ (Array[T]) => Array[T]
    modes(items) {
      var calculateModes, genItemCountPairs, ref, result;
      genItemCountPairs = (xs) => {
        var incrementCount, k, len, pairMaybe, pairs, pushNewPair, x;
        pairs = [];
        for (k = 0, len = xs.length; k < len; k++) {
          x = xs[k];
          pushNewPair = function() {
            return pairs.push([x, 1]);
          };
          incrementCount = function(pair) {
            return pair[1] += 1;
          };
          pairMaybe = find(([item, c]) => {
            return this._equality(item, x);
          })(pairs);
          fold(pushNewPair)(incrementCount)(pairMaybe);
        }
        return pairs;
      };
      calculateModes = function(xsToCounts) {
        var f;
        f = function([bests, bestCount], [item, count]) {
          if (count > bestCount) {
            return [[item], count];
          } else if (count < bestCount) {
            return [bests, bestCount];
          } else {
            return [bests.concat([item]), bestCount];
          }
        };
        return foldl(f)([[], 0])(xsToCounts);
      };
      ref = calculateModes(genItemCountPairs(items)), result = ref[0], ref[1];
      return result;
    }

    // (Number, AbstractAgentSet) => AbstractAgentSet
    nOfAgentSet(n, agentSet) {
      var items, newItems;
      items = agentSet.iterator().toArray();
      newItems = this._nOfArray(n, items);
      return agentSet.copyWithNewAgents(newItems);
    }

    // (Number, Array[Any]) => Array[Any]
    nOfList(n, list) {
      if (n === list.length) {
        return list;
      } else {
        return this._nOfArray(n, list);
      }
    }

    // (Number, AbstractAgentSet) => AbstractAgentSet
    upToNOfAgentSet(n, agentSet) {
      var items, newItems;
      if (n >= agentSet.size()) {
        return agentSet;
      } else {
        items = agentSet.iterator().toArray();
        newItems = this._nOfArray(n, items);
        return agentSet.copyWithNewAgents(newItems);
      }
    }

    // (Number, Array[Any]) => Array[Any]
    upToNOfList(n, list) {
      if (n >= list.length) {
        return list;
      } else {
        return this._nOfArray(n, list);
      }
    }

    // [Item] @ (ListOrSet[Item]) => Item
    oneOf(list) {
      return list[this._nextInt(list.length)];
    }

    // (Any, Array[Any]) => Number | Boolean
    position(x, xs) {
      var index;
      index = pipeline(findIndex((y) => {
        return this._equality(x, y);
      }), fold(function() {
        return -1;
      })(id))(xs);
      if (index !== -1) {
        return index;
      } else {
        return false;
      }
    }

    reduce(f, xs) {
      return xs.reduce(f);
    }

    // (Any, Array[Any]) => Array[Any]
    remove(x, xs) {
      return filter((y) => {
        return !this._equality(x, y);
      })(xs);
    }

    // [T] @ (Array[T]) => Array[T]
    removeDuplicates(xs) {
      var f, out, ref;
      if (xs.length < 2) {
        return xs;
      } else {
        f = ([accArr, accSet], x) => {
          var hash, values;
          hash = this._hasher(x);
          values = accSet[hash];
          if (values != null) {
            if (!exists((y) => {
              return this._equality(x, y);
            })(values)) {
              accArr.push(x);
              values.push(x);
            }
          } else {
            accArr.push(x);
            accSet[hash] = [x];
          }
          return [accArr, accSet];
        };
        ref = xs.reduce(f, [[], {}]), out = ref[0], ref[1];
        return out;
      }
    }

    // (Number, Array[Any]) => Array[Any]
    removeItem(n, xs) {
      var temp;
      temp = xs.slice(0);
      temp.splice(n, 1); // Cryptic, but effective --JAB (5/26/14)
      return temp;
    }

    // (Number, Array[Any], Any) => Array[Any]
    replaceItem(n, xs, x) {
      var temp;
      temp = xs.slice(0);
      temp.splice(n, 1, x);
      return temp;
    }

    // (Array[Any]) => Array[Any]
    reverse(xs) {
      return xs.slice(0).reverse();
    }

    // [T] @ (Array[Array[T]|T]) => Array[T]
    sentence(...xs) {
      var f;
      f = function(acc, x) {
        if (checks.isList(x)) {
          return acc.concat(x);
        } else {
          acc.push(x);
          return acc;
        }
      };
      return foldl(f)([])(xs);
    }

    // [T] @ (Array[T]) => Array[T]
    shuffle(xs) {
      var i, out, swap;
      swap = function(arr, i, j) {
        var tmp;
        tmp = arr[i];
        arr[i] = arr[j];
        return arr[j] = tmp;
      };
      out = xs.slice(0);
      i = out.length;
      while (i > 1) {
        swap(out, i - 1, this._nextInt(i));
        i--;
      }
      return out;
    }

    // (Array[Any]) => Array[Any]
    sort(xs) {
      var Agent, None, Number, String, f, filteredItems, filteredType;
      // data SortableType =
      Number = {};
      String = {};
      Agent = {};
      None = {};
      f = function(acc, x) {
        var arr, type, xType;
        xType = checks.isNumber(x) ? Number : checks.isString(x) ? String : checks.isAgent(x) && (x.id !== -1) ? Agent : None;
        [type, arr] = acc;
        switch (xType) {
          case Number: // Numbers trump all
            switch (type) {
              case Number:
                return [Number, arr.concat([x])];
              default:
                return [Number, [x]];
            }
            break;
          case String: // Strings trump agents
            switch (type) {
              case String:
                return [String, arr.concat([x])];
              case Agent:
              case None:
                return [String, [x]];
              default:
                return acc;
            }
            break;
          case Agent:
            switch (type) {
              case Agent:
                return [Agent, arr.concat([x])];
              case None:
                return [Agent, [x]];
              default:
                return acc;
            }
            break;
          default:
            return acc;
        }
      };
      [filteredType, filteredItems] = foldl(f)([None, []])(xs);
      switch (filteredType) {
        case None:
          return filteredItems;
        case Number:
          return filteredItems.sort(function(x, y) {
            return Comparator.numericCompare(x, y).toInt;
          });
        case String:
          return filteredItems.sort();
        case Agent:
          return stableSort(filteredItems)(function(x, y) {
            return x.compare(y).toInt;
          });
        default:
          throw new Error("We don't know how to sort your kind here!");
      }
    }

    // ((Agent, Agent) => Boolean, AbstractAgentSet) => Array[Agent]
    sortByAgentSet(task, agentSet) {
      return this.sortByList(task, agentSet.shufflerator().toArray());
    }

    // ((T, T) => Boolean, Array[T]) => Array[T]
    sortByList(task, xs) {
      var f;
      f = function(x, y) {
        var xy, yx;
        xy = task(x, y);
        yx = task(y, x);
        if (xy === yx) {
          return 0;
        } else if (xy) {
          return -1;
        } else {
          return 1;
        }
      };
      return stableSort(xs)(f);
    }

    // (Array[Any]) => Number
    standardDeviation(xs) {
      var mean, squareDiff, stdDev;
      mean = this.sum(xs) / xs.length;
      squareDiff = foldl(function(acc, x) {
        return acc + StrictMath.pow(x - mean, 2);
      })(0)(xs);
      stdDev = StrictMath.sqrt(squareDiff / (xs.length - 1));
      return stdDev;
    }

    // [T] @ (Array[T], Number, Number) => Array[T]
    sublist(xs, n1, n2) {
      return xs.slice(n1, n2);
    }

    // (Array[Any]) => Number
    sum(xs) {
      return xs.reduce((function(a, b) {
        return a + b;
      }), 0);
    }

    // [T] @ (Array[T]) => Number
    variance(xs) {
      var count, mean, squareOfDifference, sum;
      count = xs.length;
      sum = xs.reduce((function(acc, x) {
        return acc + x;
      }), 0);
      mean = sum / count;
      squareOfDifference = xs.reduce((function(acc, x) {
        return acc + StrictMath.pow(x - mean, 2);
      }), 0);
      return squareOfDifference / (count - 1);
    }

    // Prodding at this code is like poking a beehive with a stick... --JAB (7/30/14)
    // [Item] @ (Number, Array[Item]) => Array[Item]
    _nOfArray(n, items) {
      var i, index1, index2, j, newIndex1, newIndex2, result;
      switch (n) {
        case 0:
          return [];
        case 1:
          return [items[this._nextInt(items.length)]];
        case 2:
          index1 = this._nextInt(items.length);
          index2 = this._nextInt(items.length - 1);
          [newIndex1, newIndex2] = index2 >= index1 ? [index1, index2 + 1] : [index2, index1];
          return [items[newIndex1], items[newIndex2]];
        default:
          n = NLMath.floor(n);
          i = 0;
          j = 0;
          result = [];
          while (j < n) {
            if (this._nextInt(items.length - i) < n - j) {
              result.push(items[i]);
              j += 1;
            }
            i += 1;
          }
          return result;
      }
    }

  };

}).call(this);

},{"../core/abstractagentset":"engine/core/abstractagentset","../core/link":"engine/core/link","../core/patch":"engine/core/patch","../core/turtle":"engine/core/turtle","../core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","shim/strictmath":"shim/strictmath","util/comparator":"util/comparator","util/exception":"util/exception","util/nlmath":"util/nlmath","util/stablesort":"util/stablesort"}],"engine/prim/mouseprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MouseConfig, MousePrims;

  module.exports.Config = MouseConfig = class MouseConfig {
    // (() => Boolean, () => Boolean, () => Number, () => Number)
    constructor(peekIsDown = (function() {
        return false;
      }), peekIsInside = (function() {
        return false;
      }), peekX = (function() {
        return 0;
      }), peekY = (function() {
        return 0;
      })) {
      this.peekIsDown = peekIsDown;
      this.peekIsInside = peekIsInside;
      this.peekX = peekX;
      this.peekY = peekY;
    }

  };

  module.exports.Prims = MousePrims = class MousePrims {
    // (MouseConfig) => MousePrims
    constructor({
        peekIsDown: isDown,
        peekIsInside: isInside,
        peekX: getX,
        peekY: getY
      }) {
      this.isDown = isDown;
      this.isInside = isInside;
      this.getX = getX;
      this.getY = getY;
    }

  };

}).call(this);

},{}],"engine/prim/outputprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var OutputConfig, OutputPrims, genPrintBundle;

  genPrintBundle = require('./printbundle');

  // type PrintFunc = (String) => Unit
  module.exports.Config = OutputConfig = class OutputConfig {
    // (() => Unit, PrintFunc) => OutputConfig
    constructor(clear1 = (function() {}), write1 = (function() {})) {
      this.clear = clear1;
      this.write = write1;
    }

  };

  module.exports.Prims = OutputPrims = (function() {
    class OutputPrims {
      
      // (OutputConfig, (String) => Unit, () => Unit, (Any, Boolean) => String) => OutputPrims
      constructor({clear, write}, writeToStore, clearStored, dump) {
        var writePlus;
        this.clear = (function() {
          clearStored();
          return clear();
        });
        writePlus = (function(x) {
          writeToStore(x);
          return write(x);
        });
        ({print: this.print, show: this.show, type: this.type, write: this.write} = genPrintBundle(writePlus, dump));
      }

    };

    OutputPrims.prototype.clear = void 0; // () => Unit

    OutputPrims.prototype.print = void 0; // PrintFunc

    OutputPrims.prototype.show = void 0; // (() => Number|Agent) => PrintFunc

    OutputPrims.prototype.type = void 0; // PrintFunc

    OutputPrims.prototype.write = void 0; // PrintFunc

    return OutputPrims;

  }).call(this);

}).call(this);

},{"./printbundle":"engine/prim/printbundle"}],"engine/prim/prims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, EQ, Exception, GT, LT, Link, LinkSet, MersenneTwisterFast, Patch, PatchSet, Prims, StrictMath, Timer, Turtle, TurtleSet, checks, flatMap, flattenDeep, getNeighbors, getNeighbors4, getTypeOf, greaterThan, isEmpty, lessThan, map, range;

  AbstractAgentSet = require('../core/abstractagentset');

  Link = require('../core/link');

  LinkSet = require('../core/linkset');

  Patch = require('../core/patch');

  PatchSet = require('../core/patchset');

  Turtle = require('../core/turtle');

  TurtleSet = require('../core/turtleset');

  ({checks, getTypeOf} = require('../core/typechecker'));

  StrictMath = require('shim/strictmath');

  Exception = require('util/exception');

  Timer = require('util/timer');

  ({flatMap, flattenDeep, isEmpty, map} = require('brazierjs/array'));

  ({MersenneTwisterFast} = require('shim/engine-scala'));

  ({
    EQUALS: EQ,
    GREATER_THAN: GT,
    LESS_THAN: LT
  } = require('util/comparator'));

  getNeighbors = function(patch) {
    return patch.getNeighbors();
  };

  getNeighbors4 = function(patch) {
    return patch.getNeighbors4();
  };

  lessThan = function(a, b) {
    return a < b;
  };

  greaterThan = function(a, b) {
    return a > b;
  };

  // (Number, Number, Number) => Array[Number]
  range = function(lowerBound, upperBound, stepSize) {
    var j, ref, ref1, ref2, results, x;
    results = [];
    for (x = j = ref = lowerBound, ref1 = upperBound, ref2 = stepSize; ref2 !== 0 && (ref2 > 0 ? j < ref1 : j > ref1); x = j += ref2) {
      results.push(x);
    }
    return results;
  };

  module.exports = Prims = (function() {
    class Prims {
      
      // (Dump, Hasher, RNG, World) => Prims
      constructor(_dumper, _hasher, _rng, _world, _evalPrims) {
        this._dumper = _dumper;
        this._hasher = _hasher;
        this._rng = _rng;
        this._world = _world;
        this._evalPrims = _evalPrims;
        this._everyMap = {};
      }

      // () => Nothing
      boom() {
        throw new Error("boom!");
      }

      // (String, Array[Patch]) -> TurtleSet
      breedOn(breedName, patches) {
        var turtles;
        turtles = flatMap(function(p) {
          return p.breedHereArray(breedName);
        })(patches);
        return new TurtleSet(turtles, this._world);
      }

      // (String, Patch|Turtle|PatchSet|TurtleSet) => TurtleSet
      breedOnPatch(breedName, patch) {
        return this.breedOn(breedName, [patch]);
      }

      breedOnTurtle(breedName, turtle) {
        return this.breedOn(breedName, [turtle.getPatchHere()]);
      }

      breedOnPatchSet(breedName, patchSet) {
        return this.breedOn(breedName, patchSet.toArray());
      }

      breedOnTurtleSet(breedName, turtleSet) {
        return this.breedOn(breedName, map(function(t) {
          return t.getPatchHere();
        })(turtleSet.iterator().toArray()));
      }

      booleanCheck(b, primName) {
        if (checks.isBoolean(b)) {
          return b;
        } else {
          throw new Error(`${primName} expected input to be a TRUE/FALSE but got the ${getTypeOf(b).niceName()} ${this._dumper(b)} instead.`);
        }
      }

      ifElseValueBooleanCheck(b) {
        return this.booleanCheck(b, "IFELSE-VALUE");
      }

      ifElseValueMissingElse() {
        throw new Error("IFELSE-VALUE found no true conditions and no else branch. If you don't wish to error when no conditions are true, add a final else branch.");
      }

      // (Any, Any) => Boolean
      equality(a, b) {
        var subsumes;
        if ((a != null) && (b != null)) {
          return (a === b) || checks.isBreedSet(typeof b.getSpecialName === "function" ? b.getSpecialName() : void 0, a) || checks.isBreedSet(typeof a.getSpecialName === "function" ? a.getSpecialName() : void 0, b) || (checks.isNobody(a) && (typeof b.isDead === "function" ? b.isDead() : void 0)) || (checks.isNobody(b) && (typeof a.isDead === "function" ? a.isDead() : void 0)) || ((checks.isTurtle(a) || (checks.isLink(a) && !checks.isNobody(b))) && a.compare(b) === EQ) || (checks.isList(a) && checks.isList(b) && a.length === b.length && a.every((elem, i) => {
            return this.equality(elem, b[i]);
          })) || (checks.isAgentSet(a) && checks.isAgentSet(b) && a.size() === b.size() && Object.getPrototypeOf(a) === Object.getPrototypeOf(b) && (subsumes = (xs, ys) => {
            var index, j, len, x;
            for (index = j = 0, len = xs.length; j < len; index = ++j) {
              x = xs[index];
              if (!this.equality(ys[index], x)) {
                return false;
              }
            }
            return true;
          }, subsumes(a.sort(), b.sort())));
        } else {
          throw new Error("Checking equality on undefined is an invalid condition");
        }
      }

      // () => String
      dateAndTime() {
        var amOrPM, calendarComponent, clockTime, d, date, hours, hoursNum, millis, minutes, modHours, month, numberToMonth, seconds, withThreeDigits, withTwoDigits, year;
        withTwoDigits = function(x) {
          return (x < 10 ? "0" : "") + x;
        };
        withThreeDigits = function(x) {
          return (x < 10 ? "00" : x < 100 ? "0" : "") + x;
        };
        numberToMonth = {
          1: "Jan",
          2: "Feb",
          3: "Mar",
          4: "Apr",
          5: "May",
          6: "Jun",
          7: "Jul",
          8: "Aug",
          9: "Sep",
          10: "Oct",
          11: "Nov",
          12: "Dec"
        };
        d = new Date;
        hoursNum = d.getHours();
        modHours = hoursNum === 0 || hoursNum === 12 ? 12 : hoursNum % 12;
        hours = withTwoDigits(modHours);
        minutes = withTwoDigits(d.getMinutes());
        seconds = withTwoDigits(d.getSeconds());
        clockTime = `${hours}:${minutes}:${seconds}`;
        millis = withThreeDigits(d.getMilliseconds());
        amOrPM = hoursNum >= 12 ? "PM" : "AM";
        date = withTwoDigits(d.getDate());
        month = numberToMonth[d.getMonth() + 1];
        year = d.getFullYear();
        calendarComponent = `${date}-${month}-${year}`;
        return `${clockTime}.${millis} ${amOrPM} ${calendarComponent}`;
      }

      // (String, Agent|Number, Number) => Boolean
      isThrottleTimeElapsed(commandID, agent, timeLimit) {
        var entry;
        entry = this._everyMap[this._genEveryKey(commandID, agent)];
        return (entry == null) || entry.elapsed() >= timeLimit;
      }

      // (String, Agent|Number) => Unit
      resetThrottleTimerFor(commandID, agent) {
        return this._everyMap[this._genEveryKey(commandID, agent)] = new Timer();
      }

      // (Any, Any) => Boolean
      gt(a, b) {
        if ((checks.isString(a) && checks.isString(b)) || (checks.isNumber(a) && checks.isNumber(b))) {
          return a > b;
        } else if (typeof a === typeof b && (a.compare != null) && (b.compare != null)) {
          return a.compare(b) === GT;
        } else {
          throw new Error("Invalid operands to `gt`");
        }
      }

      // (Any, Any) => Boolean
      gte(a, b) {
        return this.gt(a, b) || this.equality(a, b);
      }

      // [T <: (Array[Link]|Link|AbstractAgentSet[Link])] @ (T*) => LinkSet
      linkSet(inputs) {
        return this._createAgentSet(inputs, Link, LinkSet);
      }

      // (Any, Any) => Boolean
      lt(a, b) {
        if ((checks.isString(a) && checks.isString(b)) || (checks.isNumber(a) && checks.isNumber(b))) {
          return a < b;
        } else if (typeof a === typeof b && (a.compare != null) && (b.compare != null)) {
          return a.compare(b) === LT;
        } else {
          throw new Error("Invalid operands to `lt`");
        }
      }

      // (Any, Any) => Boolean
      lte(a, b) {
        return this.lt(a, b) || this.equality(a, b);
      }

      // Some complications here....

      // First, this will not yield the same results as the equivalent primitive in JVM NetLogo.
      // The Java documentation for `System.nanoTime` explains that its nanotimes are set against an arbitrary origin time
      // that isn't even guaranteed to be consistent across JVM instances.  Naturally, JS engines can't reproduce it,
      // either.

      // Secondly, the resolution here is inconsistent.  In any modern browser, we can use the "High Resolution Time" API
      // but, right now, it's only a "Recommendation" and not a "Standard", so it is actually not implemented yet in
      // Nashorn.  Because of that, we use `performance.now()` if we can, but fall back to `Date.now()` if High Performance
      // Time is not available.

      // Thirdly, though, even when we have `performance.now()`, the time resolution is only guaranteed to be microsecond
      // precision.  When we use `Date.now()`, the time resolution is in milliseconds.  Regardless of the resolution,
      // though, the value is converted to nanoseconds.

      // So, in summary, the resolution of this implementation of `__nano-time` is inconsistent and not actually
      // nanoseconds, and is not consistent with the times provided in JVM NetLogo, but the Java Docs for
      // `System.nanoTime()` state that it is only to be used for measuring elapsed time, and that should still be
      // reasonably possible with the prim behavior supplied here. --JAB (1/11/16)

      // () => Number
      nanoTime() {
        var nanos, ref;
        nanos = ((ref = typeof performance !== "undefined" && performance !== null ? typeof performance.now === "function" ? performance.now() : void 0 : void 0) != null ? ref : Date.now()) * 1e6;
        return StrictMath.floor(nanos);
      }

      // [T <: (Array[Patch]|Patch|AbstractAgentSet[Patch])] @ (T*) => PatchSet
      patchSet(inputs) {
        return this._createAgentSet(inputs, Patch, PatchSet);
      }

      // (Number) => Array[Number]
      rangeUnary(upperBound) {
        return range(0, upperBound, 1);
      }

      // (Number, Number) => Array[Number]
      rangeBinary(lowerBound, upperBound) {
        return range(lowerBound, upperBound, 1);
      }

      // (Number, Number, Number) => Array[Number]
      rangeTernary(lowerBound, upperBound, stepSize) {
        if (stepSize !== 0) {
          return range(lowerBound, upperBound, stepSize);
        } else {
          throw new Error("The step-size for range must be non-zero.");
        }
      }

      // (String) => Any
      readFromString(str) {
        return this._evalPrims.readFromString(str);
      }

      // (Boolean, JsObject, Array[Any]) => Unit|Any
      runCode(isRunResult, procVars, ...args) {
        var f;
        f = args[0];
        if (checks.isString(f)) {
          if (args.length === 1) {
            return this._evalPrims.runCode(f, isRunResult, procVars);
          } else {
            throw new Error(`${(isRunResult ? "runresult" : "run")} doesn't accept further inputs if the first is a string`);
          }
        } else {
          return f(...args.slice(1));
        }
      }

      // (Any) => Unit
      stdout(x) {
        var dumpedX;
        dumpedX = this._dumper(x);
        if (typeof console !== "undefined" && console !== null) {
          console.log(dumpedX);
        } else if (typeof print !== "undefined" && print !== null) {
          print(dumpedX);
        } else {
          throw new Error(`We don't know how to output text on this platform.  But, if it helps you any, here's the thing you wanted to see: ${dumpedX}`);
        }
      }

      // [T <: (Array[Turtle]|Turtle|AbstractAgentSet[Turtle])] @ (T*) => TurtleSet
      turtleSet(inputs) {
        return this._createAgentSet(inputs, Turtle, TurtleSet);
      }

      // (Patch|Turtle) => TurtleSet
      turtlesOnAgent(agent) {
        return agent.turtlesHere();
      }

      // (PatchSet|TurtleSet) => TurtleSet
      turtlesOnAgentSet(agents) {
        var turtles;
        turtles = flatMap(function(agent) {
          return agent.turtlesHere().toArray();
        })(agents.iterator().toArray());
        return new TurtleSet(turtles, this._world);
      }

      // (Number) => Unit
      wait(seconds) {
        var startTime;
        startTime = this.nanoTime();
        while (((this.nanoTime() - startTime) / 1e9) < seconds) {}
      }

      // (String) => Unit
      uphill(varName) {
        this._moveUpOrDownhill(-2e308, greaterThan, getNeighbors, varName);
      }

      // (String) => Unit
      uphill4(varName) {
        this._moveUpOrDownhill(-2e308, greaterThan, getNeighbors4, varName);
      }

      // (String) => Unit
      downhill(varName) {
        this._moveUpOrDownhill(2e308, lessThan, getNeighbors, varName);
      }

      // (String) => Unit
      downhill4(varName) {
        this._moveUpOrDownhill(2e308, lessThan, getNeighbors4, varName);
      }

      // (Number, (Number, Number) => Boolean, (Patch) => PatchSet, String) => Unit
      _moveUpOrDownhill(worstPossible, findIsBetter, getNeighbors, varName) {
        var patch, turtle, winner, winners, winningValue;
        turtle = SelfManager.self();
        patch = turtle.getPatchHere();
        winningValue = worstPossible;
        winners = [];
        getNeighbors(patch).forEach(function(neighbor) {
          var value;
          value = neighbor.getPatchVariable(varName);
          if (checks.isNumber(value)) {
            if (findIsBetter(value, winningValue)) {
              winningValue = value;
              return winners = [neighbor];
            } else if (winningValue === value) {
              return winners.push(neighbor);
            }
          }
        });
        if (winners.length !== 0 && findIsBetter(winningValue, patch.getPatchVariable(varName))) {
          winner = winners[this._rng.nextInt(winners.length)];
          turtle.face(winner);
          turtle.moveTo(winner);
        }
      }

      // (String, Agent|Number) => String
      _genEveryKey(commandID, agent) {
        var agentID;
        agentID = agent === 0 ? "observer" : this._dumper(agent);
        return `${commandID}__${agentID}`;
      }

      // [T <: Agent, U <: AbstractAgentSet[T], V <: (Array[T]|T|AbstractAgentSet[T])] @ (Array[V], T.Class, U.Class) => U
      _createAgentSet(inputs, tClass, outClass) {
        var addT, buildFromAgentSet, buildItems, flattened, hashIt, hashSet, head, makeOutie, result;
        flattened = flattenDeep(inputs);
        makeOutie = (agents) => {
          return new outClass(agents, this._world);
        };
        if (isEmpty(flattened)) {
          return makeOutie([]);
        } else if (flattened.length === 1) {
          head = flattened[0];
          if (head instanceof outClass) {
            return makeOutie(head.toArray());
          } else if (head instanceof tClass) {
            return makeOutie([head]);
          } else {
            return makeOutie([]);
          }
        } else {
          result = [];
          hashSet = {};
          hashIt = this._hasher;
          addT = function(p) {
            var hash;
            hash = hashIt(p);
            if (!hashSet.hasOwnProperty(hash)) {
              result.push(p);
              hashSet[hash] = true;
            }
          };
          buildFromAgentSet = function(agentSet) {
            return agentSet.forEach(addT);
          };
          buildItems = (inputs) => {
            var input, j, len, results;
            results = [];
            for (j = 0, len = inputs.length; j < len; j++) {
              input = inputs[j];
              if (checks.isList(input)) {
                results.push(buildItems(input));
              } else if (input instanceof tClass) {
                results.push(addT(input));
              } else if (input !== Nobody) {
                results.push(buildFromAgentSet(input));
              } else {
                results.push(void 0);
              }
            }
            return results;
          };
          buildItems(flattened);
          return makeOutie(result);
        }
      }

    };

    // type ListOrSet[T] = Array[T]|AbstractAgentSet[T]
    Prims.prototype._everyMap = void 0; // Object[String, Timer]

    // () => Number
    Prims.prototype.generateNewSeed = (function() {
      var helper, lastSeed;
      lastSeed = 0; // Rather than adding a global, scope this permanent state here --JAB (9/25/15)
      helper = function() {
        var seed;
        seed = (new MersenneTwisterFast).nextInt();
        if (seed !== lastSeed) {
          lastSeed = seed;
          return seed;
        } else {
          return helper();
        }
      };
      return helper;
    })();

    return Prims;

  }).call(this);

}).call(this);

},{"../core/abstractagentset":"engine/core/abstractagentset","../core/link":"engine/core/link","../core/linkset":"engine/core/linkset","../core/patch":"engine/core/patch","../core/patchset":"engine/core/patchset","../core/turtle":"engine/core/turtle","../core/turtleset":"engine/core/turtleset","../core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","shim/engine-scala":"shim/engine-scala","shim/strictmath":"shim/strictmath","util/comparator":"util/comparator","util/exception":"util/exception","util/timer":"util/timer"}],"engine/prim/printbundle":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var PrintBundle, pipeline;

  ({pipeline} = require('brazierjs/function'));

  // type PrintFunc = (String) => Unit

  // (PrintFunc, (Any, Boolean) => String) => PrintBundle
  PrintBundle = class PrintBundle {
    // (PrintFunc, PrintFunc, PrintFunc, (() => Number|Agent) => PrintFunc) => PrintBundle
    constructor(print1, type1, write1, show1) {
      this.print = print1;
      this.type = type1;
      this.write = write1;
      this.show = show1;
    }

  };

  module.exports = function(printFunc, dump) {
    var dumpWrapped, newLine, preSpace, prependAgent, print, show, type, write, writeAfter;
    preSpace = function(s) {
      return " " + s;
    };
    newLine = function(s) {
      return s + "\n";
    };
    dumpWrapped = function(s) {
      return dump(s, true);
    };
    prependAgent = function(thunk) {
      return function(s) {
        var agentOrZero, agentStr;
        agentOrZero = thunk();
        agentStr = agentOrZero === 0 ? "observer" : dump(agentOrZero);
        return `${agentStr}: ${s}`;
      };
    };
    writeAfter = function(...fs) {
      return pipeline(...fs, printFunc);
    };
    print = writeAfter(dump, newLine);
    type = writeAfter(dump);
    write = writeAfter(dumpWrapped, preSpace);
    show = function(agentThunk) {
      return writeAfter(dumpWrapped, prependAgent(agentThunk), newLine);
    };
    return new PrintBundle(print, type, write, show);
  };

}).call(this);

},{"brazierjs/function":"brazier/function"}],"engine/prim/printprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var PrintConfig, PrintPrims, genPrintBundle;

  genPrintBundle = require('./printbundle');

  // type PrintFunc = (String) => Unit
  module.exports.Config = PrintConfig = class PrintConfig {
    // (PrintFunc) => PrintConfig
    constructor(write1 = (function() {})) {
      this.write = write1;
    }

  };

  module.exports.Prims = PrintPrims = (function() {
    class PrintPrims {
      
      // (PrintConfig, (Any, Boolean) => String) => PrintPrims
      constructor({write}, dump) {
        ({print: this.print, show: this.show, type: this.type, write: this.write} = genPrintBundle(write, dump));
      }

    };

    PrintPrims.prototype.print = void 0; // PrintFunc

    PrintPrims.prototype.show = void 0; // (() => Number|Agent) => PrintFunc

    PrintPrims.prototype.type = void 0; // PrintFunc

    PrintPrims.prototype.write = void 0; // PrintFunc

    return PrintPrims;

  }).call(this);

}).call(this);

},{"./printbundle":"engine/prim/printbundle"}],"engine/prim/randomprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Gamma, RandomPrims, StrictMath;

  StrictMath = require('shim/strictmath');

  Gamma = require('./gamma');

  RandomPrims = class RandomPrims {
    constructor(_rng) {
      this._rng = _rng;
    }

    // (Number) => Number
    random(n) {
      var truncated;
      truncated = n >= 0 ? StrictMath.ceil(n) : StrictMath.floor(n);
      if (truncated === 0) {
        return 0;
      } else if (truncated > 0) {
        return this._rng.nextLong(truncated);
      } else {
        return -this._rng.nextLong(-truncated);
      }
    }

    // This is for `_randomconst`, `n` must also be >0. -Jeremy B September 2020
    // (Long) => Long
    randomLong(n) {
      return this._rng.nextLong(n);
    }

    // (Number, Number) => Number
    randomInRange(min, max) {
      return min + this._rng.nextInt(max - min + 1);
    }

    // (Number, Number) => Number
    randomFloatInRange(min, max) {
      return min - 0.5 + this._rng.nextDouble() * (max - min + 1);
    }

    // (Number) => Number
    randomExponential(mean) {
      return -mean * StrictMath.log(this._rng.nextDouble());
    }

    // (Number) => Number
    randomFloat(n) {
      return n * this._rng.nextDouble();
    }

    // (Number, Number) => Number
    randomGamma(alpha, lambda) {
      return Gamma(this._rng, alpha, lambda);
    }

    // (Number, Number) => Number
    randomNormal(mean, stdDev) {
      return mean + stdDev * this._rng.nextGaussian();
    }

    // (Number) => Number
    randomPoisson(mean) {
      var q, sum;
      q = 0;
      sum = -StrictMath.log(1 - this._rng.nextDouble());
      while (sum <= mean) {
        q += 1;
        sum -= StrictMath.log(1 - this._rng.nextDouble());
      }
      return q;
    }

    randomSeed(seed) {
      return this._rng.setSeed(seed);
    }

  };

  module.exports = RandomPrims;

}).call(this);

},{"./gamma":"engine/prim/gamma","shim/strictmath":"shim/strictmath"}],"engine/prim/selfprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SelfPrims, TypeSet, checks, getTypeOf, linkType, mempty, observerType, patchType, turtleType;

  ({checks, getTypeOf} = require('../core/typechecker'));

  TypeSet = class TypeSet {
    // (Boolean, Boolean, Boolean, Boolean) => TypeSet
    constructor(link1, observer1, patch1, turtle1) {
      this.link = link1;
      this.observer = observer1;
      this.patch = patch1;
      this.turtle = turtle1;
    }

    // (TypeSet) => TypeSet
    mergeWith({link, observer, patch, turtle}) {
      return new TypeSet(this.link || link, this.observer || observer, this.patch || patch, this.turtle || turtle);
    }

    // (TypeSet) => TypeSet
    mappend(ts) {
      return this.mergeWith(ts);
    }

  };

  mempty = new TypeSet(false, false, false, false);

  linkType = new TypeSet(true, false, false, false);

  observerType = new TypeSet(false, true, false, false);

  patchType = new TypeSet(false, false, true, false);

  turtleType = new TypeSet(false, false, false, true);

  module.exports = SelfPrims = class SelfPrims {
    // (() => Agent) => Prims
    constructor(_getSelf) {
      this._getSelf = _getSelf;
    }

    // [T] @ (AbstractAgentSet[T]) => AbstractAgentSet[T]
    other(agentSet) {
      var self;
      self = this._getSelf();
      return agentSet.filter((agent) => {
        return agent !== self;
      });
    }

    // [T] @ (AbstractAgentSet[T]) => Boolean
    _optimalAnyOther(agentSet) {
      var self;
      self = this._getSelf();
      return agentSet.exists(function(agent) {
        return agent !== self;
      });
    }

    // [T] @ (AbstractAgentSet[T]) => Number
    _optimalCountOther(agentSet) {
      var self;
      self = this._getSelf();
      return (agentSet.filter(function(agent) {
        return agent !== self;
      })).size();
    }

    // () => Number
    linkHeading() {
      return this._getSelfSafe(linkType).getHeading();
    }

    // () => Number
    linkLength() {
      return this._getSelfSafe(linkType).getSize();
    }

    // (TypeSet) => Agent
    _getSelfSafe(typeSet) {
      var agentStr, allowsL, allowsP, allowsT, part1, part2, self;
      ({
        link: allowsL,
        patch: allowsP,
        turtle: allowsT
      } = typeSet);
      self = this._getSelf();
      if ((checks.isTurtle(self) && allowsT) || (checks.isPatch(self) && allowsP) || (checks.isLink(self) && allowsL)) {
        return self;
      } else {
        part1 = `this code can't be run by a ${getTypeOf(self).niceName()}`;
        agentStr = this._typeSetToAgentString(typeSet);
        part2 = agentStr.length !== 0 ? `, only ${agentStr}` : "";
        throw new Error(part1 + part2);
      }
    }

    // (TypeSet) => String
    _typeSetToAgentString(typeSet) {
      if (typeSet.turtle) {
        return "a turtle";
      } else if (typeSet.patch) {
        return "a patch";
      } else if (typeSet.link) {
        return "a link";
      } else {
        return "";
      }
    }

  };

}).call(this);

},{"../core/typechecker":"engine/core/typechecker"}],"engine/prim/stringprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var StringPrims;

  StringPrims = class StringPrims {
    // (Number, String, String) => String
    insertItem(n, xs, x) {
      var chars;
      chars = xs.split('');
      chars.splice(n, 0, x);
      return chars.join('');
    }

    // (String, String) => Boolean
    member(chunk, text) {
      return text.indexOf(chunk) !== -1;
    }

    // (String, String) => Number | Boolean
    position(chunk, text) {
      var index;
      index = text.indexOf(chunk);
      if (index !== -1) {
        return index;
      } else {
        return false;
      }
    }

    // (String, String) => String
    remove(chunk, text) {
      return text.replace(new RegExp(chunk, "g"), "");
    }

    // (Number, String) => String
    removeItem(n, text) {
      var post, pre;
      pre = text.slice(0, n);
      post = text.slice(n + 1);
      return pre + post;
    }

    // (Number, String, String) => String
    replaceItem(n, text, chunk) {
      var post, pre;
      pre = text.slice(0, n);
      post = text.slice(n + 1);
      return pre + chunk + post;
    }

    // (String) => String
    reverse(text) {
      return text.split("").reverse().join("");
    }

    // (String, Number, Number) => String
    substring(text, n1, n2) {
      return text.substr(n1, n2 - n1);
    }

  };

  module.exports = StringPrims;

}).call(this);

},{}],"engine/prim/tasks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Exception, all, length, map, pipeline, rangeUntil;

  ({all, length, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({rangeUntil} = require('brazierjs/number'));

  Exception = require('util/exception');

  module.exports = {
    // (Function, String) => Function
    commandTask: function(fn, body) {
      fn.isReporter = false;
      fn.nlogoBody = body;
      return fn;
    },
    // (Function, String) => Function
    reporterTask: function(fn, body) {
      fn.isReporter = true;
      fn.nlogoBody = body;
      return fn;
    },
    // [Result] @ (Product => Result, Array[Any]) => Result
    apply: function(fn, args) {
      var pluralStr;
      if (args.length >= fn.length) {
        return fn.apply(fn, args);
      } else {
        pluralStr = fn.length === 1 ? "" : "s";
        throw new Error(`anonymous procedure expected ${fn.length} input${pluralStr}, but only got ${args.length}`);
      }
    },
    // [Result] @ (Product => Result, Array[Any]*) => Array[Result]
    map: function(fn, ...lists) {
      return this._processLists(fn, lists, "map");
    },
    // [Result] @ (Number, (Number) => Result) => Array[Result]
    nValues: function(n, fn) {
      return map(fn)(rangeUntil(0)(n));
    },
    // [Result] @ (Product => Result, Array[Any]*) => Any
    forEach: function(fn, ...lists) {
      return this._processLists(fn, lists, "foreach");
    },
    // [Result] @ (Product => Result, Array[Array[Any]], String) => Array[Result]
    _processLists: function(fn, lists, primName) {
      var head, i, j, k, len, m, numLists, ref, ref1, res, results, x;
      numLists = lists.length;
      head = lists[0];
      if (numLists === 1) {
        if (fn.isReporter) {
          return map(fn)(head);
        } else {
          for (j = 0, len = head.length; j < len; j++) {
            x = head[j];
            res = fn(x);
            if (res != null) {
              return res;
            }
          }
        }
      } else if (all(function(l) {
        return l.length === head.length;
      })(lists)) {
        if (fn.isReporter) {
          results = [];
          for (i = k = 0, ref = head.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
            results.push(fn(...map(function(list) {
              return list[i];
            })(lists)));
          }
          return results;
        } else {
          for (i = m = 0, ref1 = head.length; (0 <= ref1 ? m < ref1 : m > ref1); i = 0 <= ref1 ? ++m : --m) {
            res = fn(...map(function(list) {
              return list[i];
            })(lists));
            if (res != null) {
              return res;
            }
          }
        }
      } else {
        throw new Error(`All the list arguments to ${primName.toUpperCase()} must be the same length.`);
      }
    }
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/number":"brazier/number","util/exception":"util/exception"}],"engine/prim/userdialogprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var HaltInterrupt, UserDialogConfig, UserDialogPrims;

  ({HaltInterrupt} = require('util/exception'));

  module.exports.Config = UserDialogConfig = class UserDialogConfig {
    // ((String) => Unit, (String) => Boolean, (String) => Boolean, (String) => String) => UserDialogConfig
    constructor(notify = (function() {}), confirm = (function() {
        return true;
      }), yesOrNo = (function() {
        return true;
      }), input = (function() {
        return "dummy implementation";
      })) {
      this.notify = notify;
      this.confirm = confirm;
      this.yesOrNo = yesOrNo;
      this.input = input;
    }

  };

  module.exports.Prims = UserDialogPrims = class UserDialogPrims {
    // (UserDialogConfig) => UserDialogPrims
    constructor({
        confirm: _confirm,
        input: _input,
        yesOrNo: _yesOrNo
      }) {
      this._confirm = _confirm;
      this._input = _input;
      this._yesOrNo = _yesOrNo;
    }

    // (String) => Unit
    confirm(msg) {
      if (!this._confirm(msg)) {
        throw new HaltInterrupt;
      }
    }

    // (String) => String
    input(msg) {
      var ref;
      return (function() {
        if ((ref = this._input(msg)) != null) {
          return ref;
        } else {
          throw new HaltInterrupt;
        }
      }).call(this);
    }

    // (String) => Boolean
    yesOrNo(msg) {
      var ref;
      return (function() {
        if ((ref = this._yesOrNo(msg)) != null) {
          return ref;
        } else {
          throw new HaltInterrupt;
        }
      }).call(this);
    }

  };

}).call(this);

},{"util/exception":"util/exception"}],"engine/updater":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Link, Observer, Patch, Turtle, Update, Updater, World, ignored, perspectiveToNum;

  Link = require('./core/link');

  Patch = require('./core/patch');

  Turtle = require('./core/turtle');

  World = require('./core/world');

  ({
    Perspective: {perspectiveToNum},
    Observer
  } = require('./core/observer'));

  ignored = [
    "",
    function() {
      return "";
    }
  ];

  // type ID           = String
  // type Key          = String
  // type Getter       = (Any) -> Any
  // type UpdateEntry  = Object[Key, Getter]
  // type UpdateSet    = Object[ID, UpdateEntry]
  // type _US          = UpdateSet
  // type DrawingEvent = Object[String, Any]

  // (_US, _US, _US, _US, _US, Array[DrawingEvent]) => Update
  Update = class Update {
    constructor(turtles = {}, patches = {}, links = {}, observer1 = {}, world1 = {}, drawingEvents = []) {
      this.turtles = turtles;
      this.patches = patches;
      this.links = links;
      this.observer = observer1;
      this.world = world1;
      this.drawingEvents = drawingEvents;
    }

  };

  module.exports = Updater = (function() {
    class Updater {
      
      // ((Any) => String) => Updater
      constructor(_dump) {
        // (Number) => Unit
        this.registerDeadLink = this.registerDeadLink.bind(this);
        // (Number) => Unit
        this.registerDeadTurtle = this.registerDeadTurtle.bind(this);
        // (Number, Number, Number, Number, RGB, Number, String) => Unit
        this.registerPenTrail = this.registerPenTrail.bind(this);
        // (Number, Number, Number, Number, RGB, String, String) => Unit
        this.registerTurtleStamp = this.registerTurtleStamp.bind(this);
        // (Number, Number, Number, Number, Number, Number, Number, RGB, String, Number, Boolean, Number, Boolean, String) => Unit
        this.registerLinkStamp = this.registerLinkStamp.bind(this);
        // (Updatable) => (EngineKey*) => Unit
        this.updated = this.updated.bind(this);
        this._dump = _dump;
        this._flushUpdates();
      }

      // () => Unit
      clearDrawing() {
        this._reportDrawingEvent({
          type: "clear-drawing"
        });
      }

      // (String) => Unit
      importDrawing(imageBase64) {
        this._reportDrawingEvent({
          type: "import-drawing",
          imageBase64
        });
      }

      // () => Array[Update]
      collectUpdates() {
        var temp;
        temp = this._updates;
        this._flushUpdates();
        return temp;
      }

      // () => Boolean
      drawingWasJustCleared() {
        return this._drawingWasJustCleared;
      }

      // () => Boolean
      hasUpdates() {
        return this._hasUpdates;
      }

      registerDeadLink(id) {
        this._update("links", id, {
          WHO: -1
        });
      }

      registerDeadTurtle(id) {
        this._update("turtles", id, {
          WHO: -1
        });
      }

      registerPenTrail(fromX, fromY, toX, toY, rgb, size, penMode) {
        this._reportDrawingEvent({
          type: "line",
          fromX,
          fromY,
          toX,
          toY,
          rgb,
          size,
          penMode
        });
      }

      registerTurtleStamp(x, y, size, heading, color, shapeName, stampMode) {
        this._reportDrawingEvent({
          type: "stamp-image",
          agentType: "turtle",
          stamp: {x, y, size, heading, color, shapeName, stampMode}
        });
      }

      registerLinkStamp(x1, y1, x2, y2, midpointX, midpointY, heading, color, shapeName, thickness, isDirected, size, isHidden, stampMode) {
        this._reportDrawingEvent({
          type: "stamp-image",
          agentType: "link",
          stamp: {
            x1,
            y1,
            x2,
            y2,
            midpointX,
            midpointY,
            heading,
            color,
            shapeName,
            thickness,
            'directed?': isDirected,
            size,
            'hidden?': isHidden,
            stampMode
          }
        });
      }

      // (UpdateEntry, Number) => Unit
      registerWorldState(state, id = 0) {
        this._update("world", id, state);
      }

      // () => Unit
      rescaleDrawing() {
        this._reportDrawingEvent({
          type: "rescale-drawing"
        });
      }

      updated(obj) {
        return (...vars) => {
          var entry, entryUpdate, getter, i, len, mapping, objMap, ref, update, v, varName;
          this._hasUpdates = true;
          update = this._updates[0];
          [entry, objMap] = (function() {
            if (obj instanceof Turtle) {
              return [update.turtles, this._turtleMap()];
            } else if (obj instanceof Patch) {
              return [update.patches, this._patchMap()];
            } else if (obj instanceof Link) {
              return [update.links, this._linkMap()];
            } else if (obj instanceof World) {
              return [update.world, this._worldMap()];
            } else if (obj instanceof Observer) {
              return [update.observer, this._observerMap()];
            } else {
              throw new Error("Unrecognized update type");
            }
          }).call(this);
          entryUpdate = (ref = entry[obj.id]) != null ? ref : {};
          // Receiving updates for a turtle that's about to die means the turtle was
          // reborn, so we revive it in the update - BH 1/13/2014
          if (entryUpdate['WHO'] < 0) {
            delete entryUpdate['WHO'];
          }
          for (i = 0, len = vars.length; i < len; i++) {
            v = vars[i];
            mapping = objMap[v];
            if (mapping != null) {
              if (mapping !== ignored) {
                [varName, getter] = mapping;
                entryUpdate[varName] = getter(obj);
                entry[obj.id] = entryUpdate;
              }
            } else {
              throw new Error(`Unknown ${obj.constructor.name} variable for update: ${v}`);
            }
          }
        };
      }

      // (Turtle) => Object[EngineKey, (Key, Getter)]
      _turtleMap() {
        return {
          breed: [
            "BREED",
            function(turtle) {
              return turtle.getBreedName();
            }
          ],
          color: [
            "COLOR",
            function(turtle) {
              return turtle._color;
            }
          ],
          heading: [
            "HEADING",
            function(turtle) {
              return turtle._heading;
            }
          ],
          who: [
            "WHO",
            function(turtle) {
              return turtle.id;
            }
          ],
          'label-color': [
            "LABEL-COLOR",
            function(turtle) {
              return turtle._labelcolor;
            }
          ],
          'hidden?': [
            "HIDDEN?",
            function(turtle) {
              return turtle._hidden;
            }
          ],
          label: [
            "LABEL",
            (turtle) => {
              return this._dump(turtle._label);
            }
          ],
          'pen-size': [
            "PEN-SIZE",
            function(turtle) {
              return turtle.penManager.getSize();
            }
          ],
          'pen-mode': [
            "PEN-MODE",
            function(turtle) {
              return turtle.penManager.getMode().toString();
            }
          ],
          shape: [
            "SHAPE",
            function(turtle) {
              return turtle._getShape();
            }
          ],
          size: [
            "SIZE",
            function(turtle) {
              return turtle._size;
            }
          ],
          xcor: [
            "XCOR",
            function(turtle) {
              return turtle.xcor;
            }
          ],
          ycor: [
            "YCOR",
            function(turtle) {
              return turtle.ycor;
            }
          ]
        };
      }

      // (Patch) => Object[EngineKey, (Key, Getter)]
      _patchMap() {
        return {
          id: [
            "WHO",
            function(patch) {
              return patch.id;
            }
          ],
          pcolor: [
            "PCOLOR",
            function(patch) {
              return patch._pcolor;
            }
          ],
          plabel: [
            "PLABEL",
            (patch) => {
              return this._dump(patch._plabel);
            }
          ],
          'plabel-color': [
            "PLABEL-COLOR",
            function(patch) {
              return patch._plabelcolor;
            }
          ],
          pxcor: [
            "PXCOR",
            function(patch) {
              return patch.pxcor;
            }
          ],
          pycor: [
            "PYCOR",
            function(patch) {
              return patch.pycor;
            }
          ]
        };
      }

      // (Link) => Object[EngineKey, (Key, Getter)]
      _linkMap() {
        return {
          breed: [
            "BREED",
            function(link) {
              return link.getBreedName();
            }
          ],
          color: [
            "COLOR",
            function(link) {
              return link._color;
            }
          ],
          end1: [
            "END1",
            function(link) {
              return link.end1.id;
            }
          ],
          end2: [
            "END2",
            function(link) {
              return link.end2.id;
            }
          ],
          heading: [
            "HEADING",
            function(link) {
              var _;
              try {
                return link.getHeading();
              } catch (error) {
                _ = error;
                return 0;
              }
            }
          ],
          'hidden?': [
            "HIDDEN?",
            function(link) {
              return link._isHidden;
            }
          ],
          id: [
            "ID",
            function(link) {
              return link.id;
            }
          ],
          'directed?': [
            "DIRECTED?",
            function(link) {
              return link.isDirected;
            }
          ],
          label: [
            "LABEL",
            (link) => {
              return this._dump(link._label);
            }
          ],
          'label-color': [
            "LABEL-COLOR",
            function(link) {
              return link._labelcolor;
            }
          ],
          midpointx: [
            "MIDPOINTX",
            function(link) {
              return link.getMidpointX();
            }
          ],
          midpointy: [
            "MIDPOINTY",
            function(link) {
              return link.getMidpointY();
            }
          ],
          shape: [
            "SHAPE",
            function(link) {
              return link._shape;
            }
          ],
          size: [
            "SIZE",
            function(link) {
              return link.getSize();
            }
          ],
          thickness: [
            "THICKNESS",
            function(link) {
              return link._thickness;
            }
          ],
          'tie-mode': [
            "TIE-MODE",
            function(link) {
              return link.tiemode;
            }
          ],
          lcolor: ignored,
          llabel: ignored,
          llabelcolor: ignored,
          lhidden: ignored,
          lbreed: ignored,
          lshape: ignored
        };
      }

      // (World) => Object[EngineKey, (Key, Getter)]
      _worldMap() {
        return {
          height: [
            "worldHeight",
            function(world) {
              return world.topology.height;
            }
          ],
          id: [
            "WHO",
            function(world) {
              return world.id;
            }
          ],
          patchesAllBlack: [
            "patchesAllBlack",
            function(world) {
              return world._patchesAllBlack;
            }
          ],
          patchesWithLabels: [
            "patchesWithLabels",
            function(world) {
              return world._patchesWithLabels;
            }
          ],
          maxPxcor: [
            "MAXPXCOR",
            function(world) {
              return world.topology.maxPxcor;
            }
          ],
          maxPycor: [
            "MAXPYCOR",
            function(world) {
              return world.topology.maxPycor;
            }
          ],
          minPxcor: [
            "MINPXCOR",
            function(world) {
              return world.topology.minPxcor;
            }
          ],
          minPycor: [
            "MINPYCOR",
            function(world) {
              return world.topology.minPycor;
            }
          ],
          patchSize: [
            "patchSize",
            function(world) {
              return world.patchSize;
            }
          ],
          ticks: [
            "ticks",
            function(world) {
              return world.ticker._count;
            }
          ],
          unbreededLinksAreDirected: [
            "unbreededLinksAreDirected",
            function(world) {
              return world.breedManager.links().isDirected();
            }
          ],
          width: [
            "worldWidth",
            function(world) {
              return world.topology.width;
            }
          ],
          wrappingAllowedInX: [
            "wrappingAllowedInX",
            function(world) {
              return world.topology._wrapInX;
            }
          ],
          wrappingAllowedInY: [
            "wrappingAllowedInY",
            function(world) {
              return world.topology._wrapInY;
            }
          ]
        };
      }

      // (Observer) => Object[EngineKey, (Key, Getter)]
      _observerMap() {
        return {
          id: [
            "WHO",
            function(observer) {
              return observer.id;
            }
          ],
          perspective: [
            "perspective",
            function(observer) {
              return perspectiveToNum(observer.getPerspective());
            }
          ],
          targetAgent: [
            "targetAgent",
            function(observer) {
              return observer._getTargetAgentUpdate();
            }
          ]
        };
      }

      // (String, Number, UpdateEntry) => Unit
      _update(agentType, id, newAgent) {
        this._hasUpdates = true;
        this._updates[0][agentType][id] = newAgent;
      }

      // (Object[String, Any]) => Unit
      _reportDrawingEvent(event) {
        this._hasUpdates = true;
        this._drawingWasJustCleared = event.type === "clear-drawing";
        this._updates[0].drawingEvents.push(event);
      }

      // () => Unit
      _flushUpdates() {
        this._hasUpdates = false;
        this._updates = [new Update()];
      }

    };

    // type Updatable   = Turtle|Patch|Link|World|Observer
    // type EngineKey   = String
    Updater.prototype._drawingWasJustCleared = true; // Boolean

    Updater.prototype._hasUpdates = void 0; // Boolean

    Updater.prototype._updates = void 0; // Array[Update]

    return Updater;

  }).call(this);

}).call(this);

},{"./core/link":"engine/core/link","./core/observer":"engine/core/observer","./core/patch":"engine/core/patch","./core/turtle":"engine/core/turtle","./core/world":"engine/core/world"}],"engine/workspace":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedManager, Dump, EvalPrims, Hasher, I18nBundle, ImportExportConfig, ImportExportPrims, InspectionConfig, InspectionPrims, LayoutManager, LinkPrims, ListPrims, Meta, MiniWorkspace, MouseConfig, MousePrims, None, OutputConfig, OutputPrims, PlotManager, PrimChecks, Prims, PrintConfig, PrintPrims, RNG, RandomPrims, SelfManager, SelfPrims, StringPrims, Timer, Updater, UserDialogConfig, UserDialogPrims, World, WorldConfig, csvToWorldState, fold, id, importPColors, lookup, toObject, values;

  WorldConfig = class WorldConfig {
    // (() => Unit) => WorldConfig
    constructor(resizeWorld = (function() {})) {
      this.resizeWorld = resizeWorld;
    }

  };

  BreedManager = require('./core/breedmanager');

  Dump = require('./dump');

  EvalPrims = require('./prim/evalprims');

  Hasher = require('./hasher');

  I18nBundle = require('i18n/i18n-bundle');

  importPColors = require('./prim/importpcolors');

  LayoutManager = require('./prim/layoutmanager');

  LinkPrims = require('./prim/linkprims');

  ListPrims = require('./prim/listprims');

  PlotManager = require('./plot/plotmanager');

  Prims = require('./prim/prims');

  RandomPrims = require('./prim/randomprims');

  PrimChecks = require('./prim-checks/checker');

  RNG = require('util/rng');

  SelfManager = require('./core/structure/selfmanager');

  SelfPrims = require('./prim/selfprims');

  StringPrims = require('./prim/stringprims');

  Timer = require('util/timer');

  Updater = require('./updater');

  World = require('./core/world');

  csvToWorldState = require('serialize/importcsv');

  ({toObject} = require('brazier/array'));

  ({fold, None} = require('brazier/maybe'));

  ({id} = require('brazier/function'));

  ({lookup, values} = require('brazier/object'));

  ({
    Config: InspectionConfig,
    Prims: InspectionPrims
  } = require('./prim/inspectionprims'));

  ({
    Config: ImportExportConfig,
    Prims: ImportExportPrims
  } = require('./prim/importexportprims'));

  ({
    Config: MouseConfig,
    Prims: MousePrims
  } = require('./prim/mouseprims'));

  ({
    Config: OutputConfig,
    Prims: OutputPrims
  } = require('./prim/outputprims'));

  ({
    Config: PrintConfig,
    Prims: PrintPrims
  } = require('./prim/printprims'));

  ({
    Config: UserDialogConfig,
    Prims: UserDialogPrims
  } = require('./prim/userdialogprims'));

  Meta = require('meta');

  MiniWorkspace = class MiniWorkspace {
    // (SelfManager, Updater, BreedManager, RNG, PlotManager) => MiniWorkspace
    constructor(selfManager1, updater1, breedManager1, rng1, plotManager1) {
      this.selfManager = selfManager1;
      this.updater = updater1;
      this.breedManager = breedManager1;
      this.rng = rng1;
      this.plotManager = plotManager1;
    }

  };

  module.exports = function(modelConfig) {
    return function(breedObjs) {
      return function(turtlesOwns, linksOwns) {
        return function(code) {
          return function(widgets) {
            return function(extensionPorters) {
              return function() { // World args; see constructor for `World` --JAB (4/17/14)
                var asyncDialogConfig, base64ToImageData, breedManager, dialogConfig, dump, evalPrims, i18nBundle, importExportConfig, importExportPrims, importPatchColors, importWorldFromCSV, inspectionConfig, inspectionPrims, ioConfig, layoutManager, linkPrims, listPrims, mouseConfig, mousePrims, outputConfig, outputPrims, outputStore, plotManager, plots, primChecks, prims, printConfig, printPrims, randomPrims, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, reportErrors, rng, selfManager, selfPrims, stringPrims, timer, updater, userDialogPrims, workspace, world, worldArgs, worldConfig;
                worldArgs = arguments; // If you want `Workspace` to take more parameters--parameters not related to `World`--just keep returning new functions
                asyncDialogConfig = (ref = modelConfig != null ? modelConfig.asyncDialog : void 0) != null ? ref : {
                  getChoice: (function() {
                    return function() {
                      return None;
                    };
                  }),
                  getText: (function() {
                    return function() {
                      return None;
                    };
                  }),
                  getYesOrNo: (function() {
                    return function() {
                      return None;
                    };
                  }),
                  showMessage: (function() {
                    return function() {
                      return None;
                    };
                  })
                };
                base64ToImageData = (ref1 = modelConfig != null ? modelConfig.base64ToImageData : void 0) != null ? ref1 : (function() {
                  throw new Error("Sorry, no image data converter was provided.");
                });
                dialogConfig = (ref2 = modelConfig != null ? modelConfig.dialog : void 0) != null ? ref2 : new UserDialogConfig;
                importExportConfig = (ref3 = modelConfig != null ? modelConfig.importExport : void 0) != null ? ref3 : new ImportExportConfig;
                inspectionConfig = (ref4 = modelConfig != null ? modelConfig.inspection : void 0) != null ? ref4 : new InspectionConfig;
                ioConfig = (ref5 = modelConfig != null ? modelConfig.io : void 0) != null ? ref5 : {
                  importFile: (function() {
                    return function() {};
                  }),
                  slurpFileDialogAsync: (function() {}),
                  slurpURL: (function() {}),
                  slurpURLAsync: (function() {
                    return function() {};
                  })
                };
                mouseConfig = (ref6 = modelConfig != null ? modelConfig.mouse : void 0) != null ? ref6 : new MouseConfig;
                outputConfig = (ref7 = modelConfig != null ? modelConfig.output : void 0) != null ? ref7 : new OutputConfig;
                plots = (ref8 = modelConfig != null ? modelConfig.plots : void 0) != null ? ref8 : [];
                printConfig = (ref9 = modelConfig != null ? modelConfig.print : void 0) != null ? ref9 : new PrintConfig;
                worldConfig = (ref10 = modelConfig != null ? modelConfig.world : void 0) != null ? ref10 : new WorldConfig;
                reportErrors = (ref11 = modelConfig != null ? modelConfig.reportErrors : void 0) != null ? ref11 : function(messages) {
                  return console.log(messages);
                };
                Meta.version = (ref12 = modelConfig != null ? modelConfig.version : void 0) != null ? ref12 : Meta.version;
                dump = Dump(extensionPorters);
                rng = new RNG;
                outputStore = "";
                selfManager = new SelfManager;
                breedManager = new BreedManager(breedObjs, turtlesOwns, linksOwns);
                plotManager = new PlotManager(plots);
                timer = new Timer;
                updater = new Updater(dump);
                workspace = new MiniWorkspace(selfManager, updater, breedManager, rng, plotManager);
                world = new World(workspace, worldConfig, (function() {
                  return importExportConfig.getViewBase64();
                }), (function() {
                  outputConfig.clear();
                  return outputStore = "";
                }), (function() {
                  return outputStore;
                }), (function(text) {
                  return outputStore = text;
                }), extensionPorters, ...worldArgs);
                layoutManager = new LayoutManager(world, rng.nextDouble);
                evalPrims = new EvalPrims(code, widgets);
                prims = new Prims(dump, Hasher, rng, world, evalPrims);
                randomPrims = new RandomPrims(rng);
                selfPrims = new SelfPrims(selfManager.self);
                linkPrims = new LinkPrims(world);
                listPrims = new ListPrims(dump, Hasher, prims.equality.bind(prims), rng.nextInt);
                stringPrims = new StringPrims();
                inspectionPrims = new InspectionPrims(inspectionConfig);
                mousePrims = new MousePrims(mouseConfig);
                outputPrims = new OutputPrims(outputConfig, (function(x) {
                  return outputStore += x;
                }), (function() {
                  return outputStore = "";
                }), dump);
                printPrims = new PrintPrims(printConfig, dump);
                userDialogPrims = new UserDialogPrims(dialogConfig);
                i18nBundle = new I18nBundle();
                primChecks = new PrimChecks(i18nBundle, dump, prims, listPrims, randomPrims, stringPrims, selfManager.self);
                importWorldFromCSV = function(csvText) {
                  var breedNamePairs, functionify, pluralToSingular, ptsObject, singularToPlural, stpObject, worldState;
                  functionify = function(obj) {
                    return function(x) {
                      var msg;
                      msg = `Cannot find corresponding breed name for ${x}!`;
                      return fold(function() {
                        throw new Error(msg);
                      })(id)(lookup(x)(obj));
                    };
                  };
                  breedNamePairs = values(breedManager.breeds()).map(function({name, singular}) {
                    return [name, singular];
                  });
                  ptsObject = toObject(breedNamePairs);
                  stpObject = toObject(breedNamePairs.map(function([p, s]) {
                    return [s, p];
                  }));
                  pluralToSingular = functionify(ptsObject);
                  singularToPlural = functionify(stpObject);
                  worldState = csvToWorldState(singularToPlural, pluralToSingular, extensionPorters)(csvText);
                  return world.importState(worldState);
                };
                importPatchColors = importPColors((function() {
                  return world.topology;
                }), (function() {
                  return world.patchSize;
                }), (function(x, y) {
                  return world.getPatchAt(x, y);
                }), base64ToImageData);
                importExportPrims = new ImportExportPrims(importExportConfig, (function() {
                  return world.exportCSV();
                }), (function() {
                  return world.exportAllPlotsCSV();
                }), (function(plot) {
                  return world.exportPlotCSV(plot);
                }), (function(plot) {
                  return world.exportRawPlotCSV(plot);
                }), (function(path) {
                  return world.importDrawing(path);
                }), importPatchColors, importWorldFromCSV);
                return {selfManager, breedManager, dump, reportErrors, importExportPrims, inspectionPrims, asyncDialogConfig, ioConfig, layoutManager, linkPrims, listPrims, mousePrims, outputPrims, plotManager, evalPrims, prims, randomPrims, primChecks, printPrims, rng, selfPrims, timer, updater, userDialogPrims, world};
              };
            };
          };
        };
      };
    };
  };

}).call(this);

},{"./core/breedmanager":"engine/core/breedmanager","./core/structure/selfmanager":"engine/core/structure/selfmanager","./core/world":"engine/core/world","./dump":"engine/dump","./hasher":"engine/hasher","./plot/plotmanager":"engine/plot/plotmanager","./prim-checks/checker":"engine/prim-checks/checker","./prim/evalprims":"engine/prim/evalprims","./prim/importexportprims":"engine/prim/importexportprims","./prim/importpcolors":"engine/prim/importpcolors","./prim/inspectionprims":"engine/prim/inspectionprims","./prim/layoutmanager":"engine/prim/layoutmanager","./prim/linkprims":"engine/prim/linkprims","./prim/listprims":"engine/prim/listprims","./prim/mouseprims":"engine/prim/mouseprims","./prim/outputprims":"engine/prim/outputprims","./prim/prims":"engine/prim/prims","./prim/printprims":"engine/prim/printprims","./prim/randomprims":"engine/prim/randomprims","./prim/selfprims":"engine/prim/selfprims","./prim/stringprims":"engine/prim/stringprims","./prim/userdialogprims":"engine/prim/userdialogprims","./updater":"engine/updater","brazier/array":"brazier/array","brazier/function":"brazier/function","brazier/maybe":"brazier/maybe","brazier/object":"brazier/object","i18n/i18n-bundle":"i18n/i18n-bundle","meta":"meta","serialize/importcsv":"serialize/importcsv","util/rng":"util/rng","util/timer":"util/timer"}],"extensions/all":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var extensionPaths;

  extensionPaths = ['array', 'codap', 'csv', 'encode', 'dialog', 'export-the', 'fetch', 'http-req', 'import-a', 'logging', 'matrix', 'mini-csv', 'nlmap', 'nt', 'send-to', 'sound', 'store', 'table'];

  module.exports = {
    initialize: function(workspace, ...importedExtensions) {
      var extensions, upperNames;
      upperNames = importedExtensions.map(function(name) {
        return name.toUpperCase();
      });
      extensions = {};
      extensionPaths.forEach(function(path) {
        var extension, extensionModule, upperName;
        extensionModule = require(`extensions/${path}`);
        extension = extensionModule.init(workspace);
        upperName = extension.name.toUpperCase();
        if (upperNames.includes(upperName)) {
          return extensions[upperName] = extension;
        }
      });
      return extensions;
    },
    porters: function(...importedExtensions) {
      var porters, upperNames;
      upperNames = importedExtensions.map(function(name) {
        return name.toUpperCase();
      });
      porters = [];
      extensionPaths.forEach(function(path) {
        var extensionModule, upperName;
        extensionModule = require(`extensions/${path}`);
        if (extensionModule.porter != null) {
          upperName = extensionModule.porter.extensionName.toUpperCase();
          if (upperNames.includes(upperName)) {
            return porters.push(extensionModule.porter);
          }
        }
      });
      return porters;
    }
  };

}).call(this);

},{}],"extensions/array":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, dumpArray, exportArray, extensionName, formatArray, importArray, isArray, readArray;

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  // (Any) => Boolean
  isArray = function(x) {
    return x.type === "ext_array";
  };

  dumpArray = function(extObj, dumpValue) {
    return extObj.items.map(function(item) {
      return dumpValue(item, true);
    }).join(' ');
  };

  exportArray = function(extObj, exportValue) {
    return extObj.items.map(function(item) {
      return exportValue(item);
    });
  };

  formatArray = function(exportedObj, formatAny) {
    return exportedObj.data.map(function(item) {
      return formatAny(item);
    }).join(' ');
  };

  readArray = function(text, parseAny) {
    return parseAny(`[${text}]`);
  };

  importArray = function(exportedObj, reify) {
    return {
      items: exportedObj.data.map(function(i) {
        return reify(i);
      }),
      type: "ext_array"
    };
  };

  extensionName = "array";

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isArray, dumpArray, exportArray, formatArray, readArray, importArray),
    init: function(workspace) {
      var extArray, fromList, invalidIndexException, item, length, notArrayException, set, toList;
      // type ExtArray = { type: "ext_array", items: Array[Any] }
      extArray = function(array) {
        this.items = array;
        this.type = "ext_array";
      };
      // List[Any] => ExtArray
      fromList = function(list) {
        return new extArray(list.slice(0));
      };
      // (ExtArray) => Number|List[Any]
      toList = function(extArray) {
        if (!isArray(extArray)) {
          throw new Error(notArrayException(extArray));
        }
        return extArray.items.slice(0);
      };
      // (ExtArray) => Number
      length = function(extArray) {
        if (!isArray(extArray)) {
          throw new Error(notArrayException(extArray));
        }
        return extArray.items.length;
      };
      // (ExtArray, Number) => Any
      item = function(extArray, index) {
        var ref;
        if (!isArray(extArray)) {
          throw new Error(notArrayException(extArray));
        }
        return (function() {
          if ((ref = extArray.items[index]) != null) {
            return ref;
          } else {
            throw new Error(invalidIndexException(extArray, index));
          }
        })();
      };
      // (ExtArray, Number, Any) => Unit
      set = function(extArray, index, value) {
        if (!isArray(extArray)) {
          throw new Error(notArrayException(extArray));
        }
        if (extArray.items[index] != null) {
          extArray.items[index] = value;
        } else {
          throw new Error(invalidIndexException(extArray, index));
        }
      };
      notArrayException = function(x) {
        return `Extension exception: not an array: ${workspace.dump(x, true)}`;
      };
      invalidIndexException = function(extArray, index) {
        return `Extension exception: ${index} is not a valid index into an array of length ${length(extArray)}`;
      };
      return {
        name: extensionName,
        prims: {
          "FROM-LIST": fromList,
          "TO-LIST": toList,
          "IS-ARRAY?": isArray,
          "LENGTH": length,
          "ITEM": item,
          "SET": set
        }
      };
    }
  };

}).call(this);

},{"../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter"}],"extensions/codap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var IFramePhone;

  IFramePhone = require('iframe-phone');

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var phone;
      phone = void 0;
      return {
        name: "codap",
        prims: {
          INIT: function(handler) {
            var ref;
            phone = ((typeof window !== "undefined" && window !== null ? window.parent : void 0) != null) && window.parent !== window ? new IFramePhone.IframePhoneRpcEndpoint(handler, "data-interactive", window.parent) : (((ref = typeof console !== "undefined" && console !== null ? console.log : void 0) != null ? ref : print)("CODAP Extension: Not in a frame; calls will have no effect."), {
              call: function(x) {
                var ref1;
                return ((ref1 = typeof console !== "undefined" && console !== null ? console.log : void 0) != null ? ref1 : print)("CODAP Extension: Not in a frame; doing nothing; received:", x);
              }
            });
            phone.call({
              action: "update",
              resource: "interactiveFrame",
              values: {
                preventDataContextReorg: false,
                title: "NetLogo Web"
              }
            });
          },
          CALL: function(argObj) {
            phone.call(argObj);
          }
        }
      };
    }
  };

}).call(this);

},{"iframe-phone":14}],"extensions/csv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var boolNames, cast, checks, parse, tryParseBool, tryParseFloat;

  ({checks} = require('../engine/core/typechecker'));

  parse = require('csv-parse/lib/sync');

  boolNames = ["false", "true"];

  // (String) => Float | Null
  tryParseFloat = function(value) {
    var maybeFloat;
    // NetLogo does not consider ',' a valid float character and I don't want
    // to pull the whole NetLogo `NumberParser` in from Scala, so...
    // Jeremy B -August 2020
    if (value.includes(",")) {
      return null;
    }
    maybeFloat = Number.parseFloat(value);
    if (!Number.isNaN(maybeFloat)) {
      return maybeFloat;
    }
    return null;
  };

  // (String) => Bool | Null
  tryParseBool = function(value) {
    var lower;
    if (value === null || value.length < 4 || value.length > 5) {
      return null;
    }
    lower = value.toLowerCase();
    if ("false" === lower) {
      return false;
    }
    if ("true" === lower) {
      return true;
    }
    return null;
  };

  // It's silly we have to do this, but csv-parse doesn't cast boolean values, and if you
  // add a cast function, it completely disables the built-in auto-cast.  Bwuh?
  // -Jeremy B August 2020

  // (String, CsvParseContext) => Bool | Float | String
  cast = function(value, context) {
    var maybeBool, maybeFloat;
    if (context.quoting) {
      return value;
    }
    maybeFloat = tryParseFloat(value);
    if (maybeFloat !== null) {
      return maybeFloat;
    }
    maybeBool = tryParseBool(value);
    if (maybeBool !== null) {
      return maybeBool;
    }
    return value;
  };

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var dumpAndWrap, fromFileNotSupported, fromRow, fromString, guardedToRow, toFileNotSupported, toRow, toString;
      // (String, String) => List[List[Any]]
      fromString = function(csvText, delimiter = ",") {
        return parse(csvText, {
          comment: '#',
          cast: cast,
          max_record_size: 1e12,
          skip_empty_lines: true,
          relax_column_count: true,
          delimiter: delimiter
        });
      };
      // (String, String) => List[Any]
      fromRow = function(csvText, delimiter = ",") {
        var list;
        // Match the desktop extension's behavior with empty rows
        // -Jeremy B August 2020
        if (csvText.trim() === "") {
          return [csvText];
        }
        list = fromString(csvText, delimiter);
        if (list.length === 0) {
          return list;
        } else {
          return list[0];
        }
      };
      // (List[List[Any]], String) => String
      toString = function(list, delimiter = ",") {
        return list.map(function(maybeRow) {
          return guardedToRow(maybeRow, delimiter);
        }).join("\n");
      };
      // (Any | List[Any], String) => String
      guardedToRow = function(maybeRow, delimiter) {
        if (!checks.isList(maybeRow)) {
          throw new Error(`Extension exception: Expected a list of lists, but ${workspace.dump(maybeRow)} was one of the elements.`);
        }
        return toRow(maybeRow, delimiter);
      };
      // (List[Any], String) => String
      toRow = function(row, delimiter = ",") {
        return row.map(function(cell) {
          return dumpAndWrap(cell, delimiter);
        }).join(delimiter);
      };
      // (Any, String) => String
      dumpAndWrap = function(cell, delimiter) {
        var cellString;
        cellString = workspace.dump(cell);
        if (cellString.startsWith("\"") && cellString.endsWith("\"")) {
          return `""${cellString}""`;
        } else if (cellString.includes(delimiter) || cellString.includes("\n")) {
          return `"${cellString}"`;
        } else {
          return cellString;
        }
      };
      // () => Unit
      fromFileNotSupported = function() {
        throw new Error("Extension exception: Reading directly from a file is not supported in NetLogo Web.  Instead you can use the Fetch extension to asynchronously read in a text file.\n\nfetch:user-file-async [ file-contents -> show csv:from-string file-contents ]");
      };
      // () => Unit
      toFileNotSupported = function() {
        throw new Error("Extension exception: Writing directly to a file is not supported in NetLogo Web.  Instead you can use the SendTo extension to download a text file of the user's choice.\n\nsend-to:file \"output.csv\" csv:to-string [[0 1 true \"hello\"][1 10 false \"goodbye\"][2 5 true \"...\"]]");
      };
      return {
        name: "csv",
        prims: {
          "FROM-STRING": fromString,
          "FROM-ROW": fromRow,
          "FROM-FILE": fromFileNotSupported,
          "TO-STRING": toString,
          "TO-ROW": toRow,
          "TO-FILE": toFileNotSupported
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","csv-parse/lib/sync":7}],"extensions/dialog":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var HaltInterrupt, flip, fold, halt, id, item, pipeline;

  ({HaltInterrupt} = require('util/exception'));

  ({item} = require('brazierjs/array'));

  ({flip, id, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  halt = function() {
    throw new HaltInterrupt;
  };

  module.exports = {
    init: function(workspace) {
      var _noDialogIsOpen, prim, userInput, userMessage, userOneOf, userYesOrNo;
      // (String, (String) => Unit) => Unit
      userInput = function(message, callback) {
        prim(function(config) {
          return config.getText(message);
        })(callback);
      };
      // (String, () => Unit) => Unit
      userMessage = function(message, callback) {
        prim(function(config) {
          return config.showMessage(message);
        })(callback);
      };
      // (String, Array[Any], () => Unit) => Unit
      userOneOf = function(message, choices, callback) {
        var fullCallback;
        fullCallback = pipeline(flip(item)(choices), fold(function() {
          throw new Error("Bad choice index");
        })(id), callback);
        if (choices.length !== 0) {
          prim(function(config) {
            return config.getChoice(message, choices.map(function(x) {
              return workspace.dump(x);
            }));
          })(fullCallback);
        } else {
          throw new Error("Extension exception: List is empty.");
        }
      };
      // (String, (Boolean) => Unit) => Unit
      userYesOrNo = function(message, callback) {
        prim(function(config) {
          return config.getYesOrNo(message);
        })(callback);
      };
      _noDialogIsOpen = true;
      // [T] @ (DialogConfig => (Maybe[T] => Unit) => Unit) => (T => Unit) => Unit
      prim = function(withConfig) {
        return function(callback) {
          if (_noDialogIsOpen) {
            _noDialogIsOpen = false;
            withConfig(workspace.asyncDialogConfig)(function(resultMaybe) {
              _noDialogIsOpen = true;
              return fold(halt)(callback)(resultMaybe);
            });
          }
        };
      };
      return {
        name: "dialog",
        prims: {
          "USER-INPUT": userInput,
          "USER-MESSAGE": userMessage,
          "USER-ONE-OF": userOneOf,
          "USER-YES-OR-NO?": userYesOrNo
        }
      };
    }
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","util/exception":"util/exception"}],"extensions/encode":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var all, checks, map, pipeline, rangeUntil;

  ({checks} = require('../engine/core/typechecker'));

  ({all, map} = require('brazier/array'));

  ({pipeline} = require('brazier/function'));

  ({rangeUntil} = require('brazier/number'));

  module.exports = {
    init: function(workspace) {
      var _reportFromBytes, base64ToBytes, bytesToBase64, bytesToString, stringToBytes;
      // [T] @ (Array[Number], String) => ((Array[Number]) => T) => T
      _reportFromBytes = function(bytes, primName) {
        return function(f) {
          var isLegit;
          isLegit = function(x) {
            return checks.isNumber(x) && (x >= -128) && (x <= 127);
          };
          if (all(isLegit)(bytes)) {
            return f(bytes);
          } else {
            throw new Error(`Extension exception: All elements of the list argument to 'encode:${primName}' must be numbers between -128 and 127`);
          }
        };
      };
      // (String) => Array[Number]
      base64ToBytes = function(base64) {
        var str;
        str = atob(base64);
        return pipeline(rangeUntil(0), map(function(n) {
          return str.codePointAt(n);
        }))(str.length);
      };
      // Array[Number] => String
      bytesToBase64 = function(bytes) {
        return _reportFromBytes(bytes, "bytes-to-base64")(function(bytes) {
          return btoa(String.fromCharCode(...bytes));
        });
      };
      // Array[Number] => String
      bytesToString = function(bytes) {
        return _reportFromBytes(bytes, "bytes-to-string")(function(bytes) {
          return String.fromCharCode(...bytes);
        });
      };
      // (String) => Array[Number]
      stringToBytes = function(str) {
        return pipeline(rangeUntil(0), map(function(n) {
          return str.codePointAt(n);
        }))(str.length);
      };
      return {
        name: "encode",
        prims: {
          "BASE64-TO-BYTES": base64ToBytes,
          "BYTES-TO-BASE64": bytesToBase64,
          "BYTES-TO-STRING": bytesToString,
          "STRING-TO-BYTES": stringToBytes
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","brazier/array":"brazier/array","brazier/function":"brazier/function","brazier/number":"brazier/number"}],"extensions/export-the":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var exportModel, exportOutput, exportPlot, exportView, exportWorld;
      // () => String
      exportModel = function() {
        return workspace.importExportPrims.exportNlogoRaw();
      };
      // () => String
      exportOutput = function() {
        return workspace.importExportPrims.exportOutputRaw();
      };
      // (String) => String
      exportPlot = function(plotName) {
        return workspace.importExportPrims.exportPlotNoHeadersRaw(plotName);
      };
      // () => String
      exportView = function() {
        return workspace.importExportPrims.exportViewRaw();
      };
      // () => String
      exportWorld = function() {
        return workspace.importExportPrims.exportWorldRaw();
      };
      return {
        name: "export-the",
        prims: {
          "MODEL": exportModel,
          "OUTPUT": exportOutput,
          "PLOT": exportPlot,
          "VIEW": exportView,
          "WORLD": exportWorld
        }
      };
    }
  };

}).call(this);

},{}],"extensions/fetch":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var fromFileDialog, fromFileDialogSynchronously, fromFilepath, fromFilepathSynchronously, fromURL, fromURLSynchronously;
      // (String, (String) => Unit) => Unit
      fromFilepath = function(filepath, callback) {
        // `TestModels` needs this, and I don't see any sensible way around it --JAB (3/13/19)
        if (typeof Polyglot !== "undefined" && Polyglot !== null) {
          workspace.ioConfig.importFile(filepath)(callback);
        } else {
          throw new Error("'fetch:file-async' is not supported in NetLogo Web.  Use 'fetch:user-file-async' instead.");
        }
      };
      // (String) => String
      fromFilepathSynchronously = function(filepath, callback) {
        throw new Error("'fetch:file' is not supported in NetLogo Web.  Use 'fetch:user-file-async' instead.");
      };
      // (String, (String) => Unit) => Unit
      fromURL = function(url, callback) {
        workspace.ioConfig.slurpURLAsync(url)(callback, workspace.reportErrors);
      };
      // (String) => String
      fromURLSynchronously = function(url) {
        return workspace.ioConfig.slurpURL(url);
      };
      // ((Boolean|String) => Unit) => String
      fromFileDialog = function(callback) {
        workspace.ioConfig.slurpFileDialogAsync(callback);
      };
      // () => String
      fromFileDialogSynchronously = function() {
        throw new Error("'fetch:user-file' is not supported in NetLogo Web.  Use 'fetch:user-file-async' instead.");
      };
      return {
        name: "fetch",
        prims: {
          "FILE": fromFilepathSynchronously,
          "FILE-ASYNC": fromFilepath,
          "URL": fromURLSynchronously,
          "URL-ASYNC": fromURL,
          "USER-FILE": fromFileDialogSynchronously,
          "USER-FILE-ASYNC": fromFileDialog
        }
      };
    }
  };

}).call(this);

},{}],"extensions/http-req":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var get, post, requestor;
      // (String) => [String, String, String]
      get = function(url) {
        var ref, req;
        req = requestor("GET", url);
        return [req.status, req.statusText, (ref = req.responseText) != null ? ref : ''];
      };
      // (String, String, String) => [String, String, String]
      post = function(url, message, contentType) {
        var req;
        req = requestor("POST", url, message, contentType != null ? contentType : "text/plain");
        return [req.status, req.statusText, req.responseText];
      };
      // (String, String, String, String) => XMLHttpRequest
      requestor = function(reqType, url, message, contentType) {
        var ct, req;
        req = new XMLHttpRequest();
        // Setting the async option to `false` is deprecated and "bad" as far as HTML/JS is
        // concerned.  But this is NetLogo and NetLogo model code doesn't have a concept of
        // async execution, so this is the best we can do.  As long as it isn't used on a
        // per-tick basis or in a loop, it should be okay.  -JMB August 2017
        req.open(reqType, url, false);
        if (contentType != null) {
          ct = (function() {
            switch (contentType) {
              case 'json':
                return 'application/json';
              case 'urlencoded':
                return 'application/x-www-form-urlencoded';
              default:
                return contentType;
            }
          })();
          req.setRequestHeader("Content-type", ct);
        }
        req.send(message != null ? message : "");
        return req;
      };
      return {
        name: "http-req",
        prims: {
          "GET": get,
          "POST": post
        }
      };
    }
  };

}).call(this);

},{}],"extensions/import-a":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var importDrawing, importPColors, importPColorsRGB, importWorld;
      // (String) => Unit
      importDrawing = function(base64) {
        workspace.importExportPrims.importDrawingRaw(base64);
      };
      // (String) => Unit
      importPColors = function(base64) {
        workspace.importExportPrims.importPColorsRaw(true)(base64);
      };
      // (String) => Unit
      importPColorsRGB = function(base64) {
        workspace.importExportPrims.importPColorsRaw(false)(base64);
      };
      // (String) => Unit
      importWorld = function(text) {
        workspace.importExportPrims.importWorldRaw(text);
      };
      return {
        name: "import-a",
        prims: {
          "DRAWING": importDrawing,
          "PCOLORS": importPColors,
          "PCOLORS-RGB": importPColorsRGB,
          "WORLD": importWorld
        }
      };
    }
  };

}).call(this);

},{}],"extensions/logging":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var contains, filter, flip, foldl, id, isEmpty, map, pipeline, tail, tee;

  ({contains, filter, foldl, isEmpty, map, tail} = require('brazierjs/array'));

  ({flip, id, pipeline, tee} = require('brazierjs/function'));

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var allLogs, clearLogs, logBuffer, logGlobals, logMessage;
      logBuffer = []; // Array[String]
      
      // (String) => Unit
      logMessage = function(str) {
        logBuffer.push(str);
      };
      // (String*) => Unit
      logGlobals = function(...names) {
        var getGlobal, globalNames, join, nameToLog, observer, toLogMessage, trueNames;
        observer = workspace.world.observer;
        globalNames = observer.varNames();
        getGlobal = observer.getGlobal.bind(observer);
        trueNames = isEmpty(names) ? globalNames : filter(flip(contains(globalNames)))(names);
        toLogMessage = function([name, value]) {
          return `${name}: ${value}`;
        };
        nameToLog = pipeline(tee(id)(pipeline(getGlobal, function(x) {
          return workspace.dump(x, true);
        })), toLogMessage);
        join = pipeline(foldl(function(acc, s) {
          return acc + "\n" + s;
        })(""), tail); // Use `tail` to drop initial newline
        pipeline(map(nameToLog), join, logMessage)(trueNames);
      };
      // () => Array[String]
      allLogs = function() {
        return logBuffer.slice(0);
      };
      // () => Unit
      clearLogs = function() {
        logBuffer = [];
      };
      return {
        name: "logging",
        prims: {
          "ALL-LOGS": allLogs,
          "CLEAR-LOGS": clearLogs,
          "LOG-GLOBALS": logGlobals,
          "LOG-MESSAGE": logMessage
        }
      };
    }
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function"}],"extensions/matrix":[function(require,module,exports){
(function() {
  var SingleObjectExtensionPorter, StrictMath, arrayEquals, checkNestedList, checks, dumpMatrix, exportMatrix, extensionName, find, floor, fold, formatExpMatrix, formatMatrix, importMatrix, isMatrix, map, notImplementedException, pipeline, rangeUntil, readMatrix, vec;

  ({find, map} = require('brazierjs/array'));

  ({arrayEquals} = require('brazierjs/equals'));

  ({pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  ({rangeUntil} = require('brazierjs/number'));

  ({floor} = require('util/nlmath'));

  ({checks} = require('../engine/core/typechecker'));

  StrictMath = require('shim/strictmath');

  vec = require('vectorious');

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  notImplementedException = function(prim) {
    throw new Error(`Extension exception: ${prim} has not been implemented.`);
  };

  // Check nestedList input for possible problems, used by fromRowList & fromColumnList
  // If input nestedList includes items, not numbers, replace them by zeros.
  // -- XZ(Summer, 2020)
  // List[Any] => List[List[Number]]
  checkNestedList = function(list) {
    var column, k, l, len1, len2, len3, n, numCols, numRows, ref, ref1, row, rowList;
    numRows = list.length;
    if (numRows === 0) {
      throw new Error("Extension exception: input list was empty");
    }
    numCols = -1;
    for (k = 0, len1 = list.length; k < len1; k++) {
      rowList = list[k];
      if (rowList instanceof Array) {
        if (numCols === -1) {
          numCols = rowList.length;
        } else if (numCols !== rowList.length) {
          throw new Error("Extension exception: To convert a nested list into a matrix, all nested lists must be the same length" + " -- e.g. [[1 2 3 4] [1 2 3]] is invalid, because row 1 has one more entry.");
        }
      } else {
        throw new Error("Extension exception: To convert a nested list into a matrix, there must be exactly two levels of nesting" + " -- e.g. [[1 2 3] [4 5 6]] creates a good 2x3 matrix.");
      }
    }
    if (numCols === 0) {
      throw new Error("Extension exception: input list contained only empty lists");
    }
    ref = rangeUntil(0)(numRows);
    // Assign zeros if the element is not a number
    for (l = 0, len2 = ref.length; l < len2; l++) {
      row = ref[l];
      ref1 = rangeUntil(0)(numCols);
      for (n = 0, len3 = ref1.length; n < len3; n++) {
        column = ref1[n];
        if (typeof list[row][column] !== 'number') {
          list[row][column] = 0;
        }
      }
    }
    return list;
  };

  // Any => Boolean
  isMatrix = function(x) {
    return x instanceof vec;
  };

  dumpMatrix = function(matrix) {
    return ` ${formatMatrix(matrix)}`;
  };

  exportMatrix = function(matrix) {
    return matrix;
  };

  // Matrix => String
  formatExpMatrix = function(exportedObj) {
    return formatMatrix(exportedObj.data);
  };

  formatMatrix = function(matrix) {
    var inner;
    inner = matrix.toArray().map(function(row) {
      return `[ ${row.join(" ")} ]`;
    }).join("");
    return `[ ${inner} ]`;
  };

  readMatrix = function(x, parseAny) {
    var list, parseable;
    parseable = x.replaceAll("\[ ", "[").replaceAll(" \]", "]").replaceAll("][", "] [");
    list = parseAny(parseable);
    return vec.array(list);
  };

  importMatrix = function(exportedObj) {
    return exportedObj.data;
  };

  extensionName = "matrix";

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isMatrix, dumpMatrix, exportMatrix, formatExpMatrix, readMatrix, importMatrix),
    init: function(workspace) {
      var copy, det, dimensions, eigenvectors, forecastCompoundGrowth, forecastContinuousGrowth, forecastGrowthHelper, forecastLinearGrowth, fromColumnList, fromRowList, get, getColumn, getRow, imaginaryEigenvalues, inverse, makeConstant, makeIdentity, matrixMap, minus, opReducer, plus, prettyPrint, rank, realEigenvalues, regress, set, setAndReport, setColumn, setRow, solve, submatrix, swapColumns, swapRows, times, timesElementWise, toColumnList, toRowList, trace, transpose, validate;
      // Check input values: matrix is valid; rows & cols are not out of boundary; newVals is a valid list.
      // Return [Integer(rows), Integer(cols)].
      // e.g. matrix:get glob1 1.1 2.2 == matrix:get glob1 1 2
      // -- XZ(Summer, 2020)
      // (Any, Number*, Number*, List[Number]*) => [Number|Null, Number|Null]
      validate = function(matrix, rows, cols, newVals) {
        var len, numCols, numRows;
        if (!isMatrix(matrix)) {
          throw new Error(`Extension exception: not a matrix: ${workspace.dump(matrix, true)}`);
        }
        [numRows, numCols] = matrix.shape;
        if ((rows != null) && (cols != null)) {
          if (!((0 <= rows && rows < numRows)) || !((0 <= cols && cols < numCols))) {
            throw new Error("Extension exception: " + `[${rows} ${cols}] are not valid indices for a matrix with dimensions ${numRows}x${numCols}`);
          } else {
            return [floor(rows), floor(cols)];
          }
        } else if (rows != null) {
          if (!((0 <= rows && rows < numRows))) {
            throw new Error("Extension exception: " + `${rows} is not a valid index for a matrix with dimensions ${numRows}x${numCols}`);
          }
          if (newVals && (len = newVals.length) !== numCols) {
            throw new Error("Extension exception: " + `The length of the given list (${len}) is different from the length of the matrix row (${numRows})`);
          } else {
            return [floor(rows), null];
          }
        } else if (cols != null) {
          if (!((0 <= cols && cols < numCols))) {
            throw new Error("Extension exception: " + `${cols} is not a valid index for a matrix with dimensions ${numRows}x${numCols}`);
          }
          if (newVals && (len = newVals.length) !== numRows) {
            throw new Error("Extension exception: " + `The length of the given list (${len}) is different from the length of the matrix column (${numCols})`);
          } else {
            return [null, floor(cols)];
          }
        }
      };
      // (Number, Number, Number) => Matrix
      makeConstant = function(rows, cols, initialValue) {
        return vec.matrix(rows, cols).fill(initialValue);
      };
      // Number => Matrix
      makeIdentity = function(size) {
        return vec.eye(size);
      };
      // List[List[Number]] => Matrix
      fromRowList = function(nestedList) {
        nestedList = checkNestedList(nestedList);
        return vec.array(nestedList);
      };
      // List[List[Number]] => Matrix
      fromColumnList = function(nestedList) {
        nestedList = checkNestedList(nestedList);
        return vec.array(nestedList).T;
      };
      // Matrix => List[List[Number]]
      toRowList = function(matrix) {
        validate(matrix);
        return matrix.toArray();
      };
      // Matrix => List[List[Number]]
      toColumnList = function(matrix) {
        validate(matrix);
        return matrix.T.toArray();
      };
      // Matrix => Matrix
      copy = function(matrix) {
        validate(matrix);
        return matrix.copy();
      };
      // Matrix => String
      prettyPrint = function(matrix) {
        var alignRow, aligned;
        validate(matrix);
        alignRow = function(row) {
          return `[ ${row.join('  ')} ]`;
        };
        aligned = matrix.toArray().map(function(row) {
          return alignRow(row);
        }).join('\n ');
        return `[${aligned}]`;
      };
      // (Matrix, Number, Number) => Number
      get = function(matrix, i, j) {
        [i, j] = validate(matrix, i, j);
        return matrix.get(i, j);
      };
      // (Matrix, Number) => List[Number]
      getRow = function(matrix, i) {
        var _, cols;
        [i, _] = validate(matrix, i);
        [_, cols] = matrix.shape;
        return rangeUntil(0)(cols).map(function(j) {
          return matrix.get(i, j);
        });
      };
      // (Matrix, Number) => List[Number]
      getColumn = function(matrix, j) {
        var _, rows;
        [_, j] = validate(matrix, _, j);
        [rows, _] = matrix.shape;
        return rangeUntil(0)(rows).map(function(i) {
          return matrix.get(i, j);
        });
      };
      // (Matrix, Number, Number, Number) => Unit
      set = function(matrix, i, j, newVal) {
        [i, j] = validate(matrix, i, j);
        matrix.set(i, j, newVal);
      };
      // (Matrix, Number, List[Number]) => Unit
      setRow = function(matrix, i, newVals) {
        var _, cols;
        [i, _] = validate(matrix, i, _, newVals);
        [_, cols] = matrix.shape;
        rangeUntil(0)(cols).forEach(function(j) {
          return matrix.set(i, j, newVals[j]);
        });
      };
      // (Matrix, Number, List[Number]) => Unit
      setColumn = function(matrix, j, newVals) {
        var _, rows;
        [_, j] = validate(matrix, _, j, newVals);
        [rows, _] = matrix.shape;
        rangeUntil(0)(rows).forEach(function(i) {
          return matrix.set(i, j, newVals[i]);
        });
      };
      // (Matrix, Number, Number) => Unit
      swapRows = function(matrix, r1, r2) {
        validate(matrix, r1);
        validate(matrix, r2);
        matrix.swap(r1, r2);
      };
      // (Matrix, Number, Number) => Unit
      swapColumns = function(matrix, c1, c2) {
        var _, i, k, len1, oldC1, ref, rows;
        [_, c1] = validate(matrix, _, c1);
        [_, c2] = validate(matrix, _, c2);
        [rows, _] = matrix.shape;
        ref = rangeUntil(0)(rows);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          i = ref[k];
          oldC1 = matrix.get(i, c1);
          matrix.set(i, c1, matrix.get(i, c2));
          matrix.set(i, c2, oldC1);
        }
      };
      // (Matrix, Number, Number, Number) => Matrix
      setAndReport = function(matrix, i, j, newVal) {
        var dupe;
        validate(matrix, i, j);
        dupe = matrix.copy();
        set(dupe, i, j, newVal);
        return dupe;
      };
      // (Matrix) => (Number, Number)
      dimensions = function(matrix) {
        validate(matrix);
        return matrix.shape;
      };
      // (Matrix, Number, Number, Number, Number) => Matrix
      submatrix = function(matrix, r1, c1, r2, c2) {
        var arr, i, j, k, l, len1, len2, ref, ref1, subArr, subCols, subRows;
        (function() { // Error-checking blurb
          var checkArg, numCols, numRows;
          [numRows, numCols] = matrix.shape;
          checkArg = function({arg, lower, upper, isStart, isRow}) {
            var complaint, dimName, polarity, remedy;
            if (!((lower <= arg && arg <= upper))) {
              polarity = isStart ? "Start" : "End";
              dimName = isRow ? "row" : "column";
              complaint = `Extension exception: ${polarity} ${dimName} index (${arg}) is invalid.`;
              remedy = `Should be between ${lower} and ${upper} inclusive.`;
              throw new Error(`${complaint}  ${remedy}`);
            }
          };
          return [
            {
              arg: r1,
              lower: 0,
              upper: numRows - 1,
              isStart: true,
              isRow: true
            },
            {
              arg: c1,
              lower: 0,
              upper: numCols - 1,
              isStart: true,
              isRow: false
            },
            {
              arg: r2,
              lower: 1,
              upper: numRows,
              isStart: false,
              isRow: true
            },
            {
              arg: c2,
              lower: 1,
              upper: numCols,
              isStart: false,
              isRow: false
            }
          ].forEach(checkArg);
        })();
        arr = matrix.toArray();
        subRows = r2 - r1;
        subCols = c2 - c1;
        subArr = pipeline(rangeUntil(0), map(function() {
          return [];
        }))(subRows);
        ref = rangeUntil(0)(subRows);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          i = ref[k];
          ref1 = rangeUntil(0)(subCols);
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            j = ref1[l];
            subArr[i][j] = arr[r1 + i][c1 + j];
          }
        }
        return vec.array(subArr);
      };
      // ((Number* => Number), Matrix, Matrix*) => Matrix
      matrixMap = function(reporter, matrix, ...rest) {
        var badShape, firstShape, k, len1, m, shapeToStr;
        if (reporter.length > rest.length + 1) {
          throw new Error(`Extension exception: Task expected ${reporter.length} matrix inputs but only got ${rest.length + 1}.`);
        }
        for (k = 0, len1 = rest.length; k < len1; k++) {
          m = rest[k];
          if (!arrayEquals(matrix.shape)(m.shape)) {
            shapeToStr = function([x, y]) {
              return `${x}x${y}`;
            };
            firstShape = shapeToStr(matrix.shape);
            badShape = shapeToStr(m.shape);
            throw new Error(`Extension exception: All matrices must have the same dimensions: the first was ${firstShape} and another was ${badShape}.`);
          }
        }
        return matrix.map(function(item, i) {
          var restItems;
          restItems = rest.map(function(m) {
            return m.get(floor(i / m.shape[1]), i % m.shape[1]);
          });
          return reporter(item, ...restItems);
        });
      };
      // ((Number, Number) => Number, (Matrix, Matrix) => Matrix, (Matrix, Number) => Matrix) =>
      //   (Matrix|Number, Matrix|Number, (Matrix|Number)*) =>
      //     Matrix|Number
      opReducer = function(scalarOp, matrixOp, mixedOp) {
        return function(m1, m2, ...rest) {
          return [m1, m2, ...rest].reduce(function(left, right) {
            if (checks.isNumber(left)) {
              if (checks.isNumber(right)) {
                return scalarOp(left, right);
              } else {
                return mixedOp(right, left);
              }
            } else {
              if (checks.isNumber(right)) {
                return mixedOp(left, right);
              } else {
                return matrixOp(left, right);
              }
            }
          });
        };
      };
      // (Matrix|Number, Matrix|Number, (Matrix|Number)*) => Matrix|Number
      times = function(m1, m2, ...rest) {
        return opReducer(((s1, s2) => {
          return s1 * s2;
        }), vec.multiply, vec.scale)(m1, m2, ...rest);
      };
      // (Matrix, Matrix, Matrix*) => Matrix
      timesElementWise = function(m1, m2, ...rest) {
        return opReducer(((s1, s2) => {
          return s1 * s2;
        }), vec.product, vec.scale)(m1, m2, ...rest);
      };
      // (Matrix|Number, Matrix|Number, (Matrix|Number)*) => Matrix|Number
      plus = function(m1, m2, ...rest) {
        return opReducer(((s1, s2) => {
          return s1 + s2;
        }), vec.add, (function(m, s) {
          return m.map(function(x) {
            return x + s;
          });
        }))(m1, m2, ...rest);
      };
      // (Matrix|Number, Matrix|Number, (Matrix|Number)*) => Matrix|Number
      minus = function(m1, m2, ...rest) {
        var broadcastIfNumber, cols, operands, rows;
        operands = [m1, m2, ...rest];
        [rows, cols] = pipeline(find(isMatrix), fold(function() {
          throw new Error("One or more (-) operands must be a matrix...");
        })(function(x) {
          return x.shape;
        }))(operands);
        broadcastIfNumber = function(x) {
          if (checks.isNumber(x)) {
            return makeConstant(rows, cols, x);
          } else {
            return x;
          }
        };
        return operands.reduce(function(left, right) {
          return vec.subtract(broadcastIfNumber(left), broadcastIfNumber(right));
        });
      };
      // Matrix => Matrix
      inverse = function(matrix) {
        validate(matrix);
        return matrix.inv();
      };
      // Matrix => Matrix
      transpose = function(matrix) {
        validate(matrix);
        return matrix.T;
      };
      // Apparently this is inefficient for large matrices. --SL (Spring, 2017)
      // Matrix => Number
      det = function(matrix) {
        validate(matrix);
        return matrix.det();
      };
      // Matrix => Number
      rank = function(matrix) {
        validate(matrix);
        return matrix.rank();
      };
      // Matrix => Number
      trace = function(matrix) {
        validate(matrix);
        return matrix.trace();
      };
      // (Matrix, Matrix) => Matrix
      solve = function(m1, m2) {
        validate(m1);
        validate(m2);
        return m1.solve(m2);
      };
      // Following three eigen-related APIs are dummy implementations.
      // We throw an error to explain we have not implemented them yet. -- XZ (Summer, 2020)
      // (Matrix) => List
      realEigenvalues = function(matrix) {
        return notImplementedException("matrix:real-eigenvalues");
      };
      // (Matrix) => List
      imaginaryEigenvalues = function(matrix) {
        return notImplementedException("matrix:imaginary-eigenvalues");
      };
      // (Matrix) => Matrix
      eigenvectors = function(matrix) {
        return notImplementedException("matrix:eigenvectors");
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastGrowthHelper = function(data) {
        var constant, dataMatrix, indepVar, r2, slope;
        indepVar = rangeUntil(0)(data.length);
        dataMatrix = fromColumnList([data, indepVar]);
        [[constant, slope], [r2]] = regress(dataMatrix);
        return [constant, slope, r2];
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastLinearGrowth = function(data) {
        var constant, forecast, r2, slope;
        [constant, slope, r2] = forecastGrowthHelper(data);
        forecast = slope * data.length + constant;
        return [forecast, constant, slope, r2];
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastCompoundGrowth = function(data) {
        var c, constant, forecast, lnData, p, proportion, r2;
        lnData = data.map(function(x) {
          return StrictMath.log(x);
        });
        [c, p, r2] = forecastGrowthHelper(lnData);
        constant = StrictMath.exp(c);
        proportion = StrictMath.exp(p);
        forecast = constant * proportion ** data.length;
        return [forecast, constant, proportion, r2];
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastContinuousGrowth = function(data) {
        var c, constant, forecast, lnData, r2, rate;
        lnData = data.map(function(x) {
          return StrictMath.log(x);
        });
        [c, rate, r2] = forecastGrowthHelper(lnData);
        constant = StrictMath.exp(c);
        forecast = constant * StrictMath.exp(rate * data.length);
        return [forecast, constant, rate, r2];
      };
      // Matrix => (List[Number], (Number, Number, Number))
      regress = function(data) {
        var coefficients, indepVars, matrix, nObservations, nVars, ones, rSquared, resid, residSumSq, stats, totalSumSq, y, yBar, yDiff, ySum;
        y = fromColumnList([getColumn(data, 0)]);
        // To construct the matrix (known as "matrix" in the code, and as "X" in the comments),
        // we replace the first column (the dependent variable) of the input matrix with all 1's --SL (Spring, 2017)
        [nObservations, nVars] = data.shape;
        indepVars = submatrix(data, 0, 1, nObservations, nVars);
        ones = y.map(function() {
          return 1;
        });
        matrix = vec.augment(ones, indepVars);
        // Solve the system Xb = y for b, the row vector of coefficients for each independent variable.
        // The following form ensures X does not need to be square: y.T * X * (X.T * X)^-1 --SL (Spring, 2017)
        coefficients = times(y.T, matrix, inverse(times(matrix.copy().T, matrix)));
        ySum = y.reduce(function(a, b) {
          return a + b;
        });
        yBar = ySum / nObservations;
        yDiff = minus(y, makeConstant(nObservations, 1, yBar));
        totalSumSq = times(yDiff.copy().T, yDiff).get(0, 0);
        resid = minus(times(matrix, coefficients.copy().T), y);
        residSumSq = times(resid.copy().T, resid).get(0, 0);
        rSquared = 1 - (residSumSq / totalSumSq);
        stats = [rSquared, totalSumSq, residSumSq];
        return [getRow(coefficients, 0), stats];
      };
      return {
        name: extensionName,
        prims: {
          "MAKE-CONSTANT": makeConstant,
          "MAKE-IDENTITY": makeIdentity,
          "FROM-ROW-LIST": fromRowList,
          "FROM-COLUMN-LIST": fromColumnList,
          "TO-ROW-LIST": toRowList,
          "TO-COLUMN-LIST": toColumnList,
          "COPY": copy,
          "PRETTY-PRINT-TEXT": prettyPrint,
          "SOLVE": solve,
          "GET": get,
          "GET-ROW": getRow,
          "GET-COLUMN": getColumn,
          "SET": set,
          "SET-ROW": setRow,
          "SET-COLUMN": setColumn,
          "SWAP-ROWS": swapRows,
          "SWAP-COLUMNS": swapColumns,
          "SET-AND-REPORT": setAndReport,
          "DIMENSIONS": dimensions,
          "SUBMATRIX": submatrix,
          "MAP": matrixMap,
          "TIMES-SCALAR": times,
          "TIMES": times,
          "*": times,
          "TIMES-ELEMENT-WISE": timesElementWise,
          "PLUS-SCALAR": plus,
          "PLUS": plus,
          "+": plus,
          "MINUS": minus,
          "-": minus,
          "INVERSE": inverse,
          "TRANSPOSE": transpose,
          "DET": det,
          "RANK": rank,
          "TRACE": trace,
          "FORECAST-LINEAR-GROWTH": forecastLinearGrowth,
          "FORECAST-COMPOUND-GROWTH": forecastCompoundGrowth,
          "FORECAST-CONTINUOUS-GROWTH": forecastContinuousGrowth,
          "REGRESS": regress,
          "IS-MATRIX?": isMatrix,
          "REAL-EIGENVALUES": realEigenvalues,
          "IMAGINARY-EIGENVALUES": imaginaryEigenvalues,
          "EIGENVECTORS": eigenvectors
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter","brazierjs/array":"brazier/array","brazierjs/equals":"brazier/equals","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/number":"brazier/number","shim/strictmath":"shim/strictmath","util/nlmath":"util/nlmath","vectorious":129}],"extensions/mini-csv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var csv;

  csv = require("extensions/csv");

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var core, deprecatePrim;
      core = csv.init(workspace);
      // (String, String, U => T) => U => T
      deprecatePrim = function(oldName, newName, f) {
        return function() {
          workspace.printPrims.print(`${oldName} is deprecated and will be removed in a future NetLogo Web release.  Please switch to using ${newName} instead.`);
          return f.apply(null, arguments);
        };
      };
      return {
        name: "mini-csv",
        prims: {
          "FROM-STRING": deprecatePrim("mini-csv:from-string", "csv:from-string", core.prims["FROM-STRING"]),
          "FROM-ROW": deprecatePrim("mini-csv:from-row", "csv:from-row", core.prims["FROM-ROW"]),
          "TO-STRING": deprecatePrim("mini-csv:to-string", "csv:to-string", core.prims["TO-STRING"]),
          "TO-ROW": deprecatePrim("mini-csv:to-row", "csv:to-row", core.prims["TO-ROW"])
        }
      };
    }
  };

}).call(this);

},{"extensions/csv":"extensions/csv"}],"extensions/nlmap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, dumpMap, exportMap, extensionName, formatMap, importMap, isMap, newMap, readMap, toMap,
    hasProp = {}.hasOwnProperty;

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  // (Any) => Boolean
  isMap = function(x) {
    return x._type === "nl_map";
  };

  // type NLMap = Object[Any]

  // ((NLMap) => String) => NLMap
  newMap = function() {
    var out;
    out = {};
    return toMap(out);
  };

  // (POJO, (NLMap) => String) => NLMap
  toMap = function(obj) {
    Object.defineProperty(obj, "_type", {
      enumerable: false,
      value: "nl_map",
      writable: false
    });
    return obj;
  };

  extensionName = "nlmap";

  dumpMap = function(x, dumpValue) {
    var values;
    values = Object.keys(x).map((key) => {
      return `["${key}" ${dumpValue(x[key], true)}]`;
    }).join(' ');
    return ` ${values}`;
  };

  exportMap = function(x, exportValue) {
    var out;
    out = {};
    Object.keys(x).map(function(k) {
      return out[k] = exportValue(x[k]);
    });
    return toMap(out);
  };

  formatMap = function(exportedObj, formatAny) {
    return Object.keys(exportedObj.data).map((key) => {
      return `["${key}" ${formatAny(x[key])}]`;
    }).join(' ');
  };

  readMap = function(x, parseAny) {
    var i, k, len, list, out, v;
    out = {};
    list = parseAny(`[${x}]`);
    for (i = 0, len = list.length; i < len; i++) {
      [k, v] = list[i];
      out[k] = v;
    }
    return out;
  };

  importMap = function(exportedObj, reify) {
    var out;
    out = {};
    Object.keys(exportedObj.data).map(function(k) {
      return out[k] = reify(exportedObj.data[k]);
    });
    return toMap(out);
  };

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isMap, dumpMap, exportMap, formatMap, readMap, importMap),
    init: function(workspace) {
      var add, fromList, get, jsonToMap, mapToJson, mapToUrlEncoded, remove, toList;
      // List[(String, Any)] => NLMap
      fromList = function(list) {
        var i, k, len, out, v;
        out = newMap();
        for (i = 0, len = list.length; i < len; i++) {
          [k, v] = list[i];
          out[k] = v;
        }
        return out;
      };
      // (NLMap) => List[(String, Any)]
      toList = function(nlMap) {
        var k, results;
        results = [];
        for (k in nlMap) {
          results.push([k, nlMap[k]]);
        }
        return results;
      };
      // (NLMap, String, Any) -> NLMap
      add = function(nlMap, key, value) {
        var k, out;
        out = newMap();
        for (k in nlMap) {
          out[k] = nlMap[k];
        }
        out[key] = value;
        return out;
      };
      // (NLMap, String) => Any
      get = function(nlMap, key) {
        var ref;
        return (function() {
          if ((ref = nlMap[key]) != null) {
            return ref;
          } else {
            throw new Error(`${key} does not exist in this map`);
          }
        })();
      };
      // (NLMap, String) => NLMap
      remove = function(nlMap, key) {
        var k, out;
        out = newMap();
        for (k in nlMap) {
          if (k !== key) {
            out[k] = nlMap[k];
          }
        }
        return out;
      };
      // NLMap => String
      mapToJson = function(nlMap) {
        if (nlMap._type !== "nl_map") {
          throw new Error("Only nlmap type values can be converted to JSON format.");
        }
        return JSON.stringify(nlMap);
      };
      // NLMap => String
      mapToUrlEncoded = function(nlMap) {
        var key, kvps, value;
        if (nlMap._type !== "nl_map") {
          throw new Error("Only nlmap type values can be converted to URL format.");
        } else {
          kvps = [];
          for (key in nlMap) {
            if (!hasProp.call(nlMap, key)) continue;
            value = nlMap[key];
            if (typeof value !== 'object') {
              kvps.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
            }
          }
          return kvps.join('&');
        }
      };
      // String => NLMap
      jsonToMap = function(json) {
        return JSON.parse(json, function(key, value) {
          if (typeof value === 'object') {
            return toMap(value);
          } else {
            return value;
          }
        });
      };
      return {
        name: extensionName,
        prims: {
          "FROM-LIST": fromList,
          "TO-LIST": toList,
          "IS-MAP?": isMap,
          "ADD": add,
          "GET": get,
          "REMOVE": remove,
          "TO-JSON": mapToJson,
          "TO-URLENC": mapToUrlEncoded,
          "FROM-JSON": jsonToMap
        }
      };
    }
  };

}).call(this);

},{"../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter"}],"extensions/nt":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var get, ntStore, set;
      ntStore = {};
      get = function(key) {
        if (ntStore.hasOwnProperty(key)) {
          return ntStore[key];
        } else {
          return "";
        }
      };
      set = function(key, value) {
        ntStore[key] = value;
      };
      return {
        name: "nt",
        prims: {
          "GET": get,
          "SET": set
        }
      };
    }
  };

}).call(this);

},{}],"extensions/send-to":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var file;
      // (String, String) => Unit
      file = function(fileName, content) {
        workspace.importExportPrims.exportFile(content)(fileName);
      };
      return {
        name: "send-to",
        prims: {
          "FILE": file
        }
      };
    }
  };

}).call(this);

},{}],"extensions/sound":[function(require,module,exports){
(function() {
  module.exports = {
    init: function(workspace) {
      var playTone, setup, synth;
      synth = null;
      setup = function() {
        var tone;
        tone = require('tone');
        return synth = new tone.PolySynth(tone.Synth).toDestination();
      };
      playTone = function(note, duration, velocity) {
        var regex;
        if (synth === null) {
          setup();
        }
        regex = /(A|B|C|D|E|F|G)(#|b)?\d/;
        if (regex.test(note)) {
          return synth.triggerAttackRelease(note, duration, void 0, velocity);
        } else {
          throw new Error("Extension exception: " + note + " is not a valid note!");
        }
      };
      return {
        name: "sound",
        prims: {
          "PLAY-TONE": playTone
        }
      };
    }
  };

}).call(this);

},{"tone":37}],"extensions/store":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ForageStorage, ObjectStorage;

  ObjectStorage = class ObjectStorage {
    constructor() {
      // ((String[]) => Unit) => Unit
      this.listStores = this.listStores.bind(this);
      // (String) => Unit
      this.switchStore = this.switchStore.bind(this);
      // (String) => Unit
      this.deleteStore = this.deleteStore.bind(this);
      // (String, (String) => Unit) => Unit
      this.getItem = this.getItem.bind(this);
      // (String, String, () => Unit) => Unit
      this.setItem = this.setItem.bind(this);
      // (String, () => Unit) => Unit
      this.removeItem = this.removeItem.bind(this);
      // (String, (Boolean) => Unit) => Unit
      this.hasKey = this.hasKey.bind(this);
      // ((String[]) => Unit) => Unit
      this.getKeys = this.getKeys.bind(this);
      // (() => Unit) => Unit
      this.clear = this.clear.bind(this);
      this.store = {
        name: "",
        data: {}
      };
      this.stores = [];
      this.stores.push(this.store);
    }

    listStores(callback) {
      callback(this.stores.filter(function(store) {
        return store.name !== "";
      }).map(function(store) {
        return store.name;
      }));
    }

    switchStore(name) {
      var matchingStore, store;
      name = name !== "Default Store" ? name : "";
      matchingStore = this.stores.find(function(store) {
        return store.name === name;
      });
      this.store = (matchingStore != null) ? matchingStore : (store = {
        name: name,
        data: {}
      }, this.stores.push(store), store);
    }

    deleteStore(name) {
      if (name === "" || name === "Default Store") {
        throw new Error("Extension exception: Cannot delete the default store, but you can clear it if you want.");
      }
      if (this.store.name === name) {
        throw new Error("Extension exception: Cannot delete the current store, switch to another store first.");
      }
      this.stores = this.stores.filter(function(store) {
        return store.name !== name;
      });
    }

    getItem(key, callback) {
      this.hasKey(key, (isValidKey) => {
        if (!isValidKey) {
          throw new Error(`Extension exception: Could not find a value for key: '${key}'.`);
        }
        return callback(this.store.data[key]);
      });
    }

    setItem(key, value, callback = (function() {})) {
      this.store.data[key] = value;
      callback();
    }

    removeItem(key, callback = (function() {})) {
      this.hasKey(key, (isValidKey) => {
        if (isValidKey) {
          return delete this.store.data[key];
        }
      });
      callback();
    }

    hasKey(key, callback) {
      callback(this.store.data.hasOwnProperty(key));
    }

    getKeys(callback) {
      callback(Object.getOwnPropertyNames(this.store.data));
    }

    clear(callback = (function() {})) {
      this.store.data = {};
      callback();
    }

  };

  ForageStorage = class ForageStorage {
    constructor(localforage, reportErrors) {
      // (String, Int | String) => Unit
      this._setCurrentStorage = this._setCurrentStorage.bind(this);
      // ((String[]) => Unit) => Unit
      this.listStores = this.listStores.bind(this);
      // (String) => Unit
      this.switchStore = this.switchStore.bind(this);
      // (String) => Unit
      this.deleteStore = this.deleteStore.bind(this);
      // (String, (String) => Unit) => Unit
      this.getItem = this.getItem.bind(this);
      // ((String[]) => Unit) => Unit
      this.getKeys = this.getKeys.bind(this);
      // (String, (Boolean) => Unit) => Unit
      this.hasKey = this.hasKey.bind(this);
      // (String, String, () => Unit) => Unit
      this.setItem = this.setItem.bind(this);
      // (String, () => Unit) => Unit
      this.removeItem = this.removeItem.bind(this);
      // (() => Unit) => Unit
      this.clear = this.clear.bind(this);
      this.localforage = localforage;
      this.reportError = function(error) {
        return reportErrors(["Extension exception: Unable to process your store request.", "", error.message]);
      };
      this._setCurrentStorage("Default Store", "default");
      this.storesInstance = this.localforage.createInstance({
        name: "Store Extension for NLW",
        storeName: "nlw_store_extension_stores"
      });
      this.stores = [];
      this.lastStoreNumber = 0;
      this.storesInstance.iterate((storeNumber, name) => {
        var storeName;
        storeName = this._storeName(storeNumber);
        this.stores.push({name, storeName, storeNumber});
        if (storeNumber > this.lastStoreNumber) {
          return this.lastStoreNumber = storeNumber;
        }
      });
      return;
    }

    _storeName(storeNumber) {
      return `nlw_store_extension_${storeNumber}`;
    }

    _setCurrentStorage(name, storeNumber) {
      var store;
      store = {
        name: name,
        storeName: this._storeName(storeNumber),
        storeNumber: storeNumber
      };
      this.currentStorage = this.localforage.createInstance(store);
      return store;
    }

    listStores(callback) {
      callback(this.stores.filter(function(store) {
        return store.name !== "";
      }).map(function(store) {
        return store.name;
      }));
    }

    switchStore(name) {
      var matchingStore;
      if (name === "" || name === "Default Store") {
        this._setCurrentStorage("Default Store", "default");
        return;
      }
      matchingStore = this.stores.find(function(store) {
        return store.name === name;
      });
      if ((matchingStore != null)) {
        this._setCurrentStorage(matchingStore.name, matchingStore.storeNumber);
      } else {
        this.lastStoreNumber = this.lastStoreNumber + 1;
        this.storesInstance.setItem(name, this.lastStoreNumber);
        this.stores.push(this._setCurrentStorage(name, this.lastStoreNumber));
      }
    }

    deleteStore(name) {
      var deleteStore, store;
      if (name === "" || name === "Default Store") {
        throw new Error("Extension exception: Cannot delete the default store, but you can clear it if you want.");
      }
      if (this.currentStorage._config.name === name) {
        throw new Error("Extension exception: Cannot delete the current store, switch to another store first.");
      }
      this.storesInstance.removeItem(name);
      store = this.stores.find(function(store) {
        return store.name === name;
      });
      if (store == null) {
        return;
      }
      deleteStore = this.localforage.createInstance({
        name: name,
        storeName: store.storeName
      });
      deleteStore.dropInstance();
      this.stores = this.stores.filter(function(store) {
        return store.name !== name;
      });
    }

    getItem(key, callback) {
      this.hasKey(key, (isValidKey) => {
        if (!isValidKey) {
          throw new Error(`Could not find a value for key: '${key}'.`);
        }
        return this.currentStorage.getItem(key).then(callback).catch(this.reportError);
      });
    }

    getKeys(callback) {
      this.currentStorage.keys().then(callback).catch(this.reportError);
    }

    hasKey(key, callback) {
      this.getKeys(function(keys) {
        return callback(keys.includes(key));
      });
    }

    setItem(key, value, callback = (function() {})) {
      this.currentStorage.setItem(key, value).then(callback).catch(this.reportError);
    }

    removeItem(key, callback = (function() {})) {
      this.currentStorage.removeItem(key).then(callback).catch(this.reportError);
    }

    clear(callback = (function() {})) {
      this.currentStorage.clear().then(callback).catch(this.reportError);
    }

  };

  module.exports = {
    init: function(workspace) {
      var storage;
      storage = ((typeof window !== "undefined" && window !== null ? window.localforage : void 0) != null) ? new ForageStorage(window.localforage, workspace.reportErrors) : new ObjectStorage();
      return {
        name: "store",
        prims: {
          "LIST-STORES": storage.listStores,
          "SWITCH-STORE": storage.switchStore,
          "DELETE-STORE": storage.deleteStore,
          "CLEAR": storage.clear,
          "GET": storage.getItem,
          "GET-KEYS": storage.getKeys,
          "HAS-KEY": storage.hasKey,
          "PUT": storage.setItem,
          "REMOVE": storage.removeItem
        }
      };
    }
  };

}).call(this);

},{}],"extensions/table":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, checkInput, checkIsValidList, checks, dumpTable, equals, exportTable, extensionName, formatTable, getOriginKey, importTable, isTable, isValidKey, readTable;

  ({checks} = require('../engine/core/typechecker'));

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  // (Any) => Boolean
  isTable = function(x) {
    return x instanceof Map;
  };

  // This method is to get the same-value key in a table.
  // e.g (table:get glob1 [1 2]) where passing `key` param is an array; array is a reference type in JavaScript.
  // So we need to find whether there's a same-value key in the table.
  // -- XZ (July, 2020)
  // (Table, Any) => Any | Undefined
  getOriginKey = function(table, key) {
    return Array.from(table.keys()).find(function(k) {
      return equals(k, key);
    });
  };

  // Compare two Array by their values instead of references.
  // (Any, Any) => Boolean
  equals = function(a, b) {
    if (a instanceof Array && b instanceof Array) {
      return a.length === b.length && a.every(function(val, index) {
        return equals(val, b[index]);
      });
    } else {
      return a === b;
    }
  };

  // (Any) => Boolean
  isValidKey = function(x) {
    if (!checks.isList(x)) {
      return checks.isString(x) || checks.isNumber(x) || checks.isBoolean(x);
    } else {
      return x.every(function(item) {
        return isValidKey(item);
      });
    }
  };

  // (List) => Boolean
  checkIsValidList = function(list) {
    var i, len, pair;
    for (i = 0, len = list.length; i < len; i++) {
      pair = list[i];
      if (!(pair instanceof Array && pair.length >= 2)) {
        throw new Error(`Extension Exception: expected a two-element list: ${workspace.dump(pair, true)}`);
      }
    }
  };

  // (Any, String|Boolean|Number|List) ->
  checkInput = function({table, key}) {
    if (!isTable(table)) {
      throw new Error(`Extension Exception: not a table ${workspace.dump(table, true)}`);
    }
    if ((key != null) && !isValidKey(key)) {
      throw new Error("Extension Exception: " + `${workspace.dump(key, true)} is not a valid table key ` + "(a table key may only be a number, a string, true or false, or a list whose items are valid keys)");
    }
  };

  extensionName = "table";

  dumpTable = function(x, dumpValue) {
    return `[${Array.from(x).map((item) => {
      return dumpValue(item, true);
    }).join(' ')}]`;
  };

  exportTable = function(x, exportValue) {
    var map;
    map = new Map();
    Array.from(x.keys()).forEach(function(key) {
      var value;
      value = x.get(key);
      map.set(key, exportValue(value));
    });
    return map;
  };

  formatTable = function(exportedObj, formatAny) {
    var values;
    values = Array.from(exportedObj.data.keys()).map(function(key) {
      return `[""${key}"" ${formatAny(exportedObj.data.get(key))}]`;
    });
    return `[${values.join(' ')}]`;
  };

  readTable = function(x, parseAny) {
    var list;
    list = parseAny(x);
    return new Map(list);
  };

  // (ExportedExtensionObject, (Any) => Any)) => Table
  importTable = function(exportedObj, reify) {
    var map;
    map = new Map();
    Array.from(exportedObj.data.keys()).forEach(function(key) {
      var value;
      value = exportedObj.data.get(key);
      map.set(key, reify(value));
    });
    return map;
  };

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isTable, dumpTable, exportTable, formatTable, readTable, importTable),
    init: function(workspace) {
      var clear, counts, fromList, get, getOrDefault, groupAgents, groupItems, hasKey, keys, length, make, put, remove, toList, values;
      // () => Table
      make = function() {
        return new Map();
      };
      // (List) => Map
      fromList = function(list) {
        checkIsValidList(list);
        return new Map(list.slice(0));
      };
      // (Table) => List
      toList = function(table) {
        checkInput({
          table: table
        });
        return Array.from(table).slice(0);
      };
      // (Table) => Unit
      clear = function(table) {
        checkInput({
          table: table
        });
        table.clear();
      };
      // (Table, Any) => Any
      get = function(table, key) {
        var originKey;
        checkInput({
          table: table
        });
        if (!(key instanceof Array)) {
          return table.get(key);
        }
        originKey = getOriginKey(table, key);
        if (originKey != null) {
          return table.get(originKey);
        } else {
          throw new Error(`Extension Exception: No value for ${key} in table.`);
        }
      };
      // (Table, Any) => Boolean
      hasKey = function(table, key) {
        checkInput({
          table: table
        });
        if (!(key instanceof Array)) {
          return table.has(key);
        }
        return Array.from(table.keys()).some(function(k) {
          return equals(k, key);
        });
      };
      // (Table) => List
      keys = function(table) {
        checkInput({
          table: table
        });
        return Array.from(table.keys()).slice(0);
      };
      // (Table) => List
      values = function(table) {
        checkInput({
          table: table
        });
        return Array.from(table.values()).slice(0);
      };
      // (Table) => Number
      length = function(table) {
        checkInput({
          table: table
        });
        return table.size;
      };
      // (Table, Any, Any) => Unit
      put = function(table, key, value) {
        var ref;
        checkInput({
          table: table,
          key: key
        });
        if (!(key instanceof Array)) {
          table.set(key, value);
          return;
        }
        key = (ref = getOriginKey(table, key)) != null ? ref : key;
        table.set(key, value);
      };
      // (Table, Any) => Unit
      remove = function(table, key) {
        var originKey;
        checkInput({
          table: table
        });
        if (!(key instanceof Array)) {
          table.delete(key);
          return;
        }
        originKey = getOriginKey(table, key);
        if (originKey != null) {
          table.delete(originKey);
        }
      };
      // (List) => Table
      counts = function(list) {
        var count, i, item, len;
        counts = new Map();
        for (i = 0, len = list.length; i < len; i++) {
          item = list[i];
          count = hasKey(counts, item) ? get(counts, item) + 1 : 1;
          put(counts, item, count);
        }
        return counts;
      };
      // (Table, Any, Any) => Any
      getOrDefault = function(table, key, defaultValue) {
        checkInput({
          table: table
        });
        if (hasKey(table, key)) {
          return get(table, key);
        } else {
          return defaultValue;
        }
      };
      // (Agentset, Reporter) => Table
      groupAgents = function(agentset, reporter) {
        var group;
        group = new Map();
        agentset.shufflerator().forEach(function(agent) {
          var key, ref, value;
          key = workspace.world.selfManager.askAgent(reporter)(agent);
          value = (ref = group.get(key)) != null ? ref : [];
          value.push(agent);
          return group.set(key, value);
        });
        group.forEach(function(value, key) {
          var newAgentset;
          newAgentset = (function() {
            switch (agentset._agentTypeName) {
              case "turtles":
                return new TurtleSet(value, workspace.world);
              case "patches":
                return new PatchSet(value, workspace.world);
              case "links":
                return new LinkSet(value, workspace.world);
              default:
                throw new Error("Extension Exception: Unknown agentset type");
            }
          })();
          return group.set(key, newAgentset);
        });
        return group;
      };
      // (List, (Number => Number)) => Table
      groupItems = function(list, reporter) {
        var group, i, item, key, len, ref, ref1, value;
        group = new Map();
        for (i = 0, len = list.length; i < len; i++) {
          item = list[i];
          key = (ref = getOriginKey(group, reporter(item))) != null ? ref : reporter(item);
          value = (ref1 = group.get(key)) != null ? ref1 : [];
          value.push(item);
          group.set(key, value);
        }
        return group;
      };
      return {
        name: extensionName,
        prims: {
          "CLEAR": clear,
          "COUNTS": counts,
          "GROUP-AGENTS": groupAgents,
          "GROUP-ITEMS": groupItems,
          "FROM-LIST": fromList,
          "GET": get,
          "GET-OR-DEFAULT": getOrDefault,
          "HAS-KEY?": hasKey,
          "KEYS": keys,
          "LENGTH": length,
          "MAKE": make,
          "PUT": put,
          "REMOVE": remove,
          "TO-LIST": toList,
          "VALUES": values,
          "IS-TABLE?": isTable
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter"}],"i18n/en_us":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var bundle;

  bundle = {
    // Math Prims
    'atan is undefined when both inputs are zero.': function() {
      return "atan is undefined when both inputs are zero.";
    },
    '_ isn_t a valid base for a logarithm.': function(b) {
      return `${b} isn't a valid base for a logarithm.`;
    },
    'The square root of _ is an imaginary number.': function(n) {
      return `The square root of ${n} is an imaginary number.`;
    },
    'math operation produced a non-number': function() {
      return "math operation produced a non-number";
    },
    'math operation produced a number too large for NetLogo': function() {
      return "math operation produced a number too large for NetLogo";
    },
    'Division by zero.': function() {
      return "Division by zero.";
    },
    'Can_t take logarithm of _.': function(n) {
      return `Can't take logarithm of ${n}.`;
    },
    'random-normal_s second input can_t be negative.': function() {
      return "random-normal's second input can't be negative.";
    },
    'Both Inputs to RANDOM-GAMMA must be positive.': function() {
      return "Both Inputs to RANDOM-GAMMA must be positive.";
    },
    '_ is not in the allowable range for random seeds (-2147483648 to 2147483647)': function(n) {
      return `${n} is not in the allowable range for random seeds (-2147483648 to 2147483647)`;
    },
    '_ is too large to be represented exactly as an integer in NetLogo': function(n) {
      return `${n} is too large to be represented exactly as an integer in NetLogo`;
    },
    '_ expected input to be _ but got _ instead.': function(prim, expectedType, actualType) {
      return `${prim} expected input to be ${expectedType} but got ${actualType} instead.`;
    },
    'List is empty.': function() {
      return "List is empty.";
    },
    'Can_t find element _ of the _ _, which is only of length _.': function(n, type, list, length) {
      return `Can't find element ${n} of the ${type} ${list}, which is only of length ${length}.`;
    },
    'The list argument to reduce must not be empty.': function() {
      return "The list argument to reduce must not be empty.";
    },
    '_ is greater than the length of the input list (_).': function(endIndex, listLength) {
      return `${endIndex} is greater than the length of the input list (${listLength}).`;
    },
    '_ is less than zero.': function(index) {
      return `${index} is less than zero.`;
    },
    '_ is less than _.': function(endIndex, startIndex) {
      return `${endIndex} is less than ${startIndex}.`;
    },
    '_ got an empty _ as input.': function(prim, type) {
      return `${prim} got an empty ${type} as input.`;
    },
    '_ isn_t greater than or equal to zero.': function(index) {
      return `${index} isn't greater than or equal to zero.`;
    },
    'Can_t find the _ of a list with no numbers: __': function(aspect, list, punc) {
      return `Can't find the ${aspect} of a list with no numbers: ${list}${punc}`;
    },
    'Requested _ random items from a list of length _.': function(count, length) {
      return `Requested ${count} random items from a list of length ${length}.`;
    },
    'Requested _ random agents from a set of only _ agents.': function(count, size) {
      return `Requested ${count} random agents from a set of only ${size} agents.`;
    },
    'Can_t find the _ of a list without at least two numbers: __': function(aspect, list, punc) {
      return `Can't find the ${aspect} of a list without at least two numbers: ${list}${punc}`;
    },
    'Invalid list of points: _': function(points) {
      return `Invalid list of points: ${points}`;
    },
    'Requested _ random agents from a set of only _ agents.': function(n, size) {
      return `Requested ${n} random agents from a set of only ${size} agents.`;
    },
    'First input to _ can_t be negative.': function(prim) {
      return `First input to ${prim} can't be negative.`;
    },
    '_ expected a true/false value from _, but got _ instead.': function(prim, item, value) {
      return `${prim} expected a true/false value from ${item}, but got ${value} instead.`;
    },
    '_-SET expected input to be a _ agentset or _ but got _ instead.': function(prim, agentType, value) {
      return `${prim}-SET expected input to be a ${agentType} agentset or ${agentType} but got ${value} instead.`;
    },
    'List inputs to _-SET must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.': function(prim, agentType, list, value) {
      return `List inputs to ${prim}-SET must only contain ${agentType}, ${agentType} agentset, or list elements.  The list ${list} contained ${value} which is NOT a ${agentType} or ${agentType} agentset.`;
    },
    'List inputs to _-SET must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.': function(prim, agentType, list, value) {
      return `List inputs to ${prim}-SET must only contain ${agentType}, ${agentType} agentset, or list elements.  The list ${list} contained a different type agentset: ${value}.`;
    },
    'SORT-ON works on numbers, strings, or agents of the same type, but not on _ and _': function(type1, type2) {
      return `SORT-ON works on numbers, strings, or agents of the same type, but not on ${type1} and ${type2}`;
    }
  };

  module.exports = bundle;

}).call(this);

},{}],"i18n/i18n-bundle":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var EN_US, I18nBundle;

  EN_US = require('./en_us');

  I18nBundle = (function() {
    var _current;

    // At the moment this doesn't do much but it'd be a good place to add
    // the ability to swap the current locale as needed.
    // -Jeremy B November 2020
    class I18nBundle {
      constructor() {
        this._current = EN_US;
      }

      get(key, ...args) {
        var bundle, message;
        bundle = (function() {
          if (this._current.hasOwnProperty(key)) {
            return this._current;
          } else if (this._current !== EN_US && EN_US.hasOwnProperty(key)) {
            return EN_US;
          } else {
            throw new Error(`Could not find a message for this key: ${key}`);
          }
        }).call(this);
        message = bundle[key];
        return message(...args);
      }

    };

    _current = null;

    return I18nBundle;

  }).call(this);

  module.exports = I18nBundle;

}).call(this);

},{"./en_us":"i18n/en_us"}],"meta":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    isApplet: false,
    isWeb: true,
    behaviorSpaceName: "",
    behaviorSpaceRun: 0,
    // for any explorer who finds this and is wanting to update the `netlogo-version`, know that this is just a placeholder
    // and should be overwritten by a version provided to the workspace via `modelConfig`.  -JMB March 2018
    version: "1.0"
  };

}).call(this);

},{}],"mori":[function(require,module,exports){
(function(definition){if(typeof exports==="object"){module.exports=definition();}else if(typeof define==="function"&&define.amd){define(definition);}else{mori=definition();}})(function(){return function(){
if(typeof Math.imul == "undefined" || (Math.imul(0xffffffff,5) == 0)) {
    Math.imul = function (a, b) {
        var ah  = (a >>> 16) & 0xffff;
        var al = a & 0xffff;
        var bh  = (b >>> 16) & 0xffff;
        var bl = b & 0xffff;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
    }
}

var k,aa=this;
function n(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}var ba="closure_uid_"+(1E9*Math.random()>>>0),ca=0;function r(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d=d[e]?d[e]:d[e]={}:d[e]=b};function da(a){return Array.prototype.join.call(arguments,"")};function ea(a,b){for(var c in a)b.call(void 0,a[c],c,a)};function fa(a,b){null!=a&&this.append.apply(this,arguments)}fa.prototype.Za="";fa.prototype.append=function(a,b,c){this.Za+=a;if(null!=b)for(var d=1;d<arguments.length;d++)this.Za+=arguments[d];return this};fa.prototype.clear=function(){this.Za=""};fa.prototype.toString=function(){return this.Za};function ga(a,b){a.sort(b||ha)}function ia(a,b){for(var c=0;c<a.length;c++)a[c]={index:c,value:a[c]};var d=b||ha;ga(a,function(a,b){return d(a.value,b.value)||a.index-b.index});for(c=0;c<a.length;c++)a[c]=a[c].value}function ha(a,b){return a>b?1:a<b?-1:0};var ja;if("undefined"===typeof ka)var ka=function(){throw Error("No *print-fn* fn set for evaluation environment");};var la=null,ma=null;if("undefined"===typeof na)var na=null;function oa(){return new pa(null,5,[sa,!0,ua,!0,wa,!1,ya,!1,za,la],null)}function t(a){return null!=a&&!1!==a}function Aa(a){return t(a)?!1:!0}function w(a,b){return a[n(null==b?null:b)]?!0:a._?!0:!1}function Ba(a){return null==a?null:a.constructor}
function x(a,b){var c=Ba(b),c=t(t(c)?c.Yb:c)?c.Xb:n(b);return Error(["No protocol method ",a," defined for type ",c,": ",b].join(""))}function Da(a){var b=a.Xb;return t(b)?b:""+z(a)}var Ea="undefined"!==typeof Symbol&&"function"===n(Symbol)?Symbol.Cc:"@@iterator";function Fa(a){for(var b=a.length,c=Array(b),d=0;;)if(d<b)c[d]=a[d],d+=1;else break;return c}function Ha(a){for(var b=Array(arguments.length),c=0;;)if(c<b.length)b[c]=arguments[c],c+=1;else return b}
var Ia=function(){function a(a,b){function c(a,b){a.push(b);return a}var g=[];return A.c?A.c(c,g,b):A.call(null,c,g,b)}function b(a){return c.a(null,a)}var c=null,c=function(d,c){switch(arguments.length){case 1:return b.call(this,d);case 2:return a.call(this,0,c)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Ja={},La={};function Ma(a){if(a?a.L:a)return a.L(a);var b;b=Ma[n(null==a?null:a)];if(!b&&(b=Ma._,!b))throw x("ICounted.-count",a);return b.call(null,a)}
function Na(a){if(a?a.J:a)return a.J(a);var b;b=Na[n(null==a?null:a)];if(!b&&(b=Na._,!b))throw x("IEmptyableCollection.-empty",a);return b.call(null,a)}var Qa={};function Ra(a,b){if(a?a.G:a)return a.G(a,b);var c;c=Ra[n(null==a?null:a)];if(!c&&(c=Ra._,!c))throw x("ICollection.-conj",a);return c.call(null,a,b)}
var Ta={},C=function(){function a(a,b,c){if(a?a.$:a)return a.$(a,b,c);var g;g=C[n(null==a?null:a)];if(!g&&(g=C._,!g))throw x("IIndexed.-nth",a);return g.call(null,a,b,c)}function b(a,b){if(a?a.Q:a)return a.Q(a,b);var c;c=C[n(null==a?null:a)];if(!c&&(c=C._,!c))throw x("IIndexed.-nth",a);return c.call(null,a,b)}var c=null,c=function(d,c,f){switch(arguments.length){case 2:return b.call(this,d,c);case 3:return a.call(this,d,c,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),
Ua={};function Va(a){if(a?a.N:a)return a.N(a);var b;b=Va[n(null==a?null:a)];if(!b&&(b=Va._,!b))throw x("ISeq.-first",a);return b.call(null,a)}function Wa(a){if(a?a.S:a)return a.S(a);var b;b=Wa[n(null==a?null:a)];if(!b&&(b=Wa._,!b))throw x("ISeq.-rest",a);return b.call(null,a)}
var Xa={},Za={},$a=function(){function a(a,b,c){if(a?a.s:a)return a.s(a,b,c);var g;g=$a[n(null==a?null:a)];if(!g&&(g=$a._,!g))throw x("ILookup.-lookup",a);return g.call(null,a,b,c)}function b(a,b){if(a?a.t:a)return a.t(a,b);var c;c=$a[n(null==a?null:a)];if(!c&&(c=$a._,!c))throw x("ILookup.-lookup",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=
a;return c}(),ab={};function bb(a,b){if(a?a.rb:a)return a.rb(a,b);var c;c=bb[n(null==a?null:a)];if(!c&&(c=bb._,!c))throw x("IAssociative.-contains-key?",a);return c.call(null,a,b)}function cb(a,b,c){if(a?a.Ka:a)return a.Ka(a,b,c);var d;d=cb[n(null==a?null:a)];if(!d&&(d=cb._,!d))throw x("IAssociative.-assoc",a);return d.call(null,a,b,c)}var db={};function eb(a,b){if(a?a.wb:a)return a.wb(a,b);var c;c=eb[n(null==a?null:a)];if(!c&&(c=eb._,!c))throw x("IMap.-dissoc",a);return c.call(null,a,b)}var fb={};
function hb(a){if(a?a.hb:a)return a.hb(a);var b;b=hb[n(null==a?null:a)];if(!b&&(b=hb._,!b))throw x("IMapEntry.-key",a);return b.call(null,a)}function ib(a){if(a?a.ib:a)return a.ib(a);var b;b=ib[n(null==a?null:a)];if(!b&&(b=ib._,!b))throw x("IMapEntry.-val",a);return b.call(null,a)}var jb={};function kb(a,b){if(a?a.Eb:a)return a.Eb(a,b);var c;c=kb[n(null==a?null:a)];if(!c&&(c=kb._,!c))throw x("ISet.-disjoin",a);return c.call(null,a,b)}
function lb(a){if(a?a.La:a)return a.La(a);var b;b=lb[n(null==a?null:a)];if(!b&&(b=lb._,!b))throw x("IStack.-peek",a);return b.call(null,a)}function mb(a){if(a?a.Ma:a)return a.Ma(a);var b;b=mb[n(null==a?null:a)];if(!b&&(b=mb._,!b))throw x("IStack.-pop",a);return b.call(null,a)}var nb={};function pb(a,b,c){if(a?a.Ua:a)return a.Ua(a,b,c);var d;d=pb[n(null==a?null:a)];if(!d&&(d=pb._,!d))throw x("IVector.-assoc-n",a);return d.call(null,a,b,c)}
function qb(a){if(a?a.Ra:a)return a.Ra(a);var b;b=qb[n(null==a?null:a)];if(!b&&(b=qb._,!b))throw x("IDeref.-deref",a);return b.call(null,a)}var rb={};function sb(a){if(a?a.H:a)return a.H(a);var b;b=sb[n(null==a?null:a)];if(!b&&(b=sb._,!b))throw x("IMeta.-meta",a);return b.call(null,a)}var tb={};function ub(a,b){if(a?a.F:a)return a.F(a,b);var c;c=ub[n(null==a?null:a)];if(!c&&(c=ub._,!c))throw x("IWithMeta.-with-meta",a);return c.call(null,a,b)}
var vb={},wb=function(){function a(a,b,c){if(a?a.O:a)return a.O(a,b,c);var g;g=wb[n(null==a?null:a)];if(!g&&(g=wb._,!g))throw x("IReduce.-reduce",a);return g.call(null,a,b,c)}function b(a,b){if(a?a.R:a)return a.R(a,b);var c;c=wb[n(null==a?null:a)];if(!c&&(c=wb._,!c))throw x("IReduce.-reduce",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();
function xb(a,b,c){if(a?a.gb:a)return a.gb(a,b,c);var d;d=xb[n(null==a?null:a)];if(!d&&(d=xb._,!d))throw x("IKVReduce.-kv-reduce",a);return d.call(null,a,b,c)}function yb(a,b){if(a?a.A:a)return a.A(a,b);var c;c=yb[n(null==a?null:a)];if(!c&&(c=yb._,!c))throw x("IEquiv.-equiv",a);return c.call(null,a,b)}function zb(a){if(a?a.B:a)return a.B(a);var b;b=zb[n(null==a?null:a)];if(!b&&(b=zb._,!b))throw x("IHash.-hash",a);return b.call(null,a)}var Bb={};
function Cb(a){if(a?a.D:a)return a.D(a);var b;b=Cb[n(null==a?null:a)];if(!b&&(b=Cb._,!b))throw x("ISeqable.-seq",a);return b.call(null,a)}var Db={},Eb={},Fb={};function Gb(a){if(a?a.ab:a)return a.ab(a);var b;b=Gb[n(null==a?null:a)];if(!b&&(b=Gb._,!b))throw x("IReversible.-rseq",a);return b.call(null,a)}function Hb(a,b){if(a?a.Hb:a)return a.Hb(a,b);var c;c=Hb[n(null==a?null:a)];if(!c&&(c=Hb._,!c))throw x("ISorted.-sorted-seq",a);return c.call(null,a,b)}
function Ib(a,b,c){if(a?a.Ib:a)return a.Ib(a,b,c);var d;d=Ib[n(null==a?null:a)];if(!d&&(d=Ib._,!d))throw x("ISorted.-sorted-seq-from",a);return d.call(null,a,b,c)}function Jb(a,b){if(a?a.Gb:a)return a.Gb(a,b);var c;c=Jb[n(null==a?null:a)];if(!c&&(c=Jb._,!c))throw x("ISorted.-entry-key",a);return c.call(null,a,b)}function Kb(a){if(a?a.Fb:a)return a.Fb(a);var b;b=Kb[n(null==a?null:a)];if(!b&&(b=Kb._,!b))throw x("ISorted.-comparator",a);return b.call(null,a)}
function Lb(a,b){if(a?a.Wb:a)return a.Wb(0,b);var c;c=Lb[n(null==a?null:a)];if(!c&&(c=Lb._,!c))throw x("IWriter.-write",a);return c.call(null,a,b)}var Mb={};function Nb(a,b,c){if(a?a.v:a)return a.v(a,b,c);var d;d=Nb[n(null==a?null:a)];if(!d&&(d=Nb._,!d))throw x("IPrintWithWriter.-pr-writer",a);return d.call(null,a,b,c)}function Ob(a){if(a?a.$a:a)return a.$a(a);var b;b=Ob[n(null==a?null:a)];if(!b&&(b=Ob._,!b))throw x("IEditableCollection.-as-transient",a);return b.call(null,a)}
function Pb(a,b){if(a?a.Sa:a)return a.Sa(a,b);var c;c=Pb[n(null==a?null:a)];if(!c&&(c=Pb._,!c))throw x("ITransientCollection.-conj!",a);return c.call(null,a,b)}function Qb(a){if(a?a.Ta:a)return a.Ta(a);var b;b=Qb[n(null==a?null:a)];if(!b&&(b=Qb._,!b))throw x("ITransientCollection.-persistent!",a);return b.call(null,a)}function Rb(a,b,c){if(a?a.kb:a)return a.kb(a,b,c);var d;d=Rb[n(null==a?null:a)];if(!d&&(d=Rb._,!d))throw x("ITransientAssociative.-assoc!",a);return d.call(null,a,b,c)}
function Sb(a,b){if(a?a.Jb:a)return a.Jb(a,b);var c;c=Sb[n(null==a?null:a)];if(!c&&(c=Sb._,!c))throw x("ITransientMap.-dissoc!",a);return c.call(null,a,b)}function Tb(a,b,c){if(a?a.Ub:a)return a.Ub(0,b,c);var d;d=Tb[n(null==a?null:a)];if(!d&&(d=Tb._,!d))throw x("ITransientVector.-assoc-n!",a);return d.call(null,a,b,c)}function Ub(a){if(a?a.Vb:a)return a.Vb();var b;b=Ub[n(null==a?null:a)];if(!b&&(b=Ub._,!b))throw x("ITransientVector.-pop!",a);return b.call(null,a)}
function Vb(a,b){if(a?a.Tb:a)return a.Tb(0,b);var c;c=Vb[n(null==a?null:a)];if(!c&&(c=Vb._,!c))throw x("ITransientSet.-disjoin!",a);return c.call(null,a,b)}function Xb(a){if(a?a.Pb:a)return a.Pb();var b;b=Xb[n(null==a?null:a)];if(!b&&(b=Xb._,!b))throw x("IChunk.-drop-first",a);return b.call(null,a)}function Yb(a){if(a?a.Cb:a)return a.Cb(a);var b;b=Yb[n(null==a?null:a)];if(!b&&(b=Yb._,!b))throw x("IChunkedSeq.-chunked-first",a);return b.call(null,a)}
function Zb(a){if(a?a.Db:a)return a.Db(a);var b;b=Zb[n(null==a?null:a)];if(!b&&(b=Zb._,!b))throw x("IChunkedSeq.-chunked-rest",a);return b.call(null,a)}function $b(a){if(a?a.Bb:a)return a.Bb(a);var b;b=$b[n(null==a?null:a)];if(!b&&(b=$b._,!b))throw x("IChunkedNext.-chunked-next",a);return b.call(null,a)}function ac(a,b){if(a?a.bb:a)return a.bb(0,b);var c;c=ac[n(null==a?null:a)];if(!c&&(c=ac._,!c))throw x("IVolatile.-vreset!",a);return c.call(null,a,b)}var bc={};
function cc(a){if(a?a.fb:a)return a.fb(a);var b;b=cc[n(null==a?null:a)];if(!b&&(b=cc._,!b))throw x("IIterable.-iterator",a);return b.call(null,a)}function dc(a){this.qc=a;this.q=0;this.j=1073741824}dc.prototype.Wb=function(a,b){return this.qc.append(b)};function ec(a){var b=new fa;a.v(null,new dc(b),oa());return""+z(b)}
var fc="undefined"!==typeof Math.imul&&0!==(Math.imul.a?Math.imul.a(4294967295,5):Math.imul.call(null,4294967295,5))?function(a,b){return Math.imul.a?Math.imul.a(a,b):Math.imul.call(null,a,b)}:function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0};function gc(a){a=fc(a,3432918353);return fc(a<<15|a>>>-15,461845907)}function hc(a,b){var c=a^b;return fc(c<<13|c>>>-13,5)+3864292196}
function ic(a,b){var c=a^b,c=fc(c^c>>>16,2246822507),c=fc(c^c>>>13,3266489909);return c^c>>>16}var kc={},lc=0;function mc(a){255<lc&&(kc={},lc=0);var b=kc[a];if("number"!==typeof b){a:if(null!=a)if(b=a.length,0<b){for(var c=0,d=0;;)if(c<b)var e=c+1,d=fc(31,d)+a.charCodeAt(c),c=e;else{b=d;break a}b=void 0}else b=0;else b=0;kc[a]=b;lc+=1}return a=b}
function nc(a){a&&(a.j&4194304||a.vc)?a=a.B(null):"number"===typeof a?a=(Math.floor.b?Math.floor.b(a):Math.floor.call(null,a))%2147483647:!0===a?a=1:!1===a?a=0:"string"===typeof a?(a=mc(a),0!==a&&(a=gc(a),a=hc(0,a),a=ic(a,4))):a=a instanceof Date?a.valueOf():null==a?0:zb(a);return a}
function oc(a){var b;b=a.name;var c;a:{c=1;for(var d=0;;)if(c<b.length){var e=c+2,d=hc(d,gc(b.charCodeAt(c-1)|b.charCodeAt(c)<<16));c=e}else{c=d;break a}c=void 0}c=1===(b.length&1)?c^gc(b.charCodeAt(b.length-1)):c;b=ic(c,fc(2,b.length));a=mc(a.ba);return b^a+2654435769+(b<<6)+(b>>2)}function pc(a,b){if(a.ta===b.ta)return 0;var c=Aa(a.ba);if(t(c?b.ba:c))return-1;if(t(a.ba)){if(Aa(b.ba))return 1;c=ha(a.ba,b.ba);return 0===c?ha(a.name,b.name):c}return ha(a.name,b.name)}
function qc(a,b,c,d,e){this.ba=a;this.name=b;this.ta=c;this.Ya=d;this.Z=e;this.j=2154168321;this.q=4096}k=qc.prototype;k.v=function(a,b){return Lb(b,this.ta)};k.B=function(){var a=this.Ya;return null!=a?a:this.Ya=a=oc(this)};k.F=function(a,b){return new qc(this.ba,this.name,this.ta,this.Ya,b)};k.H=function(){return this.Z};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return $a.c(c,this,null);case 3:return $a.c(c,this,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return $a.c(c,this,null)};a.c=function(a,c,d){return $a.c(c,this,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return $a.c(a,this,null)};k.a=function(a,b){return $a.c(a,this,b)};k.A=function(a,b){return b instanceof qc?this.ta===b.ta:!1};
k.toString=function(){return this.ta};var rc=function(){function a(a,b){var c=null!=a?[z(a),z("/"),z(b)].join(""):b;return new qc(a,b,c,null,null)}function b(a){return a instanceof qc?a:c.a(null,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();
function D(a){if(null==a)return null;if(a&&(a.j&8388608||a.mc))return a.D(null);if(a instanceof Array||"string"===typeof a)return 0===a.length?null:new F(a,0);if(w(Bb,a))return Cb(a);throw Error([z(a),z(" is not ISeqable")].join(""));}function G(a){if(null==a)return null;if(a&&(a.j&64||a.jb))return a.N(null);a=D(a);return null==a?null:Va(a)}function H(a){return null!=a?a&&(a.j&64||a.jb)?a.S(null):(a=D(a))?Wa(a):J:J}function K(a){return null==a?null:a&&(a.j&128||a.xb)?a.T(null):D(H(a))}
var sc=function(){function a(a,b){return null==a?null==b:a===b||yb(a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;)if(b.a(a,d))if(K(e))a=d,d=G(e),e=K(e);else return b.a(d,G(e));else return!1}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return!0;
case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(){return!0};b.a=a;b.d=c.d;return b}();function tc(a){this.C=a}tc.prototype.next=function(){if(null!=this.C){var a=G(this.C);this.C=K(this.C);return{done:!1,value:a}}return{done:!0,value:null}};function uc(a){return new tc(D(a))}
function vc(a,b){var c=gc(a),c=hc(0,c);return ic(c,b)}function wc(a){var b=0,c=1;for(a=D(a);;)if(null!=a)b+=1,c=fc(31,c)+nc(G(a))|0,a=K(a);else return vc(c,b)}function xc(a){var b=0,c=0;for(a=D(a);;)if(null!=a)b+=1,c=c+nc(G(a))|0,a=K(a);else return vc(c,b)}La["null"]=!0;Ma["null"]=function(){return 0};Date.prototype.A=function(a,b){return b instanceof Date&&this.toString()===b.toString()};yb.number=function(a,b){return a===b};rb["function"]=!0;sb["function"]=function(){return null};
Ja["function"]=!0;zb._=function(a){return a[ba]||(a[ba]=++ca)};function yc(a){this.o=a;this.q=0;this.j=32768}yc.prototype.Ra=function(){return this.o};function Ac(a){return a instanceof yc}function Bc(a){return Ac(a)?L.b?L.b(a):L.call(null,a):a}function L(a){return qb(a)}
var Cc=function(){function a(a,b,c,d){for(var l=Ma(a);;)if(d<l){var m=C.a(a,d);c=b.a?b.a(c,m):b.call(null,c,m);if(Ac(c))return qb(c);d+=1}else return c}function b(a,b,c){var d=Ma(a),l=c;for(c=0;;)if(c<d){var m=C.a(a,c),l=b.a?b.a(l,m):b.call(null,l,m);if(Ac(l))return qb(l);c+=1}else return l}function c(a,b){var c=Ma(a);if(0===c)return b.l?b.l():b.call(null);for(var d=C.a(a,0),l=1;;)if(l<c){var m=C.a(a,l),d=b.a?b.a(d,m):b.call(null,d,m);if(Ac(d))return qb(d);l+=1}else return d}var d=null,d=function(d,
f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),Dc=function(){function a(a,b,c,d){for(var l=a.length;;)if(d<l){var m=a[d];c=b.a?b.a(c,m):b.call(null,c,m);if(Ac(c))return qb(c);d+=1}else return c}function b(a,b,c){var d=a.length,l=c;for(c=0;;)if(c<d){var m=a[c],l=b.a?b.a(l,m):b.call(null,l,m);if(Ac(l))return qb(l);c+=1}else return l}function c(a,
b){var c=a.length;if(0===a.length)return b.l?b.l():b.call(null);for(var d=a[0],l=1;;)if(l<c){var m=a[l],d=b.a?b.a(d,m):b.call(null,d,m);if(Ac(d))return qb(d);l+=1}else return d}var d=null,d=function(d,f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}();function Ec(a){return a?a.j&2||a.cc?!0:a.j?!1:w(La,a):w(La,a)}
function Fc(a){return a?a.j&16||a.Qb?!0:a.j?!1:w(Ta,a):w(Ta,a)}function Gc(a,b){this.e=a;this.m=b}Gc.prototype.ga=function(){return this.m<this.e.length};Gc.prototype.next=function(){var a=this.e[this.m];this.m+=1;return a};function F(a,b){this.e=a;this.m=b;this.j=166199550;this.q=8192}k=F.prototype;k.toString=function(){return ec(this)};k.Q=function(a,b){var c=b+this.m;return c<this.e.length?this.e[c]:null};k.$=function(a,b,c){a=b+this.m;return a<this.e.length?this.e[a]:c};k.vb=!0;
k.fb=function(){return new Gc(this.e,this.m)};k.T=function(){return this.m+1<this.e.length?new F(this.e,this.m+1):null};k.L=function(){return this.e.length-this.m};k.ab=function(){var a=Ma(this);return 0<a?new Hc(this,a-1,null):null};k.B=function(){return wc(this)};k.A=function(a,b){return Ic.a?Ic.a(this,b):Ic.call(null,this,b)};k.J=function(){return J};k.R=function(a,b){return Dc.n(this.e,b,this.e[this.m],this.m+1)};k.O=function(a,b,c){return Dc.n(this.e,b,c,this.m)};k.N=function(){return this.e[this.m]};
k.S=function(){return this.m+1<this.e.length?new F(this.e,this.m+1):J};k.D=function(){return this};k.G=function(a,b){return M.a?M.a(b,this):M.call(null,b,this)};F.prototype[Ea]=function(){return uc(this)};
var Jc=function(){function a(a,b){return b<a.length?new F(a,b):null}function b(a){return c.a(a,0)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Kc=function(){function a(a,b){return Jc.a(a,b)}function b(a){return Jc.a(a,0)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+
arguments.length);};c.b=b;c.a=a;return c}();function Hc(a,b,c){this.qb=a;this.m=b;this.k=c;this.j=32374990;this.q=8192}k=Hc.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){return 0<this.m?new Hc(this.qb,this.m-1,null):null};k.L=function(){return this.m+1};k.B=function(){return wc(this)};k.A=function(a,b){return Ic.a?Ic.a(this,b):Ic.call(null,this,b)};k.J=function(){var a=this.k;return O.a?O.a(J,a):O.call(null,J,a)};
k.R=function(a,b){return P.a?P.a(b,this):P.call(null,b,this)};k.O=function(a,b,c){return P.c?P.c(b,c,this):P.call(null,b,c,this)};k.N=function(){return C.a(this.qb,this.m)};k.S=function(){return 0<this.m?new Hc(this.qb,this.m-1,null):J};k.D=function(){return this};k.F=function(a,b){return new Hc(this.qb,this.m,b)};k.G=function(a,b){return M.a?M.a(b,this):M.call(null,b,this)};Hc.prototype[Ea]=function(){return uc(this)};function Lc(a){return G(K(a))}yb._=function(a,b){return a===b};
var Nc=function(){function a(a,b){return null!=a?Ra(a,b):Ra(J,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;)if(t(e))a=b.a(a,d),d=G(e),e=K(e);else return b.a(a,d)}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return Mc;case 1:return b;
case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.l=function(){return Mc};b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Oc(a){return null==a?null:Na(a)}
function Q(a){if(null!=a)if(a&&(a.j&2||a.cc))a=a.L(null);else if(a instanceof Array)a=a.length;else if("string"===typeof a)a=a.length;else if(w(La,a))a=Ma(a);else a:{a=D(a);for(var b=0;;){if(Ec(a)){a=b+Ma(a);break a}a=K(a);b+=1}a=void 0}else a=0;return a}
var Pc=function(){function a(a,b,c){for(;;){if(null==a)return c;if(0===b)return D(a)?G(a):c;if(Fc(a))return C.c(a,b,c);if(D(a))a=K(a),b-=1;else return c}}function b(a,b){for(;;){if(null==a)throw Error("Index out of bounds");if(0===b){if(D(a))return G(a);throw Error("Index out of bounds");}if(Fc(a))return C.a(a,b);if(D(a)){var c=K(a),g=b-1;a=c;b=g}else throw Error("Index out of bounds");}}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,
c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),R=function(){function a(a,b,c){if("number"!==typeof b)throw Error("index argument to nth must be a number.");if(null==a)return c;if(a&&(a.j&16||a.Qb))return a.$(null,b,c);if(a instanceof Array||"string"===typeof a)return b<a.length?a[b]:c;if(w(Ta,a))return C.a(a,b);if(a?a.j&64||a.jb||(a.j?0:w(Ua,a)):w(Ua,a))return Pc.c(a,b,c);throw Error([z("nth not supported on this type "),z(Da(Ba(a)))].join(""));}function b(a,b){if("number"!==
typeof b)throw Error("index argument to nth must be a number");if(null==a)return a;if(a&&(a.j&16||a.Qb))return a.Q(null,b);if(a instanceof Array||"string"===typeof a)return b<a.length?a[b]:null;if(w(Ta,a))return C.a(a,b);if(a?a.j&64||a.jb||(a.j?0:w(Ua,a)):w(Ua,a))return Pc.a(a,b);throw Error([z("nth not supported on this type "),z(Da(Ba(a)))].join(""));}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+
arguments.length);};c.a=b;c.c=a;return c}(),S=function(){function a(a,b,c){return null!=a?a&&(a.j&256||a.Rb)?a.s(null,b,c):a instanceof Array?b<a.length?a[b]:c:"string"===typeof a?b<a.length?a[b]:c:w(Za,a)?$a.c(a,b,c):c:c}function b(a,b){return null==a?null:a&&(a.j&256||a.Rb)?a.t(null,b):a instanceof Array?b<a.length?a[b]:null:"string"===typeof a?b<a.length?a[b]:null:w(Za,a)?$a.a(a,b):null}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,
c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),Rc=function(){function a(a,b,c){if(null!=a)a=cb(a,b,c);else a:{a=[b];c=[c];b=a.length;for(var g=0,h=Ob(Qc);;)if(g<b)var l=g+1,h=h.kb(null,a[g],c[g]),g=l;else{a=Qb(h);break a}a=void 0}return a}var b=null,c=function(){function a(b,d,h,l){var m=null;if(3<arguments.length){for(var m=0,p=Array(arguments.length-3);m<p.length;)p[m]=arguments[m+3],++m;m=new F(p,0)}return c.call(this,b,d,h,m)}function c(a,d,e,l){for(;;)if(a=b.c(a,
d,e),t(l))d=G(l),e=Lc(l),l=K(K(l));else return a}a.i=3;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=K(a);var l=G(a);a=H(a);return c(b,d,l,a)};a.d=c;return a}(),b=function(b,e,f,g){switch(arguments.length){case 3:return a.call(this,b,e,f);default:var h=null;if(3<arguments.length){for(var h=0,l=Array(arguments.length-3);h<l.length;)l[h]=arguments[h+3],++h;h=new F(l,0)}return c.d(b,e,f,h)}throw Error("Invalid arity: "+arguments.length);};b.i=3;b.f=c.f;b.c=a;b.d=c.d;return b}(),Sc=function(){function a(a,
b){return null==a?null:eb(a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;){if(null==a)return null;a=b.a(a,d);if(t(e))d=G(e),e=K(e);else return a}}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);
default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Tc(a){var b="function"==n(a);return t(b)?b:a?t(t(null)?null:a.bc)?!0:a.yb?!1:w(Ja,a):w(Ja,a)}function Uc(a,b){this.h=a;this.k=b;this.q=0;this.j=393217}k=Uc.prototype;
k.call=function(){function a(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra,I){a=this.h;return T.ub?T.ub(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra,I):T.call(null,a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra,I)}function b(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra){a=this;return a.h.Fa?a.h.Fa(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra)}function c(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y){a=this;return a.h.Ea?a.h.Ea(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,
Y):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y)}function d(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N){a=this;return a.h.Da?a.h.Da(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N)}function e(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E){a=this;return a.h.Ca?a.h.Ca(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E)}function f(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B){a=this;return a.h.Ba?a.h.Ba(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B):a.h.call(null,
b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B)}function g(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y){a=this;return a.h.Aa?a.h.Aa(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y)}function h(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v){a=this;return a.h.za?a.h.za(b,c,d,e,f,g,h,l,m,p,q,u,s,v):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v)}function l(a,b,c,d,e,f,g,h,l,m,p,q,u,s){a=this;return a.h.ya?a.h.ya(b,c,d,e,f,g,h,l,m,p,q,u,s):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s)}function m(a,b,c,d,e,f,g,h,l,m,p,q,u){a=this;
return a.h.xa?a.h.xa(b,c,d,e,f,g,h,l,m,p,q,u):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u)}function p(a,b,c,d,e,f,g,h,l,m,p,q){a=this;return a.h.wa?a.h.wa(b,c,d,e,f,g,h,l,m,p,q):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q)}function q(a,b,c,d,e,f,g,h,l,m,p){a=this;return a.h.va?a.h.va(b,c,d,e,f,g,h,l,m,p):a.h.call(null,b,c,d,e,f,g,h,l,m,p)}function s(a,b,c,d,e,f,g,h,l,m){a=this;return a.h.Ha?a.h.Ha(b,c,d,e,f,g,h,l,m):a.h.call(null,b,c,d,e,f,g,h,l,m)}function u(a,b,c,d,e,f,g,h,l){a=this;return a.h.Ga?a.h.Ga(b,c,
d,e,f,g,h,l):a.h.call(null,b,c,d,e,f,g,h,l)}function v(a,b,c,d,e,f,g,h){a=this;return a.h.ia?a.h.ia(b,c,d,e,f,g,h):a.h.call(null,b,c,d,e,f,g,h)}function y(a,b,c,d,e,f,g){a=this;return a.h.P?a.h.P(b,c,d,e,f,g):a.h.call(null,b,c,d,e,f,g)}function B(a,b,c,d,e,f){a=this;return a.h.r?a.h.r(b,c,d,e,f):a.h.call(null,b,c,d,e,f)}function E(a,b,c,d,e){a=this;return a.h.n?a.h.n(b,c,d,e):a.h.call(null,b,c,d,e)}function N(a,b,c,d){a=this;return a.h.c?a.h.c(b,c,d):a.h.call(null,b,c,d)}function Y(a,b,c){a=this;
return a.h.a?a.h.a(b,c):a.h.call(null,b,c)}function ra(a,b){a=this;return a.h.b?a.h.b(b):a.h.call(null,b)}function Pa(a){a=this;return a.h.l?a.h.l():a.h.call(null)}var I=null,I=function(I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De,Wf,dh){switch(arguments.length){case 1:return Pa.call(this,I);case 2:return ra.call(this,I,qa);case 3:return Y.call(this,I,qa,ta);case 4:return N.call(this,I,qa,ta,va);case 5:return E.call(this,I,qa,ta,va,xa);case 6:return B.call(this,I,qa,ta,va,xa,Ca);case 7:return y.call(this,
I,qa,ta,va,xa,Ca,Ga);case 8:return v.call(this,I,qa,ta,va,xa,Ca,Ga,Ka);case 9:return u.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa);case 10:return s.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa);case 11:return q.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya);case 12:return p.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb);case 13:return m.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob);case 14:return l.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab);case 15:return h.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,
ob,Ab,Wb);case 16:return g.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc);case 17:return f.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc);case 18:return e.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc);case 19:return d.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd);case 20:return c.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De);case 21:return b.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De,
Wf);case 22:return a.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De,Wf,dh)}throw Error("Invalid arity: "+arguments.length);};I.b=Pa;I.a=ra;I.c=Y;I.n=N;I.r=E;I.P=B;I.ia=y;I.Ga=v;I.Ha=u;I.va=s;I.wa=q;I.xa=p;I.ya=m;I.za=l;I.Aa=h;I.Ba=g;I.Ca=f;I.Da=e;I.Ea=d;I.Fa=c;I.hc=b;I.ub=a;return I}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.l=function(){return this.h.l?this.h.l():this.h.call(null)};
k.b=function(a){return this.h.b?this.h.b(a):this.h.call(null,a)};k.a=function(a,b){return this.h.a?this.h.a(a,b):this.h.call(null,a,b)};k.c=function(a,b,c){return this.h.c?this.h.c(a,b,c):this.h.call(null,a,b,c)};k.n=function(a,b,c,d){return this.h.n?this.h.n(a,b,c,d):this.h.call(null,a,b,c,d)};k.r=function(a,b,c,d,e){return this.h.r?this.h.r(a,b,c,d,e):this.h.call(null,a,b,c,d,e)};k.P=function(a,b,c,d,e,f){return this.h.P?this.h.P(a,b,c,d,e,f):this.h.call(null,a,b,c,d,e,f)};
k.ia=function(a,b,c,d,e,f,g){return this.h.ia?this.h.ia(a,b,c,d,e,f,g):this.h.call(null,a,b,c,d,e,f,g)};k.Ga=function(a,b,c,d,e,f,g,h){return this.h.Ga?this.h.Ga(a,b,c,d,e,f,g,h):this.h.call(null,a,b,c,d,e,f,g,h)};k.Ha=function(a,b,c,d,e,f,g,h,l){return this.h.Ha?this.h.Ha(a,b,c,d,e,f,g,h,l):this.h.call(null,a,b,c,d,e,f,g,h,l)};k.va=function(a,b,c,d,e,f,g,h,l,m){return this.h.va?this.h.va(a,b,c,d,e,f,g,h,l,m):this.h.call(null,a,b,c,d,e,f,g,h,l,m)};
k.wa=function(a,b,c,d,e,f,g,h,l,m,p){return this.h.wa?this.h.wa(a,b,c,d,e,f,g,h,l,m,p):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p)};k.xa=function(a,b,c,d,e,f,g,h,l,m,p,q){return this.h.xa?this.h.xa(a,b,c,d,e,f,g,h,l,m,p,q):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q)};k.ya=function(a,b,c,d,e,f,g,h,l,m,p,q,s){return this.h.ya?this.h.ya(a,b,c,d,e,f,g,h,l,m,p,q,s):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s)};
k.za=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u){return this.h.za?this.h.za(a,b,c,d,e,f,g,h,l,m,p,q,s,u):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u)};k.Aa=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v){return this.h.Aa?this.h.Aa(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v)};k.Ba=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y){return this.h.Ba?this.h.Ba(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y)};
k.Ca=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B){return this.h.Ca?this.h.Ca(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B)};k.Da=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E){return this.h.Da?this.h.Da(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E)};
k.Ea=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N){return this.h.Ea?this.h.Ea(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N)};k.Fa=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y){return this.h.Fa?this.h.Fa(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y)};
k.hc=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra){var Pa=this.h;return T.ub?T.ub(Pa,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra):T.call(null,Pa,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra)};k.bc=!0;k.F=function(a,b){return new Uc(this.h,b)};k.H=function(){return this.k};function O(a,b){return Tc(a)&&!(a?a.j&262144||a.Bc||(a.j?0:w(tb,a)):w(tb,a))?new Uc(a,b):null==a?null:ub(a,b)}function Vc(a){var b=null!=a;return(b?a?a.j&131072||a.kc||(a.j?0:w(rb,a)):w(rb,a):b)?sb(a):null}
function Wc(a){return null==a?null:lb(a)}
var Xc=function(){function a(a,b){return null==a?null:kb(a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;){if(null==a)return null;a=b.a(a,d);if(t(e))d=G(e),e=K(e);else return a}}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,
b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Yc(a){return null==a||Aa(D(a))}function $c(a){return null==a?!1:a?a.j&8||a.tc?!0:a.j?!1:w(Qa,a):w(Qa,a)}function ad(a){return null==a?!1:a?a.j&4096||a.zc?!0:a.j?!1:w(jb,a):w(jb,a)}
function bd(a){return a?a.j&512||a.rc?!0:a.j?!1:w(ab,a):w(ab,a)}function cd(a){return a?a.j&16777216||a.yc?!0:a.j?!1:w(Db,a):w(Db,a)}function dd(a){return null==a?!1:a?a.j&1024||a.ic?!0:a.j?!1:w(db,a):w(db,a)}function ed(a){return a?a.j&16384||a.Ac?!0:a.j?!1:w(nb,a):w(nb,a)}function fd(a){return a?a.q&512||a.sc?!0:!1:!1}function gd(a){var b=[];ea(a,function(a,b){return function(a,c){return b.push(c)}}(a,b));return b}function hd(a,b,c,d,e){for(;0!==e;)c[d]=a[b],d+=1,e-=1,b+=1}
function id(a,b,c,d,e){b+=e-1;for(d+=e-1;0!==e;)c[d]=a[b],d-=1,e-=1,b-=1}var jd={};function kd(a){return null==a?!1:a?a.j&64||a.jb?!0:a.j?!1:w(Ua,a):w(Ua,a)}function ld(a){return a?a.j&8388608||a.mc?!0:a.j?!1:w(Bb,a):w(Bb,a)}function md(a){return t(a)?!0:!1}function nd(a,b){return S.c(a,b,jd)===jd?!1:!0}
function od(a,b){if(a===b)return 0;if(null==a)return-1;if(null==b)return 1;if(Ba(a)===Ba(b))return a&&(a.q&2048||a.sb)?a.tb(null,b):ha(a,b);throw Error("compare on non-nil objects of different types");}
var pd=function(){function a(a,b,c,g){for(;;){var h=od(R.a(a,g),R.a(b,g));if(0===h&&g+1<c)g+=1;else return h}}function b(a,b){var f=Q(a),g=Q(b);return f<g?-1:f>g?1:c.n(a,b,f,0)}var c=null,c=function(c,e,f,g){switch(arguments.length){case 2:return b.call(this,c,e);case 4:return a.call(this,c,e,f,g)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.n=a;return c}();
function qd(a){return sc.a(a,od)?od:function(b,c){var d=a.a?a.a(b,c):a.call(null,b,c);return"number"===typeof d?d:t(d)?-1:t(a.a?a.a(c,b):a.call(null,c,b))?1:0}}
var sd=function(){function a(a,b){if(D(b)){var c=rd.b?rd.b(b):rd.call(null,b),g=qd(a);ia(c,g);return D(c)}return J}function b(a){return c.a(od,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),td=function(){function a(a,b,c){return sd.a(function(c,f){return qd(b).call(null,a.b?a.b(c):a.call(null,c),a.b?a.b(f):a.call(null,f))},c)}function b(a,b){return c.c(a,od,
b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),P=function(){function a(a,b,c){for(c=D(c);;)if(c){var g=G(c);b=a.a?a.a(b,g):a.call(null,b,g);if(Ac(b))return qb(b);c=K(c)}else return b}function b(a,b){var c=D(b);if(c){var g=G(c),c=K(c);return A.c?A.c(a,g,c):A.call(null,a,g,c)}return a.l?a.l():a.call(null)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,
c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),A=function(){function a(a,b,c){return c&&(c.j&524288||c.Sb)?c.O(null,a,b):c instanceof Array?Dc.c(c,a,b):"string"===typeof c?Dc.c(c,a,b):w(vb,c)?wb.c(c,a,b):P.c(a,b,c)}function b(a,b){return b&&(b.j&524288||b.Sb)?b.R(null,a):b instanceof Array?Dc.a(b,a):"string"===typeof b?Dc.a(b,a):w(vb,b)?wb.a(b,a):P.a(a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,
c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();function ud(a){return a}
var vd=function(){function a(a,b){return function(){function c(b,e){return a.a?a.a(b,e):a.call(null,b,e)}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return a.l?a.l():a.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}function b(a){return c.a(a,ud)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),wd=function(){function a(a,b,c,g){a=a.b?a.b(b):a.call(null,b);c=A.c(a,c,g);return a.b?a.b(c):a.call(null,c)}function b(a,b,f){return c.n(a,b,b.l?b.l():b.call(null),f)}var c=null,c=function(c,e,f,g){switch(arguments.length){case 3:return b.call(this,c,e,f);case 4:return a.call(this,c,e,f,g)}throw Error("Invalid arity: "+arguments.length);};c.c=b;c.n=a;return c}(),xd=function(){var a=null,b=function(){function b(a,
c,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return d.call(this,a,c,h)}function d(b,c,d){return A.c(a,b+c,d)}b.i=2;b.f=function(a){var b=G(a);a=K(a);var c=G(a);a=H(a);return d(b,c,a)};b.d=d;return b}(),a=function(a,d,e){switch(arguments.length){case 0:return 0;case 1:return a;case 2:return a+d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,
0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.l=function(){return 0};a.b=function(a){return a};a.a=function(a,b){return a+b};a.d=b.d;return a}(),yd=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a<c)if(K(d))a=c,c=G(d),d=K(d);else return c<G(d);else return!1}a.i=2;a.f=function(a){var c=
G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a<d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a<b};a.d=b.d;return a}(),zd=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<
arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a<=c)if(K(d))a=c,c=G(d),d=K(d);else return c<=G(d);else return!1}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a<=d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+
2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a<=b};a.d=b.d;return a}(),Ad=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a>c)if(K(d))a=c,c=G(d),d=K(d);else return c>G(d);else return!1}a.i=2;a.f=function(a){var c=
G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a>d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a>b};a.d=b.d;return a}(),Bd=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<
arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a>=c)if(K(d))a=c,c=G(d),d=K(d);else return c>=G(d);else return!1}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a>=d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+
2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a>=b};a.d=b.d;return a}();function Cd(a,b){var c=(a-a%b)/b;return 0<=c?Math.floor.b?Math.floor.b(c):Math.floor.call(null,c):Math.ceil.b?Math.ceil.b(c):Math.ceil.call(null,c)}function Dd(a){a-=a>>1&1431655765;a=(a&858993459)+(a>>2&858993459);return 16843009*(a+(a>>4)&252645135)>>24}
function Ed(a){var b=1;for(a=D(a);;)if(a&&0<b)b-=1,a=K(a);else return a}
var z=function(){function a(a){return null==a?"":da(a)}var b=null,c=function(){function a(b,d){var h=null;if(1<arguments.length){for(var h=0,l=Array(arguments.length-1);h<l.length;)l[h]=arguments[h+1],++h;h=new F(l,0)}return c.call(this,b,h)}function c(a,d){for(var e=new fa(b.b(a)),l=d;;)if(t(l))e=e.append(b.b(G(l))),l=K(l);else return e.toString()}a.i=1;a.f=function(a){var b=G(a);a=H(a);return c(b,a)};a.d=c;return a}(),b=function(b,e){switch(arguments.length){case 0:return"";case 1:return a.call(this,
b);default:var f=null;if(1<arguments.length){for(var f=0,g=Array(arguments.length-1);f<g.length;)g[f]=arguments[f+1],++f;f=new F(g,0)}return c.d(b,f)}throw Error("Invalid arity: "+arguments.length);};b.i=1;b.f=c.f;b.l=function(){return""};b.b=a;b.d=c.d;return b}();function Ic(a,b){var c;if(cd(b))if(Ec(a)&&Ec(b)&&Q(a)!==Q(b))c=!1;else a:{c=D(a);for(var d=D(b);;){if(null==c){c=null==d;break a}if(null!=d&&sc.a(G(c),G(d)))c=K(c),d=K(d);else{c=!1;break a}}c=void 0}else c=null;return md(c)}
function Fd(a,b,c,d,e){this.k=a;this.first=b;this.M=c;this.count=d;this.p=e;this.j=65937646;this.q=8192}k=Fd.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){return 1===this.count?null:this.M};k.L=function(){return this.count};k.La=function(){return this.first};k.Ma=function(){return Wa(this)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return ub(J,this.k)};
k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.first};k.S=function(){return 1===this.count?J:this.M};k.D=function(){return this};k.F=function(a,b){return new Fd(b,this.first,this.M,this.count,this.p)};k.G=function(a,b){return new Fd(this.k,b,this,this.count+1,null)};Fd.prototype[Ea]=function(){return uc(this)};function Hd(a){this.k=a;this.j=65937614;this.q=8192}k=Hd.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};
k.T=function(){return null};k.L=function(){return 0};k.La=function(){return null};k.Ma=function(){throw Error("Can't pop empty list");};k.B=function(){return 0};k.A=function(a,b){return Ic(this,b)};k.J=function(){return this};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return null};k.S=function(){return J};k.D=function(){return null};k.F=function(a,b){return new Hd(b)};k.G=function(a,b){return new Fd(this.k,b,null,1,null)};var J=new Hd(null);
Hd.prototype[Ea]=function(){return uc(this)};function Id(a){return a?a.j&134217728||a.xc?!0:a.j?!1:w(Fb,a):w(Fb,a)}function Jd(a){return Id(a)?Gb(a):A.c(Nc,J,a)}
var Kd=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){var b;if(a instanceof F&&0===a.m)b=a.e;else a:{for(b=[];;)if(null!=a)b.push(a.N(null)),a=a.T(null);else break a;b=void 0}a=b.length;for(var e=J;;)if(0<a){var f=a-1,e=e.G(null,b[a-1]);a=f}else return e}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}();
function Ld(a,b,c,d){this.k=a;this.first=b;this.M=c;this.p=d;this.j=65929452;this.q=8192}k=Ld.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){return null==this.M?null:D(this.M)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.first};
k.S=function(){return null==this.M?J:this.M};k.D=function(){return this};k.F=function(a,b){return new Ld(b,this.first,this.M,this.p)};k.G=function(a,b){return new Ld(null,b,this,this.p)};Ld.prototype[Ea]=function(){return uc(this)};function M(a,b){var c=null==b;return(c?c:b&&(b.j&64||b.jb))?new Ld(null,a,b,null):new Ld(null,a,D(b),null)}
function Md(a,b){if(a.pa===b.pa)return 0;var c=Aa(a.ba);if(t(c?b.ba:c))return-1;if(t(a.ba)){if(Aa(b.ba))return 1;c=ha(a.ba,b.ba);return 0===c?ha(a.name,b.name):c}return ha(a.name,b.name)}function U(a,b,c,d){this.ba=a;this.name=b;this.pa=c;this.Ya=d;this.j=2153775105;this.q=4096}k=U.prototype;k.v=function(a,b){return Lb(b,[z(":"),z(this.pa)].join(""))};k.B=function(){var a=this.Ya;return null!=a?a:this.Ya=a=oc(this)+2654435769|0};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return S.a(c,this);case 3:return S.c(c,this,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return S.a(c,this)};a.c=function(a,c,d){return S.c(c,this,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return S.a(a,this)};k.a=function(a,b){return S.c(a,this,b)};k.A=function(a,b){return b instanceof U?this.pa===b.pa:!1};
k.toString=function(){return[z(":"),z(this.pa)].join("")};function Nd(a,b){return a===b?!0:a instanceof U&&b instanceof U?a.pa===b.pa:!1}
var Pd=function(){function a(a,b){return new U(a,b,[z(t(a)?[z(a),z("/")].join(""):null),z(b)].join(""),null)}function b(a){if(a instanceof U)return a;if(a instanceof qc){var b;if(a&&(a.q&4096||a.lc))b=a.ba;else throw Error([z("Doesn't support namespace: "),z(a)].join(""));return new U(b,Od.b?Od.b(a):Od.call(null,a),a.ta,null)}return"string"===typeof a?(b=a.split("/"),2===b.length?new U(b[0],b[1],a,null):new U(null,b[0],a,null)):null}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function V(a,b,c,d){this.k=a;this.cb=b;this.C=c;this.p=d;this.q=0;this.j=32374988}k=V.prototype;k.toString=function(){return ec(this)};function Qd(a){null!=a.cb&&(a.C=a.cb.l?a.cb.l():a.cb.call(null),a.cb=null);return a.C}k.H=function(){return this.k};k.T=function(){Cb(this);return null==this.C?null:K(this.C)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};
k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){Cb(this);return null==this.C?null:G(this.C)};k.S=function(){Cb(this);return null!=this.C?H(this.C):J};k.D=function(){Qd(this);if(null==this.C)return null;for(var a=this.C;;)if(a instanceof V)a=Qd(a);else return this.C=a,D(this.C)};k.F=function(a,b){return new V(b,this.cb,this.C,this.p)};k.G=function(a,b){return M(b,this)};
V.prototype[Ea]=function(){return uc(this)};function Rd(a,b){this.Ab=a;this.end=b;this.q=0;this.j=2}Rd.prototype.L=function(){return this.end};Rd.prototype.add=function(a){this.Ab[this.end]=a;return this.end+=1};Rd.prototype.ca=function(){var a=new Sd(this.Ab,0,this.end);this.Ab=null;return a};function Td(a){return new Rd(Array(a),0)}function Sd(a,b,c){this.e=a;this.V=b;this.end=c;this.q=0;this.j=524306}k=Sd.prototype;k.R=function(a,b){return Dc.n(this.e,b,this.e[this.V],this.V+1)};
k.O=function(a,b,c){return Dc.n(this.e,b,c,this.V)};k.Pb=function(){if(this.V===this.end)throw Error("-drop-first of empty chunk");return new Sd(this.e,this.V+1,this.end)};k.Q=function(a,b){return this.e[this.V+b]};k.$=function(a,b,c){return 0<=b&&b<this.end-this.V?this.e[this.V+b]:c};k.L=function(){return this.end-this.V};
var Ud=function(){function a(a,b,c){return new Sd(a,b,c)}function b(a,b){return new Sd(a,b,a.length)}function c(a){return new Sd(a,0,a.length)}var d=null,d=function(d,f,g){switch(arguments.length){case 1:return c.call(this,d);case 2:return b.call(this,d,f);case 3:return a.call(this,d,f,g)}throw Error("Invalid arity: "+arguments.length);};d.b=c;d.a=b;d.c=a;return d}();function Vd(a,b,c,d){this.ca=a;this.ra=b;this.k=c;this.p=d;this.j=31850732;this.q=1536}k=Vd.prototype;k.toString=function(){return ec(this)};
k.H=function(){return this.k};k.T=function(){if(1<Ma(this.ca))return new Vd(Xb(this.ca),this.ra,this.k,null);var a=Cb(this.ra);return null==a?null:a};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.N=function(){return C.a(this.ca,0)};k.S=function(){return 1<Ma(this.ca)?new Vd(Xb(this.ca),this.ra,this.k,null):null==this.ra?J:this.ra};k.D=function(){return this};k.Cb=function(){return this.ca};
k.Db=function(){return null==this.ra?J:this.ra};k.F=function(a,b){return new Vd(this.ca,this.ra,b,this.p)};k.G=function(a,b){return M(b,this)};k.Bb=function(){return null==this.ra?null:this.ra};Vd.prototype[Ea]=function(){return uc(this)};function Wd(a,b){return 0===Ma(a)?b:new Vd(a,b,null,null)}function Xd(a,b){a.add(b)}function rd(a){for(var b=[];;)if(D(a))b.push(G(a)),a=K(a);else return b}function Yd(a,b){if(Ec(a))return Q(a);for(var c=a,d=b,e=0;;)if(0<d&&D(c))c=K(c),d-=1,e+=1;else return e}
var $d=function Zd(b){return null==b?null:null==K(b)?D(G(b)):M(G(b),Zd(K(b)))},ae=function(){function a(a,b){return new V(null,function(){var c=D(a);return c?fd(c)?Wd(Yb(c),d.a(Zb(c),b)):M(G(c),d.a(H(c),b)):b},null,null)}function b(a){return new V(null,function(){return a},null,null)}function c(){return new V(null,function(){return null},null,null)}var d=null,e=function(){function a(c,d,e){var f=null;if(2<arguments.length){for(var f=0,q=Array(arguments.length-2);f<q.length;)q[f]=arguments[f+2],++f;
f=new F(q,0)}return b.call(this,c,d,f)}function b(a,c,e){return function q(a,b){return new V(null,function(){var c=D(a);return c?fd(c)?Wd(Yb(c),q(Zb(c),b)):M(G(c),q(H(c),b)):t(b)?q(G(b),K(b)):null},null,null)}(d.a(a,c),e)}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),d=function(d,g,h){switch(arguments.length){case 0:return c.call(this);case 1:return b.call(this,d);case 2:return a.call(this,d,g);default:var l=null;if(2<arguments.length){for(var l=0,m=
Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return e.d(d,g,l)}throw Error("Invalid arity: "+arguments.length);};d.i=2;d.f=e.f;d.l=c;d.b=b;d.a=a;d.d=e.d;return d}(),be=function(){function a(a,b,c,d){return M(a,M(b,M(c,d)))}function b(a,b,c){return M(a,M(b,c))}var c=null,d=function(){function a(c,d,e,m,p){var q=null;if(4<arguments.length){for(var q=0,s=Array(arguments.length-4);q<s.length;)s[q]=arguments[q+4],++q;q=new F(s,0)}return b.call(this,c,d,e,m,q)}function b(a,
c,d,e,f){return M(a,M(c,M(d,M(e,$d(f)))))}a.i=4;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var p=G(a);a=H(a);return b(c,d,e,p,a)};a.d=b;return a}(),c=function(c,f,g,h,l){switch(arguments.length){case 1:return D(c);case 2:return M(c,f);case 3:return b.call(this,c,f,g);case 4:return a.call(this,c,f,g,h);default:var m=null;if(4<arguments.length){for(var m=0,p=Array(arguments.length-4);m<p.length;)p[m]=arguments[m+4],++m;m=new F(p,0)}return d.d(c,f,g,h,m)}throw Error("Invalid arity: "+
arguments.length);};c.i=4;c.f=d.f;c.b=function(a){return D(a)};c.a=function(a,b){return M(a,b)};c.c=b;c.n=a;c.d=d.d;return c}();function ce(a){return Qb(a)}
var de=function(){function a(){return Ob(Mc)}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){for(;;)if(a=Pb(a,c),t(d))c=G(d),d=K(d);else return a}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return a.call(this);case 1:return b;case 2:return Pb(b,
e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.l=a;b.b=function(a){return a};b.a=function(a,b){return Pb(a,b)};b.d=c.d;return b}(),ee=function(){var a=null,b=function(){function a(c,f,g,h){var l=null;if(3<arguments.length){for(var l=0,m=Array(arguments.length-3);l<m.length;)m[l]=arguments[l+3],++l;l=new F(m,0)}return b.call(this,
c,f,g,l)}function b(a,c,d,h){for(;;)if(a=Rb(a,c,d),t(h))c=G(h),d=Lc(h),h=K(K(h));else return a}a.i=3;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=K(a);var h=G(a);a=H(a);return b(c,g,h,a)};a.d=b;return a}(),a=function(a,d,e,f){switch(arguments.length){case 3:return Rb(a,d,e);default:var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return b.d(a,d,e,g)}throw Error("Invalid arity: "+arguments.length);};a.i=3;a.f=b.f;a.c=function(a,
b,e){return Rb(a,b,e)};a.d=b.d;return a}(),fe=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a=Sb(a,c),t(d))c=G(d),d=K(d);else return a}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 2:return Sb(a,d);default:var f=null;if(2<
arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.a=function(a,b){return Sb(a,b)};a.d=b.d;return a}(),ge=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a=Vb(a,c),t(d))c=G(d),d=K(d);
else return a}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 2:return Vb(a,d);default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.a=function(a,b){return Vb(a,b)};a.d=b.d;return a}();
function he(a,b,c){var d=D(c);if(0===b)return a.l?a.l():a.call(null);c=Va(d);var e=Wa(d);if(1===b)return a.b?a.b(c):a.b?a.b(c):a.call(null,c);var d=Va(e),f=Wa(e);if(2===b)return a.a?a.a(c,d):a.a?a.a(c,d):a.call(null,c,d);var e=Va(f),g=Wa(f);if(3===b)return a.c?a.c(c,d,e):a.c?a.c(c,d,e):a.call(null,c,d,e);var f=Va(g),h=Wa(g);if(4===b)return a.n?a.n(c,d,e,f):a.n?a.n(c,d,e,f):a.call(null,c,d,e,f);var g=Va(h),l=Wa(h);if(5===b)return a.r?a.r(c,d,e,f,g):a.r?a.r(c,d,e,f,g):a.call(null,c,d,e,f,g);var h=Va(l),
m=Wa(l);if(6===b)return a.P?a.P(c,d,e,f,g,h):a.P?a.P(c,d,e,f,g,h):a.call(null,c,d,e,f,g,h);var l=Va(m),p=Wa(m);if(7===b)return a.ia?a.ia(c,d,e,f,g,h,l):a.ia?a.ia(c,d,e,f,g,h,l):a.call(null,c,d,e,f,g,h,l);var m=Va(p),q=Wa(p);if(8===b)return a.Ga?a.Ga(c,d,e,f,g,h,l,m):a.Ga?a.Ga(c,d,e,f,g,h,l,m):a.call(null,c,d,e,f,g,h,l,m);var p=Va(q),s=Wa(q);if(9===b)return a.Ha?a.Ha(c,d,e,f,g,h,l,m,p):a.Ha?a.Ha(c,d,e,f,g,h,l,m,p):a.call(null,c,d,e,f,g,h,l,m,p);var q=Va(s),u=Wa(s);if(10===b)return a.va?a.va(c,d,e,
f,g,h,l,m,p,q):a.va?a.va(c,d,e,f,g,h,l,m,p,q):a.call(null,c,d,e,f,g,h,l,m,p,q);var s=Va(u),v=Wa(u);if(11===b)return a.wa?a.wa(c,d,e,f,g,h,l,m,p,q,s):a.wa?a.wa(c,d,e,f,g,h,l,m,p,q,s):a.call(null,c,d,e,f,g,h,l,m,p,q,s);var u=Va(v),y=Wa(v);if(12===b)return a.xa?a.xa(c,d,e,f,g,h,l,m,p,q,s,u):a.xa?a.xa(c,d,e,f,g,h,l,m,p,q,s,u):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u);var v=Va(y),B=Wa(y);if(13===b)return a.ya?a.ya(c,d,e,f,g,h,l,m,p,q,s,u,v):a.ya?a.ya(c,d,e,f,g,h,l,m,p,q,s,u,v):a.call(null,c,d,e,f,g,h,l,m,p,
q,s,u,v);var y=Va(B),E=Wa(B);if(14===b)return a.za?a.za(c,d,e,f,g,h,l,m,p,q,s,u,v,y):a.za?a.za(c,d,e,f,g,h,l,m,p,q,s,u,v,y):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y);var B=Va(E),N=Wa(E);if(15===b)return a.Aa?a.Aa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B):a.Aa?a.Aa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B);var E=Va(N),Y=Wa(N);if(16===b)return a.Ba?a.Ba(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E):a.Ba?a.Ba(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E);var N=
Va(Y),ra=Wa(Y);if(17===b)return a.Ca?a.Ca(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N):a.Ca?a.Ca(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N);var Y=Va(ra),Pa=Wa(ra);if(18===b)return a.Da?a.Da(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y):a.Da?a.Da(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y);ra=Va(Pa);Pa=Wa(Pa);if(19===b)return a.Ea?a.Ea(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra):a.Ea?a.Ea(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra):a.call(null,
c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra);var I=Va(Pa);Wa(Pa);if(20===b)return a.Fa?a.Fa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra,I):a.Fa?a.Fa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra,I):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra,I);throw Error("Only up to 20 arguments supported on functions");}
var T=function(){function a(a,b,c,d,e){b=be.n(b,c,d,e);c=a.i;return a.f?(d=Yd(b,c+1),d<=c?he(a,d,b):a.f(b)):a.apply(a,rd(b))}function b(a,b,c,d){b=be.c(b,c,d);c=a.i;return a.f?(d=Yd(b,c+1),d<=c?he(a,d,b):a.f(b)):a.apply(a,rd(b))}function c(a,b,c){b=be.a(b,c);c=a.i;if(a.f){var d=Yd(b,c+1);return d<=c?he(a,d,b):a.f(b)}return a.apply(a,rd(b))}function d(a,b){var c=a.i;if(a.f){var d=Yd(b,c+1);return d<=c?he(a,d,b):a.f(b)}return a.apply(a,rd(b))}var e=null,f=function(){function a(c,d,e,f,g,u){var v=null;
if(5<arguments.length){for(var v=0,y=Array(arguments.length-5);v<y.length;)y[v]=arguments[v+5],++v;v=new F(y,0)}return b.call(this,c,d,e,f,g,v)}function b(a,c,d,e,f,g){c=M(c,M(d,M(e,M(f,$d(g)))));d=a.i;return a.f?(e=Yd(c,d+1),e<=d?he(a,e,c):a.f(c)):a.apply(a,rd(c))}a.i=5;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=K(a);var g=G(a);a=H(a);return b(c,d,e,f,g,a)};a.d=b;return a}(),e=function(e,h,l,m,p,q){switch(arguments.length){case 2:return d.call(this,e,h);case 3:return c.call(this,
e,h,l);case 4:return b.call(this,e,h,l,m);case 5:return a.call(this,e,h,l,m,p);default:var s=null;if(5<arguments.length){for(var s=0,u=Array(arguments.length-5);s<u.length;)u[s]=arguments[s+5],++s;s=new F(u,0)}return f.d(e,h,l,m,p,s)}throw Error("Invalid arity: "+arguments.length);};e.i=5;e.f=f.f;e.a=d;e.c=c;e.n=b;e.r=a;e.d=f.d;return e}(),ie=function(){function a(a,b,c,d,e,f){var g=O,v=Vc(a);b=b.r?b.r(v,c,d,e,f):b.call(null,v,c,d,e,f);return g(a,b)}function b(a,b,c,d,e){var f=O,g=Vc(a);b=b.n?b.n(g,
c,d,e):b.call(null,g,c,d,e);return f(a,b)}function c(a,b,c,d){var e=O,f=Vc(a);b=b.c?b.c(f,c,d):b.call(null,f,c,d);return e(a,b)}function d(a,b,c){var d=O,e=Vc(a);b=b.a?b.a(e,c):b.call(null,e,c);return d(a,b)}function e(a,b){var c=O,d;d=Vc(a);d=b.b?b.b(d):b.call(null,d);return c(a,d)}var f=null,g=function(){function a(c,d,e,f,g,h,y){var B=null;if(6<arguments.length){for(var B=0,E=Array(arguments.length-6);B<E.length;)E[B]=arguments[B+6],++B;B=new F(E,0)}return b.call(this,c,d,e,f,g,h,B)}function b(a,
c,d,e,f,g,h){return O(a,T.d(c,Vc(a),d,e,f,Kc([g,h],0)))}a.i=6;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=K(a);var g=G(a);a=K(a);var h=G(a);a=H(a);return b(c,d,e,f,g,h,a)};a.d=b;return a}(),f=function(f,l,m,p,q,s,u){switch(arguments.length){case 2:return e.call(this,f,l);case 3:return d.call(this,f,l,m);case 4:return c.call(this,f,l,m,p);case 5:return b.call(this,f,l,m,p,q);case 6:return a.call(this,f,l,m,p,q,s);default:var v=null;if(6<arguments.length){for(var v=
0,y=Array(arguments.length-6);v<y.length;)y[v]=arguments[v+6],++v;v=new F(y,0)}return g.d(f,l,m,p,q,s,v)}throw Error("Invalid arity: "+arguments.length);};f.i=6;f.f=g.f;f.a=e;f.c=d;f.n=c;f.r=b;f.P=a;f.d=g.d;return f}(),je=function(){function a(a,b){return!sc.a(a,b)}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){return Aa(T.n(sc,a,c,d))}a.i=
2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return!1;case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(){return!1};b.a=a;b.d=c.d;return b}(),qe=function ke(){"undefined"===typeof ja&&(ja=function(b,c){this.pc=
b;this.oc=c;this.q=0;this.j=393216},ja.prototype.ga=function(){return!1},ja.prototype.next=function(){return Error("No such element")},ja.prototype.H=function(){return this.oc},ja.prototype.F=function(b,c){return new ja(this.pc,c)},ja.Yb=!0,ja.Xb="cljs.core/t12660",ja.nc=function(b){return Lb(b,"cljs.core/t12660")});return new ja(ke,new pa(null,5,[le,54,me,2998,ne,3,oe,2994,pe,"/Users/davidnolen/development/clojure/mori/out-mori-adv/cljs/core.cljs"],null))};function re(a,b){this.C=a;this.m=b}
re.prototype.ga=function(){return this.m<this.C.length};re.prototype.next=function(){var a=this.C.charAt(this.m);this.m+=1;return a};function se(a,b){this.e=a;this.m=b}se.prototype.ga=function(){return this.m<this.e.length};se.prototype.next=function(){var a=this.e[this.m];this.m+=1;return a};var te={},ue={};function ve(a,b){this.eb=a;this.Qa=b}ve.prototype.ga=function(){this.eb===te?(this.eb=ue,this.Qa=D(this.Qa)):this.eb===this.Qa&&(this.Qa=K(this.eb));return null!=this.Qa};
ve.prototype.next=function(){if(Aa(this.ga()))throw Error("No such element");this.eb=this.Qa;return G(this.Qa)};function we(a){if(null==a)return qe();if("string"===typeof a)return new re(a,0);if(a instanceof Array)return new se(a,0);if(a?t(t(null)?null:a.vb)||(a.yb?0:w(bc,a)):w(bc,a))return cc(a);if(ld(a))return new ve(te,a);throw Error([z("Cannot create iterator from "),z(a)].join(""));}function xe(a,b){this.fa=a;this.$b=b}
xe.prototype.step=function(a){for(var b=this;;){if(t(function(){var c=null!=a.X;return c?b.$b.ga():c}()))if(Ac(function(){var c=b.$b.next();return b.fa.a?b.fa.a(a,c):b.fa.call(null,a,c)}()))null!=a.M&&(a.M.X=null);else continue;break}return null==a.X?null:b.fa.b?b.fa.b(a):b.fa.call(null,a)};
function ye(a,b){var c=function(){function a(b,c){b.first=c;b.M=new ze(b.X,null,null,null);b.X=null;return b.M}function b(a){(Ac(a)?qb(a):a).X=null;return a}var c=null,c=function(c,f){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,f)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();return new xe(a.b?a.b(c):a.call(null,c),b)}function Ae(a,b,c){this.fa=a;this.Kb=b;this.ac=c}
Ae.prototype.ga=function(){for(var a=D(this.Kb);;)if(null!=a){var b=G(a);if(Aa(b.ga()))return!1;a=K(a)}else return!0};Ae.prototype.next=function(){for(var a=this.Kb.length,b=0;;)if(b<a)this.ac[b]=this.Kb[b].next(),b+=1;else break;return Jc.a(this.ac,0)};Ae.prototype.step=function(a){for(;;){var b;b=(b=null!=a.X)?this.ga():b;if(t(b))if(Ac(T.a(this.fa,M(a,this.next()))))null!=a.M&&(a.M.X=null);else continue;break}return null==a.X?null:this.fa.b?this.fa.b(a):this.fa.call(null,a)};
var Be=function(){function a(a,b,c){var g=function(){function a(b,c){b.first=c;b.M=new ze(b.X,null,null,null);b.X=null;return b.M}function b(a){a=Ac(a)?qb(a):a;a.X=null;return a}var c=null,c=function(c,d){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,d)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();return new Ae(a.b?a.b(g):a.call(null,g),b,c)}function b(a,b){return c.c(a,b,Array(b.length))}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,
c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();function ze(a,b,c,d){this.X=a;this.first=b;this.M=c;this.k=d;this.q=0;this.j=31719628}k=ze.prototype;k.T=function(){null!=this.X&&Cb(this);return null==this.M?null:Cb(this.M)};k.N=function(){null!=this.X&&Cb(this);return null==this.M?null:this.first};k.S=function(){null!=this.X&&Cb(this);return null==this.M?J:this.M};
k.D=function(){null!=this.X&&this.X.step(this);return null==this.M?null:this};k.B=function(){return wc(this)};k.A=function(a,b){return null!=Cb(this)?Ic(this,b):cd(b)&&null==D(b)};k.J=function(){return J};k.G=function(a,b){return M(b,Cb(this))};k.F=function(a,b){return new ze(this.X,this.first,this.M,b)};ze.prototype[Ea]=function(){return uc(this)};
var Ce=function(){function a(a){return kd(a)?a:(a=D(a))?a:J}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){d=rd(M(c,d));c=[];d=D(d);for(var e=null,m=0,p=0;;)if(p<m){var q=e.Q(null,p);c.push(we(q));p+=1}else if(d=D(d))e=d,fd(e)?(d=Yb(e),p=Zb(e),e=d,m=Q(d),d=p):(d=G(e),c.push(we(d)),d=K(e),e=null,m=0),p=0;else break;return new ze(Be.c(a,c,
Array(c.length)),null,null,null)}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return a.call(this,b);case 2:return new ze(ye(b,we(e)),null,null,null);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=a;b.a=function(a,b){return new ze(ye(a,
we(b)),null,null,null)};b.d=c.d;return b}();function Ee(a,b){for(;;){if(null==D(b))return!0;var c;c=G(b);c=a.b?a.b(c):a.call(null,c);if(t(c)){c=a;var d=K(b);a=c;b=d}else return!1}}function Fe(a,b){for(;;)if(D(b)){var c;c=G(b);c=a.b?a.b(c):a.call(null,c);if(t(c))return c;c=a;var d=K(b);a=c;b=d}else return null}function Ge(a){if("number"===typeof a&&Aa(isNaN(a))&&Infinity!==a&&parseFloat(a)===parseInt(a,10))return 0===(a&1);throw Error([z("Argument must be an integer: "),z(a)].join(""));}
function He(a){return function(){function b(b,c){return Aa(a.a?a.a(b,c):a.call(null,b,c))}function c(b){return Aa(a.b?a.b(b):a.call(null,b))}function d(){return Aa(a.l?a.l():a.call(null))}var e=null,f=function(){function b(a,d,e){var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return c.call(this,a,d,f)}function c(b,d,e){return Aa(T.n(a,b,d,e))}b.i=2;b.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};b.d=c;
return b}(),e=function(a,e,l){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,a);case 2:return b.call(this,a,e);default:var m=null;if(2<arguments.length){for(var m=0,p=Array(arguments.length-2);m<p.length;)p[m]=arguments[m+2],++m;m=new F(p,0)}return f.d(a,e,m)}throw Error("Invalid arity: "+arguments.length);};e.i=2;e.f=f.f;e.l=d;e.b=c;e.a=b;e.d=f.d;return e}()}
var Ie=function(){function a(a,b,c){return function(){function d(h,l,m){h=c.c?c.c(h,l,m):c.call(null,h,l,m);h=b.b?b.b(h):b.call(null,h);return a.b?a.b(h):a.call(null,h)}function l(d,h){var l;l=c.a?c.a(d,h):c.call(null,d,h);l=b.b?b.b(l):b.call(null,l);return a.b?a.b(l):a.call(null,l)}function m(d){d=c.b?c.b(d):c.call(null,d);d=b.b?b.b(d):b.call(null,d);return a.b?a.b(d):a.call(null,d)}function p(){var d;d=c.l?c.l():c.call(null);d=b.b?b.b(d):b.call(null,d);return a.b?a.b(d):a.call(null,d)}var q=null,
s=function(){function d(a,b,c,e){var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return h.call(this,a,b,c,f)}function h(d,l,m,p){d=T.r(c,d,l,m,p);d=b.b?b.b(d):b.call(null,d);return a.b?a.b(d):a.call(null,d)}d.i=3;d.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return h(b,c,d,a)};d.d=h;return d}(),q=function(a,b,c,e){switch(arguments.length){case 0:return p.call(this);case 1:return m.call(this,a);case 2:return l.call(this,
a,b);case 3:return d.call(this,a,b,c);default:var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return s.d(a,b,c,f)}throw Error("Invalid arity: "+arguments.length);};q.i=3;q.f=s.f;q.l=p;q.b=m;q.a=l;q.c=d;q.d=s.d;return q}()}function b(a,b){return function(){function c(d,g,h){d=b.c?b.c(d,g,h):b.call(null,d,g,h);return a.b?a.b(d):a.call(null,d)}function d(c,g){var h=b.a?b.a(c,g):b.call(null,c,g);return a.b?a.b(h):a.call(null,h)}
function l(c){c=b.b?b.b(c):b.call(null,c);return a.b?a.b(c):a.call(null,c)}function m(){var c=b.l?b.l():b.call(null);return a.b?a.b(c):a.call(null,c)}var p=null,q=function(){function c(a,b,e,f){var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return d.call(this,a,b,e,g)}function d(c,g,h,l){c=T.r(b,c,g,h,l);return a.b?a.b(c):a.call(null,c)}c.i=3;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var e=G(a);a=H(a);return d(b,
c,e,a)};c.d=d;return c}(),p=function(a,b,e,f){switch(arguments.length){case 0:return m.call(this);case 1:return l.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,e);default:var p=null;if(3<arguments.length){for(var p=0,E=Array(arguments.length-3);p<E.length;)E[p]=arguments[p+3],++p;p=new F(E,0)}return q.d(a,b,e,p)}throw Error("Invalid arity: "+arguments.length);};p.i=3;p.f=q.f;p.l=m;p.b=l;p.a=d;p.c=c;p.d=q.d;return p}()}var c=null,d=function(){function a(c,d,e,m){var p=null;
if(3<arguments.length){for(var p=0,q=Array(arguments.length-3);p<q.length;)q[p]=arguments[p+3],++p;p=new F(q,0)}return b.call(this,c,d,e,p)}function b(a,c,d,e){return function(a){return function(){function b(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return c.call(this,d)}function c(b){b=T.a(G(a),b);for(var d=K(a);;)if(d)b=G(d).call(null,b),d=K(d);else return b}b.i=0;b.f=function(a){a=D(a);return c(a)};b.d=c;return b}()}(Jd(be.n(a,
c,d,e)))}a.i=3;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=H(a);return b(c,d,e,a)};a.d=b;return a}(),c=function(c,f,g,h){switch(arguments.length){case 0:return ud;case 1:return c;case 2:return b.call(this,c,f);case 3:return a.call(this,c,f,g);default:var l=null;if(3<arguments.length){for(var l=0,m=Array(arguments.length-3);l<m.length;)m[l]=arguments[l+3],++l;l=new F(m,0)}return d.d(c,f,g,l)}throw Error("Invalid arity: "+arguments.length);};c.i=3;c.f=d.f;c.l=function(){return ud};
c.b=function(a){return a};c.a=b;c.c=a;c.d=d.d;return c}(),Je=function(){function a(a,b,c,d){return function(){function e(m,p,q){return a.P?a.P(b,c,d,m,p,q):a.call(null,b,c,d,m,p,q)}function p(e,m){return a.r?a.r(b,c,d,e,m):a.call(null,b,c,d,e,m)}function q(e){return a.n?a.n(b,c,d,e):a.call(null,b,c,d,e)}function s(){return a.c?a.c(b,c,d):a.call(null,b,c,d)}var u=null,v=function(){function e(a,b,c,d){var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+
3],++f;f=new F(g,0)}return m.call(this,a,b,c,f)}function m(e,p,q,s){return T.d(a,b,c,d,e,Kc([p,q,s],0))}e.i=3;e.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return m(b,c,d,a)};e.d=m;return e}(),u=function(a,b,c,d){switch(arguments.length){case 0:return s.call(this);case 1:return q.call(this,a);case 2:return p.call(this,a,b);case 3:return e.call(this,a,b,c);default:var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=
new F(g,0)}return v.d(a,b,c,f)}throw Error("Invalid arity: "+arguments.length);};u.i=3;u.f=v.f;u.l=s;u.b=q;u.a=p;u.c=e;u.d=v.d;return u}()}function b(a,b,c){return function(){function d(e,l,m){return a.r?a.r(b,c,e,l,m):a.call(null,b,c,e,l,m)}function e(d,l){return a.n?a.n(b,c,d,l):a.call(null,b,c,d,l)}function p(d){return a.c?a.c(b,c,d):a.call(null,b,c,d)}function q(){return a.a?a.a(b,c):a.call(null,b,c)}var s=null,u=function(){function d(a,b,c,f){var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-
3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return e.call(this,a,b,c,g)}function e(d,l,m,p){return T.d(a,b,c,d,l,Kc([m,p],0))}d.i=3;d.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return e(b,c,d,a)};d.d=e;return d}(),s=function(a,b,c,f){switch(arguments.length){case 0:return q.call(this);case 1:return p.call(this,a);case 2:return e.call(this,a,b);case 3:return d.call(this,a,b,c);default:var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=
arguments[g+3],++g;g=new F(h,0)}return u.d(a,b,c,g)}throw Error("Invalid arity: "+arguments.length);};s.i=3;s.f=u.f;s.l=q;s.b=p;s.a=e;s.c=d;s.d=u.d;return s}()}function c(a,b){return function(){function c(d,e,h){return a.n?a.n(b,d,e,h):a.call(null,b,d,e,h)}function d(c,e){return a.c?a.c(b,c,e):a.call(null,b,c,e)}function e(c){return a.a?a.a(b,c):a.call(null,b,c)}function p(){return a.b?a.b(b):a.call(null,b)}var q=null,s=function(){function c(a,b,e,f){var g=null;if(3<arguments.length){for(var g=0,
h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return d.call(this,a,b,e,g)}function d(c,e,h,l){return T.d(a,b,c,e,h,Kc([l],0))}c.i=3;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var e=G(a);a=H(a);return d(b,c,e,a)};c.d=d;return c}(),q=function(a,b,f,g){switch(arguments.length){case 0:return p.call(this);case 1:return e.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,f);default:var q=null;if(3<arguments.length){for(var q=0,N=Array(arguments.length-
3);q<N.length;)N[q]=arguments[q+3],++q;q=new F(N,0)}return s.d(a,b,f,q)}throw Error("Invalid arity: "+arguments.length);};q.i=3;q.f=s.f;q.l=p;q.b=e;q.a=d;q.c=c;q.d=s.d;return q}()}var d=null,e=function(){function a(c,d,e,f,q){var s=null;if(4<arguments.length){for(var s=0,u=Array(arguments.length-4);s<u.length;)u[s]=arguments[s+4],++s;s=new F(u,0)}return b.call(this,c,d,e,f,s)}function b(a,c,d,e,f){return function(){function b(a){var c=null;if(0<arguments.length){for(var c=0,d=Array(arguments.length-
0);c<d.length;)d[c]=arguments[c+0],++c;c=new F(d,0)}return g.call(this,c)}function g(b){return T.r(a,c,d,e,ae.a(f,b))}b.i=0;b.f=function(a){a=D(a);return g(a)};b.d=g;return b}()}a.i=4;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=H(a);return b(c,d,e,f,a)};a.d=b;return a}(),d=function(d,g,h,l,m){switch(arguments.length){case 1:return d;case 2:return c.call(this,d,g);case 3:return b.call(this,d,g,h);case 4:return a.call(this,d,g,h,l);default:var p=null;if(4<arguments.length){for(var p=
0,q=Array(arguments.length-4);p<q.length;)q[p]=arguments[p+4],++p;p=new F(q,0)}return e.d(d,g,h,l,p)}throw Error("Invalid arity: "+arguments.length);};d.i=4;d.f=e.f;d.b=function(a){return a};d.a=c;d.c=b;d.n=a;d.d=e.d;return d}(),Ke=function(){function a(a,b,c,d){return function(){function l(l,m,p){l=null==l?b:l;m=null==m?c:m;p=null==p?d:p;return a.c?a.c(l,m,p):a.call(null,l,m,p)}function m(d,h){var l=null==d?b:d,m=null==h?c:h;return a.a?a.a(l,m):a.call(null,l,m)}var p=null,q=function(){function l(a,
b,c,d){var e=null;if(3<arguments.length){for(var e=0,f=Array(arguments.length-3);e<f.length;)f[e]=arguments[e+3],++e;e=new F(f,0)}return m.call(this,a,b,c,e)}function m(l,p,q,s){return T.r(a,null==l?b:l,null==p?c:p,null==q?d:q,s)}l.i=3;l.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return m(b,c,d,a)};l.d=m;return l}(),p=function(a,b,c,d){switch(arguments.length){case 2:return m.call(this,a,b);case 3:return l.call(this,a,b,c);default:var e=null;if(3<arguments.length){for(var e=
0,f=Array(arguments.length-3);e<f.length;)f[e]=arguments[e+3],++e;e=new F(f,0)}return q.d(a,b,c,e)}throw Error("Invalid arity: "+arguments.length);};p.i=3;p.f=q.f;p.a=m;p.c=l;p.d=q.d;return p}()}function b(a,b,c){return function(){function d(h,l,m){h=null==h?b:h;l=null==l?c:l;return a.c?a.c(h,l,m):a.call(null,h,l,m)}function l(d,h){var l=null==d?b:d,m=null==h?c:h;return a.a?a.a(l,m):a.call(null,l,m)}var m=null,p=function(){function d(a,b,c,e){var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-
3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return h.call(this,a,b,c,f)}function h(d,l,m,p){return T.r(a,null==d?b:d,null==l?c:l,m,p)}d.i=3;d.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return h(b,c,d,a)};d.d=h;return d}(),m=function(a,b,c,e){switch(arguments.length){case 2:return l.call(this,a,b);case 3:return d.call(this,a,b,c);default:var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return p.d(a,
b,c,f)}throw Error("Invalid arity: "+arguments.length);};m.i=3;m.f=p.f;m.a=l;m.c=d;m.d=p.d;return m}()}function c(a,b){return function(){function c(d,g,h){d=null==d?b:d;return a.c?a.c(d,g,h):a.call(null,d,g,h)}function d(c,g){var h=null==c?b:c;return a.a?a.a(h,g):a.call(null,h,g)}function l(c){c=null==c?b:c;return a.b?a.b(c):a.call(null,c)}var m=null,p=function(){function c(a,b,e,f){var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,
0)}return d.call(this,a,b,e,g)}function d(c,g,h,l){return T.r(a,null==c?b:c,g,h,l)}c.i=3;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var e=G(a);a=H(a);return d(b,c,e,a)};c.d=d;return c}(),m=function(a,b,e,f){switch(arguments.length){case 1:return l.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,e);default:var m=null;if(3<arguments.length){for(var m=0,B=Array(arguments.length-3);m<B.length;)B[m]=arguments[m+3],++m;m=new F(B,0)}return p.d(a,b,e,m)}throw Error("Invalid arity: "+
arguments.length);};m.i=3;m.f=p.f;m.b=l;m.a=d;m.c=c;m.d=p.d;return m}()}var d=null,d=function(d,f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),Le=function(){function a(a,b){return new V(null,function(){var f=D(b);if(f){if(fd(f)){for(var g=Yb(f),h=Q(g),l=Td(h),m=0;;)if(m<h){var p=function(){var b=C.a(g,m);return a.b?a.b(b):a.call(null,b)}();
null!=p&&l.add(p);m+=1}else break;return Wd(l.ca(),c.a(a,Zb(f)))}h=function(){var b=G(f);return a.b?a.b(b):a.call(null,b)}();return null==h?c.a(a,H(f)):M(h,c.a(a,H(f)))}return null},null,null)}function b(a){return function(b){return function(){function c(f,g){var h=a.b?a.b(g):a.call(null,g);return null==h?f:b.a?b.a(f,h):b.call(null,f,h)}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return b.l?b.l():b.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);
case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function Me(a){this.state=a;this.q=0;this.j=32768}Me.prototype.Ra=function(){return this.state};Me.prototype.bb=function(a,b){return this.state=b};
var Ne=function(){function a(a,b){return function g(b,c){return new V(null,function(){var e=D(c);if(e){if(fd(e)){for(var p=Yb(e),q=Q(p),s=Td(q),u=0;;)if(u<q){var v=function(){var c=b+u,e=C.a(p,u);return a.a?a.a(c,e):a.call(null,c,e)}();null!=v&&s.add(v);u+=1}else break;return Wd(s.ca(),g(b+q,Zb(e)))}q=function(){var c=G(e);return a.a?a.a(b,c):a.call(null,b,c)}();return null==q?g(b+1,H(e)):M(q,g(b+1,H(e)))}return null},null,null)}(0,b)}function b(a){return function(b){return function(c){return function(){function g(g,
h){var l=c.bb(0,c.Ra(null)+1),l=a.a?a.a(l,h):a.call(null,l,h);return null==l?g:b.a?b.a(g,l):b.call(null,g,l)}function h(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,a);case 2:return g.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=h;m.a=g;return m}()}(new Me(-1))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Oe=function(){function a(a,b,c,d){return new V(null,function(){var f=D(b),q=D(c),s=D(d);if(f&&q&&s){var u=M,v;v=G(f);var y=G(q),B=G(s);v=a.c?a.c(v,y,B):a.call(null,v,y,B);f=u(v,e.n(a,H(f),H(q),H(s)))}else f=null;return f},null,null)}function b(a,b,c){return new V(null,function(){var d=D(b),f=D(c);if(d&&f){var q=M,s;s=G(d);var u=G(f);s=a.a?a.a(s,u):a.call(null,s,u);d=q(s,e.c(a,H(d),H(f)))}else d=
null;return d},null,null)}function c(a,b){return new V(null,function(){var c=D(b);if(c){if(fd(c)){for(var d=Yb(c),f=Q(d),q=Td(f),s=0;;)if(s<f)Xd(q,function(){var b=C.a(d,s);return a.b?a.b(b):a.call(null,b)}()),s+=1;else break;return Wd(q.ca(),e.a(a,Zb(c)))}return M(function(){var b=G(c);return a.b?a.b(b):a.call(null,b)}(),e.a(a,H(c)))}return null},null,null)}function d(a){return function(b){return function(){function c(d,e){var f=a.b?a.b(e):a.call(null,e);return b.a?b.a(d,f):b.call(null,d,f)}function d(a){return b.b?
b.b(a):b.call(null,a)}function e(){return b.l?b.l():b.call(null)}var f=null,s=function(){function c(a,b,e){var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return d.call(this,a,b,f)}function d(c,e,f){e=T.c(a,e,f);return b.a?b.a(c,e):b.call(null,c,e)}c.i=2;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=H(a);return d(b,c,a)};c.d=d;return c}(),f=function(a,b,f){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,
a);case 2:return c.call(this,a,b);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return s.d(a,b,g)}throw Error("Invalid arity: "+arguments.length);};f.i=2;f.f=s.f;f.l=e;f.b=d;f.a=c;f.d=s.d;return f}()}}var e=null,f=function(){function a(c,d,e,f,g){var u=null;if(4<arguments.length){for(var u=0,v=Array(arguments.length-4);u<v.length;)v[u]=arguments[u+4],++u;u=new F(v,0)}return b.call(this,c,d,e,f,u)}function b(a,c,d,
f,g){var h=function y(a){return new V(null,function(){var b=e.a(D,a);return Ee(ud,b)?M(e.a(G,b),y(e.a(H,b))):null},null,null)};return e.a(function(){return function(b){return T.a(a,b)}}(h),h(Nc.d(g,f,Kc([d,c],0))))}a.i=4;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=H(a);return b(c,d,e,f,a)};a.d=b;return a}(),e=function(e,h,l,m,p){switch(arguments.length){case 1:return d.call(this,e);case 2:return c.call(this,e,h);case 3:return b.call(this,e,h,l);case 4:return a.call(this,
e,h,l,m);default:var q=null;if(4<arguments.length){for(var q=0,s=Array(arguments.length-4);q<s.length;)s[q]=arguments[q+4],++q;q=new F(s,0)}return f.d(e,h,l,m,q)}throw Error("Invalid arity: "+arguments.length);};e.i=4;e.f=f.f;e.b=d;e.a=c;e.c=b;e.n=a;e.d=f.d;return e}(),Pe=function(){function a(a,b){return new V(null,function(){if(0<a){var f=D(b);return f?M(G(f),c.a(a-1,H(f))):null}return null},null,null)}function b(a){return function(b){return function(a){return function(){function c(d,g){var h=qb(a),
l=a.bb(0,a.Ra(null)-1),h=0<h?b.a?b.a(d,g):b.call(null,d,g):d;return 0<l?h:Ac(h)?h:new yc(h)}function d(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=d;m.a=c;return m}()}(new Me(a))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,
c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Qe=function(){function a(a,b){return new V(null,function(c){return function(){return c(a,b)}}(function(a,b){for(;;){var c=D(b);if(0<a&&c){var d=a-1,c=H(c);a=d;b=c}else return c}}),null,null)}function b(a){return function(b){return function(a){return function(){function c(d,g){var h=qb(a);a.bb(0,a.Ra(null)-1);return 0<h?d:b.a?b.a(d,g):b.call(null,d,g)}function d(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?
b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=d;m.a=c;return m}()}(new Me(a))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Re=function(){function a(a,b){return new V(null,function(c){return function(){return c(a,
b)}}(function(a,b){for(;;){var c=D(b),d;if(d=c)d=G(c),d=a.b?a.b(d):a.call(null,d);if(t(d))d=a,c=H(c),a=d,b=c;else return c}}),null,null)}function b(a){return function(b){return function(c){return function(){function g(g,h){var l=qb(c);if(t(t(l)?a.b?a.b(h):a.call(null,h):l))return g;ac(c,null);return b.a?b.a(g,h):b.call(null,g,h)}function h(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,
a);case 2:return g.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=h;m.a=g;return m}()}(new Me(!0))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Se=function(){function a(a,b){return Pe.a(a,c.b(b))}function b(a){return new V(null,function(){return M(a,c.b(a))},null,null)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Te=function(){function a(a,b){return Pe.a(a,c.b(b))}function b(a){return new V(null,function(){return M(a.l?a.l():a.call(null),c.b(a))},null,null)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Ue=function(){function a(a,c){return new V(null,function(){var f=
D(a),g=D(c);return f&&g?M(G(f),M(G(g),b.a(H(f),H(g)))):null},null,null)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){return new V(null,function(){var c=Oe.a(D,Nc.d(e,d,Kc([a],0)));return Ee(ud,c)?ae.a(Oe.a(G,c),T.a(b,Oe.a(H,c))):null},null,null)}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),
b=function(b,e,f){switch(arguments.length){case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.a=a;b.d=c.d;return b}(),We=function(){function a(a){return Ie.a(Oe.b(a),Ve)}var b=null,c=function(){function a(c,d){var h=null;if(1<arguments.length){for(var h=0,l=Array(arguments.length-1);h<l.length;)l[h]=arguments[h+
1],++h;h=new F(l,0)}return b.call(this,c,h)}function b(a,c){return T.a(ae,T.c(Oe,a,c))}a.i=1;a.f=function(a){var c=G(a);a=H(a);return b(c,a)};a.d=b;return a}(),b=function(b,e){switch(arguments.length){case 1:return a.call(this,b);default:var f=null;if(1<arguments.length){for(var f=0,g=Array(arguments.length-1);f<g.length;)g[f]=arguments[f+1],++f;f=new F(g,0)}return c.d(b,f)}throw Error("Invalid arity: "+arguments.length);};b.i=1;b.f=c.f;b.b=a;b.d=c.d;return b}(),Xe=function(){function a(a,b){return new V(null,
function(){var f=D(b);if(f){if(fd(f)){for(var g=Yb(f),h=Q(g),l=Td(h),m=0;;)if(m<h){var p;p=C.a(g,m);p=a.b?a.b(p):a.call(null,p);t(p)&&(p=C.a(g,m),l.add(p));m+=1}else break;return Wd(l.ca(),c.a(a,Zb(f)))}g=G(f);f=H(f);return t(a.b?a.b(g):a.call(null,g))?M(g,c.a(a,f)):c.a(a,f)}return null},null,null)}function b(a){return function(b){return function(){function c(f,g){return t(a.b?a.b(g):a.call(null,g))?b.a?b.a(f,g):b.call(null,f,g):f}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return b.l?
b.l():b.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Ye=function(){function a(a,b){return Xe.a(He(a),b)}function b(a){return Xe.b(He(a))}
var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function Ze(a){var b=$e;return function d(a){return new V(null,function(){return M(a,t(b.b?b.b(a):b.call(null,a))?We.d(d,Kc([D.b?D.b(a):D.call(null,a)],0)):null)},null,null)}(a)}
var af=function(){function a(a,b,c){return a&&(a.q&4||a.dc)?O(ce(wd.n(b,de,Ob(a),c)),Vc(a)):wd.n(b,Nc,a,c)}function b(a,b){return null!=a?a&&(a.q&4||a.dc)?O(ce(A.c(Pb,Ob(a),b)),Vc(a)):A.c(Ra,a,b):A.c(Nc,J,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),bf=function(){function a(a,b,c,h){return new V(null,function(){var l=D(h);if(l){var m=Pe.a(a,l);return a===
Q(m)?M(m,d.n(a,b,c,Qe.a(b,l))):Ra(J,Pe.a(a,ae.a(m,c)))}return null},null,null)}function b(a,b,c){return new V(null,function(){var h=D(c);if(h){var l=Pe.a(a,h);return a===Q(l)?M(l,d.c(a,b,Qe.a(b,h))):null}return null},null,null)}function c(a,b){return d.c(a,a,b)}var d=null,d=function(d,f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),cf=function(){function a(a,
b,c){var g=jd;for(b=D(b);;)if(b){var h=a;if(h?h.j&256||h.Rb||(h.j?0:w(Za,h)):w(Za,h)){a=S.c(a,G(b),g);if(g===a)return c;b=K(b)}else return c}else return a}function b(a,b){return c.c(a,b,null)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),df=function(){function a(a,b,c,d,f,q){var s=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,s,e.P(S.a(a,s),b,c,d,f,q)):Rc.c(a,s,
function(){var b=S.a(a,s);return c.n?c.n(b,d,f,q):c.call(null,b,d,f,q)}())}function b(a,b,c,d,f){var q=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,q,e.r(S.a(a,q),b,c,d,f)):Rc.c(a,q,function(){var b=S.a(a,q);return c.c?c.c(b,d,f):c.call(null,b,d,f)}())}function c(a,b,c,d){var f=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,f,e.n(S.a(a,f),b,c,d)):Rc.c(a,f,function(){var b=S.a(a,f);return c.a?c.a(b,d):c.call(null,b,d)}())}function d(a,b,c){var d=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,d,e.c(S.a(a,d),b,c)):Rc.c(a,d,function(){var b=
S.a(a,d);return c.b?c.b(b):c.call(null,b)}())}var e=null,f=function(){function a(c,d,e,f,g,u,v){var y=null;if(6<arguments.length){for(var y=0,B=Array(arguments.length-6);y<B.length;)B[y]=arguments[y+6],++y;y=new F(B,0)}return b.call(this,c,d,e,f,g,u,y)}function b(a,c,d,f,g,h,v){var y=R.c(c,0,null);return(c=Ed(c))?Rc.c(a,y,T.d(e,S.a(a,y),c,d,f,Kc([g,h,v],0))):Rc.c(a,y,T.d(d,S.a(a,y),f,g,h,Kc([v],0)))}a.i=6;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=K(a);var g=
G(a);a=K(a);var v=G(a);a=H(a);return b(c,d,e,f,g,v,a)};a.d=b;return a}(),e=function(e,h,l,m,p,q,s){switch(arguments.length){case 3:return d.call(this,e,h,l);case 4:return c.call(this,e,h,l,m);case 5:return b.call(this,e,h,l,m,p);case 6:return a.call(this,e,h,l,m,p,q);default:var u=null;if(6<arguments.length){for(var u=0,v=Array(arguments.length-6);u<v.length;)v[u]=arguments[u+6],++u;u=new F(v,0)}return f.d(e,h,l,m,p,q,u)}throw Error("Invalid arity: "+arguments.length);};e.i=6;e.f=f.f;e.c=d;e.n=c;
e.r=b;e.P=a;e.d=f.d;return e}();function ef(a,b){this.u=a;this.e=b}function ff(a){return new ef(a,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null])}function gf(a){return new ef(a.u,Fa(a.e))}function hf(a){a=a.g;return 32>a?0:a-1>>>5<<5}function jf(a,b,c){for(;;){if(0===b)return c;var d=ff(a);d.e[0]=c;c=d;b-=5}}
var lf=function kf(b,c,d,e){var f=gf(d),g=b.g-1>>>c&31;5===c?f.e[g]=e:(d=d.e[g],b=null!=d?kf(b,c-5,d,e):jf(null,c-5,e),f.e[g]=b);return f};function mf(a,b){throw Error([z("No item "),z(a),z(" in vector of length "),z(b)].join(""));}function nf(a,b){if(b>=hf(a))return a.W;for(var c=a.root,d=a.shift;;)if(0<d)var e=d-5,c=c.e[b>>>d&31],d=e;else return c.e}function of(a,b){return 0<=b&&b<a.g?nf(a,b):mf(b,a.g)}
var qf=function pf(b,c,d,e,f){var g=gf(d);if(0===c)g.e[e&31]=f;else{var h=e>>>c&31;b=pf(b,c-5,d.e[h],e,f);g.e[h]=b}return g},sf=function rf(b,c,d){var e=b.g-2>>>c&31;if(5<c){b=rf(b,c-5,d.e[e]);if(null==b&&0===e)return null;d=gf(d);d.e[e]=b;return d}if(0===e)return null;d=gf(d);d.e[e]=null;return d};function tf(a,b,c,d,e,f){this.m=a;this.zb=b;this.e=c;this.oa=d;this.start=e;this.end=f}tf.prototype.ga=function(){return this.m<this.end};
tf.prototype.next=function(){32===this.m-this.zb&&(this.e=nf(this.oa,this.m),this.zb+=32);var a=this.e[this.m&31];this.m+=1;return a};function W(a,b,c,d,e,f){this.k=a;this.g=b;this.shift=c;this.root=d;this.W=e;this.p=f;this.j=167668511;this.q=8196}k=W.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return"number"===typeof b?C.c(this,b,c):c};
k.gb=function(a,b,c){a=0;for(var d=c;;)if(a<this.g){var e=nf(this,a);c=e.length;a:{for(var f=0;;)if(f<c){var g=f+a,h=e[f],d=b.c?b.c(d,g,h):b.call(null,d,g,h);if(Ac(d)){e=d;break a}f+=1}else{e=d;break a}e=void 0}if(Ac(e))return b=e,L.b?L.b(b):L.call(null,b);a+=c;d=e}else return d};k.Q=function(a,b){return of(this,b)[b&31]};k.$=function(a,b,c){return 0<=b&&b<this.g?nf(this,b)[b&31]:c};
k.Ua=function(a,b,c){if(0<=b&&b<this.g)return hf(this)<=b?(a=Fa(this.W),a[b&31]=c,new W(this.k,this.g,this.shift,this.root,a,null)):new W(this.k,this.g,this.shift,qf(this,this.shift,this.root,b,c),this.W,null);if(b===this.g)return Ra(this,c);throw Error([z("Index "),z(b),z(" out of bounds  [0,"),z(this.g),z("]")].join(""));};k.vb=!0;k.fb=function(){var a=this.g;return new tf(0,0,0<Q(this)?nf(this,0):null,this,0,a)};k.H=function(){return this.k};k.L=function(){return this.g};
k.hb=function(){return C.a(this,0)};k.ib=function(){return C.a(this,1)};k.La=function(){return 0<this.g?C.a(this,this.g-1):null};
k.Ma=function(){if(0===this.g)throw Error("Can't pop empty vector");if(1===this.g)return ub(Mc,this.k);if(1<this.g-hf(this))return new W(this.k,this.g-1,this.shift,this.root,this.W.slice(0,-1),null);var a=nf(this,this.g-2),b=sf(this,this.shift,this.root),b=null==b?uf:b,c=this.g-1;return 5<this.shift&&null==b.e[1]?new W(this.k,c,this.shift-5,b.e[0],a,null):new W(this.k,c,this.shift,b,a,null)};k.ab=function(){return 0<this.g?new Hc(this,this.g-1,null):null};
k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){if(b instanceof W)if(this.g===Q(b))for(var c=cc(this),d=cc(b);;)if(t(c.ga())){var e=c.next(),f=d.next();if(!sc.a(e,f))return!1}else return!0;else return!1;else return Ic(this,b)};k.$a=function(){var a=this;return new vf(a.g,a.shift,function(){var b=a.root;return wf.b?wf.b(b):wf.call(null,b)}(),function(){var b=a.W;return xf.b?xf.b(b):xf.call(null,b)}())};k.J=function(){return O(Mc,this.k)};
k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){a=0;for(var d=c;;)if(a<this.g){var e=nf(this,a);c=e.length;a:{for(var f=0;;)if(f<c){var g=e[f],d=b.a?b.a(d,g):b.call(null,d,g);if(Ac(d)){e=d;break a}f+=1}else{e=d;break a}e=void 0}if(Ac(e))return b=e,L.b?L.b(b):L.call(null,b);a+=c;d=e}else return d};k.Ka=function(a,b,c){if("number"===typeof b)return pb(this,b,c);throw Error("Vector's key for assoc must be a number.");};
k.D=function(){if(0===this.g)return null;if(32>=this.g)return new F(this.W,0);var a;a:{a=this.root;for(var b=this.shift;;)if(0<b)b-=5,a=a.e[0];else{a=a.e;break a}a=void 0}return yf.n?yf.n(this,a,0,0):yf.call(null,this,a,0,0)};k.F=function(a,b){return new W(b,this.g,this.shift,this.root,this.W,this.p)};
k.G=function(a,b){if(32>this.g-hf(this)){for(var c=this.W.length,d=Array(c+1),e=0;;)if(e<c)d[e]=this.W[e],e+=1;else break;d[c]=b;return new W(this.k,this.g+1,this.shift,this.root,d,null)}c=(d=this.g>>>5>1<<this.shift)?this.shift+5:this.shift;d?(d=ff(null),d.e[0]=this.root,e=jf(null,this.shift,new ef(null,this.W)),d.e[1]=e):d=lf(this,this.shift,this.root,new ef(null,this.W));return new W(this.k,this.g+1,c,d,[b],null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.Q(null,c);case 3:return this.$(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.Q(null,c)};a.c=function(a,c,d){return this.$(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.Q(null,a)};k.a=function(a,b){return this.$(null,a,b)};
var uf=new ef(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]),Mc=new W(null,0,5,uf,[],0);W.prototype[Ea]=function(){return uc(this)};function zf(a){return Qb(A.c(Pb,Ob(Mc),a))}
var Af=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){if(a instanceof F&&0===a.m)a:{a=a.e;var b=a.length;if(32>b)a=new W(null,b,5,uf,a,null);else{for(var e=32,f=(new W(null,32,5,uf,a.slice(0,32),null)).$a(null);;)if(e<b)var g=e+1,f=de.a(f,a[e]),e=g;else{a=Qb(f);break a}a=void 0}}else a=zf(a);return a}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}();
function Bf(a,b,c,d,e,f){this.ha=a;this.Ja=b;this.m=c;this.V=d;this.k=e;this.p=f;this.j=32375020;this.q=1536}k=Bf.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){if(this.V+1<this.Ja.length){var a;a=this.ha;var b=this.Ja,c=this.m,d=this.V+1;a=yf.n?yf.n(a,b,c,d):yf.call(null,a,b,c,d);return null==a?null:a}return $b(this)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(Mc,this.k)};
k.R=function(a,b){var c=this;return Cc.a(function(){var a=c.ha,b=c.m+c.V,f=Q(c.ha);return Cf.c?Cf.c(a,b,f):Cf.call(null,a,b,f)}(),b)};k.O=function(a,b,c){var d=this;return Cc.c(function(){var a=d.ha,b=d.m+d.V,c=Q(d.ha);return Cf.c?Cf.c(a,b,c):Cf.call(null,a,b,c)}(),b,c)};k.N=function(){return this.Ja[this.V]};k.S=function(){if(this.V+1<this.Ja.length){var a;a=this.ha;var b=this.Ja,c=this.m,d=this.V+1;a=yf.n?yf.n(a,b,c,d):yf.call(null,a,b,c,d);return null==a?J:a}return Zb(this)};k.D=function(){return this};
k.Cb=function(){return Ud.a(this.Ja,this.V)};k.Db=function(){var a=this.m+this.Ja.length;if(a<Ma(this.ha)){var b=this.ha,c=nf(this.ha,a);return yf.n?yf.n(b,c,a,0):yf.call(null,b,c,a,0)}return J};k.F=function(a,b){var c=this.ha,d=this.Ja,e=this.m,f=this.V;return yf.r?yf.r(c,d,e,f,b):yf.call(null,c,d,e,f,b)};k.G=function(a,b){return M(b,this)};k.Bb=function(){var a=this.m+this.Ja.length;if(a<Ma(this.ha)){var b=this.ha,c=nf(this.ha,a);return yf.n?yf.n(b,c,a,0):yf.call(null,b,c,a,0)}return null};
Bf.prototype[Ea]=function(){return uc(this)};var yf=function(){function a(a,b,c,d,l){return new Bf(a,b,c,d,l,null)}function b(a,b,c,d){return new Bf(a,b,c,d,null,null)}function c(a,b,c){return new Bf(a,of(a,b),b,c,null,null)}var d=null,d=function(d,f,g,h,l){switch(arguments.length){case 3:return c.call(this,d,f,g);case 4:return b.call(this,d,f,g,h);case 5:return a.call(this,d,f,g,h,l)}throw Error("Invalid arity: "+arguments.length);};d.c=c;d.n=b;d.r=a;return d}();
function Df(a,b,c,d,e){this.k=a;this.oa=b;this.start=c;this.end=d;this.p=e;this.j=166617887;this.q=8192}k=Df.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return"number"===typeof b?C.c(this,b,c):c};k.Q=function(a,b){return 0>b||this.end<=this.start+b?mf(b,this.end-this.start):C.a(this.oa,this.start+b)};k.$=function(a,b,c){return 0>b||this.end<=this.start+b?c:C.c(this.oa,this.start+b,c)};
k.Ua=function(a,b,c){var d=this.start+b;a=this.k;c=Rc.c(this.oa,d,c);b=this.start;var e=this.end,d=d+1,d=e>d?e:d;return Ef.r?Ef.r(a,c,b,d,null):Ef.call(null,a,c,b,d,null)};k.H=function(){return this.k};k.L=function(){return this.end-this.start};k.La=function(){return C.a(this.oa,this.end-1)};k.Ma=function(){if(this.start===this.end)throw Error("Can't pop empty vector");var a=this.k,b=this.oa,c=this.start,d=this.end-1;return Ef.r?Ef.r(a,b,c,d,null):Ef.call(null,a,b,c,d,null)};
k.ab=function(){return this.start!==this.end?new Hc(this,this.end-this.start-1,null):null};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(Mc,this.k)};k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){return Cc.c(this,b,c)};k.Ka=function(a,b,c){if("number"===typeof b)return pb(this,b,c);throw Error("Subvec's key for assoc must be a number.");};
k.D=function(){var a=this;return function(b){return function d(e){return e===a.end?null:M(C.a(a.oa,e),new V(null,function(){return function(){return d(e+1)}}(b),null,null))}}(this)(a.start)};k.F=function(a,b){var c=this.oa,d=this.start,e=this.end,f=this.p;return Ef.r?Ef.r(b,c,d,e,f):Ef.call(null,b,c,d,e,f)};k.G=function(a,b){var c=this.k,d=pb(this.oa,this.end,b),e=this.start,f=this.end+1;return Ef.r?Ef.r(c,d,e,f,null):Ef.call(null,c,d,e,f,null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.Q(null,c);case 3:return this.$(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.Q(null,c)};a.c=function(a,c,d){return this.$(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.Q(null,a)};k.a=function(a,b){return this.$(null,a,b)};Df.prototype[Ea]=function(){return uc(this)};
function Ef(a,b,c,d,e){for(;;)if(b instanceof Df)c=b.start+c,d=b.start+d,b=b.oa;else{var f=Q(b);if(0>c||0>d||c>f||d>f)throw Error("Index out of bounds");return new Df(a,b,c,d,e)}}var Cf=function(){function a(a,b,c){return Ef(null,a,b,c,null)}function b(a,b){return c.c(a,b,Q(a))}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();
function Ff(a,b){return a===b.u?b:new ef(a,Fa(b.e))}function wf(a){return new ef({},Fa(a.e))}function xf(a){var b=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];hd(a,0,b,0,a.length);return b}
var Hf=function Gf(b,c,d,e){d=Ff(b.root.u,d);var f=b.g-1>>>c&31;if(5===c)b=e;else{var g=d.e[f];b=null!=g?Gf(b,c-5,g,e):jf(b.root.u,c-5,e)}d.e[f]=b;return d},Jf=function If(b,c,d){d=Ff(b.root.u,d);var e=b.g-2>>>c&31;if(5<c){b=If(b,c-5,d.e[e]);if(null==b&&0===e)return null;d.e[e]=b;return d}if(0===e)return null;d.e[e]=null;return d};function vf(a,b,c,d){this.g=a;this.shift=b;this.root=c;this.W=d;this.j=275;this.q=88}k=vf.prototype;
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};k.t=function(a,b){return $a.c(this,b,null)};
k.s=function(a,b,c){return"number"===typeof b?C.c(this,b,c):c};k.Q=function(a,b){if(this.root.u)return of(this,b)[b&31];throw Error("nth after persistent!");};k.$=function(a,b,c){return 0<=b&&b<this.g?C.a(this,b):c};k.L=function(){if(this.root.u)return this.g;throw Error("count after persistent!");};
k.Ub=function(a,b,c){var d=this;if(d.root.u){if(0<=b&&b<d.g)return hf(this)<=b?d.W[b&31]=c:(a=function(){return function f(a,h){var l=Ff(d.root.u,h);if(0===a)l.e[b&31]=c;else{var m=b>>>a&31,p=f(a-5,l.e[m]);l.e[m]=p}return l}}(this).call(null,d.shift,d.root),d.root=a),this;if(b===d.g)return Pb(this,c);throw Error([z("Index "),z(b),z(" out of bounds for TransientVector of length"),z(d.g)].join(""));}throw Error("assoc! after persistent!");};
k.Vb=function(){if(this.root.u){if(0===this.g)throw Error("Can't pop empty vector");if(1===this.g)this.g=0;else if(0<(this.g-1&31))this.g-=1;else{var a;a:if(a=this.g-2,a>=hf(this))a=this.W;else{for(var b=this.root,c=b,d=this.shift;;)if(0<d)c=Ff(b.u,c.e[a>>>d&31]),d-=5;else{a=c.e;break a}a=void 0}b=Jf(this,this.shift,this.root);b=null!=b?b:new ef(this.root.u,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null]);5<this.shift&&null==b.e[1]?(this.root=Ff(this.root.u,b.e[0]),this.shift-=5):this.root=b;this.g-=1;this.W=a}return this}throw Error("pop! after persistent!");};k.kb=function(a,b,c){if("number"===typeof b)return Tb(this,b,c);throw Error("TransientVector's key for assoc! must be a number.");};
k.Sa=function(a,b){if(this.root.u){if(32>this.g-hf(this))this.W[this.g&31]=b;else{var c=new ef(this.root.u,this.W),d=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];d[0]=b;this.W=d;if(this.g>>>5>1<<this.shift){var d=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],e=this.shift+
5;d[0]=this.root;d[1]=jf(this.root.u,this.shift,c);this.root=new ef(this.root.u,d);this.shift=e}else this.root=Hf(this,this.shift,this.root,c)}this.g+=1;return this}throw Error("conj! after persistent!");};k.Ta=function(){if(this.root.u){this.root.u=null;var a=this.g-hf(this),b=Array(a);hd(this.W,0,b,0,a);return new W(null,this.g,this.shift,this.root,b,null)}throw Error("persistent! called twice");};function Kf(a,b,c,d){this.k=a;this.ea=b;this.sa=c;this.p=d;this.q=0;this.j=31850572}k=Kf.prototype;
k.toString=function(){return ec(this)};k.H=function(){return this.k};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.N=function(){return G(this.ea)};k.S=function(){var a=K(this.ea);return a?new Kf(this.k,a,this.sa,null):null==this.sa?Na(this):new Kf(this.k,this.sa,null,null)};k.D=function(){return this};k.F=function(a,b){return new Kf(b,this.ea,this.sa,this.p)};k.G=function(a,b){return M(b,this)};
Kf.prototype[Ea]=function(){return uc(this)};function Lf(a,b,c,d,e){this.k=a;this.count=b;this.ea=c;this.sa=d;this.p=e;this.j=31858766;this.q=8192}k=Lf.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.L=function(){return this.count};k.La=function(){return G(this.ea)};k.Ma=function(){if(t(this.ea)){var a=K(this.ea);return a?new Lf(this.k,this.count-1,a,this.sa,null):new Lf(this.k,this.count-1,D(this.sa),Mc,null)}return this};
k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(Mf,this.k)};k.N=function(){return G(this.ea)};k.S=function(){return H(D(this))};k.D=function(){var a=D(this.sa),b=this.ea;return t(t(b)?b:a)?new Kf(null,this.ea,D(a),null):null};k.F=function(a,b){return new Lf(b,this.count,this.ea,this.sa,this.p)};
k.G=function(a,b){var c;t(this.ea)?(c=this.sa,c=new Lf(this.k,this.count+1,this.ea,Nc.a(t(c)?c:Mc,b),null)):c=new Lf(this.k,this.count+1,Nc.a(this.ea,b),Mc,null);return c};var Mf=new Lf(null,0,null,Mc,0);Lf.prototype[Ea]=function(){return uc(this)};function Nf(){this.q=0;this.j=2097152}Nf.prototype.A=function(){return!1};var Of=new Nf;function Pf(a,b){return md(dd(b)?Q(a)===Q(b)?Ee(ud,Oe.a(function(a){return sc.a(S.c(b,G(a),Of),Lc(a))},a)):null:null)}
function Qf(a,b){var c=a.e;if(b instanceof U)a:{for(var d=c.length,e=b.pa,f=0;;){if(d<=f){c=-1;break a}var g=c[f];if(g instanceof U&&e===g.pa){c=f;break a}f+=2}c=void 0}else if(d="string"==typeof b,t(t(d)?d:"number"===typeof b))a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(b===c[e]){c=e;break a}e+=2}c=void 0}else if(b instanceof qc)a:{d=c.length;e=b.ta;for(f=0;;){if(d<=f){c=-1;break a}g=c[f];if(g instanceof qc&&e===g.ta){c=f;break a}f+=2}c=void 0}else if(null==b)a:{d=c.length;for(e=0;;){if(d<=
e){c=-1;break a}if(null==c[e]){c=e;break a}e+=2}c=void 0}else a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(sc.a(b,c[e])){c=e;break a}e+=2}c=void 0}return c}function Rf(a,b,c){this.e=a;this.m=b;this.Z=c;this.q=0;this.j=32374990}k=Rf.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.Z};k.T=function(){return this.m<this.e.length-2?new Rf(this.e,this.m+2,this.Z):null};k.L=function(){return(this.e.length-this.m)/2};k.B=function(){return wc(this)};
k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.Z)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return new W(null,2,5,uf,[this.e[this.m],this.e[this.m+1]],null)};k.S=function(){return this.m<this.e.length-2?new Rf(this.e,this.m+2,this.Z):J};k.D=function(){return this};k.F=function(a,b){return new Rf(this.e,this.m,b)};k.G=function(a,b){return M(b,this)};Rf.prototype[Ea]=function(){return uc(this)};
function Sf(a,b,c){this.e=a;this.m=b;this.g=c}Sf.prototype.ga=function(){return this.m<this.g};Sf.prototype.next=function(){var a=new W(null,2,5,uf,[this.e[this.m],this.e[this.m+1]],null);this.m+=2;return a};function pa(a,b,c,d){this.k=a;this.g=b;this.e=c;this.p=d;this.j=16647951;this.q=8196}k=pa.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){a=Qf(this,b);return-1===a?c:this.e[a+1]};
k.gb=function(a,b,c){a=this.e.length;for(var d=0;;)if(d<a){var e=this.e[d],f=this.e[d+1];c=b.c?b.c(c,e,f):b.call(null,c,e,f);if(Ac(c))return b=c,L.b?L.b(b):L.call(null,b);d+=2}else return c};k.vb=!0;k.fb=function(){return new Sf(this.e,0,2*this.g)};k.H=function(){return this.k};k.L=function(){return this.g};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};
k.A=function(a,b){if(b&&(b.j&1024||b.ic)){var c=this.e.length;if(this.g===b.L(null))for(var d=0;;)if(d<c){var e=b.s(null,this.e[d],jd);if(e!==jd)if(sc.a(this.e[d+1],e))d+=2;else return!1;else return!1}else return!0;else return!1}else return Pf(this,b)};k.$a=function(){return new Tf({},this.e.length,Fa(this.e))};k.J=function(){return ub(Uf,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};
k.wb=function(a,b){if(0<=Qf(this,b)){var c=this.e.length,d=c-2;if(0===d)return Na(this);for(var d=Array(d),e=0,f=0;;){if(e>=c)return new pa(this.k,this.g-1,d,null);sc.a(b,this.e[e])||(d[f]=this.e[e],d[f+1]=this.e[e+1],f+=2);e+=2}}else return this};
k.Ka=function(a,b,c){a=Qf(this,b);if(-1===a){if(this.g<Vf){a=this.e;for(var d=a.length,e=Array(d+2),f=0;;)if(f<d)e[f]=a[f],f+=1;else break;e[d]=b;e[d+1]=c;return new pa(this.k,this.g+1,e,null)}return ub(cb(af.a(Qc,this),b,c),this.k)}if(c===this.e[a+1])return this;b=Fa(this.e);b[a+1]=c;return new pa(this.k,this.g,b,null)};k.rb=function(a,b){return-1!==Qf(this,b)};k.D=function(){var a=this.e;return 0<=a.length-2?new Rf(a,0,null):null};k.F=function(a,b){return new pa(b,this.g,this.e,this.p)};
k.G=function(a,b){if(ed(b))return cb(this,C.a(b,0),C.a(b,1));for(var c=this,d=D(b);;){if(null==d)return c;var e=G(d);if(ed(e))c=cb(c,C.a(e,0),C.a(e,1)),d=K(d);else throw Error("conj on a map takes map entries or seqables of map entries");}};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};var Uf=new pa(null,0,[],null),Vf=8;pa.prototype[Ea]=function(){return uc(this)};
function Tf(a,b,c){this.Va=a;this.qa=b;this.e=c;this.q=56;this.j=258}k=Tf.prototype;k.Jb=function(a,b){if(t(this.Va)){var c=Qf(this,b);0<=c&&(this.e[c]=this.e[this.qa-2],this.e[c+1]=this.e[this.qa-1],c=this.e,c.pop(),c.pop(),this.qa-=2);return this}throw Error("dissoc! after persistent!");};
k.kb=function(a,b,c){var d=this;if(t(d.Va)){a=Qf(this,b);if(-1===a)return d.qa+2<=2*Vf?(d.qa+=2,d.e.push(b),d.e.push(c),this):ee.c(function(){var a=d.qa,b=d.e;return Xf.a?Xf.a(a,b):Xf.call(null,a,b)}(),b,c);c!==d.e[a+1]&&(d.e[a+1]=c);return this}throw Error("assoc! after persistent!");};
k.Sa=function(a,b){if(t(this.Va)){if(b?b.j&2048||b.jc||(b.j?0:w(fb,b)):w(fb,b))return Rb(this,Yf.b?Yf.b(b):Yf.call(null,b),Zf.b?Zf.b(b):Zf.call(null,b));for(var c=D(b),d=this;;){var e=G(c);if(t(e))var f=e,c=K(c),d=Rb(d,function(){var a=f;return Yf.b?Yf.b(a):Yf.call(null,a)}(),function(){var a=f;return Zf.b?Zf.b(a):Zf.call(null,a)}());else return d}}else throw Error("conj! after persistent!");};
k.Ta=function(){if(t(this.Va))return this.Va=!1,new pa(null,Cd(this.qa,2),this.e,null);throw Error("persistent! called twice");};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){if(t(this.Va))return a=Qf(this,b),-1===a?c:this.e[a+1];throw Error("lookup after persistent!");};k.L=function(){if(t(this.Va))return Cd(this.qa,2);throw Error("count after persistent!");};function Xf(a,b){for(var c=Ob(Qc),d=0;;)if(d<a)c=ee.c(c,b[d],b[d+1]),d+=2;else return c}function $f(){this.o=!1}
function ag(a,b){return a===b?!0:Nd(a,b)?!0:sc.a(a,b)}var bg=function(){function a(a,b,c,g,h){a=Fa(a);a[b]=c;a[g]=h;return a}function b(a,b,c){a=Fa(a);a[b]=c;return a}var c=null,c=function(c,e,f,g,h){switch(arguments.length){case 3:return b.call(this,c,e,f);case 5:return a.call(this,c,e,f,g,h)}throw Error("Invalid arity: "+arguments.length);};c.c=b;c.r=a;return c}();function cg(a,b){var c=Array(a.length-2);hd(a,0,c,0,2*b);hd(a,2*(b+1),c,2*b,c.length-2*b);return c}
var dg=function(){function a(a,b,c,g,h,l){a=a.Na(b);a.e[c]=g;a.e[h]=l;return a}function b(a,b,c,g){a=a.Na(b);a.e[c]=g;return a}var c=null,c=function(c,e,f,g,h,l){switch(arguments.length){case 4:return b.call(this,c,e,f,g);case 6:return a.call(this,c,e,f,g,h,l)}throw Error("Invalid arity: "+arguments.length);};c.n=b;c.P=a;return c}();
function eg(a,b,c){for(var d=a.length,e=0,f=c;;)if(e<d){c=a[e];if(null!=c){var g=a[e+1];c=b.c?b.c(f,c,g):b.call(null,f,c,g)}else c=a[e+1],c=null!=c?c.Xa(b,f):f;if(Ac(c))return a=c,L.b?L.b(a):L.call(null,a);e+=2;f=c}else return f}function fg(a,b,c){this.u=a;this.w=b;this.e=c}k=fg.prototype;k.Na=function(a){if(a===this.u)return this;var b=Dd(this.w),c=Array(0>b?4:2*(b+1));hd(this.e,0,c,0,2*b);return new fg(a,this.w,c)};
k.nb=function(a,b,c,d,e){var f=1<<(c>>>b&31);if(0===(this.w&f))return this;var g=Dd(this.w&f-1),h=this.e[2*g],l=this.e[2*g+1];return null==h?(b=l.nb(a,b+5,c,d,e),b===l?this:null!=b?dg.n(this,a,2*g+1,b):this.w===f?null:gg(this,a,f,g)):ag(d,h)?(e[0]=!0,gg(this,a,f,g)):this};function gg(a,b,c,d){if(a.w===c)return null;a=a.Na(b);b=a.e;var e=b.length;a.w^=c;hd(b,2*(d+1),b,2*d,e-2*(d+1));b[e-2]=null;b[e-1]=null;return a}k.lb=function(){var a=this.e;return hg.b?hg.b(a):hg.call(null,a)};
k.Xa=function(a,b){return eg(this.e,a,b)};k.Oa=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.w&e))return d;var f=Dd(this.w&e-1),e=this.e[2*f],f=this.e[2*f+1];return null==e?f.Oa(a+5,b,c,d):ag(c,e)?f:d};
k.la=function(a,b,c,d,e,f){var g=1<<(c>>>b&31),h=Dd(this.w&g-1);if(0===(this.w&g)){var l=Dd(this.w);if(2*l<this.e.length){var m=this.Na(a),p=m.e;f.o=!0;id(p,2*h,p,2*(h+1),2*(l-h));p[2*h]=d;p[2*h+1]=e;m.w|=g;return m}if(16<=l){g=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];g[c>>>b&31]=ig.la(a,b+5,c,d,e,f);for(m=h=0;;)if(32>h)0!==(this.w>>>h&1)&&(g[h]=null!=this.e[m]?ig.la(a,b+5,nc(this.e[m]),
this.e[m],this.e[m+1],f):this.e[m+1],m+=2),h+=1;else break;return new jg(a,l+1,g)}p=Array(2*(l+4));hd(this.e,0,p,0,2*h);p[2*h]=d;p[2*h+1]=e;hd(this.e,2*h,p,2*(h+1),2*(l-h));f.o=!0;m=this.Na(a);m.e=p;m.w|=g;return m}var q=this.e[2*h],s=this.e[2*h+1];if(null==q)return l=s.la(a,b+5,c,d,e,f),l===s?this:dg.n(this,a,2*h+1,l);if(ag(d,q))return e===s?this:dg.n(this,a,2*h+1,e);f.o=!0;return dg.P(this,a,2*h,null,2*h+1,function(){var f=b+5;return kg.ia?kg.ia(a,f,q,s,c,d,e):kg.call(null,a,f,q,s,c,d,e)}())};
k.ka=function(a,b,c,d,e){var f=1<<(b>>>a&31),g=Dd(this.w&f-1);if(0===(this.w&f)){var h=Dd(this.w);if(16<=h){f=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];f[b>>>a&31]=ig.ka(a+5,b,c,d,e);for(var l=g=0;;)if(32>g)0!==(this.w>>>g&1)&&(f[g]=null!=this.e[l]?ig.ka(a+5,nc(this.e[l]),this.e[l],this.e[l+1],e):this.e[l+1],l+=2),g+=1;else break;return new jg(null,h+1,f)}l=Array(2*(h+1));hd(this.e,
0,l,0,2*g);l[2*g]=c;l[2*g+1]=d;hd(this.e,2*g,l,2*(g+1),2*(h-g));e.o=!0;return new fg(null,this.w|f,l)}var m=this.e[2*g],p=this.e[2*g+1];if(null==m)return h=p.ka(a+5,b,c,d,e),h===p?this:new fg(null,this.w,bg.c(this.e,2*g+1,h));if(ag(c,m))return d===p?this:new fg(null,this.w,bg.c(this.e,2*g+1,d));e.o=!0;return new fg(null,this.w,bg.r(this.e,2*g,null,2*g+1,function(){var e=a+5;return kg.P?kg.P(e,m,p,b,c,d):kg.call(null,e,m,p,b,c,d)}()))};
k.mb=function(a,b,c){var d=1<<(b>>>a&31);if(0===(this.w&d))return this;var e=Dd(this.w&d-1),f=this.e[2*e],g=this.e[2*e+1];return null==f?(a=g.mb(a+5,b,c),a===g?this:null!=a?new fg(null,this.w,bg.c(this.e,2*e+1,a)):this.w===d?null:new fg(null,this.w^d,cg(this.e,e))):ag(c,f)?new fg(null,this.w^d,cg(this.e,e)):this};var ig=new fg(null,0,[]);
function lg(a,b,c){var d=a.e,e=d.length;a=Array(2*(a.g-1));for(var f=0,g=1,h=0;;)if(f<e)f!==c&&null!=d[f]&&(a[g]=d[f],g+=2,h|=1<<f),f+=1;else return new fg(b,h,a)}function jg(a,b,c){this.u=a;this.g=b;this.e=c}k=jg.prototype;k.Na=function(a){return a===this.u?this:new jg(a,this.g,Fa(this.e))};
k.nb=function(a,b,c,d,e){var f=c>>>b&31,g=this.e[f];if(null==g)return this;b=g.nb(a,b+5,c,d,e);if(b===g)return this;if(null==b){if(8>=this.g)return lg(this,a,f);a=dg.n(this,a,f,b);a.g-=1;return a}return dg.n(this,a,f,b)};k.lb=function(){var a=this.e;return mg.b?mg.b(a):mg.call(null,a)};k.Xa=function(a,b){for(var c=this.e.length,d=0,e=b;;)if(d<c){var f=this.e[d];if(null!=f&&(e=f.Xa(a,e),Ac(e)))return c=e,L.b?L.b(c):L.call(null,c);d+=1}else return e};
k.Oa=function(a,b,c,d){var e=this.e[b>>>a&31];return null!=e?e.Oa(a+5,b,c,d):d};k.la=function(a,b,c,d,e,f){var g=c>>>b&31,h=this.e[g];if(null==h)return a=dg.n(this,a,g,ig.la(a,b+5,c,d,e,f)),a.g+=1,a;b=h.la(a,b+5,c,d,e,f);return b===h?this:dg.n(this,a,g,b)};k.ka=function(a,b,c,d,e){var f=b>>>a&31,g=this.e[f];if(null==g)return new jg(null,this.g+1,bg.c(this.e,f,ig.ka(a+5,b,c,d,e)));a=g.ka(a+5,b,c,d,e);return a===g?this:new jg(null,this.g,bg.c(this.e,f,a))};
k.mb=function(a,b,c){var d=b>>>a&31,e=this.e[d];return null!=e?(a=e.mb(a+5,b,c),a===e?this:null==a?8>=this.g?lg(this,null,d):new jg(null,this.g-1,bg.c(this.e,d,a)):new jg(null,this.g,bg.c(this.e,d,a))):this};function ng(a,b,c){b*=2;for(var d=0;;)if(d<b){if(ag(c,a[d]))return d;d+=2}else return-1}function og(a,b,c,d){this.u=a;this.Ia=b;this.g=c;this.e=d}k=og.prototype;k.Na=function(a){if(a===this.u)return this;var b=Array(2*(this.g+1));hd(this.e,0,b,0,2*this.g);return new og(a,this.Ia,this.g,b)};
k.nb=function(a,b,c,d,e){b=ng(this.e,this.g,d);if(-1===b)return this;e[0]=!0;if(1===this.g)return null;a=this.Na(a);e=a.e;e[b]=e[2*this.g-2];e[b+1]=e[2*this.g-1];e[2*this.g-1]=null;e[2*this.g-2]=null;a.g-=1;return a};k.lb=function(){var a=this.e;return hg.b?hg.b(a):hg.call(null,a)};k.Xa=function(a,b){return eg(this.e,a,b)};k.Oa=function(a,b,c,d){a=ng(this.e,this.g,c);return 0>a?d:ag(c,this.e[a])?this.e[a+1]:d};
k.la=function(a,b,c,d,e,f){if(c===this.Ia){b=ng(this.e,this.g,d);if(-1===b){if(this.e.length>2*this.g)return a=dg.P(this,a,2*this.g,d,2*this.g+1,e),f.o=!0,a.g+=1,a;c=this.e.length;b=Array(c+2);hd(this.e,0,b,0,c);b[c]=d;b[c+1]=e;f.o=!0;f=this.g+1;a===this.u?(this.e=b,this.g=f,a=this):a=new og(this.u,this.Ia,f,b);return a}return this.e[b+1]===e?this:dg.n(this,a,b+1,e)}return(new fg(a,1<<(this.Ia>>>b&31),[null,this,null,null])).la(a,b,c,d,e,f)};
k.ka=function(a,b,c,d,e){return b===this.Ia?(a=ng(this.e,this.g,c),-1===a?(a=2*this.g,b=Array(a+2),hd(this.e,0,b,0,a),b[a]=c,b[a+1]=d,e.o=!0,new og(null,this.Ia,this.g+1,b)):sc.a(this.e[a],d)?this:new og(null,this.Ia,this.g,bg.c(this.e,a+1,d))):(new fg(null,1<<(this.Ia>>>a&31),[null,this])).ka(a,b,c,d,e)};k.mb=function(a,b,c){a=ng(this.e,this.g,c);return-1===a?this:1===this.g?null:new og(null,this.Ia,this.g-1,cg(this.e,Cd(a,2)))};
var kg=function(){function a(a,b,c,g,h,l,m){var p=nc(c);if(p===h)return new og(null,p,2,[c,g,l,m]);var q=new $f;return ig.la(a,b,p,c,g,q).la(a,b,h,l,m,q)}function b(a,b,c,g,h,l){var m=nc(b);if(m===g)return new og(null,m,2,[b,c,h,l]);var p=new $f;return ig.ka(a,m,b,c,p).ka(a,g,h,l,p)}var c=null,c=function(c,e,f,g,h,l,m){switch(arguments.length){case 6:return b.call(this,c,e,f,g,h,l);case 7:return a.call(this,c,e,f,g,h,l,m)}throw Error("Invalid arity: "+arguments.length);};c.P=b;c.ia=a;return c}();
function pg(a,b,c,d,e){this.k=a;this.Pa=b;this.m=c;this.C=d;this.p=e;this.q=0;this.j=32374860}k=pg.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return null==this.C?new W(null,2,5,uf,[this.Pa[this.m],this.Pa[this.m+1]],null):G(this.C)};
k.S=function(){if(null==this.C){var a=this.Pa,b=this.m+2;return hg.c?hg.c(a,b,null):hg.call(null,a,b,null)}var a=this.Pa,b=this.m,c=K(this.C);return hg.c?hg.c(a,b,c):hg.call(null,a,b,c)};k.D=function(){return this};k.F=function(a,b){return new pg(b,this.Pa,this.m,this.C,this.p)};k.G=function(a,b){return M(b,this)};pg.prototype[Ea]=function(){return uc(this)};
var hg=function(){function a(a,b,c){if(null==c)for(c=a.length;;)if(b<c){if(null!=a[b])return new pg(null,a,b,null,null);var g=a[b+1];if(t(g)&&(g=g.lb(),t(g)))return new pg(null,a,b+2,g,null);b+=2}else return null;else return new pg(null,a,b,c,null)}function b(a){return c.c(a,0,null)}var c=null,c=function(c,e,f){switch(arguments.length){case 1:return b.call(this,c);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.c=a;return c}();
function qg(a,b,c,d,e){this.k=a;this.Pa=b;this.m=c;this.C=d;this.p=e;this.q=0;this.j=32374860}k=qg.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return G(this.C)};
k.S=function(){var a=this.Pa,b=this.m,c=K(this.C);return mg.n?mg.n(null,a,b,c):mg.call(null,null,a,b,c)};k.D=function(){return this};k.F=function(a,b){return new qg(b,this.Pa,this.m,this.C,this.p)};k.G=function(a,b){return M(b,this)};qg.prototype[Ea]=function(){return uc(this)};
var mg=function(){function a(a,b,c,g){if(null==g)for(g=b.length;;)if(c<g){var h=b[c];if(t(h)&&(h=h.lb(),t(h)))return new qg(a,b,c+1,h,null);c+=1}else return null;else return new qg(a,b,c,g,null)}function b(a){return c.n(null,a,0,null)}var c=null,c=function(c,e,f,g){switch(arguments.length){case 1:return b.call(this,c);case 4:return a.call(this,c,e,f,g)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.n=a;return c}();
function rg(a,b,c,d,e,f){this.k=a;this.g=b;this.root=c;this.U=d;this.da=e;this.p=f;this.j=16123663;this.q=8196}k=rg.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return null==b?this.U?this.da:c:null==this.root?c:this.root.Oa(0,nc(b),b,c)};k.gb=function(a,b,c){this.U&&(a=this.da,c=b.c?b.c(c,null,a):b.call(null,c,null,a));return Ac(c)?L.b?L.b(c):L.call(null,c):null!=this.root?this.root.Xa(b,c):c};k.H=function(){return this.k};k.L=function(){return this.g};
k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};k.A=function(a,b){return Pf(this,b)};k.$a=function(){return new sg({},this.root,this.g,this.U,this.da)};k.J=function(){return ub(Qc,this.k)};k.wb=function(a,b){if(null==b)return this.U?new rg(this.k,this.g-1,this.root,!1,null,null):this;if(null==this.root)return this;var c=this.root.mb(0,nc(b),b);return c===this.root?this:new rg(this.k,this.g-1,c,this.U,this.da,null)};
k.Ka=function(a,b,c){if(null==b)return this.U&&c===this.da?this:new rg(this.k,this.U?this.g:this.g+1,this.root,!0,c,null);a=new $f;b=(null==this.root?ig:this.root).ka(0,nc(b),b,c,a);return b===this.root?this:new rg(this.k,a.o?this.g+1:this.g,b,this.U,this.da,null)};k.rb=function(a,b){return null==b?this.U:null==this.root?!1:this.root.Oa(0,nc(b),b,jd)!==jd};k.D=function(){if(0<this.g){var a=null!=this.root?this.root.lb():null;return this.U?M(new W(null,2,5,uf,[null,this.da],null),a):a}return null};
k.F=function(a,b){return new rg(b,this.g,this.root,this.U,this.da,this.p)};k.G=function(a,b){if(ed(b))return cb(this,C.a(b,0),C.a(b,1));for(var c=this,d=D(b);;){if(null==d)return c;var e=G(d);if(ed(e))c=cb(c,C.a(e,0),C.a(e,1)),d=K(d);else throw Error("conj on a map takes map entries or seqables of map entries");}};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};var Qc=new rg(null,0,null,!1,null,0);rg.prototype[Ea]=function(){return uc(this)};
function sg(a,b,c,d,e){this.u=a;this.root=b;this.count=c;this.U=d;this.da=e;this.q=56;this.j=258}k=sg.prototype;k.Jb=function(a,b){if(this.u)if(null==b)this.U&&(this.U=!1,this.da=null,this.count-=1);else{if(null!=this.root){var c=new $f,d=this.root.nb(this.u,0,nc(b),b,c);d!==this.root&&(this.root=d);t(c[0])&&(this.count-=1)}}else throw Error("dissoc! after persistent!");return this};k.kb=function(a,b,c){return tg(this,b,c)};k.Sa=function(a,b){return ug(this,b)};
k.Ta=function(){var a;if(this.u)this.u=null,a=new rg(null,this.count,this.root,this.U,this.da,null);else throw Error("persistent! called twice");return a};k.t=function(a,b){return null==b?this.U?this.da:null:null==this.root?null:this.root.Oa(0,nc(b),b)};k.s=function(a,b,c){return null==b?this.U?this.da:c:null==this.root?c:this.root.Oa(0,nc(b),b,c)};k.L=function(){if(this.u)return this.count;throw Error("count after persistent!");};
function ug(a,b){if(a.u){if(b?b.j&2048||b.jc||(b.j?0:w(fb,b)):w(fb,b))return tg(a,Yf.b?Yf.b(b):Yf.call(null,b),Zf.b?Zf.b(b):Zf.call(null,b));for(var c=D(b),d=a;;){var e=G(c);if(t(e))var f=e,c=K(c),d=tg(d,function(){var a=f;return Yf.b?Yf.b(a):Yf.call(null,a)}(),function(){var a=f;return Zf.b?Zf.b(a):Zf.call(null,a)}());else return d}}else throw Error("conj! after persistent");}
function tg(a,b,c){if(a.u){if(null==b)a.da!==c&&(a.da=c),a.U||(a.count+=1,a.U=!0);else{var d=new $f;b=(null==a.root?ig:a.root).la(a.u,0,nc(b),b,c,d);b!==a.root&&(a.root=b);d.o&&(a.count+=1)}return a}throw Error("assoc! after persistent!");}function vg(a,b,c){for(var d=b;;)if(null!=a)b=c?a.left:a.right,d=Nc.a(d,a),a=b;else return d}function wg(a,b,c,d,e){this.k=a;this.stack=b;this.pb=c;this.g=d;this.p=e;this.q=0;this.j=32374862}k=wg.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};
k.L=function(){return 0>this.g?Q(K(this))+1:this.g};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return Wc(this.stack)};k.S=function(){var a=G(this.stack),a=vg(this.pb?a.right:a.left,K(this.stack),this.pb);return null!=a?new wg(null,a,this.pb,this.g-1,null):J};k.D=function(){return this};
k.F=function(a,b){return new wg(b,this.stack,this.pb,this.g,this.p)};k.G=function(a,b){return M(b,this)};wg.prototype[Ea]=function(){return uc(this)};function xg(a,b,c){return new wg(null,vg(a,null,b),b,c,null)}
function yg(a,b,c,d){return c instanceof X?c.left instanceof X?new X(c.key,c.o,c.left.ua(),new Z(a,b,c.right,d,null),null):c.right instanceof X?new X(c.right.key,c.right.o,new Z(c.key,c.o,c.left,c.right.left,null),new Z(a,b,c.right.right,d,null),null):new Z(a,b,c,d,null):new Z(a,b,c,d,null)}
function zg(a,b,c,d){return d instanceof X?d.right instanceof X?new X(d.key,d.o,new Z(a,b,c,d.left,null),d.right.ua(),null):d.left instanceof X?new X(d.left.key,d.left.o,new Z(a,b,c,d.left.left,null),new Z(d.key,d.o,d.left.right,d.right,null),null):new Z(a,b,c,d,null):new Z(a,b,c,d,null)}
function Ag(a,b,c,d){if(c instanceof X)return new X(a,b,c.ua(),d,null);if(d instanceof Z)return zg(a,b,c,d.ob());if(d instanceof X&&d.left instanceof Z)return new X(d.left.key,d.left.o,new Z(a,b,c,d.left.left,null),zg(d.key,d.o,d.left.right,d.right.ob()),null);throw Error("red-black tree invariant violation");}
var Cg=function Bg(b,c,d){d=null!=b.left?Bg(b.left,c,d):d;if(Ac(d))return L.b?L.b(d):L.call(null,d);var e=b.key,f=b.o;d=c.c?c.c(d,e,f):c.call(null,d,e,f);if(Ac(d))return L.b?L.b(d):L.call(null,d);b=null!=b.right?Bg(b.right,c,d):d;return Ac(b)?L.b?L.b(b):L.call(null,b):b};function Z(a,b,c,d,e){this.key=a;this.o=b;this.left=c;this.right=d;this.p=e;this.q=0;this.j=32402207}k=Z.prototype;k.Mb=function(a){return a.Ob(this)};k.ob=function(){return new X(this.key,this.o,this.left,this.right,null)};
k.ua=function(){return this};k.Lb=function(a){return a.Nb(this)};k.replace=function(a,b,c,d){return new Z(a,b,c,d,null)};k.Nb=function(a){return new Z(a.key,a.o,this,a.right,null)};k.Ob=function(a){return new Z(a.key,a.o,a.left,this,null)};k.Xa=function(a,b){return Cg(this,a,b)};k.t=function(a,b){return C.c(this,b,null)};k.s=function(a,b,c){return C.c(this,b,c)};k.Q=function(a,b){return 0===b?this.key:1===b?this.o:null};k.$=function(a,b,c){return 0===b?this.key:1===b?this.o:c};
k.Ua=function(a,b,c){return(new W(null,2,5,uf,[this.key,this.o],null)).Ua(null,b,c)};k.H=function(){return null};k.L=function(){return 2};k.hb=function(){return this.key};k.ib=function(){return this.o};k.La=function(){return this.o};k.Ma=function(){return new W(null,1,5,uf,[this.key],null)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return Mc};k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){return Cc.c(this,b,c)};
k.Ka=function(a,b,c){return Rc.c(new W(null,2,5,uf,[this.key,this.o],null),b,c)};k.D=function(){return Ra(Ra(J,this.o),this.key)};k.F=function(a,b){return O(new W(null,2,5,uf,[this.key,this.o],null),b)};k.G=function(a,b){return new W(null,3,5,uf,[this.key,this.o,b],null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};Z.prototype[Ea]=function(){return uc(this)};
function X(a,b,c,d,e){this.key=a;this.o=b;this.left=c;this.right=d;this.p=e;this.q=0;this.j=32402207}k=X.prototype;k.Mb=function(a){return new X(this.key,this.o,this.left,a,null)};k.ob=function(){throw Error("red-black tree invariant violation");};k.ua=function(){return new Z(this.key,this.o,this.left,this.right,null)};k.Lb=function(a){return new X(this.key,this.o,a,this.right,null)};k.replace=function(a,b,c,d){return new X(a,b,c,d,null)};
k.Nb=function(a){return this.left instanceof X?new X(this.key,this.o,this.left.ua(),new Z(a.key,a.o,this.right,a.right,null),null):this.right instanceof X?new X(this.right.key,this.right.o,new Z(this.key,this.o,this.left,this.right.left,null),new Z(a.key,a.o,this.right.right,a.right,null),null):new Z(a.key,a.o,this,a.right,null)};
k.Ob=function(a){return this.right instanceof X?new X(this.key,this.o,new Z(a.key,a.o,a.left,this.left,null),this.right.ua(),null):this.left instanceof X?new X(this.left.key,this.left.o,new Z(a.key,a.o,a.left,this.left.left,null),new Z(this.key,this.o,this.left.right,this.right,null),null):new Z(a.key,a.o,a.left,this,null)};k.Xa=function(a,b){return Cg(this,a,b)};k.t=function(a,b){return C.c(this,b,null)};k.s=function(a,b,c){return C.c(this,b,c)};
k.Q=function(a,b){return 0===b?this.key:1===b?this.o:null};k.$=function(a,b,c){return 0===b?this.key:1===b?this.o:c};k.Ua=function(a,b,c){return(new W(null,2,5,uf,[this.key,this.o],null)).Ua(null,b,c)};k.H=function(){return null};k.L=function(){return 2};k.hb=function(){return this.key};k.ib=function(){return this.o};k.La=function(){return this.o};k.Ma=function(){return new W(null,1,5,uf,[this.key],null)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};
k.A=function(a,b){return Ic(this,b)};k.J=function(){return Mc};k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){return Cc.c(this,b,c)};k.Ka=function(a,b,c){return Rc.c(new W(null,2,5,uf,[this.key,this.o],null),b,c)};k.D=function(){return Ra(Ra(J,this.o),this.key)};k.F=function(a,b){return O(new W(null,2,5,uf,[this.key,this.o],null),b)};k.G=function(a,b){return new W(null,3,5,uf,[this.key,this.o,b],null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};X.prototype[Ea]=function(){return uc(this)};
var Eg=function Dg(b,c,d,e,f){if(null==c)return new X(d,e,null,null,null);var g;g=c.key;g=b.a?b.a(d,g):b.call(null,d,g);if(0===g)return f[0]=c,null;if(0>g)return b=Dg(b,c.left,d,e,f),null!=b?c.Lb(b):null;b=Dg(b,c.right,d,e,f);return null!=b?c.Mb(b):null},Gg=function Fg(b,c){if(null==b)return c;if(null==c)return b;if(b instanceof X){if(c instanceof X){var d=Fg(b.right,c.left);return d instanceof X?new X(d.key,d.o,new X(b.key,b.o,b.left,d.left,null),new X(c.key,c.o,d.right,c.right,null),null):new X(b.key,
b.o,b.left,new X(c.key,c.o,d,c.right,null),null)}return new X(b.key,b.o,b.left,Fg(b.right,c),null)}if(c instanceof X)return new X(c.key,c.o,Fg(b,c.left),c.right,null);d=Fg(b.right,c.left);return d instanceof X?new X(d.key,d.o,new Z(b.key,b.o,b.left,d.left,null),new Z(c.key,c.o,d.right,c.right,null),null):Ag(b.key,b.o,b.left,new Z(c.key,c.o,d,c.right,null))},Ig=function Hg(b,c,d,e){if(null!=c){var f;f=c.key;f=b.a?b.a(d,f):b.call(null,d,f);if(0===f)return e[0]=c,Gg(c.left,c.right);if(0>f)return b=Hg(b,
c.left,d,e),null!=b||null!=e[0]?c.left instanceof Z?Ag(c.key,c.o,b,c.right):new X(c.key,c.o,b,c.right,null):null;b=Hg(b,c.right,d,e);if(null!=b||null!=e[0])if(c.right instanceof Z)if(e=c.key,d=c.o,c=c.left,b instanceof X)c=new X(e,d,c,b.ua(),null);else if(c instanceof Z)c=yg(e,d,c.ob(),b);else if(c instanceof X&&c.right instanceof Z)c=new X(c.right.key,c.right.o,yg(c.key,c.o,c.left.ob(),c.right.left),new Z(e,d,c.right.right,b,null),null);else throw Error("red-black tree invariant violation");else c=
new X(c.key,c.o,c.left,b,null);else c=null;return c}return null},Kg=function Jg(b,c,d,e){var f=c.key,g=b.a?b.a(d,f):b.call(null,d,f);return 0===g?c.replace(f,e,c.left,c.right):0>g?c.replace(f,c.o,Jg(b,c.left,d,e),c.right):c.replace(f,c.o,c.left,Jg(b,c.right,d,e))};function Lg(a,b,c,d,e){this.aa=a;this.na=b;this.g=c;this.k=d;this.p=e;this.j=418776847;this.q=8192}k=Lg.prototype;k.toString=function(){return ec(this)};
function Mg(a,b){for(var c=a.na;;)if(null!=c){var d;d=c.key;d=a.aa.a?a.aa.a(b,d):a.aa.call(null,b,d);if(0===d)return c;c=0>d?c.left:c.right}else return null}k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){a=Mg(this,b);return null!=a?a.o:c};k.gb=function(a,b,c){return null!=this.na?Cg(this.na,b,c):c};k.H=function(){return this.k};k.L=function(){return this.g};k.ab=function(){return 0<this.g?xg(this.na,!1,this.g):null};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};
k.A=function(a,b){return Pf(this,b)};k.J=function(){return new Lg(this.aa,null,0,this.k,0)};k.wb=function(a,b){var c=[null],d=Ig(this.aa,this.na,b,c);return null==d?null==R.a(c,0)?this:new Lg(this.aa,null,0,this.k,null):new Lg(this.aa,d.ua(),this.g-1,this.k,null)};k.Ka=function(a,b,c){a=[null];var d=Eg(this.aa,this.na,b,c,a);return null==d?(a=R.a(a,0),sc.a(c,a.o)?this:new Lg(this.aa,Kg(this.aa,this.na,b,c),this.g,this.k,null)):new Lg(this.aa,d.ua(),this.g+1,this.k,null)};
k.rb=function(a,b){return null!=Mg(this,b)};k.D=function(){return 0<this.g?xg(this.na,!0,this.g):null};k.F=function(a,b){return new Lg(this.aa,this.na,this.g,b,this.p)};k.G=function(a,b){if(ed(b))return cb(this,C.a(b,0),C.a(b,1));for(var c=this,d=D(b);;){if(null==d)return c;var e=G(d);if(ed(e))c=cb(c,C.a(e,0),C.a(e,1)),d=K(d);else throw Error("conj on a map takes map entries or seqables of map entries");}};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};k.Hb=function(a,b){return 0<this.g?xg(this.na,b,this.g):null};
k.Ib=function(a,b,c){if(0<this.g){a=null;for(var d=this.na;;)if(null!=d){var e;e=d.key;e=this.aa.a?this.aa.a(b,e):this.aa.call(null,b,e);if(0===e)return new wg(null,Nc.a(a,d),c,-1,null);t(c)?0>e?(a=Nc.a(a,d),d=d.left):d=d.right:0<e?(a=Nc.a(a,d),d=d.right):d=d.left}else return null==a?null:new wg(null,a,c,-1,null)}else return null};k.Gb=function(a,b){return Yf.b?Yf.b(b):Yf.call(null,b)};k.Fb=function(){return this.aa};var Ng=new Lg(od,null,0,null,0);Lg.prototype[Ea]=function(){return uc(this)};
var Og=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){a=D(a);for(var b=Ob(Qc);;)if(a){var e=K(K(a)),b=ee.c(b,G(a),Lc(a));a=e}else return Qb(b)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),Pg=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,
d)}function b(a){a:{a=T.a(Ha,a);for(var b=a.length,e=0,f=Ob(Uf);;)if(e<b)var g=e+2,f=Rb(f,a[e],a[e+1]),e=g;else{a=Qb(f);break a}a=void 0}return a}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),Qg=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){a=D(a);for(var b=Ng;;)if(a){var e=K(K(a)),b=Rc.c(b,G(a),Lc(a));a=e}else return b}a.i=0;a.f=function(a){a=D(a);
return b(a)};a.d=b;return a}(),Rg=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){for(var e=D(b),f=new Lg(qd(a),null,0,null,0);;)if(e)var g=K(K(e)),f=Rc.c(f,G(e),Lc(e)),e=g;else return f}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}();function Sg(a,b){this.Y=a;this.Z=b;this.q=0;this.j=32374988}k=Sg.prototype;k.toString=function(){return ec(this)};
k.H=function(){return this.Z};k.T=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null==a?null:new Sg(a,this.Z)};k.B=function(){return wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.Z)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.Y.N(null).hb(null)};
k.S=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null!=a?new Sg(a,this.Z):J};k.D=function(){return this};k.F=function(a,b){return new Sg(this.Y,b)};k.G=function(a,b){return M(b,this)};Sg.prototype[Ea]=function(){return uc(this)};function Tg(a){return(a=D(a))?new Sg(a,null):null}function Yf(a){return hb(a)}function Ug(a,b){this.Y=a;this.Z=b;this.q=0;this.j=32374988}k=Ug.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.Z};
k.T=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null==a?null:new Ug(a,this.Z)};k.B=function(){return wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.Z)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.Y.N(null).ib(null)};k.S=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null!=a?new Ug(a,this.Z):J};
k.D=function(){return this};k.F=function(a,b){return new Ug(this.Y,b)};k.G=function(a,b){return M(b,this)};Ug.prototype[Ea]=function(){return uc(this)};function Vg(a){return(a=D(a))?new Ug(a,null):null}function Zf(a){return ib(a)}
var Wg=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return t(Fe(ud,a))?A.a(function(a,b){return Nc.a(t(a)?a:Uf,b)},a):null}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),Xg=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,
b){return t(Fe(ud,b))?A.a(function(a){return function(b,c){return A.c(a,t(b)?b:Uf,D(c))}}(function(b,d){var g=G(d),h=Lc(d);return nd(b,g)?Rc.c(b,g,function(){var d=S.a(b,g);return a.a?a.a(d,h):a.call(null,d,h)}()):Rc.c(b,g,h)}),b):null}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}();function Yg(a,b){for(var c=Uf,d=D(b);;)if(d)var e=G(d),f=S.c(a,e,Zg),c=je.a(f,Zg)?Rc.c(c,e,f):c,d=K(d);else return O(c,Vc(a))}
function $g(a,b,c){this.k=a;this.Wa=b;this.p=c;this.j=15077647;this.q=8196}k=$g.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return bb(this.Wa,b)?b:c};k.H=function(){return this.k};k.L=function(){return Ma(this.Wa)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};k.A=function(a,b){return ad(b)&&Q(this)===Q(b)&&Ee(function(a){return function(b){return nd(a,b)}}(this),b)};k.$a=function(){return new ah(Ob(this.Wa))};
k.J=function(){return O(bh,this.k)};k.Eb=function(a,b){return new $g(this.k,eb(this.Wa,b),null)};k.D=function(){return Tg(this.Wa)};k.F=function(a,b){return new $g(b,this.Wa,this.p)};k.G=function(a,b){return new $g(this.k,Rc.c(this.Wa,b,null),null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};var bh=new $g(null,Uf,0);$g.prototype[Ea]=function(){return uc(this)};
function ah(a){this.ma=a;this.j=259;this.q=136}k=ah.prototype;k.call=function(){function a(a,b,c){return $a.c(this.ma,b,jd)===jd?c:b}function b(a,b){return $a.c(this.ma,b,jd)===jd?null:b}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};
k.b=function(a){return $a.c(this.ma,a,jd)===jd?null:a};k.a=function(a,b){return $a.c(this.ma,a,jd)===jd?b:a};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return $a.c(this.ma,b,jd)===jd?c:b};k.L=function(){return Q(this.ma)};k.Tb=function(a,b){this.ma=fe.a(this.ma,b);return this};k.Sa=function(a,b){this.ma=ee.c(this.ma,b,null);return this};k.Ta=function(){return new $g(null,Qb(this.ma),null)};function ch(a,b,c){this.k=a;this.ja=b;this.p=c;this.j=417730831;this.q=8192}k=ch.prototype;
k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){a=Mg(this.ja,b);return null!=a?a.key:c};k.H=function(){return this.k};k.L=function(){return Q(this.ja)};k.ab=function(){return 0<Q(this.ja)?Oe.a(Yf,Gb(this.ja)):null};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};k.A=function(a,b){return ad(b)&&Q(this)===Q(b)&&Ee(function(a){return function(b){return nd(a,b)}}(this),b)};k.J=function(){return new ch(this.k,Na(this.ja),0)};
k.Eb=function(a,b){return new ch(this.k,Sc.a(this.ja,b),null)};k.D=function(){return Tg(this.ja)};k.F=function(a,b){return new ch(b,this.ja,this.p)};k.G=function(a,b){return new ch(this.k,Rc.c(this.ja,b,null),null)};k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();
k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};k.Hb=function(a,b){return Oe.a(Yf,Hb(this.ja,b))};k.Ib=function(a,b,c){return Oe.a(Yf,Ib(this.ja,b,c))};k.Gb=function(a,b){return b};k.Fb=function(){return Kb(this.ja)};var eh=new ch(null,Ng,0);ch.prototype[Ea]=function(){return uc(this)};
function fh(a){a=D(a);if(null==a)return bh;if(a instanceof F&&0===a.m){a=a.e;a:{for(var b=0,c=Ob(bh);;)if(b<a.length)var d=b+1,c=c.Sa(null,a[b]),b=d;else{a=c;break a}a=void 0}return a.Ta(null)}for(d=Ob(bh);;)if(null!=a)b=a.T(null),d=d.Sa(null,a.N(null)),a=b;else return d.Ta(null)}
var gh=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return A.c(Ra,eh,a)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),hh=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){return A.c(Ra,new ch(null,Rg(a),0),b)}
a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}();function Od(a){if(a&&(a.q&4096||a.lc))return a.name;if("string"===typeof a)return a;throw Error([z("Doesn't support name: "),z(a)].join(""));}
var ih=function(){function a(a,b,c){return(a.b?a.b(b):a.call(null,b))>(a.b?a.b(c):a.call(null,c))?b:c}var b=null,c=function(){function a(b,d,h,l){var m=null;if(3<arguments.length){for(var m=0,p=Array(arguments.length-3);m<p.length;)p[m]=arguments[m+3],++m;m=new F(p,0)}return c.call(this,b,d,h,m)}function c(a,d,e,l){return A.c(function(c,d){return b.c(a,c,d)},b.c(a,d,e),l)}a.i=3;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=K(a);var l=G(a);a=H(a);return c(b,d,l,a)};a.d=c;return a}(),b=function(b,
e,f,g){switch(arguments.length){case 2:return e;case 3:return a.call(this,b,e,f);default:var h=null;if(3<arguments.length){for(var h=0,l=Array(arguments.length-3);h<l.length;)l[h]=arguments[h+3],++h;h=new F(l,0)}return c.d(b,e,f,h)}throw Error("Invalid arity: "+arguments.length);};b.i=3;b.f=c.f;b.a=function(a,b){return b};b.c=a;b.d=c.d;return b}();function jh(a){this.e=a}jh.prototype.add=function(a){return this.e.push(a)};jh.prototype.size=function(){return this.e.length};
jh.prototype.clear=function(){return this.e=[]};
var kh=function(){function a(a,b,c){return new V(null,function(){var h=D(c);return h?M(Pe.a(a,h),d.c(a,b,Qe.a(b,h))):null},null,null)}function b(a,b){return d.c(a,a,b)}function c(a){return function(b){return function(c){return function(){function d(h,l){c.add(l);if(a===c.size()){var m=zf(c.e);c.clear();return b.a?b.a(h,m):b.call(null,h,m)}return h}function l(a){if(!t(0===c.e.length)){var d=zf(c.e);c.clear();a=Bc(b.a?b.a(a,d):b.call(null,a,d))}return b.b?b.b(a):b.call(null,a)}function m(){return b.l?
b.l():b.call(null)}var p=null,p=function(a,b){switch(arguments.length){case 0:return m.call(this);case 1:return l.call(this,a);case 2:return d.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};p.l=m;p.b=l;p.a=d;return p}()}(new jh([]))}}var d=null,d=function(d,f,g){switch(arguments.length){case 1:return c.call(this,d);case 2:return b.call(this,d,f);case 3:return a.call(this,d,f,g)}throw Error("Invalid arity: "+arguments.length);};d.b=c;d.a=b;d.c=a;return d}(),lh=function(){function a(a,
b){return new V(null,function(){var f=D(b);if(f){var g;g=G(f);g=a.b?a.b(g):a.call(null,g);f=t(g)?M(G(f),c.a(a,H(f))):null}else f=null;return f},null,null)}function b(a){return function(b){return function(){function c(f,g){return t(a.b?a.b(g):a.call(null,g))?b.a?b.a(f,g):b.call(null,f,g):new yc(f)}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return b.l?b.l():b.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,
a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function mh(a,b,c){return function(d){var e=Kb(a);d=Jb(a,d);e=e.a?e.a(d,c):e.call(null,d,c);return b.a?b.a(e,0):b.call(null,e,0)}}
var nh=function(){function a(a,b,c,g,h){var l=Ib(a,c,!0);if(t(l)){var m=R.c(l,0,null);return lh.a(mh(a,g,h),t(mh(a,b,c).call(null,m))?l:K(l))}return null}function b(a,b,c){var g=mh(a,b,c),h;a:{h=[Ad,Bd];var l=h.length;if(l<=Vf)for(var m=0,p=Ob(Uf);;)if(m<l)var q=m+1,p=Rb(p,h[m],null),m=q;else{h=new $g(null,Qb(p),null);break a}else for(m=0,p=Ob(bh);;)if(m<l)q=m+1,p=Pb(p,h[m]),m=q;else{h=Qb(p);break a}h=void 0}return t(h.call(null,b))?(a=Ib(a,c,!0),t(a)?(b=R.c(a,0,null),t(g.b?g.b(b):g.call(null,b))?
a:K(a)):null):lh.a(g,Hb(a,!0))}var c=null,c=function(c,e,f,g,h){switch(arguments.length){case 3:return b.call(this,c,e,f);case 5:return a.call(this,c,e,f,g,h)}throw Error("Invalid arity: "+arguments.length);};c.c=b;c.r=a;return c}();function oh(a,b,c){this.m=a;this.end=b;this.step=c}oh.prototype.ga=function(){return 0<this.step?this.m<this.end:this.m>this.end};oh.prototype.next=function(){var a=this.m;this.m+=this.step;return a};
function ph(a,b,c,d,e){this.k=a;this.start=b;this.end=c;this.step=d;this.p=e;this.j=32375006;this.q=8192}k=ph.prototype;k.toString=function(){return ec(this)};k.Q=function(a,b){if(b<Ma(this))return this.start+b*this.step;if(this.start>this.end&&0===this.step)return this.start;throw Error("Index out of bounds");};k.$=function(a,b,c){return b<Ma(this)?this.start+b*this.step:this.start>this.end&&0===this.step?this.start:c};k.vb=!0;k.fb=function(){return new oh(this.start,this.end,this.step)};k.H=function(){return this.k};
k.T=function(){return 0<this.step?this.start+this.step<this.end?new ph(this.k,this.start+this.step,this.end,this.step,null):null:this.start+this.step>this.end?new ph(this.k,this.start+this.step,this.end,this.step,null):null};k.L=function(){if(Aa(Cb(this)))return 0;var a=(this.end-this.start)/this.step;return Math.ceil.b?Math.ceil.b(a):Math.ceil.call(null,a)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};
k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){for(a=this.start;;)if(0<this.step?a<this.end:a>this.end){var d=a;c=b.a?b.a(c,d):b.call(null,c,d);if(Ac(c))return b=c,L.b?L.b(b):L.call(null,b);a+=this.step}else return c};k.N=function(){return null==Cb(this)?null:this.start};k.S=function(){return null!=Cb(this)?new ph(this.k,this.start+this.step,this.end,this.step,null):J};k.D=function(){return 0<this.step?this.start<this.end?this:null:this.start>this.end?this:null};
k.F=function(a,b){return new ph(b,this.start,this.end,this.step,this.p)};k.G=function(a,b){return M(b,this)};ph.prototype[Ea]=function(){return uc(this)};
var qh=function(){function a(a,b,c){return new ph(null,a,b,c,null)}function b(a,b){return e.c(a,b,1)}function c(a){return e.c(0,a,1)}function d(){return e.c(0,Number.MAX_VALUE,1)}var e=null,e=function(e,g,h){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,e);case 2:return b.call(this,e,g);case 3:return a.call(this,e,g,h)}throw Error("Invalid arity: "+arguments.length);};e.l=d;e.b=c;e.a=b;e.c=a;return e}(),rh=function(){function a(a,b){return new V(null,function(){var f=
D(b);return f?M(G(f),c.a(a,Qe.a(a,f))):null},null,null)}function b(a){return function(b){return function(c){return function(){function g(g,h){var l=c.bb(0,c.Ra(null)+1),m=Cd(l,a);return 0===l-a*m?b.a?b.a(g,h):b.call(null,g,h):g}function h(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,a);case 2:return g.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);
};m.l=l;m.b=h;m.a=g;return m}()}(new Me(-1))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),th=function(){function a(a,b){return new V(null,function(){var f=D(b);if(f){var g=G(f),h=a.b?a.b(g):a.call(null,g),g=M(g,lh.a(function(b,c){return function(b){return sc.a(c,a.b?a.b(b):a.call(null,b))}}(g,h,f,f),K(f)));return M(g,c.a(a,D(Qe.a(Q(g),f))))}return null},null,
null)}function b(a){return function(b){return function(c,g){return function(){function h(h,l){var m=L.b?L.b(g):L.call(null,g),p=a.b?a.b(l):a.call(null,l);ac(g,p);if(Nd(m,sh)||sc.a(p,m))return c.add(l),h;m=zf(c.e);c.clear();m=b.a?b.a(h,m):b.call(null,h,m);Ac(m)||c.add(l);return m}function l(a){if(!t(0===c.e.length)){var d=zf(c.e);c.clear();a=Bc(b.a?b.a(a,d):b.call(null,a,d))}return b.b?b.b(a):b.call(null,a)}function m(){return b.l?b.l():b.call(null)}var p=null,p=function(a,b){switch(arguments.length){case 0:return m.call(this);
case 1:return l.call(this,a);case 2:return h.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};p.l=m;p.b=l;p.a=h;return p}()}(new jh([]),new Me(sh))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),uh=function(){function a(a,b){for(;;)if(D(b)&&0<a){var c=a-1,g=K(b);a=c;b=g}else return null}function b(a){for(;;)if(D(a))a=K(a);else return null}var c=
null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),vh=function(){function a(a,b){uh.a(a,b);return b}function b(a){uh.b(a);return a}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();
function wh(a,b,c,d,e,f,g){var h=ma;try{ma=null==ma?null:ma-1;if(null!=ma&&0>ma)return Lb(a,"#");Lb(a,c);if(D(g)){var l=G(g);b.c?b.c(l,a,f):b.call(null,l,a,f)}for(var m=K(g),p=za.b(f)-1;;)if(!m||null!=p&&0===p){D(m)&&0===p&&(Lb(a,d),Lb(a,"..."));break}else{Lb(a,d);var q=G(m);c=a;g=f;b.c?b.c(q,c,g):b.call(null,q,c,g);var s=K(m);c=p-1;m=s;p=c}return Lb(a,e)}finally{ma=h}}
var xh=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){for(var e=D(b),f=null,g=0,h=0;;)if(h<g){var l=f.Q(null,h);Lb(a,l);h+=1}else if(e=D(e))f=e,fd(f)?(e=Yb(f),g=Zb(f),f=e,l=Q(e),e=g,g=l):(l=G(f),Lb(a,l),e=K(f),f=null,g=0),h=0;else return null}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}(),yh={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f",
"\n":"\\n","\r":"\\r","\t":"\\t"};function zh(a){return[z('"'),z(a.replace(RegExp('[\\\\"\b\f\n\r\t]',"g"),function(a){return yh[a]})),z('"')].join("")}
var $=function Ah(b,c,d){if(null==b)return Lb(c,"nil");if(void 0===b)return Lb(c,"#\x3cundefined\x3e");t(function(){var c=S.a(d,wa);return t(c)?(c=b?b.j&131072||b.kc?!0:b.j?!1:w(rb,b):w(rb,b))?Vc(b):c:c}())&&(Lb(c,"^"),Ah(Vc(b),c,d),Lb(c," "));if(null==b)return Lb(c,"nil");if(b.Yb)return b.nc(c);if(b&&(b.j&2147483648||b.I))return b.v(null,c,d);if(Ba(b)===Boolean||"number"===typeof b)return Lb(c,""+z(b));if(null!=b&&b.constructor===Object){Lb(c,"#js ");var e=Oe.a(function(c){return new W(null,2,5,
uf,[Pd.b(c),b[c]],null)},gd(b));return Bh.n?Bh.n(e,Ah,c,d):Bh.call(null,e,Ah,c,d)}return b instanceof Array?wh(c,Ah,"#js ["," ","]",d,b):t("string"==typeof b)?t(ua.b(d))?Lb(c,zh(b)):Lb(c,b):Tc(b)?xh.d(c,Kc(["#\x3c",""+z(b),"\x3e"],0)):b instanceof Date?(e=function(b,c){for(var d=""+z(b);;)if(Q(d)<c)d=[z("0"),z(d)].join("");else return d},xh.d(c,Kc(['#inst "',""+z(b.getUTCFullYear()),"-",e(b.getUTCMonth()+1,2),"-",e(b.getUTCDate(),2),"T",e(b.getUTCHours(),2),":",e(b.getUTCMinutes(),2),":",e(b.getUTCSeconds(),
2),".",e(b.getUTCMilliseconds(),3),"-",'00:00"'],0))):b instanceof RegExp?xh.d(c,Kc(['#"',b.source,'"'],0)):(b?b.j&2147483648||b.I||(b.j?0:w(Mb,b)):w(Mb,b))?Nb(b,c,d):xh.d(c,Kc(["#\x3c",""+z(b),"\x3e"],0))},Ch=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){var b=oa();if(Yc(a))b="";else{var e=z,f=new fa;a:{var g=new dc(f);$(G(a),g,b);a=D(K(a));for(var h=null,l=0,
m=0;;)if(m<l){var p=h.Q(null,m);Lb(g," ");$(p,g,b);m+=1}else if(a=D(a))h=a,fd(h)?(a=Yb(h),l=Zb(h),h=a,p=Q(a),a=l,l=p):(p=G(h),Lb(g," "),$(p,g,b),a=K(h),h=null,l=0),m=0;else break a}b=""+e(f)}return b}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}();function Bh(a,b,c,d){return wh(c,function(a,c,d){var h=hb(a);b.c?b.c(h,c,d):b.call(null,h,c,d);Lb(c," ");a=ib(a);return b.c?b.c(a,c,d):b.call(null,a,c,d)},"{",", ","}",d,D(a))}Me.prototype.I=!0;
Me.prototype.v=function(a,b,c){Lb(b,"#\x3cVolatile: ");$(this.state,b,c);return Lb(b,"\x3e")};F.prototype.I=!0;F.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};V.prototype.I=!0;V.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};wg.prototype.I=!0;wg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};pg.prototype.I=!0;pg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Z.prototype.I=!0;
Z.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};Rf.prototype.I=!0;Rf.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};ch.prototype.I=!0;ch.prototype.v=function(a,b,c){return wh(b,$,"#{"," ","}",c,this)};Bf.prototype.I=!0;Bf.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Ld.prototype.I=!0;Ld.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Hc.prototype.I=!0;Hc.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};
rg.prototype.I=!0;rg.prototype.v=function(a,b,c){return Bh(this,$,b,c)};qg.prototype.I=!0;qg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Df.prototype.I=!0;Df.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};Lg.prototype.I=!0;Lg.prototype.v=function(a,b,c){return Bh(this,$,b,c)};$g.prototype.I=!0;$g.prototype.v=function(a,b,c){return wh(b,$,"#{"," ","}",c,this)};Vd.prototype.I=!0;Vd.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Ug.prototype.I=!0;
Ug.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};X.prototype.I=!0;X.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};W.prototype.I=!0;W.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};Kf.prototype.I=!0;Kf.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Hd.prototype.I=!0;Hd.prototype.v=function(a,b){return Lb(b,"()")};ze.prototype.I=!0;ze.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Lf.prototype.I=!0;
Lf.prototype.v=function(a,b,c){return wh(b,$,"#queue ["," ","]",c,D(this))};pa.prototype.I=!0;pa.prototype.v=function(a,b,c){return Bh(this,$,b,c)};ph.prototype.I=!0;ph.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Sg.prototype.I=!0;Sg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Fd.prototype.I=!0;Fd.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};W.prototype.sb=!0;W.prototype.tb=function(a,b){return pd.a(this,b)};Df.prototype.sb=!0;
Df.prototype.tb=function(a,b){return pd.a(this,b)};U.prototype.sb=!0;U.prototype.tb=function(a,b){return Md(this,b)};qc.prototype.sb=!0;qc.prototype.tb=function(a,b){return pc(this,b)};var Dh=function(){function a(a,d,e){var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.call(this,a,d,f)}function b(a,b,e){return a.k=T.c(b,a.k,e)}a.i=2;a.f=function(a){var d=G(a);a=K(a);var e=G(a);a=H(a);return b(d,e,a)};a.d=b;return a}();
function Eh(a){return function(b,c){var d=a.a?a.a(b,c):a.call(null,b,c);return Ac(d)?new yc(d):d}}
function Ve(a){return function(b){return function(){function c(a,c){return A.c(b,a,c)}function d(b){return a.b?a.b(b):a.call(null,b)}function e(){return a.l?a.l():a.call(null)}var f=null,f=function(a,b){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};f.l=e;f.b=d;f.a=c;return f}()}(Eh(a))}
var Fh=function(){function a(a){return Ce.a(c.l(),a)}function b(){return function(a){return function(b){return function(){function c(f,g){var h=L.b?L.b(b):L.call(null,b);ac(b,g);return sc.a(h,g)?f:a.a?a.a(f,g):a.call(null,f,g)}function g(b){return a.b?a.b(b):a.call(null,b)}function h(){return a.l?a.l():a.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);
};l.l=h;l.b=g;l.a=c;return l}()}(new Me(sh))}}var c=null,c=function(c){switch(arguments.length){case 0:return b.call(this);case 1:return a.call(this,c)}throw Error("Invalid arity: "+arguments.length);};c.l=b;c.b=a;return c}();function Gh(a,b){this.fa=a;this.Zb=b;this.q=0;this.j=2173173760}Gh.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Gh.prototype.O=function(a,b,c){return wd.n(this.fa,b,c,this.Zb)};Gh.prototype.D=function(){return D(Ce.a(this.fa,this.Zb))};Gh.prototype[Ea]=function(){return uc(this)};
var Hh={};function Ih(a){if(a?a.gc:a)return a.gc(a);var b;b=Ih[n(null==a?null:a)];if(!b&&(b=Ih._,!b))throw x("IEncodeJS.-clj-\x3ejs",a);return b.call(null,a)}function Jh(a){return(a?t(t(null)?null:a.fc)||(a.yb?0:w(Hh,a)):w(Hh,a))?Ih(a):"string"===typeof a||"number"===typeof a||a instanceof U||a instanceof qc?Kh.b?Kh.b(a):Kh.call(null,a):Ch.d(Kc([a],0))}
var Kh=function Lh(b){if(null==b)return null;if(b?t(t(null)?null:b.fc)||(b.yb?0:w(Hh,b)):w(Hh,b))return Ih(b);if(b instanceof U)return Od(b);if(b instanceof qc)return""+z(b);if(dd(b)){var c={};b=D(b);for(var d=null,e=0,f=0;;)if(f<e){var g=d.Q(null,f),h=R.c(g,0,null),g=R.c(g,1,null);c[Jh(h)]=Lh(g);f+=1}else if(b=D(b))fd(b)?(e=Yb(b),b=Zb(b),d=e,e=Q(e)):(e=G(b),d=R.c(e,0,null),e=R.c(e,1,null),c[Jh(d)]=Lh(e),b=K(b),d=null,e=0),f=0;else break;return c}if($c(b)){c=[];b=D(Oe.a(Lh,b));d=null;for(f=e=0;;)if(f<
e)h=d.Q(null,f),c.push(h),f+=1;else if(b=D(b))d=b,fd(d)?(b=Yb(d),f=Zb(d),d=b,e=Q(b),b=f):(b=G(d),c.push(b),b=K(d),d=null,e=0),f=0;else break;return c}return b},Mh={};function Nh(a,b){if(a?a.ec:a)return a.ec(a,b);var c;c=Nh[n(null==a?null:a)];if(!c&&(c=Nh._,!c))throw x("IEncodeClojure.-js-\x3eclj",a);return c.call(null,a,b)}
var Ph=function(){function a(a){return b.d(a,Kc([new pa(null,1,[Oh,!1],null)],0))}var b=null,c=function(){function a(c,d){var h=null;if(1<arguments.length){for(var h=0,l=Array(arguments.length-1);h<l.length;)l[h]=arguments[h+1],++h;h=new F(l,0)}return b.call(this,c,h)}function b(a,c){var d=kd(c)?T.a(Og,c):c,e=S.a(d,Oh);return function(a,b,d,e){return function v(f){return(f?t(t(null)?null:f.uc)||(f.yb?0:w(Mh,f)):w(Mh,f))?Nh(f,T.a(Pg,c)):kd(f)?vh.b(Oe.a(v,f)):$c(f)?af.a(Oc(f),Oe.a(v,f)):f instanceof
Array?zf(Oe.a(v,f)):Ba(f)===Object?af.a(Uf,function(){return function(a,b,c,d){return function Pa(e){return new V(null,function(a,b,c,d){return function(){for(;;){var a=D(e);if(a){if(fd(a)){var b=Yb(a),c=Q(b),g=Td(c);return function(){for(var a=0;;)if(a<c){var e=C.a(b,a),h=g,l=uf,m;m=e;m=d.b?d.b(m):d.call(null,m);e=new W(null,2,5,l,[m,v(f[e])],null);h.add(e);a+=1}else return!0}()?Wd(g.ca(),Pa(Zb(a))):Wd(g.ca(),null)}var h=G(a);return M(new W(null,2,5,uf,[function(){var a=h;return d.b?d.b(a):d.call(null,
a)}(),v(f[h])],null),Pa(H(a)))}return null}}}(a,b,c,d),null,null)}}(a,b,d,e)(gd(f))}()):f}}(c,d,e,t(e)?Pd:z)(a)}a.i=1;a.f=function(a){var c=G(a);a=H(a);return b(c,a)};a.d=b;return a}(),b=function(b,e){switch(arguments.length){case 1:return a.call(this,b);default:var f=null;if(1<arguments.length){for(var f=0,g=Array(arguments.length-1);f<g.length;)g[f]=arguments[f+1],++f;f=new F(g,0)}return c.d(b,f)}throw Error("Invalid arity: "+arguments.length);};b.i=1;b.f=c.f;b.b=a;b.d=c.d;return b}();var wa=new U(null,"meta","meta",1499536964),ya=new U(null,"dup","dup",556298533),sh=new U("cljs.core","none","cljs.core/none",926646439),pe=new U(null,"file","file",-1269645878),le=new U(null,"end-column","end-column",1425389514),sa=new U(null,"flush-on-newline","flush-on-newline",-151457939),ne=new U(null,"column","column",2078222095),ua=new U(null,"readably","readably",1129599760),oe=new U(null,"line","line",212345235),za=new U(null,"print-length","print-length",1931866356),me=new U(null,"end-line",
"end-line",1837326455),Oh=new U(null,"keywordize-keys","keywordize-keys",1310784252),Zg=new U("cljs.core","not-found","cljs.core/not-found",-1572889185);function Qh(a,b){var c=T.c(ih,a,b);return M(c,Ye.a(function(a){return function(b){return a===b}}(c),b))}
var Rh=function(){function a(a,b){return Q(a)<Q(b)?A.c(Nc,b,a):A.c(Nc,a,b)}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){a=Qh(Q,Nc.d(d,c,Kc([a],0)));return A.c(af,G(a),H(a))}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return bh;case 1:return b;
case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.l=function(){return bh};b.b=function(a){return a};b.a=a;b.d=c.d;return b}(),Sh=function(){function a(a,b){for(;;)if(Q(b)<Q(a)){var c=a;a=b;b=c}else return A.c(function(a,b){return function(a,c){return nd(b,c)?a:Xc.a(a,c)}}(a,b),a,a)}var b=null,c=function(){function a(b,
d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){a=Qh(function(a){return-Q(a)},Nc.d(e,d,Kc([a],0)));return A.c(b,G(a),H(a))}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-
2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}(),Th=function(){function a(a,b){return Q(a)<Q(b)?A.c(function(a,c){return nd(b,c)?Xc.a(a,c):a},a,a):A.c(Xc,a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,
e){return A.c(b,a,Nc.a(e,d))}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();
function Uh(a,b){return A.c(function(b,d){var e=R.c(d,0,null),f=R.c(d,1,null);return nd(a,e)?Rc.c(b,f,S.a(a,e)):b},T.c(Sc,a,Tg(b)),b)}function Vh(a,b){return A.c(function(a,d){var e=Yg(d,b);return Rc.c(a,e,Nc.a(S.c(a,e,bh),d))},Uf,a)}function Wh(a){return A.c(function(a,c){var d=R.c(c,0,null),e=R.c(c,1,null);return Rc.c(a,e,d)},Uf,a)}
var Xh=function(){function a(a,b,c){a=Q(a)<=Q(b)?new W(null,3,5,uf,[a,b,Wh(c)],null):new W(null,3,5,uf,[b,a,c],null);b=R.c(a,0,null);c=R.c(a,1,null);var g=R.c(a,2,null),h=Vh(b,Vg(g));return A.c(function(a,b,c,d,e){return function(f,g){var h=function(){var a=Uh(Yg(g,Tg(d)),d);return e.b?e.b(a):e.call(null,a)}();return t(h)?A.c(function(){return function(a,b){return Nc.a(a,Wg.d(Kc([b,g],0)))}}(h,a,b,c,d,e),f,h):f}}(a,b,c,g,h),bh,c)}function b(a,b){if(D(a)&&D(b)){var c=Sh.a(fh(Tg(G(a))),fh(Tg(G(b)))),
g=Q(a)<=Q(b)?new W(null,2,5,uf,[a,b],null):new W(null,2,5,uf,[b,a],null),h=R.c(g,0,null),l=R.c(g,1,null),m=Vh(h,c);return A.c(function(a,b,c,d,e){return function(f,g){var h=function(){var b=Yg(g,a);return e.b?e.b(b):e.call(null,b)}();return t(h)?A.c(function(){return function(a,b){return Nc.a(a,Wg.d(Kc([b,g],0)))}}(h,a,b,c,d,e),f,h):f}}(c,g,h,l,m),bh,l)}return bh}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+
arguments.length);};c.a=b;c.c=a;return c}();r("mori.apply",T);r("mori.apply.f2",T.a);r("mori.apply.f3",T.c);r("mori.apply.f4",T.n);r("mori.apply.f5",T.r);r("mori.apply.fn",T.K);r("mori.count",Q);r("mori.distinct",function(a){return function c(a,e){return new V(null,function(){return function(a,d){for(;;){var e=a,l=R.c(e,0,null);if(e=D(e))if(nd(d,l))l=H(e),e=d,a=l,d=e;else return M(l,c(H(e),Nc.a(d,l)));else return null}}.call(null,a,e)},null,null)}(a,bh)});r("mori.empty",Oc);r("mori.first",G);r("mori.second",Lc);r("mori.next",K);
r("mori.rest",H);r("mori.seq",D);r("mori.conj",Nc);r("mori.conj.f0",Nc.l);r("mori.conj.f1",Nc.b);r("mori.conj.f2",Nc.a);r("mori.conj.fn",Nc.K);r("mori.cons",M);r("mori.find",function(a,b){return null!=a&&bd(a)&&nd(a,b)?new W(null,2,5,uf,[b,S.a(a,b)],null):null});r("mori.nth",R);r("mori.nth.f2",R.a);r("mori.nth.f3",R.c);r("mori.last",function(a){for(;;){var b=K(a);if(null!=b)a=b;else return G(a)}});r("mori.assoc",Rc);r("mori.assoc.f3",Rc.c);r("mori.assoc.fn",Rc.K);r("mori.dissoc",Sc);
r("mori.dissoc.f1",Sc.b);r("mori.dissoc.f2",Sc.a);r("mori.dissoc.fn",Sc.K);r("mori.getIn",cf);r("mori.getIn.f2",cf.a);r("mori.getIn.f3",cf.c);r("mori.updateIn",df);r("mori.updateIn.f3",df.c);r("mori.updateIn.f4",df.n);r("mori.updateIn.f5",df.r);r("mori.updateIn.f6",df.P);r("mori.updateIn.fn",df.K);r("mori.assocIn",function Yh(b,c,d){var e=R.c(c,0,null);return(c=Ed(c))?Rc.c(b,e,Yh(S.a(b,e),c,d)):Rc.c(b,e,d)});r("mori.fnil",Ke);r("mori.fnil.f2",Ke.a);r("mori.fnil.f3",Ke.c);r("mori.fnil.f4",Ke.n);
r("mori.disj",Xc);r("mori.disj.f1",Xc.b);r("mori.disj.f2",Xc.a);r("mori.disj.fn",Xc.K);r("mori.pop",function(a){return null==a?null:mb(a)});r("mori.peek",Wc);r("mori.hash",nc);r("mori.get",S);r("mori.get.f2",S.a);r("mori.get.f3",S.c);r("mori.hasKey",nd);r("mori.isEmpty",Yc);r("mori.reverse",Jd);r("mori.take",Pe);r("mori.take.f1",Pe.b);r("mori.take.f2",Pe.a);r("mori.drop",Qe);r("mori.drop.f1",Qe.b);r("mori.drop.f2",Qe.a);r("mori.takeNth",rh);r("mori.takeNth.f1",rh.b);r("mori.takeNth.f2",rh.a);
r("mori.partition",bf);r("mori.partition.f2",bf.a);r("mori.partition.f3",bf.c);r("mori.partition.f4",bf.n);r("mori.partitionAll",kh);r("mori.partitionAll.f1",kh.b);r("mori.partitionAll.f2",kh.a);r("mori.partitionAll.f3",kh.c);r("mori.partitionBy",th);r("mori.partitionBy.f1",th.b);r("mori.partitionBy.f2",th.a);r("mori.iterate",function Zh(b,c){return M(c,new V(null,function(){return Zh(b,b.b?b.b(c):b.call(null,c))},null,null))});r("mori.into",af);r("mori.into.f2",af.a);r("mori.into.f3",af.c);
r("mori.merge",Wg);r("mori.mergeWith",Xg);r("mori.subvec",Cf);r("mori.subvec.f2",Cf.a);r("mori.subvec.f3",Cf.c);r("mori.takeWhile",lh);r("mori.takeWhile.f1",lh.b);r("mori.takeWhile.f2",lh.a);r("mori.dropWhile",Re);r("mori.dropWhile.f1",Re.b);r("mori.dropWhile.f2",Re.a);r("mori.groupBy",function(a,b){return ce(A.c(function(b,d){var e=a.b?a.b(d):a.call(null,d);return ee.c(b,e,Nc.a(S.c(b,e,Mc),d))},Ob(Uf),b))});r("mori.interpose",function(a,b){return Qe.a(1,Ue.a(Se.b(a),b))});r("mori.interleave",Ue);
r("mori.interleave.f2",Ue.a);r("mori.interleave.fn",Ue.K);r("mori.concat",ae);r("mori.concat.f0",ae.l);r("mori.concat.f1",ae.b);r("mori.concat.f2",ae.a);r("mori.concat.fn",ae.K);function $e(a){return a instanceof Array||cd(a)}r("mori.flatten",function(a){return Xe.a(function(a){return!$e(a)},H(Ze(a)))});r("mori.lazySeq",function(a){return new V(null,a,null,null)});r("mori.keys",Tg);r("mori.selectKeys",Yg);r("mori.vals",Vg);r("mori.primSeq",Jc);r("mori.primSeq.f1",Jc.b);r("mori.primSeq.f2",Jc.a);
r("mori.map",Oe);r("mori.map.f1",Oe.b);r("mori.map.f2",Oe.a);r("mori.map.f3",Oe.c);r("mori.map.f4",Oe.n);r("mori.map.fn",Oe.K);
r("mori.mapIndexed",function(a,b){return function d(b,f){return new V(null,function(){var g=D(f);if(g){if(fd(g)){for(var h=Yb(g),l=Q(h),m=Td(l),p=0;;)if(p<l)Xd(m,function(){var d=b+p,f=C.a(h,p);return a.a?a.a(d,f):a.call(null,d,f)}()),p+=1;else break;return Wd(m.ca(),d(b+l,Zb(g)))}return M(function(){var d=G(g);return a.a?a.a(b,d):a.call(null,b,d)}(),d(b+1,H(g)))}return null},null,null)}(0,b)});r("mori.mapcat",We);r("mori.mapcat.f1",We.b);r("mori.mapcat.fn",We.K);r("mori.reduce",A);
r("mori.reduce.f2",A.a);r("mori.reduce.f3",A.c);r("mori.reduceKV",function(a,b,c){return null!=c?xb(c,a,b):b});r("mori.keep",Le);r("mori.keep.f1",Le.b);r("mori.keep.f2",Le.a);r("mori.keepIndexed",Ne);r("mori.keepIndexed.f1",Ne.b);r("mori.keepIndexed.f2",Ne.a);r("mori.filter",Xe);r("mori.filter.f1",Xe.b);r("mori.filter.f2",Xe.a);r("mori.remove",Ye);r("mori.remove.f1",Ye.b);r("mori.remove.f2",Ye.a);r("mori.some",Fe);r("mori.every",Ee);r("mori.equals",sc);r("mori.equals.f1",sc.b);
r("mori.equals.f2",sc.a);r("mori.equals.fn",sc.K);r("mori.range",qh);r("mori.range.f0",qh.l);r("mori.range.f1",qh.b);r("mori.range.f2",qh.a);r("mori.range.f3",qh.c);r("mori.repeat",Se);r("mori.repeat.f1",Se.b);r("mori.repeat.f2",Se.a);r("mori.repeatedly",Te);r("mori.repeatedly.f1",Te.b);r("mori.repeatedly.f2",Te.a);r("mori.sort",sd);r("mori.sort.f1",sd.b);r("mori.sort.f2",sd.a);r("mori.sortBy",td);r("mori.sortBy.f2",td.a);r("mori.sortBy.f3",td.c);r("mori.intoArray",Ia);r("mori.intoArray.f1",Ia.b);
r("mori.intoArray.f2",Ia.a);r("mori.subseq",nh);r("mori.subseq.f3",nh.c);r("mori.subseq.f5",nh.r);r("mori.dedupe",Fh);r("mori.dedupe.f0",Fh.l);r("mori.dedupe.f1",Fh.b);r("mori.transduce",wd);r("mori.transduce.f3",wd.c);r("mori.transduce.f4",wd.n);r("mori.eduction",function(a,b){return new Gh(a,b)});r("mori.sequence",Ce);r("mori.sequence.f1",Ce.b);r("mori.sequence.f2",Ce.a);r("mori.sequence.fn",Ce.K);r("mori.completing",vd);r("mori.completing.f1",vd.b);r("mori.completing.f2",vd.a);r("mori.list",Kd);
r("mori.vector",Af);r("mori.hashMap",Pg);r("mori.set",fh);r("mori.sortedSet",gh);r("mori.sortedSetBy",hh);r("mori.sortedMap",Qg);r("mori.sortedMapBy",Rg);r("mori.queue",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return af.a?af.a(Mf,a):af.call(null,Mf,a)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());r("mori.keyword",Pd);r("mori.keyword.f1",Pd.b);
r("mori.keyword.f2",Pd.a);r("mori.symbol",rc);r("mori.symbol.f1",rc.b);r("mori.symbol.f2",rc.a);r("mori.zipmap",function(a,b){for(var c=Ob(Uf),d=D(a),e=D(b);;)if(d&&e)c=ee.c(c,G(d),G(e)),d=K(d),e=K(e);else return Qb(c)});r("mori.isList",function(a){return a?a.j&33554432||a.wc?!0:a.j?!1:w(Eb,a):w(Eb,a)});r("mori.isSeq",kd);r("mori.isVector",ed);r("mori.isMap",dd);r("mori.isSet",ad);r("mori.isKeyword",function(a){return a instanceof U});r("mori.isSymbol",function(a){return a instanceof qc});
r("mori.isCollection",$c);r("mori.isSequential",cd);r("mori.isAssociative",bd);r("mori.isCounted",Ec);r("mori.isIndexed",Fc);r("mori.isReduceable",function(a){return a?a.j&524288||a.Sb?!0:a.j?!1:w(vb,a):w(vb,a)});r("mori.isSeqable",ld);r("mori.isReversible",Id);r("mori.union",Rh);r("mori.union.f0",Rh.l);r("mori.union.f1",Rh.b);r("mori.union.f2",Rh.a);r("mori.union.fn",Rh.K);r("mori.intersection",Sh);r("mori.intersection.f1",Sh.b);r("mori.intersection.f2",Sh.a);r("mori.intersection.fn",Sh.K);
r("mori.difference",Th);r("mori.difference.f1",Th.b);r("mori.difference.f2",Th.a);r("mori.difference.fn",Th.K);r("mori.join",Xh);r("mori.join.f2",Xh.a);r("mori.join.f3",Xh.c);r("mori.index",Vh);r("mori.project",function(a,b){return fh(Oe.a(function(a){return Yg(a,b)},a))});r("mori.mapInvert",Wh);r("mori.rename",function(a,b){return fh(Oe.a(function(a){return Uh(a,b)},a))});r("mori.renameKeys",Uh);r("mori.isSubset",function(a,b){return Q(a)<=Q(b)&&Ee(function(a){return nd(b,a)},a)});
r("mori.isSuperset",function(a,b){return Q(a)>=Q(b)&&Ee(function(b){return nd(a,b)},b)});r("mori.notEquals",je);r("mori.notEquals.f1",je.b);r("mori.notEquals.f2",je.a);r("mori.notEquals.fn",je.K);r("mori.gt",Ad);r("mori.gt.f1",Ad.b);r("mori.gt.f2",Ad.a);r("mori.gt.fn",Ad.K);r("mori.gte",Bd);r("mori.gte.f1",Bd.b);r("mori.gte.f2",Bd.a);r("mori.gte.fn",Bd.K);r("mori.lt",yd);r("mori.lt.f1",yd.b);r("mori.lt.f2",yd.a);r("mori.lt.fn",yd.K);r("mori.lte",zd);r("mori.lte.f1",zd.b);r("mori.lte.f2",zd.a);
r("mori.lte.fn",zd.K);r("mori.compare",od);r("mori.partial",Je);r("mori.partial.f1",Je.b);r("mori.partial.f2",Je.a);r("mori.partial.f3",Je.c);r("mori.partial.f4",Je.n);r("mori.partial.fn",Je.K);r("mori.comp",Ie);r("mori.comp.f0",Ie.l);r("mori.comp.f1",Ie.b);r("mori.comp.f2",Ie.a);r("mori.comp.f3",Ie.c);r("mori.comp.fn",Ie.K);
r("mori.pipeline",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){function b(a,c){return c.b?c.b(a):c.call(null,a)}return A.a?A.a(b,a):A.call(null,b,a)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());
r("mori.curry",function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){return function(e){return T.a(a,M.a?M.a(e,b):M.call(null,e,b))}}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}());
r("mori.juxt",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return function(){function b(a){var c=null;if(0<arguments.length){for(var c=0,d=Array(arguments.length-0);c<d.length;)d[c]=arguments[c+0],++c;c=new F(d,0)}return e.call(this,c)}function e(b){var d=function(){function d(a){return T.a(a,b)}return Oe.a?Oe.a(d,a):Oe.call(null,d,a)}();return Ia.b?Ia.b(d):Ia.call(null,
d)}b.i=0;b.f=function(a){a=D(a);return e(a)};b.d=e;return b}()}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());
r("mori.knit",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return function(b){var e=function(){function e(a,b){return a.b?a.b(b):a.call(null,b)}return Oe.c?Oe.c(e,a,b):Oe.call(null,e,a,b)}();return Ia.b?Ia.b(e):Ia.call(null,e)}}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());r("mori.sum",xd);r("mori.sum.f0",xd.l);r("mori.sum.f1",xd.b);
r("mori.sum.f2",xd.a);r("mori.sum.fn",xd.K);r("mori.inc",function(a){return a+1});r("mori.dec",function(a){return a-1});r("mori.isEven",Ge);r("mori.isOdd",function(a){return!Ge(a)});r("mori.each",function(a,b){for(var c=D(a),d=null,e=0,f=0;;)if(f<e){var g=d.Q(null,f);b.b?b.b(g):b.call(null,g);f+=1}else if(c=D(c))fd(c)?(e=Yb(c),c=Zb(c),d=e,e=Q(e)):(d=g=G(c),b.b?b.b(d):b.call(null,d),c=K(c),d=null,e=0),f=0;else return null});r("mori.identity",ud);
r("mori.constantly",function(a){return function(){function b(b){if(0<arguments.length)for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;return a}b.i=0;b.f=function(b){D(b);return a};b.d=function(){return a};return b}()});r("mori.toJs",Kh);
r("mori.toClj",function(){function a(a,b){return Ph.d(a,Kc([Oh,b],0))}function b(a){return Ph.b(a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}());r("mori.configure",function(a,b){switch(a){case "print-length":return la=b;case "print-level":return ma=b;default:throw Error([z("No matching clause: "),z(a)].join(""));}});r("mori.meta",Vc);r("mori.withMeta",O);
r("mori.varyMeta",ie);r("mori.varyMeta.f2",ie.a);r("mori.varyMeta.f3",ie.c);r("mori.varyMeta.f4",ie.n);r("mori.varyMeta.f5",ie.r);r("mori.varyMeta.f6",ie.P);r("mori.varyMeta.fn",ie.K);r("mori.alterMeta",Dh);r("mori.resetMeta",function(a,b){return a.k=b});V.prototype.inspect=function(){return this.toString()};F.prototype.inspect=function(){return this.toString()};Hc.prototype.inspect=function(){return this.toString()};wg.prototype.inspect=function(){return this.toString()};pg.prototype.inspect=function(){return this.toString()};
qg.prototype.inspect=function(){return this.toString()};Fd.prototype.inspect=function(){return this.toString()};Ld.prototype.inspect=function(){return this.toString()};Hd.prototype.inspect=function(){return this.toString()};W.prototype.inspect=function(){return this.toString()};Vd.prototype.inspect=function(){return this.toString()};Bf.prototype.inspect=function(){return this.toString()};Df.prototype.inspect=function(){return this.toString()};Z.prototype.inspect=function(){return this.toString()};
X.prototype.inspect=function(){return this.toString()};pa.prototype.inspect=function(){return this.toString()};rg.prototype.inspect=function(){return this.toString()};Lg.prototype.inspect=function(){return this.toString()};$g.prototype.inspect=function(){return this.toString()};ch.prototype.inspect=function(){return this.toString()};ph.prototype.inspect=function(){return this.toString()};U.prototype.inspect=function(){return this.toString()};qc.prototype.inspect=function(){return this.toString()};
Lf.prototype.inspect=function(){return this.toString()};Kf.prototype.inspect=function(){return this.toString()};r("mori.mutable.thaw",function(a){return Ob(a)});r("mori.mutable.freeze",ce);r("mori.mutable.conj",de);r("mori.mutable.conj.f0",de.l);r("mori.mutable.conj.f1",de.b);r("mori.mutable.conj.f2",de.a);r("mori.mutable.conj.fn",de.K);r("mori.mutable.assoc",ee);r("mori.mutable.assoc.f3",ee.c);r("mori.mutable.assoc.fn",ee.K);r("mori.mutable.dissoc",fe);r("mori.mutable.dissoc.f2",fe.a);r("mori.mutable.dissoc.fn",fe.K);r("mori.mutable.pop",function(a){return Ub(a)});r("mori.mutable.disj",ge);
r("mori.mutable.disj.f2",ge.a);r("mori.mutable.disj.fn",ge.K);;return this.mori;}.call({});});

},{}],"serialize/exportcsv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtleSet, ExtensionsHandler, JSType, LinkReference, NobodyReference, PatchReference, TurtleReference, allPlotsDataToCSV, flatMap, fold, formatAgentRef, formatAgents, formatAny, formatBoolean, formatBreedRef, formatColor, formatDate, formatDrawingData, formatFloat, formatGlobals, formatKeys, formatLinkRef, formatList, formatMetadata, formatMiniGlobals, formatNumber, formatPair, formatPatchRef, formatPensData, formatPlain, formatPlotData, formatPointsData, formatString, formatStringInner, formatTurtleRef, formatValues, id, isEmpty, joinCommaed, keys, map, mapMaybe, maxBy, maybe, onNextLineIfNotEmpty, pairs, pipeline, plotDataToCSV, rangeUntil, rawPlotToCSV, schemafyAny, schemafyLink, schemafyPatch, schemafyTurtle, tee, toObject, unique, values, worldDataToCSV;

  JSType = require('util/jstype');

  ({flatMap, isEmpty, map, maxBy, toObject, unique} = require('brazierjs/array'));

  ({id, pipeline, tee} = require('brazierjs/function'));

  ({
    fold,
    map: mapMaybe,
    maybe
  } = require('brazierjs/maybe'));

  ({rangeUntil} = require('brazierjs/number'));

  ({keys, pairs, values} = require('brazierjs/object'));

  ExtensionsHandler = require('../engine/core/world/extensionshandler');

  formatFloat = require('util/formatfloat');

  ({BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedReporterLambda, ExportedRGB, ExportedRGBA, ExportedTurtleSet, LinkReference, NobodyReference, PatchReference, TurtleReference} = require('./exportstructures'));

  // (String) => String
  onNextLineIfNotEmpty = function(x) {
    if (isEmpty(x)) {
      return '';
    } else {
      return '\n' + x;
    }
  };

  // (Array[String]) => String
  joinCommaed = function(x) {
    return x.join(',');
  };

  // (String) => String
  formatPlain = function(str) {
    return '"' + str + '"';
  };

  // (String) => String
  formatStringInner = function(str) {
    return '""' + str.replace(/\n/g, "\\n").replace(/"/g, '\\""') + '""';
  };

  // (String) => String
  formatString = function(str) {
    return formatPlain(formatStringInner(str));
  };

  // (Boolean) => String
  formatBoolean = function(bool) {
    return formatPlain(bool);
  };

  // (Number) => String
  formatNumber = function(num) {
    return formatPlain(formatFloat(num));
  };

  // (BreedReference) => String
  formatBreedRef = function({breedName}) {
    var lowered;
    lowered = breedName.toLowerCase();
    if (lowered === "turtles" || lowered === "patches" || lowered === "links") {
      return `{all-${lowered}}`;
    } else {
      return `{breed ${lowered}}`;
    }
  };

  // [T] @ ((T, (T) => String)) => String
  formatPair = function([value, formatter]) {
    return formatter(value);
  };

  // (TurtleReference) => String
  formatTurtleRef = function({
      breed: {singular},
      id: turtleID
    }) {
    return `{${singular.toLowerCase()} ${turtleID}}`;
  };

  // (PatchReference) => String
  formatPatchRef = function({pxcor, pycor}) {
    return `{patch ${pxcor} ${pycor}}`;
  };

  // (LinkReference) => String
  formatLinkRef = function({
      breed: {singular},
      id1,
      id2
    }) {
    return `{${singular.toLowerCase()} ${id1} ${id2}}`;
  };

  // (AgentReference) => String
  formatAgentRef = function(ref) {
    if (ref === NobodyReference) {
      return "nobody";
    } else if (ref instanceof LinkReference) {
      return formatLinkRef(ref);
    } else if (ref instanceof PatchReference) {
      return formatPatchRef(ref);
    } else if (ref instanceof TurtleReference) {
      return formatTurtleRef(ref);
    } else {
      throw new Error(`Unknown agent reference: ${JSON.stringify(ref)}`);
    }
  };

  // (Array[_], (Any) => String) => String
  formatList = function(xs, formatter) {
    return `[${xs.map(function(x) {
      return formatter(x);
    }).join(" ")}]`;
  };

  // (ExportedColor) => String
  formatColor = function(color) {
    if (color instanceof ExportedColorNum) {
      return formatNumber(color.value);
    } else if (color instanceof ExportedRGB) {
      return formatPlain(formatList([color.r, color.g, color.b], formatFloat));
    } else if (color instanceof ExportedRGBA) {
      return formatPlain(formatList([color.r, color.g, color.b, color.a], formatFloat));
    } else {
      throw new Error(`Unknown color: ${JSON.stringify(color)}`);
    }
  };

  // (ExtensionsFormatter, Boolean) => (Any) => String
  formatAny = function(extensionFormatter, isOuterValue = true) {
    return function(any) {
      var formatter;
      // (Any) => String
      formatter = function(x) {
        var exportInnerLink, exportInnerPatch, exportInnerTurtle, type;
        type = JSType(x);
        if (type.isArray()) {
          return formatList(x, formatter);
        } else if (type.isBoolean()) {
          return x;
        } else if (type.isNumber()) {
          return formatFloat(x);
        } else if (type.isString()) {
          return formatStringInner(x);
        } else if (x instanceof BreedReference) {
          return formatBreedRef(x);
        } else if (x === NobodyReference) {
          return "nobody";
        } else if (x instanceof LinkReference) {
          return formatLinkRef(x);
        } else if (x instanceof PatchReference) {
          return formatPatchRef(x);
        } else if (x instanceof TurtleReference) {
          return formatTurtleRef(x);
        } else if (x instanceof ExportedCommandLambda) {
          return `(anonymous command: ${x.source.replace(/"/g, '""')})`;
        } else if (x instanceof ExportedReporterLambda) {
          return `(anonymous reporter: ${x.source.replace(/"/g, '""')})`;
        } else if (x instanceof ExportedLinkSet) {
          exportInnerLink = function({
              breed: {plural},
              id1,
              id2
            }) {
            return ` [${id1} ${id2} ${formatBreedRef(new BreedReference(plural))}]`;
          };
          return `{links${x.references.map(exportInnerLink).join("")}}`;
        } else if (x instanceof ExportedPatchSet) {
          exportInnerPatch = function({pxcor, pycor}) {
            return ` [${pxcor} ${pycor}]`;
          };
          return `{patches${x.references.map(exportInnerPatch).join("")}}`;
        } else if (x instanceof ExportedTurtleSet) {
          exportInnerTurtle = function(ref) {
            return ` ${ref.id}`;
          };
          return `{turtles${x.references.map(exportInnerTurtle).join("")}}`;
        } else if (extensionFormatter.canHandle(x)) {
          return extensionFormatter.formatPlaceholder(x, formatter);
        } else {
          throw new Error(`I don't know how to CSVify this: ${JSON.stringify(x)}`);
        }
      };
      if (any == null) {
        return "";
      } else if (isOuterValue) {
        return formatPlain(formatter(any));
      } else {
        return formatter(any);
      }
    };
  };

  // (Object[String]) => String
  formatKeys = pipeline(keys, map(formatPlain), joinCommaed);

  formatValues = pipeline(values, map(formatPair), joinCommaed);

  // (Object[Any]) => String

  // ((Any) => String) => (ExportedTurtle) => Object[(Any, (Any) => String)]
  schemafyTurtle = function(formatAnyValue) {
    return function({who, color, heading, xcor, ycor, shape, label, labelColor, breed, isHidden, size, penSize, penMode}) {
      var formatWrapped;
      formatWrapped = pipeline(formatBreedRef, formatPlain);
      return {
        "who": [who, formatNumber],
        "color": [color, formatColor],
        "heading": [heading, formatNumber],
        "xcor": [xcor, formatNumber],
        "ycor": [ycor, formatNumber],
        "shape": [shape, formatString],
        "label": [label, formatAnyValue],
        "label-color": [labelColor, formatColor],
        "breed": [breed, formatWrapped],
        "hidden?": [isHidden, formatBoolean],
        "size": [size, formatNumber],
        "pen-size": [penSize, formatNumber],
        "pen-mode": [penMode, formatString]
      };
    };
  };

  // ((Any) => String) => (ExportedPatch) => Object[(Any, (Any) => String)]
  schemafyPatch = function(formatAnyValue) {
    return function({pxcor, pycor, pcolor, plabel, plabelColor}) {
      return {
        "pxcor": [pxcor, formatNumber],
        "pycor": [pycor, formatNumber],
        "pcolor": [pcolor, formatColor],
        "plabel": [plabel, formatAnyValue],
        "plabel-color": [plabelColor, formatColor]
      };
    };
  };

  // ((Any) => String) => (ExportedLink) => Object[(Any, (Any) => String)]
  schemafyLink = function(formatAnyValue) {
    return function({end1, end2, color, label, labelColor, isHidden, breed, thickness, shape, tieMode}) {
      var formatWrappedBreed, formatWrappedTurtle;
      formatWrappedBreed = pipeline(formatBreedRef, formatPlain);
      formatWrappedTurtle = pipeline(formatTurtleRef, formatPlain);
      return {
        "end1": [end1, formatWrappedTurtle],
        "end2": [end2, formatWrappedTurtle],
        "color": [color, formatColor],
        "label": [label, formatAnyValue],
        "label-color": [labelColor, formatColor],
        "hidden?": [isHidden, formatBoolean],
        "breed": [breed, formatWrappedBreed],
        "thickness": [thickness, formatNumber],
        "shape": [shape, formatString],
        "tie-mode": [tieMode, formatString]
      };
    };
  };

  // ((Any) => String) => (Object[Any]) => Object[(Any, (Any) => String)]
  schemafyAny = function(formatAnyValue) {
    return pipeline(pairs, map(function([k, v]) {
      return [k, [v, formatAnyValue]];
    }), toObject);
  };

  // Based on le_m's solution at https://codereview.stackexchange.com/a/164141/139601
  // (Date) => String
  formatDate = function(date) {
    var day, format, hour, milli, minute, month, second, tzOffset1, tzOffset2, tzSign, year;
    format = function(value, precision) {
      return value.toString().padStart(precision, '0');
    };
    month = format(date.getMonth() + 1, 2);
    day = format(date.getDate(), 2);
    year = format(date.getFullYear(), 4);
    hour = format(date.getHours(), 2);
    minute = format(date.getMinutes(), 2);
    second = format(date.getSeconds(), 2);
    milli = format(date.getMilliseconds(), 3);
    tzSign = format((date.getTimezoneOffset() > 0 ? '-' : '+'), 0);
    tzOffset1 = format(Math.abs(date.getTimezoneOffset() / 60), 2);
    tzOffset2 = format(Math.abs(date.getTimezoneOffset() % 60), 2);
    return `${month}/${day}/${year} ${hour}:${minute}:${second}:${milli} ${tzSign}${tzOffset1}${tzOffset2}`;
  };

  // (ExportedGlobals, (Any) => String) => String
  formatGlobals = function({linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, perspective, subject, ticks, codeGlobals}, formatAnyValue) {
    var builtins, formatDirectedness, formatPerspective, formatSubject, globals;
    formatPerspective = function(p) {
      return formatNumber((function() {
        switch (p.toLowerCase()) {
          case 'observe':
            return 0;
          case 'ride':
            return 1;
          case 'follow':
            return 2;
          case 'watch':
            return 3;
          default:
            throw new Error(`Unknown perspective: ${JSON.stringify(x)}`);
        }
      })());
    };
    formatDirectedness = pipeline((function(s) {
      return s.toUpperCase();
    }), formatString);
    formatSubject = pipeline(formatAgentRef, formatPlain);
    builtins = {
      'min-pxcor': [minPxcor, formatNumber],
      'max-pxcor': [maxPxcor, formatNumber],
      'min-pycor': [minPycor, formatNumber],
      'max-pycor': [maxPycor, formatNumber],
      'perspective': [perspective, formatPerspective],
      'subject': [subject, formatSubject],
      'nextIndex': [nextWhoNumber, formatNumber],
      'directed-links': [linkDirectedness, formatDirectedness],
      'ticks': [ticks, formatNumber]
    };
    globals = Object.assign(builtins, schemafyAny(formatAnyValue)(codeGlobals));
    return `${formatPlain('GLOBALS')}\n${formatKeys(globals)}\n${formatValues(globals)}`;
  };

  // (Object[Any], (Any) => String) => String
  formatMiniGlobals = function(miniGlobals, formatAnyValue) {
    return `${formatPlain('MODEL SETTINGS')}\n${formatKeys(miniGlobals)}\n${formatValues(schemafyAny(formatAnyValue)(miniGlobals))}`;
  };

  // (Metadata) => String
  formatMetadata = function({version, filename, date}) {
    return `export-world data (NetLogo Web ${version})\n${filename}\n${formatPlain(formatDate(date))}`;
  };

  // [T <: ExportedAgent] @ (Array[T], (T) => Object[(Any, (Any) => String)], Array[String], Array[String]) => String
  formatAgents = function(agents, schemafy, builtinsNames, ownsNames, formatAnyValue) {
    var keysRow, valuesRows;
    keysRow = pipeline(unique, map(formatPlain), joinCommaed)(builtinsNames.concat(ownsNames));
    valuesRows = agents.map(function(agent) {
      var base, extras, lookup;
      lookup = function(key) {
        var ref1;
        return ((ref1 = agent.breedsOwns) != null ? ref1 : agent.patchesOwns)[key];
      };
      base = schemafy(agent);
      extras = pipeline(map(tee(id)(lookup)), toObject, schemafyAny(formatAnyValue))(ownsNames);
      return formatValues(Object.assign(base, extras));
    }).join('\n');
    return `${keysRow}${onNextLineIfNotEmpty(valuesRows)}`;
  };

  // (ExportedPlot) => String
  formatPlotData = function({currentPenNameOrNull, isAutoplotting, isLegendOpen, name, pens, xMax, xMin, yMax, yMin}) {
    var convertedPlot, currentPenStr;
    currentPenStr = currentPenNameOrNull != null ? currentPenNameOrNull : '';
    convertedPlot = {
      'x min': [xMin, formatNumber],
      'x max': [xMax, formatNumber],
      'y min': [yMin, formatNumber],
      'y max': [yMax, formatNumber],
      'autoplot?': [isAutoplotting, formatBoolean],
      'current pen': [currentPenStr, formatString],
      'legend open?': [isLegendOpen, formatBoolean],
      'number of pens': [pens.length, formatNumber]
    };
    return `${formatString(name)}\n${formatKeys(convertedPlot)}\n${formatValues(convertedPlot)}\n\n${formatPensData(pens)}\n\n${formatPointsData(pens)}`;
  };

  // (Array[ExportedPen]) => String
  formatPensData = function(pens) {
    var convertPen, convertedPens, formatPenMode, pensKeys, pensValues;
    formatPenMode = function(x) {
      return formatNumber((function() {
        switch (x.toLowerCase()) {
          case 'line':
            return 0;
          case 'bar':
            return 1;
          case 'point':
            return 2;
          default:
            throw new Error(`Unknown pen mode: ${JSON.stringify(x)}`);
        }
      })());
    };
    convertPen = function({color, interval, isPenDown, mode, name, x}) {
      return {
        'pen name': [name, formatString],
        'pen down?': [isPenDown, formatBoolean],
        'mode': [mode, formatPenMode],
        'interval': [interval, formatNumber],
        'color': [color, formatNumber],
        'x': [x, formatNumber]
      };
    };
    convertedPens = pens.map(convertPen);
    pensKeys = formatKeys(convertPen({}));
    pensValues = convertedPens.map(pipeline(values, map(formatPair))).join('\n');
    return `${pensKeys}${onNextLineIfNotEmpty(pensValues)}`;
  };

  // (Array[ExportedPen]) => String
  formatPointsData = function(pens) {
    var baseKeys, convertPoint, formatRow, longest, penNames, penPointsRows, pointKeys, pointValues, transposed;
    convertPoint = function({x, y, color, isPenDown}) {
      return {
        'x': [x, formatNumber],
        'y': [y, formatNumber],
        'color': [color, formatNumber],
        'pen down?': [isPenDown, formatBoolean]
      };
    };
    penNames = pens.map(function(pen) {
      return formatString(pen.name);
    }).join(',,,,');
    baseKeys = keys(convertPoint({})).map(formatPlain);
    pointKeys = flatMap(function() {
      return baseKeys;
    })(rangeUntil(0)(pens.length)).join(',');
    penPointsRows = pens.map(function(pen) {
      return pen.points.map(pipeline(convertPoint, values));
    });
    formatRow = function(row) {
      return row.map(pipeline(maybe, fold(function() {
        return ['', '', '', ''];
      })(map(formatPair)))).join(',');
    };
    longest = pipeline(maxBy(function(a) {
      return a.length;
    }), fold(function() {
      return [];
    })(id));
    transposed = function(arrays) {
      return (longest(arrays)).map(function(_, i) {
        return arrays.map(function(array) {
          return array[i];
        });
      });
    };
    pointValues = transposed(penPointsRows).map(formatRow).join('\n');
    return `${penNames}\n${pointKeys}${onNextLineIfNotEmpty(pointValues)}`;
  };

  // (ExportPlotData, Array[ExtensionPorter]) => String
  plotDataToCSV = function({metadata, miniGlobals, plot}, extensionPorters) {
    var extensionFormatter;
    extensionFormatter = ExtensionsHandler.makeFormatter(extensionPorters);
    return `${formatMetadata(metadata)}\n\n${formatMiniGlobals(miniGlobals, formatAny(extensionFormatter))}\n\n${formatPlotData(plot)}`;
  };

  // (ExportedPlot) => String
  rawPlotToCSV = function(plot) {
    return `${formatPlotData(plot)}\n`;
  };

  // (ExportAllPlotsData) => String
  allPlotsDataToCSV = function({metadata, miniGlobals, plots}, extensionPorters) {
    var extensionFormatter;
    extensionFormatter = ExtensionsHandler.makeFormatter(extensionPorters);
    return `${formatMetadata(metadata)}\n\n${formatMiniGlobals(miniGlobals, formatAny(extensionFormatter))}\n\n${plots.map(formatPlotData).join("\n")}`;
  };

  // ((Number, String)) => String
  formatDrawingData = function([patchSize, drawing]) {
    var formatted, patchSizeStr;
    formatted = formatFloat(patchSize);
    patchSizeStr = Number.isInteger(patchSize) ? `${formatted}.0` : formatted;
    return `${formatPlain('DRAWING')}\n${formatPlain(patchSizeStr)}${onNextLineIfNotEmpty(drawing === "" ? "" : formatPlain(drawing))}`;
  };

  // (Array[String], Array[String], Array[String], Array[String], Array[String], Array[ExtensionPorter]) => (ExportWorldData) => String
  worldDataToCSV = function(allTurtlesOwnsNames, allLinksOwnsNames, patchBuiltins, turtleBuiltins, linkBuiltins, extensionPorters) {
    return function(worldData) {
      var allPatchesOwnsNames, currentPlotName, currentPlotNameOrNull, drawingDataMaybe, drawingStr, extensionFormatter, extensions, extensionsCSV, formatAnyValue, globals, isOuterValue, links, linksStr, metadata, obnoxiousPlotCSV, output, patches, patchesStr, plotCSV, plotManager, plots, randomState, turtles, turtlesStr;
      extensionFormatter = ExtensionsHandler.makeFormatter(extensionPorters);
      ({metadata, randomState, globals, patches, turtles, links, plotManager, drawingDataMaybe, output, extensions} = worldData);
      // Patches don't have a breed in the breed manager, and they all use the same exact set of vars,
      // so the best place to get the vars is from a patch, itself, and there must always be at least
      // one patch (`patch 0 0`), so we take the first patch and its varnames. --JAB (12/16/17)
      allPatchesOwnsNames = Object.keys(patches[0].patchesOwns);
      formatAnyValue = formatAny(extensionFormatter);
      patchesStr = formatAgents(patches, schemafyPatch(formatAnyValue), patchBuiltins, allPatchesOwnsNames, formatAnyValue);
      turtlesStr = formatAgents(turtles, schemafyTurtle(formatAnyValue), turtleBuiltins, allTurtlesOwnsNames, formatAnyValue);
      linksStr = formatAgents(links, schemafyLink(formatAnyValue), linkBuiltins, allLinksOwnsNames, formatAnyValue);
      ({currentPlotNameOrNull, plots} = plotManager);
      currentPlotName = currentPlotNameOrNull != null ? currentPlotNameOrNull : '';
      plotCSV = plots.map(formatPlotData).join('\n\n');
      obnoxiousPlotCSV = plotCSV.length > 0 ? plotCSV + "\n" : plotCSV;
      drawingStr = pipeline(mapMaybe(formatDrawingData), fold(function() {
        return "";
      })(id))(drawingDataMaybe);
      extensionsCSV = extensionFormatter.format(extensions, formatAny(extensionFormatter, isOuterValue = false));
      return `${formatMetadata(metadata)}\n\n${formatPlain('RANDOM STATE')}\n${formatPlain(randomState)}\n\n${formatGlobals(globals, formatAnyValue)}\n\n${formatPlain('TURTLES')}\n${turtlesStr}\n\n${formatPlain('PATCHES')}\n${patchesStr}\n\n${formatPlain('LINKS')}\n${linksStr}\n${drawingStr}\n\n${formatPlain('OUTPUT')}${onNextLineIfNotEmpty(output === "" ? "" : formatString(output))}\n${formatPlain('PLOTS')}\n${formatPlain(currentPlotName)}${onNextLineIfNotEmpty(obnoxiousPlotCSV)}\n${formatPlain('EXTENSIONS')}\n${onNextLineIfNotEmpty(extensionsCSV)}\n\n`;
    };
  };

  module.exports = {allPlotsDataToCSV, plotDataToCSV, rawPlotToCSV, worldDataToCSV};

}).call(this);

},{"../engine/core/world/extensionshandler":"engine/core/world/extensionshandler","./exportstructures":"serialize/exportstructures","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/number":"brazier/number","brazierjs/object":"brazier/object","util/formatfloat":"util/formatfloat","util/jstype":"util/jstype"}],"serialize/exportstructures":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // Did I *need* to create two dozen different classes for all of this stuff?  No, of course not.
  // *However*, I wanted to document/codify somewhere what the types of these different structures
  // are, and this, to me, seemed to be the most effective way of doing that.  So, please, pardon
  // the noise.  I'm merely trying to help. --JAB (12/10/17)
  var AgentReference, ExportedAgent, ExportedAgentSet, ExportedColor, ExportedExtension;

  module.exports.BreedNamePair = class {
    // (String, String)
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }

  };

  ExportedColor = class ExportedColor {};

  module.exports.ExportedColor = ExportedColor;

  module.exports.ExportedRGB = class extends ExportedColor {
    // (Number, Number, Number)
    constructor(r, g, b) {
      super();
      this.r = r;
      this.g = g;
      this.b = b;
    }

  };

  module.exports.ExportedRGBA = class extends ExportedColor {
    // (Number, Number, Number, Number)
    constructor(r, g, b, a = 255) {
      super();
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

  };

  module.exports.ExportedColorNum = class extends ExportedColor {
    // (Number)
    constructor(value) {
      super();
      this.value = value;
    }

  };

  module.exports.ExportedGlobals = class {
    // ( String, Number, Number, Number, Number, Number
    // , String, AgentReference, Number, Object[Any])
    constructor(linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, perspective, subject, ticks, codeGlobals) {
      this.linkDirectedness = linkDirectedness;
      this.maxPxcor = maxPxcor;
      this.maxPycor = maxPycor;
      this.minPxcor = minPxcor;
      this.minPycor = minPycor;
      this.nextWhoNumber = nextWhoNumber;
      this.perspective = perspective;
      this.subject = subject;
      this.ticks = ticks;
      this.codeGlobals = codeGlobals;
    }

  };

  module.exports.ExportedCommandLambda = class {
    // (String)
    constructor(source) {
      this.source = source;
    }

  };

  module.exports.ExportedReporterLambda = class {
    // (String)
    constructor(source) {
      this.source = source;
    }

  };

  module.exports.ExportedPoint = class {
    // (Number, Number, Boolean, Number)
    constructor(x, y, isPenDown, color) {
      this.x = x;
      this.y = y;
      this.isPenDown = isPenDown;
      this.color = color;
    }

  };

  module.exports.ExportedPen = class {
    // (Number, Number, Boolean, String, String, Array[ExportedPoint], Number)
    constructor(color, interval, isPenDown, mode, name, points, x) {
      this.color = color;
      this.interval = interval;
      this.isPenDown = isPenDown;
      this.mode = mode;
      this.name = name;
      this.points = points;
      this.x = x;
    }

  };

  module.exports.ExportedPlot = class {
    // ( String, Boolean, Boolean, String, Array[ExportedPen]
    // , Number, Number, Number, Number)
    constructor(currentPenNameOrNull, isAutoplotting, isLegendOpen, name, pens, xMax, xMin, yMax, yMin) {
      this.currentPenNameOrNull = currentPenNameOrNull;
      this.isAutoplotting = isAutoplotting;
      this.isLegendOpen = isLegendOpen;
      this.name = name;
      this.pens = pens;
      this.xMax = xMax;
      this.xMin = xMin;
      this.yMax = yMax;
      this.yMin = yMin;
    }

  };

  module.exports.ExportedPlotManager = class {
    // (String, Array[ExportedPlot])
    constructor(currentPlotNameOrNull, plots) {
      this.currentPlotNameOrNull = currentPlotNameOrNull;
      this.plots = plots;
    }

  };

  module.exports.BreedReference = class {
    // (String)
    constructor(breedName) {
      this.breedName = breedName;
    }

  };

  AgentReference = class AgentReference {
    // (String)
    constructor(referenceType) {
      this.referenceType = referenceType;
    }

  };

  module.exports.AgentReference = AgentReference;

  module.exports.LinkReference = class extends AgentReference {
    // (BreedNamePair, Number, Number)
    constructor(breed, id1, id2) {
      super("link");
      this.breed = breed;
      this.id1 = id1;
      this.id2 = id2;
    }

  };

  module.exports.PatchReference = class extends AgentReference {
    // (Number, Number)
    constructor(pxcor, pycor) {
      super("patch");
      this.pxcor = pxcor;
      this.pycor = pycor;
    }

  };

  module.exports.TurtleReference = class extends AgentReference {
    // (BreedNamePair, Number)
    constructor(breed, id) {
      super("turtle");
      this.breed = breed;
      this.id = id;
    }

  };

  module.exports.NobodyReference = new AgentReference("nobody");

  ExportedAgent = class ExportedAgent {
    // (String)
    constructor(agentType) {
      this.agentType = agentType;
    }

  };

  module.exports.ExportedAgent = ExportedAgent;

  module.exports.ExportedLink = class extends ExportedAgent {
    // ( TurtleReference, TurtleReference, ExportedColor, String, ExportedColor, Boolean
    // , BreedReference, Number, String, String, Object[Any])
    constructor(end1, end2, color, label, labelColor, isHidden, breed, thickness, shape, tieMode, breedsOwns) {
      super("link");
      this.end1 = end1;
      this.end2 = end2;
      this.color = color;
      this.label = label;
      this.labelColor = labelColor;
      this.isHidden = isHidden;
      this.breed = breed;
      this.thickness = thickness;
      this.shape = shape;
      this.tieMode = tieMode;
      this.breedsOwns = breedsOwns;
    }

  };

  module.exports.ExportedPatch = class extends ExportedAgent {
    // (Number, Number, ExportedColor, String, ExportedColor, Object[Any])
    constructor(pxcor, pycor, pcolor, plabel, plabelColor, patchesOwns) {
      super("patch");
      this.pxcor = pxcor;
      this.pycor = pycor;
      this.pcolor = pcolor;
      this.plabel = plabel;
      this.plabelColor = plabelColor;
      this.patchesOwns = patchesOwns;
    }

  };

  module.exports.ExportedTurtle = class extends ExportedAgent {
    // ( Number, ExportedColor, Number, Number, Number, String, String, ExportedColor, BreedReference
    // , Boolean, Number, Number, String, Object[Any])
    constructor(who, color, heading, xcor, ycor, shape, label, labelColor, breed, isHidden, size, penSize, penMode, breedsOwns) {
      super("turtle");
      this.who = who;
      this.color = color;
      this.heading = heading;
      this.xcor = xcor;
      this.ycor = ycor;
      this.shape = shape;
      this.label = label;
      this.labelColor = labelColor;
      this.breed = breed;
      this.isHidden = isHidden;
      this.size = size;
      this.penSize = penSize;
      this.penMode = penMode;
      this.breedsOwns = breedsOwns;
    }

  };

  ExportedAgentSet = class ExportedAgentSet {
    // (String)
    constructor(agentSetType) {
      this.agentSetType = agentSetType;
    }

  };

  module.exports.ExportedAgentSet = ExportedAgentSet;

  module.exports.ExportedLinkSet = class extends ExportedAgentSet {
    // (Array[LinkReference])
    constructor(references) {
      super("linkset");
      this.references = references;
    }

  };

  module.exports.ExportedPatchSet = class extends ExportedAgentSet {
    // (Array[PatchReference])
    constructor(references) {
      super("patchset");
      this.references = references;
    }

  };

  module.exports.ExportedTurtleSet = class extends ExportedAgentSet {
    // (Array[TurtleReference])
    constructor(references) {
      super("turtleset");
      this.references = references;
    }

  };

  ExportedExtension = class ExportedExtension {
    // (String)
    constructor(extensionName1) {
      this.extensionName = extensionName1;
    }

  };

  module.exports.ExportedExtension = ExportedExtension;

  module.exports.ExportedSimpleExtension = class extends ExportedExtension {
    // (String, Array[ExportedExtensionObject])
    constructor(extensionName, objects) {
      super(extensionName);
      this.objects = objects;
    }

  };

  module.exports.ExportedExtensionObject = class {
    // (String, String, Any)
    constructor(extensionName1, subType, data) {
      this.extensionName = extensionName1;
      this.subType = subType;
      this.data = data;
    }

  };

  module.exports.Metadata = class {
    // (String, String, Date)
    constructor(version, filename, date) {
      this.version = version;
      this.filename = filename;
      this.date = date;
    }

  };

  module.exports.ExportWorldData = class {
    // ( Metadata, String, ExportedGlobals, Array[ExportedPatch], Array[ExportedTurtle]
    // , Array[ExportedLink], Maybe[(Number, String)], String, ExportedPlotManager, Array[ExportedExtension])
    constructor(metadata, randomState, globals, patches, turtles, links, drawingDataMaybe, output, plotManager, extensions) {
      this.metadata = metadata;
      this.randomState = randomState;
      this.globals = globals;
      this.patches = patches;
      this.turtles = turtles;
      this.links = links;
      this.drawingDataMaybe = drawingDataMaybe;
      this.output = output;
      this.plotManager = plotManager;
      this.extensions = extensions;
    }

  };

  module.exports.ExportPlotData = class {
    // (Metadata, Object[Any], ExportedPlot)
    constructor(metadata, miniGlobals, plot) {
      this.metadata = metadata;
      this.miniGlobals = miniGlobals;
      this.plot = plot;
    }

  };

  module.exports.ExportAllPlotsData = class {
    // (Metadata, Object[Any], Array[Plot])
    constructor(metadata, miniGlobals, plots) {
      this.metadata = metadata;
      this.miniGlobals = miniGlobals;
      this.plots = plots;
    }

  };

}).call(this);

},{}],"serialize/importcsv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExportWorldData, ExportedColorNum, ExportedExtension, ExportedGlobals, ExportedLink, ExportedPatch, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedRGB, ExportedRGBA, ExportedTurtle, ExtensionsHandler, JSType, Metadata, arrayParse, buckets, csvNameToSaneName, drawingParse, extensionParse, extractGlobals, fold, foldl, globalParse, id, identity, maybe, nameToSchema, parse, parseAgentRefMaybe, parseAndExtract, parseAny, parseBool, parseBreed, parseColor, parseDate, parsePenMode, parsePerspective, parseString, parseStringMaybe, parseTurtleRefMaybe, parseVersion, plotParse, singletonParse, toExportedColor, toExportedGlobals, toExportedLink, toExportedPatch, toExportedPen, toExportedPlot, toExportedPlotManager, toExportedPoint, toExportedTurtle,
    indexOf = [].indexOf;

  parse = require('csv-parse/lib/sync');

  JSType = require('util/jstype');

  ({parseAgentRefMaybe, parseAny, parseBool, parseBreed, parseString, parseTurtleRefMaybe} = require('./readexportedvalue'));

  ExtensionsHandler = require('../engine/core/world/extensionshandler');

  ({ExportedColorNum, ExportedExtension, ExportedGlobals, ExportedLink, ExportedPatch, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedRGB, ExportedRGBA, ExportedTurtle, ExportWorldData, Metadata} = require('./exportstructures'));

  ({foldl} = require('brazierjs/array'));

  ({id} = require('brazierjs/function'));

  ({fold, maybe} = require('brazierjs/maybe'));

  // type ImpObj    = Object[Any]
  // type Row       = Array[String]
  // type Parser[T] = (Array[Row], Schema) => T
  // type Schema    = Object[(String) => Any]

  // (String) => String
  csvNameToSaneName = function(csvName) {
    var camelCased, firstLetter, lowered, qMatch, remainder, replaceAll;
    if (csvName !== "nextIndex") {
      replaceAll = function(str, regex, f) {
        var fullMatch, group, index, match, postfix, prefix;
        match = str.match(regex);
        if (match != null) {
          ({
            0: fullMatch,
            1: group,
            index
          } = match);
          prefix = str.slice(0, index);
          postfix = str.slice(index + fullMatch.length);
          return replaceAll(`${prefix}${f(group)}${postfix}`, regex, f);
        } else {
          return str;
        }
      };
      lowered = csvName.toLowerCase();
      camelCased = replaceAll(lowered, /[ \-]+([a-z0-9])/, function(str) {
        return str.toUpperCase();
      });
      qMatch = camelCased.match(/^(\w)(.*)\?$/);
      if (qMatch != null) {
        ({
          1: firstLetter,
          2: remainder
        } = qMatch);
        return `is${firstLetter.toUpperCase()}${remainder}`;
      } else {
        return camelCased;
      }
    } else {
      return csvName;
    }
  };

  // (String|(Number, Number, Number)|(Number, Number, Number, Number)) => ExportedColor
  toExportedColor = function(color) {
    var a, b, g, r;
    if (JSType(color).isNumber()) {
      return new ExportedColorNum(color);
    } else if (JSType(color).isArray()) {
      [r, g, b, a] = color;
      if (a != null) {
        return new ExportedRGBA(r, g, b, a);
      } else {
        return new ExportedRGB(r, g, b);
      }
    } else {
      throw new Error(`Unrecognized CSVified color: ${JSON.stringify(color)}`);
    }
  };

  // (Object[Any]) => ExportedGlobals
  toExportedGlobals = function({directedLinks, maxPxcor, maxPycor, minPxcor, minPycor, nextIndex, perspective, subject, ticks}, codeGlobals) {
    return new ExportedGlobals(directedLinks, maxPxcor, maxPycor, minPxcor, minPycor, nextIndex, perspective, subject, ticks, codeGlobals);
  };

  // (Object[Any]) => ExportedLink
  toExportedLink = function({breed, color, end1, end2, isHidden, labelColor, label, shape, thickness, tieMode, extraVars}) {
    return new ExportedLink(end1, end2, toExportedColor(color), label, toExportedColor(labelColor), isHidden, breed, thickness, shape, tieMode, extraVars);
  };

  // (Object[Any]) => ExportedPatch
  toExportedPatch = function({pcolor, plabelColor, plabel, pxcor, pycor, extraVars}) {
    return new ExportedPatch(pxcor, pycor, toExportedColor(pcolor), plabel, toExportedColor(plabelColor), extraVars);
  };

  // (Object[Any]) => ExportedTurtle
  toExportedTurtle = function({breed, color, heading, isHidden, labelColor, label, penMode, penSize, shape, size, who, xcor, ycor, extraVars}) {
    return new ExportedTurtle(who, toExportedColor(color), heading, xcor, ycor, shape, label, toExportedColor(labelColor), breed, isHidden, size, penSize, penMode, extraVars);
  };

  // (Object[Any]) => ExportedPoint
  toExportedPoint = function({x, y, isPenDown, color}) {
    return new ExportedPoint(x, y, isPenDown, color);
  };

  // (Object[Any]) => ExportedPen
  toExportedPen = function({color, interval, isPenDown, mode, penName, points, x}) {
    return new ExportedPen(color, interval, isPenDown, mode, penName, points.map(toExportedPoint), x);
  };

  // (Object[Any]) => ExportedPlot
  toExportedPlot = function({currentPen, isAutoplot, isLegendOpen, name, pens, xMax, xMin, yMax, yMin}) {
    return new ExportedPlot(fold(function() {
      return null;
    })(id)(currentPen), isAutoplot, isLegendOpen, name, pens.map(toExportedPen), xMax, xMin, yMax, yMin);
  };

  // (Object[Any]) => ExportedPlotManager
  toExportedPlotManager = function({
      default: defaultOrNull,
      plots
    }) {
    return new ExportedPlotManager(defaultOrNull, plots.map(toExportedPlot));
  };

  // START SCHEMA STUFF

  // Only used to mark things that we should delay converting until later --JAB (4/6/17)
  // [T] @ (T) => T
  identity = function(x) {
    return x;
  };

  // (String) => String|(Number, Number, Number)|(Number, Number, Number, Number)
  parseColor = function(x) {
    var unpossible;
    unpossible = function() {
      throw new Error("Why is this even getting called?  We shouldn't be parsing breed names where colors are expected.");
    };
    return parseAny(unpossible, unpossible, {
      matchesPlaceholder: function() {
        return false;
      }
    })(x);
  };

  // (String) => Number
  parseDate = function(x) {
    var _, millis, postfix, prefix;
    [_, prefix, millis, postfix] = x.match(/(.*):(\d+) (.*)/);
    return new Date(Date.parse(`${prefix} ${postfix}`) + parseInt(millis));
  };

  // (String) => Maybe[String]
  parseStringMaybe = function(x) {
    var value;
    value = parseString(x);
    return maybe(value === "" ? null : value);
  };

  parsePenMode = function(x) {
    switch (parseInt(x)) {
      case 0:
        return 'line';
      case 1:
        return 'bar';
      case 2:
        return 'point';
      default:
        throw new Error(`Unknown pen mode: ${x}`);
    }
  };

  // (String) => String
  parsePerspective = function(x) {
    switch (parseInt(x)) {
      case 0:
        return 'observe';
      case 1:
        return 'ride';
      case 2:
        return 'follow';
      case 3:
        return 'watch';
      default:
        throw new Error(`Unknown perspective number: ${x}`);
    }
  };

  // (String) => String
  parseVersion = function(x) {
    return x.match(/export-world data \([^\)]+\)/)[1];
  };

  // [T] @ (String) => ((String) => Maybe[T]) => ((String) => T)
  parseAndExtract = function(typeOfEntry) {
    return function(f) {
      return function(x) {
        return fold(function(x) {
          throw new Error(`Unable to parse ${typeOfEntry}: ${JSON.stringify(x)}`);
        })(id)(f(x));
      };
    };
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Object[Schema]
  nameToSchema = function(singularToPlural, pluralToSingular, extensionReader) {
    var parseAgentLocal, parseAnyLocal, parseTurtleLocal;
    parseAnyLocal = parseAny(singularToPlural, pluralToSingular, extensionReader);
    parseAgentLocal = parseAndExtract("agent ref")(parseAgentRefMaybe(singularToPlural));
    parseTurtleLocal = parseAndExtract("turtle ref")(parseTurtleRefMaybe(singularToPlural));
    return {
      plots: {
        color: parseFloat,
        currentPen: parseStringMaybe,
        interval: parseFloat,
        isAutoplot: parseBool,
        isLegendOpen: parseBool,
        isPenDown: parseBool,
        mode: parsePenMode,
        penName: parseString,
        xMax: parseFloat,
        xMin: parseFloat,
        x: parseFloat,
        yMax: parseFloat,
        yMin: parseFloat,
        y: parseFloat
      },
      randomState: {
        value: identity
      },
      globals: {
        directedLinks: parseString,
        minPxcor: parseInt,
        maxPxcor: parseInt,
        minPycor: parseInt,
        maxPycor: parseInt,
        nextIndex: parseInt,
        perspective: parsePerspective,
        subject: parseAgentLocal,
        ticks: parseFloat
      },
      turtles: {
        breed: parseBreed,
        color: parseColor,
        heading: parseFloat,
        isHidden: parseBool,
        labelColor: parseColor,
        label: parseAnyLocal,
        penMode: parseString,
        penSize: parseFloat,
        shape: parseString,
        size: parseFloat,
        who: parseInt,
        xcor: parseFloat,
        ycor: parseFloat
      },
      patches: {
        pcolor: parseColor,
        plabelColor: parseColor,
        plabel: parseAnyLocal,
        pxcor: parseInt,
        pycor: parseInt
      },
      links: {
        breed: parseBreed,
        color: parseColor,
        end1: parseTurtleLocal,
        end2: parseTurtleLocal,
        isHidden: parseBool,
        labelColor: parseColor,
        label: parseAnyLocal,
        shape: parseString,
        thickness: parseFloat,
        tieMode: parseString
      },
      output: {
        value: parseString
      },
      extensions: {}
    };
  };

  // END SCHEMA STUFF

  // START PARSER STUFF

  // Parser[String]
  singletonParse = function(x, schema) {
    var ref;
    if (((ref = x[0]) != null ? ref[0] : void 0) != null) {
      return schema.value(x[0][0]);
    } else {
      return '';
    }
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Parser[Array[ImpObj]]
  arrayParse = function(singularToPlural, pluralToSingular, extensionReader) {
    return function([keys, ...rows], schema) {
      var f;
      f = function(acc, row) {
        var index, j, len, obj, rawKey, saneKey, value;
        obj = {
          extraVars: {}
        };
        for (index = j = 0, len = keys.length; j < len; index = ++j) {
          rawKey = keys[index];
          saneKey = csvNameToSaneName(rawKey);
          value = row[index];
          if (schema[saneKey] != null) {
            obj[saneKey] = schema[saneKey](value);
          } else if (value !== "") { // DO NOT USE `saneKey`!  Do not touch user global names! --JAB (8/2/17)
            obj.extraVars[rawKey] = parseAny(singularToPlural, pluralToSingular, extensionReader)(value);
          }
        }
        return acc.concat([obj]);
      };
      return foldl(f)([])(rows);
    };
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Parser[ImpObj]
  globalParse = function(singularToPlural, pluralToSingular, extensionReader) {
    return function(csvBucket, schema) {
      return arrayParse(singularToPlural, pluralToSingular, extensionReader)(csvBucket, schema)[0];
    };
  };

  // Parser[ImpObj]
  plotParse = function(csvBucket, schema) {
    var csvIndex, j, length, output, parseEntity, penCount, penIndex, plot, point, pointsIndex, ref, ref1, ref2;
    parseEntity = function(acc, rowIndex, upperBound, valueRowOffset, valueColumnOffset) {
      var columnIndex, columnName, j, ref, ref1, value;
      for (columnIndex = j = 0, ref = upperBound; (0 <= ref ? j < ref : j > ref); columnIndex = 0 <= ref ? ++j : --j) {
        columnName = csvNameToSaneName(csvBucket[rowIndex][columnIndex]);
        value = csvBucket[rowIndex + valueRowOffset][columnIndex + valueColumnOffset];
        acc[columnName] = ((ref1 = schema[columnName]) != null ? ref1 : parseInt)(value);
      }
      return acc;
    };
    output = {
      default: (ref = (ref1 = csvBucket[0]) != null ? ref1[0] : void 0) != null ? ref : null,
      plots: []
    };
    // Iterate over every plot
    csvIndex = 1;
    while (csvIndex < csvBucket.length) {
      plot = parseEntity({
        name: parseString(csvBucket[csvIndex++][0])
      }, csvIndex, csvBucket[csvIndex].length, 1, 0);
      penCount = plot.numberOfPens;
      delete plot.penCount;
      csvIndex += 2;
      plot.pens = (function() {
        var results = [];
        for (var j = 0; 0 <= penCount ? j < penCount : j > penCount; 0 <= penCount ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this).map(function(i) {
        return parseEntity({
          points: []
        }, csvIndex, csvBucket[csvIndex].length, 1 + i, 0);
      });
      csvIndex += 2 + penCount;
      // For each pen, parsing of the list of points associated with the pen
      pointsIndex = 1;
      while (csvIndex + pointsIndex < csvBucket.length && csvBucket[csvIndex + pointsIndex].length !== 1) {
        length = csvBucket[csvIndex].length / penCount;
        for (penIndex = j = 0, ref2 = penCount; (0 <= ref2 ? j < ref2 : j > ref2); penIndex = 0 <= ref2 ? ++j : --j) {
          if (csvBucket[csvIndex + pointsIndex][penIndex * length] !== '') {
            point = parseEntity({}, csvIndex, length, pointsIndex, penIndex * length);
            plot.pens[penIndex].points.push(point);
          }
        }
        pointsIndex++;
      }
      csvIndex += pointsIndex;
      output.plots.push(plot);
    }
    return output;
  };

  // (Array[String]) => Parser[Map[String, Array[String]]]
  extensionParse = function(extensionNames) {
    return function(csvBucket, schema) {
      var current, first, index, j, line, output, ref;
      if (csvBucket.length === 0) {
        return {};
      }
      [first] = csvBucket[0];
      if (!extensionNames.includes(first.toUpperCase())) {
        throw new Error("Extension section must start with an extension name.");
      }
      output = {};
      current = [];
      output[first] = current;
      for (index = j = 1, ref = csvBucket.length; (1 <= ref ? j < ref : j > ref); index = 1 <= ref ? ++j : --j) {
        [line] = csvBucket[index];
        if (extensionNames.includes(line.toUpperCase())) {
          current = [];
          output[line] = current;
        } else {
          current.push(line);
        }
      }
      return output;
    };
  };

  // Parser[(Number, String)]
  drawingParse = function(csvBucket, schema) {
    var base64Str, patchSizeStr;
    if (csvBucket.length === 0) {
      return "";
    } else if (csvBucket.length === 2) {
      [[patchSizeStr], [base64Str]] = csvBucket;
      return [parseFloat(patchSizeStr), base64Str];
    } else {
      throw new Error("NetLogo Web cannot parse `export-world` drawings from before NetLogo 6.1.");
    }
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Object[Parser[Any]]
  buckets = function(singularToPlural, pluralToSingular, extensionReader) {
    return {
      extensions: extensionParse(extensionReader.extensionNames),
      drawing: drawingParse,
      globals: globalParse(singularToPlural, pluralToSingular, extensionReader),
      links: arrayParse(singularToPlural, pluralToSingular, extensionReader),
      output: singletonParse,
      patches: arrayParse(singularToPlural, pluralToSingular, extensionReader),
      plots: plotParse,
      randomState: singletonParse,
      turtles: arrayParse(singularToPlural, pluralToSingular, extensionReader)
    };
  };

  // END PARSER STUFF

  // (ImpObj, Array[String]) => (ImpObj, Object[String])
  extractGlobals = function(globals, knownNames) {
    var builtIn, key, user, value;
    builtIn = {};
    user = {};
    for (key in globals) {
      value = globals[key];
      if (indexOf.call(knownNames, key) >= 0) {
        builtIn[key] = value;
      } else {
        user[key] = value;
      }
    }
    return [builtIn, user];
  };

  // ((String) => String, (String) => String, Array[ExtensionPorter]) => (String) => WorldState
  module.exports = function(singularToPlural, pluralToSingular, extensionPorters) {
    return function(csvText) {
      var _, bucketParser, bucketToRows, buckies, builtInGlobals, clusterRows, codeGlobals, dateRow, drawing, extensionReader, extensions, filenameRow, getSchema, globals, links, name, outExtensions, outGlobals, outLinks, outMetadata, outPatches, outPlotManager, outTurtles, output, parseAnyLocal, parsedCSV, patches, plots, randomState, titleRow, turtles, world;
      extensionReader = ExtensionsHandler.makeReader(extensionPorters);
      buckies = buckets(singularToPlural, pluralToSingular, extensionReader);
      getSchema = nameToSchema(singularToPlural, pluralToSingular, extensionReader);
      parsedCSV = parse(csvText, {
        comment: '#',
        max_record_size: 1e12,
        skip_empty_lines: true,
        relax_column_count: true
      });
      clusterRows = function([acc, latestRows], row) {
        var ex, rows, saneName;
        saneName = (function() {
          try {
            if (row.length === 1) {
              return csvNameToSaneName(row[0]);
            } else {
              return void 0;
            }
          } catch (error) {
            ex = error;
            return void 0;
          }
        })();
        if ((saneName != null) && saneName in buckies) {
          rows = [];
          acc[saneName] = rows;
          return [acc, rows];
        } else if (latestRows != null) {
          latestRows.push(row);
          return [acc, latestRows];
        } else {
          return [acc, latestRows];
        }
      };
      [bucketToRows, _] = foldl(clusterRows)([{}, void 0])(parsedCSV);
      world = {};
      for (name in buckies) {
        bucketParser = buckies[name];
        if (bucketToRows[name] != null) {
          world[name] = bucketParser(bucketToRows[name], getSchema[name]);
        }
      }
      titleRow = parsedCSV[0][0];
      filenameRow = parsedCSV[1][0];
      dateRow = parsedCSV[2][0];
      ({globals, randomState, turtles, patches, links, drawing, output, plots, extensions} = world);
      codeGlobals = globals.extraVars;
      delete globals.extraVars;
      builtInGlobals = globals;
      outMetadata = new Metadata(parseVersion(titleRow), filenameRow, parseDate(dateRow));
      outGlobals = toExportedGlobals(builtInGlobals, codeGlobals);
      outPatches = patches.map(toExportedPatch);
      outTurtles = turtles.map(toExportedTurtle);
      outLinks = links.map(toExportedLink);
      outPlotManager = toExportedPlotManager(plots);
      parseAnyLocal = parseAny(singularToPlural, pluralToSingular, extensionReader);
      outExtensions = extensionReader.readExtensions(extensions, parseAnyLocal);
      return new ExportWorldData(outMetadata, randomState, outGlobals, outPatches, outTurtles, outLinks, maybe(drawing), output, outPlotManager, outExtensions);
    };
  };

}).call(this);

},{"../engine/core/world/extensionshandler":"engine/core/world/extensionshandler","./exportstructures":"serialize/exportstructures","./readexportedvalue":"serialize/readexportedvalue","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","csv-parse/lib/sync":7,"util/jstype":"util/jstype"}],"serialize/readexportedvalue":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedNamePair, BreedReference, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedReporterLambda, ExportedTurtleSet, LinkReference, NobodyReference, None, PatchReference, TurtleReference, firstIndexOfUnescapedQuote, fold, isSomething, mapMaybe, match, maybe, parseBreedMaybe, parseGeneric, parseInnerLink, parseLinkRefMaybe, parseList, parsePatchRefMaybe, parseTurtleRefMaybe, readAgenty, tryParsers;

  ({BreedNamePair, BreedReference, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedReporterLambda, ExportedTurtleSet, LinkReference, NobodyReference, PatchReference, TurtleReference} = require('./exportstructures'));

  ({
    fold,
    isSomething,
    map: mapMaybe,
    maybe,
    None
  } = require('brazier/maybe'));

  // (String) => Number
  firstIndexOfUnescapedQuote = function(str) {
    var index;
    index = str.indexOf('"');
    if (index > 0) {
      if (str[index - 1] !== "\\") {
        return index;
      } else {
        return 1 + index + firstIndexOfUnescapedQuote(str.slice(index + 1));
      }
    } else {
      return index;
    }
  };

  // (String, (String) => Any, (String) => Any, ExtensionsReader) => Array[Any]
  parseList = function() {
    var parseListHelper;
    parseListHelper = function(list, readValue, readAgentLike, extensionReader) {
      var parseInner;
      parseInner = function(contents, acc = [], accIndex = 0) {
        var endIndex, index, item, placeholder, placeholderMatch, recurse, rightIndex, spaceIndex, strFrom, strIndex, strUntil, tempered;
        strIndex = function(char) {
          return contents.indexOf(char);
        };
        strFrom = function(index) {
          return contents.slice(index);
        };
        strUntil = function(index) {
          return contents.slice(0, index);
        };
        tempered = function(index) {
          return index + (contents[index + 1] === ']' ? 1 : 2);
        };
        recurse = function(nextIndex, item) {
          return parseInner(strFrom(nextIndex), acc.concat([item]), accIndex + nextIndex);
        };
        if (!(contents.startsWith('(anonymous command:') || contents.startsWith('(anonymous reporter:'))) {
          switch (contents[0]) {
            case ']': // End of list
              return [acc, accIndex + 1];
            case '[': // Start of list
              [item, endIndex] = parseListHelper(contents, readValue, readAgentLike, extensionReader);
              return recurse(tempered(endIndex), item);
            case '{': // Start of agent/agentset or extension placeholder
              if (contents[1] === '{') {
                index = strIndex('}}') + 1;
                placeholder = strUntil(index + 1);
                placeholderMatch = extensionReader.matchesPlaceholder(placeholder);
                if (placeholderMatch == null) {
                  throw new Error("This looks like an extension object, but it's not?");
                }
                return recurse(tempered(index), extensionReader.readPlaceholder(placeholderMatch));
              } else {
                index = strIndex('}');
                return recurse(tempered(index), readAgentLike(strUntil(index + 1)));
              }
              break;
            case '"': // Start of string
              index = firstIndexOfUnescapedQuote(strFrom(1)) + 1;
              return recurse(tempered(index), readValue(strUntil(index + 1)));
            default:
              rightIndex = strIndex(']'); // End of next item, if there's no item after it
              spaceIndex = strIndex(' '); // Separator between next item and the one after
              if (rightIndex < spaceIndex || spaceIndex < 0) {
                return recurse(rightIndex, readValue(strUntil(rightIndex)));
              } else {
                return recurse(spaceIndex + 1, readValue(strUntil(spaceIndex)));
              }
          }
        } else {
          throw new Error("Importing a list of anonymous procedures?  Not happening!");
        }
      };
      if (list[0] === '[') {
        return parseInner(list.slice(1));
      } else {
        throw new Error(`Not a valid list: ${list}`);
      }
    };
    return parseListHelper(...arguments)[0];
  };

  // (Regex, String, String) => RegexMatch
  match = function(regex, str) {
    var result;
    result = str.match(regex);
    if (result != null) {
      return result;
    } else {
      throw new Error(`Could not match regex ${regex} with this string: ${str}`);
    }
  };

  // (String) => Boolean
  module.exports.parseBool = function(x) {
    return x.toLowerCase() === "true";
  };

  // (String) => BreedReference
  parseBreedMaybe = function(x) {
    switch (x) {
      case "{all-turtles}":
        return maybe(new BreedReference("TURTLES"));
      case "{all-patches}":
        return maybe(new BreedReference("PATCHES"));
      case "{all-links}":
        return maybe(new BreedReference("LINKS"));
      default:
        return parseGeneric(/{breed (.*)}/)(function([_, breedName]) {
          return new BreedReference(breedName.toLowerCase());
        })(x);
    }
  };

  // (String) => BreedReference
  module.exports.parseBreed = function(x) {
    return fold(function() {
      throw new Error(`Cannot parse as breed: ${x}`);
    })(function(x) {
      return x;
    })(parseBreedMaybe(x));
  };

  // (String) => String
  module.exports.parseString = function(str) {
    return match(/^"(.*)"$/, str)[1].replace(new RegExp('\\\\"', 'g'), '"');
  };

  // [T] @ (RegExp) => ((Array[String]) => Maybe[T]) => (String) => Maybe[T]
  parseGeneric = function(regex) {
    return function(f) {
      return function(x) {
        return mapMaybe(f)(maybe(x.match(regex)));
      };
    };
  };

  // ((String) => String) => (String) => Maybe[TurtleReference]
  parseTurtleRefMaybe = function(singularToPlural) {
    return parseGeneric(/{([^ ]+) (\d+)}/)(function([_, breedName, idStr]) {
      var breed;
      breed = new BreedNamePair(breedName, singularToPlural(breedName).toLowerCase());
      return new TurtleReference(breed, parseInt(idStr));
    });
  };

  module.exports.parseTurtleRefMaybe = parseTurtleRefMaybe;

  // (String) => Maybe[PatchReference]
  parsePatchRefMaybe = parseGeneric(/{patch ([\d-]+) ([\d-]+)}/)(function([_, xStr, yStr]) {
    return new PatchReference(parseInt(xStr), parseInt(yStr));
  });

  // ((String) => String) => (String) => Maybe[LinkReference]
  parseLinkRefMaybe = function(singularToPlural) {
    return parseGeneric(/{([^ ]+) (\d+) (\d+)}/)(function([_, breedName, end1IDStr, end2IDStr]) {
      var breed;
      breed = new BreedNamePair(breedName, singularToPlural(breedName).toLowerCase());
      return new LinkReference(breed, parseInt(end1IDStr), parseInt(end2IDStr));
    });
  };

  // [T] @ (Array[(String) => Maybe[T]]) => (String) => Maybe[T]
  tryParsers = function(parsers) {
    return function(x) {
      var i, len, parser, result;
      for (i = 0, len = parsers.length; i < len; i++) {
        parser = parsers[i];
        result = parser(x);
        if (isSomething(result)) {
          return result;
        }
      }
      return None;
    };
  };

  // ((String) => String) => (String) => Maybe[AgentReference]
  module.exports.parseAgentRefMaybe = function(singularToPlural) {
    return function(x) {
      var lowerCased, stp;
      lowerCased = x.toLowerCase();
      stp = singularToPlural;
      if (lowerCased === 'nobody') {
        return maybe(NobodyReference);
      } else {
        return tryParsers([parsePatchRefMaybe, parseLinkRefMaybe(stp), parseTurtleRefMaybe(stp)])(lowerCased);
      }
    };
  };

  // ((String) => String) => (String) => LinkReference
  parseInnerLink = function(pluralToSingular) {
    return function(x) {
      var _, breed, breedName, id1, id2, unparsedBreed;
      [_, id1, id2, unparsedBreed] = match(/\[(\d+) (\d+) (.*)/, x);
      breedName = unparsedBreed === "{all-links}" ? "links" : match(/{breed (.*)}/, unparsedBreed)[1];
      breed = new BreedNamePair(pluralToSingular(breedName), breedName.toLowerCase());
      return new LinkReference(breed, parseInt(id1), parseInt(id2));
    };
  };

  // ((String) => String, (String) => String) => (String) => Any
  readAgenty = function(singularToPlural, pluralToSingular) {
    return function(x) {
      var lowerCased, parseLinkSet, parsePatchSet, parseTurtleSet, parsedMaybe, parsers, stp;
      lowerCased = x.toLowerCase();
      stp = singularToPlural;
      parseTurtleSet = parseGeneric(/{turtles ?([^}]*)}/)(function([_, nums]) {
        var breed;
        breed = new BreedNamePair("turtle", "turtles");
        return new ExportedTurtleSet(nums.split(' ').map(function(x) {
          return parseInt(x);
        }).map(function(who) {
          return new TurtleReference(breed, who);
        }));
      });
      parsePatchSet = parseGeneric(/{patches ?([^}]*)}/)(function([_, pairs]) {
        return new ExportedPatchSet(pairs.split(/] ?/).slice(0, -1).map(function(x) {
          return x.slice(1).split(' ').map(function(x) {
            return parseInt(x);
          });
        }).map(function([x, y]) {
          return new PatchReference(x, y);
        }));
      });
      parseLinkSet = parseGeneric(/{links ?(.*)}$/)(function([_, triples]) {
        return new ExportedLinkSet(triples.split(/] ?/).slice(0, -1).map(parseInnerLink(pluralToSingular)));
      });
      parsers = [parseBreedMaybe, parseTurtleSet, parsePatchSet, parseLinkSet, parsePatchRefMaybe, parseLinkRefMaybe(stp), parseTurtleRefMaybe(stp)];
      parsedMaybe = tryParsers(parsers)(lowerCased);
      return fold(function() {
        throw new Error(`You supplied ${x}, and I don't know what the heck that is!`);
      })(function(x) {
        return x;
      })(parsedMaybe);
    };
  };

  // ((String) => String, (String) => String, ExtensionsReader) => (String) => Any
  module.exports.parseAny = function(singularToPlural, pluralToSingular, extensionReader) {
    var helper;
    helper = function(x) {
      var lowerCased, result;
      lowerCased = x.toLowerCase();
      result = (function() {
        switch (lowerCased) {
          case "e":
            return maybe(Math.E);
          case "pi":
            return maybe(Math.PI);
          case "true":
            return maybe(true);
          case "false":
            return maybe(false);
          case "nobody":
            return maybe(NobodyReference);
          case "black":
            return maybe(0);
          case "gray":
            return maybe(5);
          case "white":
            return maybe(9.9);
          case "red":
            return maybe(15);
          case "orange":
            return maybe(25);
          case "brown":
            return maybe(35);
          case "yellow":
            return maybe(45);
          case "green":
            return maybe(55);
          case "lime":
            return maybe(65);
          case "turquoise":
            return maybe(75);
          case "cyan":
            return maybe(85);
          case "sky":
            return maybe(95);
          case "blue":
            return maybe(105);
          case "violet":
            return maybe(115);
          case "magenta":
            return maybe(125);
          case "pink":
            return maybe(135);
          default:
            return None;
        }
      })();
      return fold(function() {
        var commandLambdaMatch, extensionsMatch, listMatch, parsedNum, reporterLambdaMatch, strMatch;
        listMatch = x.match(/^\[.*\]$/);
        if (listMatch != null) {
          return parseList(x, helper, readAgenty(singularToPlural, pluralToSingular), extensionReader); // If not a list
        } else {
          strMatch = x.match(/^"(.*)"$/);
          if (strMatch != null) {
            return strMatch[1].replace(new RegExp('\\\\"', 'g'), '"'); // If not a string
          } else {
            parsedNum = parseFloat(x);
            if (!Number.isNaN(parsedNum)) {
              return parsedNum; // If not a number
            } else {
              commandLambdaMatch = x.match(/\(anonymous command: (\[.*\])\)$/);
              if (commandLambdaMatch != null) {
                return new ExportedCommandLambda(commandLambdaMatch[1]);
              } else {
                reporterLambdaMatch = x.match(/\(anonymous reporter: (\[.*\])\)$/);
                if (reporterLambdaMatch != null) {
                  return new ExportedReporterLambda(reporterLambdaMatch[1]);
                } else {
                  extensionsMatch = extensionReader.matchesPlaceholder(x);
                  if (extensionsMatch != null) {
                    return extensionReader.readPlaceholder(extensionsMatch, helper); // If not an extension placeholder
                  } else {
                    return readAgenty(singularToPlural, pluralToSingular)(lowerCased);
                  }
                }
              }
            }
          }
        }
      })(function(res) {
        return res;
      })(result);
    };
    return helper;
  };

}).call(this);

},{"./exportstructures":"serialize/exportstructures","brazier/maybe":"brazier/maybe"}],"shim/auxrandom":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MersenneTwisterFast;

  ({MersenneTwisterFast} = require('./engine-scala'));

  module.exports = MersenneTwisterFast();

}).call(this);

},{"./engine-scala":"shim/engine-scala"}],"shim/cloner":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var JSType, cloneFunc, foldl;

  ({foldl} = require('brazierjs/array'));

  JSType = require('util/jstype');

  // [T] @ (T) => T
  cloneFunc = function(obj) { // Stored into a variable for the sake of recursion --JAB (4/29/14)
    var basicClone, entryCopyFunc, properties;
    if (JSType(obj).isObject() && !JSType(obj).isFunction()) {
      properties = Object.getOwnPropertyNames(obj);
      entryCopyFunc = function(acc, x) {
        acc[x] = cloneFunc(obj[x]);
        return acc;
      };
      basicClone = new obj.constructor();
      return foldl(entryCopyFunc)(basicClone)(properties);
    } else {
      return obj;
    }
  };

  module.exports = cloneFunc;

}).call(this);

},{"brazierjs/array":"brazier/array","util/jstype":"util/jstype"}],"shim/engine-scala":[function(require,module,exports){
(function (global){
(function() {

(function(){'use strict';
'use strict';var f,g="object"===typeof __ScalaJSEnv&&__ScalaJSEnv?__ScalaJSEnv:{},l="object"===typeof g.global&&g.global?g.global:"object"===typeof global&&global&&global.Object===Object?global:this;g.global=l;var aa="object"===typeof g.exportsNamespace&&g.exportsNamespace?g.exportsNamespace:l;g.exportsNamespace=aa;l.Object.freeze(g);var ca={envInfo:g,semantics:{asInstanceOfs:2,arrayIndexOutOfBounds:2,moduleInit:2,strictFloats:!1,productionMode:!0},assumingES6:!1,linkerVersion:"0.6.29",globalThis:this};
l.Object.freeze(ca);l.Object.freeze(ca.semantics);var m=l.Math.imul||function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0},da=l.Math.clz32||function(a){if(0===a)return 32;var b=1;0===(a&4294901760)&&(a<<=16,b+=16);0===(a&4278190080)&&(a<<=8,b+=8);0===(a&4026531840)&&(a<<=4,b+=4);0===(a&3221225472)&&(a<<=2,b+=2);return b+(a>>31)},ea=0,fa=l.WeakMap?new l.WeakMap:null;
function ha(a){return function(b,c){return!(!b||!b.$classData||b.$classData.ta!==c||b.$classData.ra!==a)}}function ia(a){for(var b in a)return b}function ja(a,b){return new a.db(b)}function ka(a,b){return la(a,b,0)}function la(a,b,c){var d=new a.db(b[c]);if(c<b.length-1){a=a.va;c+=1;for(var e=d.a,h=0;h<e.length;h++)e[h]=la(a,b,c)}return d}function ma(a){return void 0===a?"undefined":a.toString()}
function na(a){switch(typeof a){case "string":return n(oa);case "number":var b=a|0;return b===a?pa(b)?n(qa):ra(b)?n(sa):n(ta):"number"===typeof a?n(ua):n(va);case "boolean":return n(wa);case "undefined":return n(xa);default:return null===a?a.ff():a instanceof q?n(ya):a&&a.$classData?n(a.$classData):null}}function za(a,b){return a&&a.$classData||null===a?a.B(b):"number"===typeof a?"number"===typeof b&&(a===b?0!==a||1/a===1/b:a!==a&&b!==b):a===b}
function Aa(a){switch(typeof a){case "string":return Ba(Ca(),a);case "number":return Da(Ea(),a);case "boolean":return a?1231:1237;case "undefined":return 0;default:return a&&a.$classData||null===a?a.u():null===fa?42:Fa(a)}}function Ga(a){return 2147483647<a?2147483647:-2147483648>a?-2147483648:a|0}
var Fa=null!==fa?function(a){switch(typeof a){case "string":case "number":case "boolean":case "undefined":return Aa(a);default:if(null===a)return 0;var b=fa.get(a);void 0===b&&(ea=b=ea+1|0,fa.set(a,b));return b}}:function(a){if(a&&a.$classData){var b=a.$idHashCode$0;if(void 0!==b)return b;if(l.Object.isSealed(a))return 42;ea=b=ea+1|0;return a.$idHashCode$0=b}return null===a?0:Aa(a)};function pa(a){return"number"===typeof a&&a<<24>>24===a&&1/a!==1/-0}
function ra(a){return"number"===typeof a&&a<<16>>16===a&&1/a!==1/-0}function Ha(a){return null===a?r().oa:a}function Ia(){this.Sa=this.db=void 0;this.ra=this.va=this.G=null;this.ta=0;this.qb=null;this.Ia="";this.D=this.Fa=this.Ga=void 0;this.name="";this.isRawJSType=this.isArrayClass=this.isInterface=this.isPrimitive=!1;this.isInstance=void 0}
function Ja(a,b,c){var d=new Ia;d.G={};d.va=null;d.qb=a;d.Ia=b;d.D=function(){return!1};d.name=c;d.isPrimitive=!0;d.isInstance=function(){return!1};return d}function v(a,b,c,d,e,h,k){var p=new Ia,t=ia(a);h=h||function(u){return!!(u&&u.$classData&&u.$classData.G[t])};k=k||function(u,G){return!!(u&&u.$classData&&u.$classData.ta===G&&u.$classData.ra.G[t])};p.Sa=e;p.G=c;p.Ia="L"+b+";";p.D=k;p.name=b;p.isInterface=!1;p.isRawJSType=!!d;p.isInstance=h;return p}
function Ka(a){function b(p){if("number"===typeof p){this.a=Array(p);for(var t=0;t<p;t++)this.a[t]=e}else this.a=p}var c=new Ia,d=a.qb,e="longZero"==d?r().oa:d;b.prototype=new w;b.prototype.constructor=b;b.prototype.tb=function(){return this.a instanceof Array?new b(this.a.slice(0)):new b(new this.a.constructor(this.a))};b.prototype.$classData=c;d="["+a.Ia;var h=a.ra||a,k=a.ta+1;c.db=b;c.Sa=La;c.G={c:1,Hb:1,d:1};c.va=a;c.ra=h;c.ta=k;c.qb=null;c.Ia=d;c.Ga=void 0;c.Fa=void 0;c.D=void 0;c.name=d;c.isPrimitive=
!1;c.isInterface=!1;c.isArrayClass=!0;c.isInstance=function(p){return h.D(p,k)};return c}function n(a){if(!a.Ga){var b=new Ma;b.Ma=a;a.Ga=b}return a.Ga}function Na(a){a.Fa||(a.Fa=Ka(a));return a.Fa}Ia.prototype.getFakeInstance=function(){if(this===oa)return"some string";if(this===wa)return!1;if(this===qa||this===sa||this===ta||this===ua||this===va)return 0;if(this===ya)return r().oa;if(this!==xa)return{$classData:this}};Ia.prototype.getSuperclass=function(){return this.Sa?n(this.Sa):null};
Ia.prototype.getComponentType=function(){return this.va?n(this.va):null};Ia.prototype.newArrayOfThisClass=function(a){for(var b=this,c=0;c<a.length;c++)b=Na(b);return ka(b,a)};var Oa=Ja(!1,"Z","boolean"),Pa=Ja(0,"C","char"),Qa=Ja(0,"B","byte"),Ra=Ja(0,"S","short"),Sa=Ja(0,"I","int"),Ta=Ja("longZero","J","long"),Ua=Ja(0,"F","float"),Va=Ja(0,"D","double");Oa.D=ha(Oa);Pa.D=ha(Pa);Qa.D=ha(Qa);Ra.D=ha(Ra);Sa.D=ha(Sa);Ta.D=ha(Ta);Ua.D=ha(Ua);Va.D=ha(Va);function Wa(){}function w(){}w.prototype=Wa.prototype;Wa.prototype.b=function(){return this};Wa.prototype.B=function(a){return this===a};Wa.prototype.i=function(){var a=Xa(na(this)),b=(+(this.u()>>>0)).toString(16);return a+"@"+b};Wa.prototype.u=function(){return Fa(this)};Wa.prototype.toString=function(){return this.i()};var La=v({c:0},"java.lang.Object",{c:1},void 0,void 0,function(a){return null!==a},function(a,b){if(a=a&&a.$classData){var c=a.ta||0;return!(c<b)&&(c>b||!a.ra.isPrimitive)}return!1});
Wa.prototype.$classData=La;function Ya(){this.Ya=null;this.k=!1}Ya.prototype=new w;Ya.prototype.constructor=Ya;Ya.prototype.b=function(){return this};function Za(a){if(!a.k){var b=function(){return function(d){return void 0===d?x():(new y).C(d)}}(a),c=$a();c.h()?c=x():(c=c.T(),c=b(c));c.h()?c=x():(c=c.T(),c=(new y).C(c.lang));c.h()?c=x():(c=c.T(),c=b(c));c.h()?c=x():(c=c.T(),c=(new y).C(c.StrictMath));c.h()?b=x():(c=c.T(),b=b(c));a.Ya=b.h()?l.StrictMath:b.T();a.k=!0}return a.Ya}
Ya.prototype.$classData=v({qc:0},"org.nlogo.tortoise.engine.MersenneMath$",{qc:1,c:1});var ab=void 0;function bb(){ab||(ab=(new Ya).b());return ab}function Ma(){this.Ma=null}Ma.prototype=new w;Ma.prototype.constructor=Ma;function Xa(a){return a.Ma.name}Ma.prototype.i=function(){return(this.Ma.isInterface?"interface ":this.Ma.isPrimitive?"":"class ")+Xa(this)};Ma.prototype.$classData=v({Ec:0},"java.lang.Class",{Ec:1,c:1});function cb(){this.yb=null}cb.prototype=new w;cb.prototype.constructor=cb;
cb.prototype.b=function(){db=this;(new eb).b();(new eb).b();this.yb=l.performance?l.performance.now?function(){fb();return+l.performance.now()}:l.performance.webkitNow?function(){fb();return+l.performance.webkitNow()}:function(){fb();return+(new l.Date).getTime()}:function(){fb();return+(new l.Date).getTime()};return this};cb.prototype.$classData=v({Uc:0},"java.lang.System$",{Uc:1,c:1});var db=void 0;function fb(){db||(db=(new cb).b());return db}function gb(){}gb.prototype=new w;
gb.prototype.constructor=gb;gb.prototype.b=function(){return this};gb.prototype.$classData=v({Wc:0},"java.util.Arrays$",{Wc:1,c:1});var hb=void 0;function ib(){}ib.prototype=new w;ib.prototype.constructor=ib;function jb(){}jb.prototype=ib.prototype;function kb(){}kb.prototype=new w;kb.prototype.constructor=kb;kb.prototype.b=function(){return this};kb.prototype.$classData=v({sd:0},"scala.math.Ordered$",{sd:1,c:1});var lb=void 0;function mb(){this.k=0}mb.prototype=new w;mb.prototype.constructor=mb;
mb.prototype.b=function(){nb=this;(new ob).b();pb||(pb=(new qb).b());rb||(rb=(new sb).b());tb||(tb=(new ub).b());vb();wb();xb||(xb=(new yb).b());zb();Ab||(Ab=(new Bb).b());Cb||(Cb=(new Db).b());Eb||(Eb=(new Fb).b());Gb();Hb||(Hb=(new Ib).b());Jb||(Jb=(new Kb).b());Lb||(Lb=(new Mb).b());Nb||(Nb=(new Ob).b());Pb||(Pb=(new Qb).b());Rb||(Rb=(new Sb).b());Tb||(Tb=(new Ub).b());Vb||(Vb=(new Wb).b());lb||(lb=(new kb).b());Xb||(Xb=(new Yb).b());$b||($b=(new ac).b());bc||(bc=(new cc).b());dc||(dc=(new ec).b());
return this};mb.prototype.$classData=v({ud:0},"scala.package$",{ud:1,c:1});var nb=void 0;function fc(){}fc.prototype=new w;fc.prototype.constructor=fc;fc.prototype.b=function(){gc=this;hc||(hc=(new ic).b());jc||(jc=(new kc).b());lc||(lc=(new mc).b());nc||(nc=(new oc).b());pc||(pc=(new qc).b());rc||(rc=(new sc).b());tc||(tc=(new uc).b());vc||(vc=(new wc).b());xc||(xc=(new yc).b());zc||(zc=(new Ac).b());Bc||(Bc=(new Cc).b());Dc||(Dc=(new Ec).b());Fc||(Fc=(new Gc).b());Hc||(Hc=(new Jc).b());return this};
fc.prototype.$classData=v({wd:0},"scala.reflect.ClassManifestFactory$",{wd:1,c:1});var gc=void 0;function Kc(){}Kc.prototype=new w;Kc.prototype.constructor=Kc;Kc.prototype.b=function(){return this};Kc.prototype.$classData=v({xd:0},"scala.reflect.ManifestFactory$",{xd:1,c:1});var Lc=void 0;function Mc(){}Mc.prototype=new w;Mc.prototype.constructor=Mc;Mc.prototype.b=function(){Nc=this;gc||(gc=(new fc).b());Lc||(Lc=(new Kc).b());return this};
Mc.prototype.$classData=v({Nd:0},"scala.reflect.package$",{Nd:1,c:1});var Nc=void 0;function Oc(){}Oc.prototype=new w;Oc.prototype.constructor=Oc;Oc.prototype.b=function(){(new Pc).b();return this};Oc.prototype.$classData=v({Sd:0},"scala.util.control.Breaks",{Sd:1,c:1});function Qc(){}Qc.prototype=new w;Qc.prototype.constructor=Qc;function Rc(){}Rc.prototype=Qc.prototype;function Sc(a,b){b=m(-862048943,b);b=m(461845907,b<<15|b>>>17|0);return a^b}
function Tc(a,b,c){if(null===b)throw(new z).b();if(b.N)a=b.O;else{var d=new Uc;if(null===a)throw A(null);d.ea=a;d.Q=0;d.Oa=c;a=Vc(b,d)}return a}function Wc(a,b){a=Sc(a,b);return-430675100+m(5,a<<13|a>>>19|0)|0}function Xc(a){a=m(-2048144789,a^(a>>>16|0));a=m(-1028477387,a^(a>>>13|0));return a^(a>>>16|0)}function Yc(a){Zc();var b=a.Z();if(0===b)return a=a.aa(),Ba(Ca(),a);for(var c=-889275714,d=0;d<b;)c=Wc(c,$c(ad(),a.$(d))),d=1+d|0;return Xc(c^b)}
function bd(a){if(a.N)a=a.O;else{if(null===a)throw(new z).b();if(a.N)a=a.O;else{var b=new cd;b.Ha=0;b.Ja=0;b.Q=0;b.La=1;a=Vc(a,b)}}return a}function Fb(){}Fb.prototype=new w;Fb.prototype.constructor=Fb;Fb.prototype.b=function(){return this};Fb.prototype.$classData=v({Xd:0},"scala.collection.$colon$plus$",{Xd:1,c:1});var Eb=void 0;function Db(){}Db.prototype=new w;Db.prototype.constructor=Db;Db.prototype.b=function(){return this};
Db.prototype.$classData=v({Yd:0},"scala.collection.$plus$colon$",{Yd:1,c:1});var Cb=void 0;function dd(){this.eb=null}dd.prototype=new w;dd.prototype.constructor=dd;dd.prototype.b=function(){ed=this;this.eb=(new fd).b();return this};dd.prototype.$classData=v({le:0},"scala.collection.Iterator$",{le:1,c:1});var ed=void 0;function wb(){ed||(ed=(new dd).b());return ed}function gd(a,b,c){var d=(new B).b(),e=(new C).b();hd(d,b);a.W(e.N?e.O:id(e,d,c));hd(d,")");return d.F.p}
function id(a,b,c){if(null===a)throw(new z).b();if(a.N)a=a.O;else{var d=new jd;d.Ka=b;d.jc=c;d.gb=!0;a=Vc(a,d)}return a}function kd(){}kd.prototype=new w;kd.prototype.constructor=kd;function ld(){}ld.prototype=kd.prototype;function md(){}md.prototype=new w;md.prototype.constructor=md;function nd(){}nd.prototype=md.prototype;function Ib(){}Ib.prototype=new w;Ib.prototype.constructor=Ib;Ib.prototype.b=function(){return this};
Ib.prototype.$classData=v({He:0},"scala.collection.immutable.Stream$$hash$colon$colon$",{He:1,c:1});var Hb=void 0;function od(){}od.prototype=new w;od.prototype.constructor=od;od.prototype.b=function(){return this};od.prototype.$classData=v({Le:0},"scala.collection.immutable.StringOps$",{Le:1,c:1});var pd=void 0;function qd(){this.ba=!1;this.xb=this.Qa=this.sa=null;this.ab=!1;this.Jb=this.zb=0}qd.prototype=new w;qd.prototype.constructor=qd;
qd.prototype.b=function(){rd=this;this.sa=(this.ba=!!(l.ArrayBuffer&&l.Int32Array&&l.Float32Array&&l.Float64Array))?new l.ArrayBuffer(8):null;this.Qa=this.ba?new l.Int32Array(this.sa,0,2):null;this.ba&&new l.Float32Array(this.sa,0,2);this.xb=this.ba?new l.Float64Array(this.sa,0,1):null;if(this.ba)this.Qa[0]=16909060,a=1===((new l.Int8Array(this.sa,0,8))[0]|0);else var a=!0;this.zb=(this.ab=a)?0:1;this.Jb=this.ab?1:0;return this};
function Da(a,b){var c=b|0;if(c===b&&-Infinity!==1/b)return c;if(a.ba)a.xb[0]=b,a=(new q).P(a.Qa[a.Jb]|0,a.Qa[a.zb]|0);else{if(b!==b)a=!1,b=2047,c=+l.Math.pow(2,51);else if(Infinity===b||-Infinity===b)a=0>b,b=2047,c=0;else if(0===b)a=-Infinity===1/b,c=b=0;else{var d=(a=0>b)?-b:b;if(d>=+l.Math.pow(2,-1022)){b=+l.Math.pow(2,52);c=+l.Math.log(d)/.6931471805599453;c=+l.Math.floor(c)|0;c=1023>c?c:1023;var e=+l.Math.pow(2,c);e>d&&(c=-1+c|0,e/=2);e=d/e*b;d=+l.Math.floor(e);e-=d;d=.5>e?d:.5<e?1+d:0!==d%2?
1+d:d;2<=d/b&&(c=1+c|0,d=1);1023<c?(c=2047,d=0):(c=1023+c|0,d-=b);b=c;c=d}else b=d/+l.Math.pow(2,-1074),c=+l.Math.floor(b),d=b-c,b=0,c=.5>d?c:.5<d?1+c:0!==c%2?1+c:c}c=+c;a=(new q).P(c|0,(a?-2147483648:0)|(b|0)<<20|c/4294967296|0)}return a.q^a.r}qd.prototype.$classData=v({Re:0},"scala.scalajs.runtime.Bits$",{Re:1,c:1});var rd=void 0;function Ea(){rd||(rd=(new qd).b());return rd}function sd(){this.k=!1}sd.prototype=new w;sd.prototype.constructor=sd;sd.prototype.b=function(){return this};
function Ba(a,b){a=0;for(var c=1,d=-1+(b.length|0)|0;0<=d;)a=a+m(65535&(b.charCodeAt(d)|0),c)|0,c=m(31,c),d=-1+d|0;return a}sd.prototype.$classData=v({Ue:0},"scala.scalajs.runtime.RuntimeString$",{Ue:1,c:1});var td=void 0;function Ca(){td||(td=(new sd).b());return td}function ud(){}ud.prototype=new w;ud.prototype.constructor=ud;ud.prototype.b=function(){return this};function A(a){vd();return a instanceof wd?a.S:a}function xd(a,b){return b instanceof D?b:(new wd).C(b)}
ud.prototype.$classData=v({Ve:0},"scala.scalajs.runtime.package$",{Ve:1,c:1});var yd=void 0;function vd(){yd||(yd=(new ud).b());return yd}function zd(){}zd.prototype=new w;zd.prototype.constructor=zd;zd.prototype.b=function(){return this};function Ad(a,b){if(b instanceof E)return a.M===b.M;if(Bd(b)){if("number"===typeof b)return+b===a.M;if(b instanceof q){b=Ha(b);var c=b.r;a=a.M;return b.q===a&&c===a>>31}return null===b?null===a:za(b,a)}return null===a&&null===b}
function Cd(a,b,c){if(b===c)c=!0;else if(Bd(b))a:if(Bd(c))c=Dd(b,c);else{if(c instanceof E){if("number"===typeof b){c=+b===c.M;break a}if(b instanceof q){a=Ha(b);b=a.r;c=c.M;c=a.q===c&&b===c>>31;break a}}c=null===b?null===c:za(b,c)}else c=b instanceof E?Ad(b,c):null===b?null===c:za(b,c);return c}
function Dd(a,b){if("number"===typeof a){a=+a;if("number"===typeof b)return a===+b;if(b instanceof q){var c=Ha(b);b=c.q;c=c.r;return a===Ed(r(),b,c)}return!1}if(a instanceof q){c=Ha(a);a=c.q;c=c.r;if(b instanceof q){b=Ha(b);var d=b.r;return a===b.q&&c===d}return"number"===typeof b?(b=+b,Ed(r(),a,c)===b):!1}return null===a?null===b:za(a,b)}zd.prototype.$classData=v({Xe:0},"scala.runtime.BoxesRunTime$",{Xe:1,c:1});var Fd=void 0;function Gd(){Fd||(Fd=(new zd).b());return Fd}
var Hd=v({$e:0},"scala.runtime.Null$",{$e:1,c:1});function Id(){}Id.prototype=new w;Id.prototype.constructor=Id;Id.prototype.b=function(){return this};Id.prototype.$classData=v({af:0},"scala.runtime.ScalaRunTime$",{af:1,c:1});var Jd=void 0;function Kd(){}Kd.prototype=new w;Kd.prototype.constructor=Kd;Kd.prototype.b=function(){return this};
function $c(a,b){if(null===b)return 0;if("number"===typeof b){a=+b;b=Ga(a);if(b===a)a=b;else{var c=r();b=Ld(c,a);c=c.n;a=Ed(r(),b,c)===a?b^c:Da(Ea(),a)}return a}return b instanceof q?(a=Ha(b),b=(new q).P(a.q,a.r),a=b.q,b=b.r,b===a>>31?a:a^b):Aa(b)}Kd.prototype.$classData=v({cf:0},"scala.runtime.Statics$",{cf:1,c:1});var Md=void 0;function ad(){Md||(Md=(new Kd).b());return Md}function Nd(){}Nd.prototype=new w;Nd.prototype.constructor=Nd;function Od(){}Od.prototype=Nd.prototype;
function Bd(a){return a instanceof Nd||"number"===typeof a}function D(){this.m=null}D.prototype=new w;D.prototype.constructor=D;function Pd(){}Pd.prototype=D.prototype;D.prototype.Na=function(){if(void 0===l.Error.captureStackTrace){try{var a={}.undef()}catch(b){if(a=xd(vd(),b),null!==a)if(a instanceof wd)a=a.S;else throw A(a);else throw b;}this.stackdata=a}else l.Error.captureStackTrace(this),this.stackdata=this;return this};D.prototype.hb=function(){return this.m};
D.prototype.i=function(){var a=Xa(na(this)),b=this.hb();return null===b?a:a+": "+b};D.prototype.s=function(a){this.m=a;this.Na()};function Qd(){}Qd.prototype=new w;Qd.prototype.constructor=Qd;function Rd(){}Rd.prototype=Qd.prototype;Qd.prototype.Pa=function(a){Sd(this,a);return this};function Td(){this.Cb=this.Vb=null;this.Wb=this.Xb=0;this.Y=this.Db=this.kb=null;this.cb=!1}Td.prototype=new w;Td.prototype.constructor=Td;
function Ud(a){if(a.cb){a.Y=a.kb.exec(a.Db);if(null!==a.Y){var b=a.Y[0];if(void 0===b)throw(new F).e("undefined.get");if(null===b)throw(new z).b();""===b&&(b=a.kb,b.lastIndex=1+(b.lastIndex|0)|0)}else a.cb=!1;return null!==a.Y}return!1}function Vd(a){if(null===a.Y)throw(new Wd).e("No match available");return a.Y}function Xd(a){var b=Vd(a).index|0;a=Vd(a)[0];if(void 0===a)throw(new F).e("undefined.get");return b+(a.length|0)|0}Td.prototype.$classData=v({Zc:0},"java.util.regex.Matcher",{Zc:1,c:1,jf:1});
function Yd(){}Yd.prototype=new w;Yd.prototype.constructor=Yd;Yd.prototype.b=function(){return this};Yd.prototype.$classData=v({id:0},"scala.Predef$$anon$1",{id:1,c:1,Aa:1});function ob(){}ob.prototype=new w;ob.prototype.constructor=ob;ob.prototype.b=function(){return this};ob.prototype.i=function(){return"object AnyRef"};ob.prototype.$classData=v({vd:0},"scala.package$$anon$1",{vd:1,c:1,rf:1});function Zd(){this.Kb=this.ob=0}Zd.prototype=new Rc;Zd.prototype.constructor=Zd;
Zd.prototype.b=function(){$d=this;this.ob=Ba(Ca(),"Seq");this.Kb=Ba(Ca(),"Map");Ba(Ca(),"Set");var a=zb(),b=this.Kb;if(a.h()){var c=Wc(b,0);c=Wc(c,0);c=Sc(c,1);Xc(c^0)}else c=(new C).b(),a.W(bd(c)),a=Wc(b,bd(c).Ha),a=Wc(a,bd(c).Ja),a=Sc(a,bd(c).La),c=bd(c).Q,Xc(a^c);return this};
function ae(a){var b=Zc();if(a instanceof be){for(b=b.ob;!a.h();)ce();a=Xc(b^0)}else{var c=b.ob;if(a.h())a=Xc(c^0);else{var d=(new C).b();a.W(d.N?d.O:Tc(b,d,c));a=(d.N?d.O:Tc(b,d,c)).Oa;b=(d.N?d.O:Tc(b,d,c)).Q;a=Xc(a^b)}}return a}Zd.prototype.$classData=v({Ud:0},"scala.util.hashing.MurmurHash3$",{Ud:1,wf:1,c:1});var $d=void 0;function Zc(){$d||($d=(new Zd).b());return $d}function cd(){this.La=this.Q=this.Ja=this.Ha=0}cd.prototype=new w;cd.prototype.constructor=cd;cd.prototype.H=function(a){this.qa(a)};
cd.prototype.i=function(){return"\x3cfunction1\x3e"};cd.prototype.qa=function(a){a=$c(ad(),a);this.Ha=this.Ha+a|0;this.Ja^=a;0!==a&&(this.La=m(this.La,a));this.Q=1+this.Q|0};cd.prototype.$classData=v({Vd:0},"scala.util.hashing.MurmurHash3$hasher$1$",{Vd:1,c:1,V:1});function Uc(){this.Oa=this.Q=0;this.ea=null}Uc.prototype=new w;Uc.prototype.constructor=Uc;Uc.prototype.H=function(a){this.qa(a)};Uc.prototype.i=function(){return"\x3cfunction1\x3e"};
Uc.prototype.qa=function(a){this.Oa=Wc(this.Oa,$c(ad(),a));this.Q=1+this.Q|0};Uc.prototype.$classData=v({Wd:0},"scala.util.hashing.MurmurHash3$hasher$3$",{Wd:1,c:1,V:1});function jd(){this.gb=!1;this.jc=this.Ka=null}jd.prototype=new w;jd.prototype.constructor=jd;jd.prototype.H=function(a){this.qa(a)};jd.prototype.i=function(){return"\x3cfunction1\x3e"};jd.prototype.qa=function(a){if(this.gb){var b=this.Ka.F;b.p+=""+a;this.gb=!1}else hd(this.Ka,this.jc),b=this.Ka.F,b.p+=""+a};
jd.prototype.$classData=v({te:0},"scala.collection.TraversableOnce$appender$1$",{te:1,c:1,V:1});v({ue:0},"scala.collection.generic.GenMapFactory$MapCanBuildFrom",{ue:1,c:1,Aa:1});function de(){}de.prototype=new nd;de.prototype.constructor=de;function ee(){}ee.prototype=de.prototype;v({ve:0},"scala.collection.generic.GenSetFactory$$anon$1",{ve:1,c:1,Aa:1});function H(){}H.prototype=new nd;H.prototype.constructor=H;function fe(){}fe.prototype=H.prototype;H.prototype.b=function(){(new ge).wa(this);return this};
function he(){this.ea=null}he.prototype=new w;he.prototype.constructor=he;function ie(){}ie.prototype=he.prototype;he.prototype.wa=function(a){if(null===a)throw A(null);this.ea=a};function je(){}je.prototype=new ld;je.prototype.constructor=je;function ke(){}ke.prototype=je.prototype;function le(){}le.prototype=new w;le.prototype.constructor=le;le.prototype.b=function(){return this};le.prototype.H=function(){};le.prototype.i=function(){return"\x3cfunction1\x3e"};
le.prototype.$classData=v({Be:0},"scala.collection.immutable.List$$anon$1",{Be:1,c:1,V:1});var xa=v({We:0},"scala.runtime.BoxedUnit",{We:1,c:1,d:1},void 0,void 0,function(a){return void 0===a});function me(){this.Tb=this.Sb=this.Ob=this.Ub=this.Qb=this.Pb=this.Rb=0;this.Nb=null;this.j=0}me.prototype=new w;me.prototype.constructor=me;
me.prototype.b=function(){ne=this;this.Rb=624;this.j=(1|this.j)<<24>>24;this.Pb=397;this.j=(2|this.j)<<24>>24;this.Qb=-1727483681;this.j=(4|this.j)<<24>>24;this.Ub=-2147483648;this.j=(8|this.j)<<24>>24;this.Ob=2147483647;this.j=(16|this.j)<<24>>24;this.Sb=-1658038656;this.j=(32|this.j)<<24>>24;this.Tb=-272236544;this.j=(64|this.j)<<24>>24;this.Nb="0";this.j=(128|this.j)<<24>>24;return this};
function I(){var a=oe();if(0===(16&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 146");return a.Ob}function L(){var a=oe();if(0===(2&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 143");return a.Pb}
function M(){var a=oe();if(0===(32&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 147");return a.Sb}function N(){var a=oe();if(0===(8&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 145");return a.Ub}
function O(){var a=oe();if(0===(1&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 142");return a.Rb}function P(){var a=oe();if(0===(64&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 148");return a.Tb}
function pe(){var a=oe();if(0===(128&a.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 149");return a.Nb}me.prototype.$classData=v({sc:0},"org.nlogo.tortoise.engine.MersenneTwisterFast$",{sc:1,c:1,f:1,d:1});var ne=void 0;function oe(){ne||(ne=(new me).b());return ne}var wa=v({Ac:0},"java.lang.Boolean",{Ac:1,c:1,d:1,J:1},void 0,void 0,function(a){return"boolean"===typeof a});function E(){this.M=0}E.prototype=new w;
E.prototype.constructor=E;E.prototype.B=function(a){return a instanceof E?this.M===a.M:!1};E.prototype.i=function(){return l.String.fromCharCode(this.M)};function qe(a){var b=new E;b.M=a;return b}E.prototype.u=function(){return this.M};E.prototype.$classData=v({Cc:0},"java.lang.Character",{Cc:1,c:1,d:1,J:1});function re(){this.Lb=null;this.k=0}re.prototype=new w;re.prototype.constructor=re;re.prototype.b=function(){return this};
function se(a){0===(16&a.k)<<24>>24&&0===(16&a.k)<<24>>24&&(a.Lb=ja(Na(Sa),[1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43600,44016,65296,66720,69734,69872,69942,70096,71360,120782,120792,120802,120812,120822]),a.k=(16|a.k)<<24>>24);return a.Lb}re.prototype.$classData=v({Dc:0},"java.lang.Character$",{Dc:1,c:1,f:1,d:1});var te=void 0;function ue(){this.vb=this.wb=null;this.k=0}
ue.prototype=new w;ue.prototype.constructor=ue;ue.prototype.b=function(){return this};ue.prototype.ha=function(a){throw(new ve).e('For input string: "'+a+'"');};ue.prototype.$classData=v({Gc:0},"java.lang.Double$",{Gc:1,c:1,f:1,d:1});var we=void 0;function xe(){this.m=null}xe.prototype=new Pd;xe.prototype.constructor=xe;function ye(){}ye.prototype=xe.prototype;function ze(){this.m=null}ze.prototype=new Pd;ze.prototype.constructor=ze;function Ae(){}Ae.prototype=ze.prototype;function Be(){}
Be.prototype=new w;Be.prototype.constructor=Be;Be.prototype.b=function(){return this};Be.prototype.ha=function(a){throw(new ve).e('For input string: "'+a+'"');};
function Ce(a,b){var c=null===b?0:b.length|0;0===c&&a.ha(b);var d=65535&(b.charCodeAt(0)|0),e=45===d,h=e?2147483648:2147483647;d=e||43===d?1:0;d>=(b.length|0)&&a.ha(b);for(var k=0;d!==c;){te||(te=(new re).b());var p=te;var t=65535&(b.charCodeAt(d)|0);if(256>t)p=48<=t&&57>=t?-48+t|0:65<=t&&90>=t?-55+t|0:97<=t&&122>=t?-87+t|0:-1;else if(65313<=t&&65338>=t)p=-65303+t|0;else if(65345<=t&&65370>=t)p=-65335+t|0;else{hb||(hb=(new gb).b());a:{var u=se(p);var G=t,J=0,ba=u.a.length;for(;;){if(J===ba){u=-1-
J|0;break a}var Zb=(J+ba|0)>>>1|0,Ic=u.a[Zb];if(G<Ic)ba=Zb;else{if(Cd(Gd(),G,Ic)){u=Zb;break a}J=1+Zb|0}}}u=0>u?-2-u|0:u;0>u?p=-1:(p=t-se(p).a[u]|0,p=9<p?-1:p)}p=10>p?p:-1;k=10*k+p;(-1===p||k>h)&&a.ha(b);d=1+d|0}return e?-k|0:k|0}Be.prototype.$classData=v({Lc:0},"java.lang.Integer$",{Lc:1,c:1,f:1,d:1});var De=void 0;function Ee(){De||(De=(new Be).b());return De}function Fe(){}Fe.prototype=new w;Fe.prototype.constructor=Fe;Fe.prototype.b=function(){return this};
function Ge(){He||(He=(new Fe).b());var a=Ie(),b=Ie();return(new q).P(b,a)}function Ie(){var a=4294967296*+l.Math.random();return Ga(-2147483648+ +l.Math.floor(a))}Fe.prototype.$classData=v({Yc:0},"java.util.Random$",{Yc:1,c:1,f:1,d:1});var He=void 0;function Je(){this.sb=this.X=null;this.k=0}Je.prototype=new w;Je.prototype.constructor=Je;Je.prototype.i=function(){return this.sb};Je.prototype.$classData=v({$c:0},"java.util.regex.Pattern",{$c:1,c:1,f:1,d:1});function Ke(){this.Eb=this.Fb=null}
Ke.prototype=new w;Ke.prototype.constructor=Ke;Ke.prototype.b=function(){Le=this;this.Fb=new l.RegExp("^\\\\Q(.|\\n|\\r)\\\\E$");this.Eb=new l.RegExp("^\\(\\?([idmsuxU]*)(?:-([idmsuxU]*))?\\)");return this};function Me(a){for(var b="",c=0;c<(a.length|0);){var d=65535&(a.charCodeAt(c)|0);switch(d){case 92:case 46:case 40:case 41:case 91:case 93:case 123:case 125:case 124:case 63:case 42:case 43:case 94:case 36:d="\\"+qe(d);break;default:d=qe(d)}b=""+b+d;c=1+c|0}return b}
function Ne(a,b){switch(b){case 105:return 2;case 100:return 1;case 109:return 8;case 115:return 32;case 117:return 64;case 120:return 4;case 85:return 256;default:throw(new Q).e("bad in-pattern flag");}}Ke.prototype.$classData=v({ad:0},"java.util.regex.Pattern$",{ad:1,c:1,f:1,d:1});var Le=void 0;function Oe(){Le||(Le=(new Ke).b());return Le}function Pe(){}Pe.prototype=new w;Pe.prototype.constructor=Pe;Pe.prototype.b=function(){return this};
function $a(){Qe||(Qe=(new Pe).b());var a=l.java;return null===a?x():(new y).C(a)}Pe.prototype.$classData=v({fd:0},"scala.Option$",{fd:1,c:1,f:1,d:1});var Qe=void 0;function Re(){}Re.prototype=new jb;Re.prototype.constructor=Re;Re.prototype.b=function(){Se=this;nb||(nb=(new mb).b());xb||(xb=(new yb).b());Te||(Te=(new Ue).b());Ve||(Ve=(new We).b());Nc||(Nc=(new Mc).b());Nc||(Nc=(new Mc).b());Xe||(Xe=(new Ye).b());(new Yd).b();(new Ze).b();(new $e).b();return this};
Re.prototype.$classData=v({hd:0},"scala.Predef$",{hd:1,mf:1,c:1,kf:1});var Se=void 0;function Sb(){}Sb.prototype=new w;Sb.prototype.constructor=Sb;Sb.prototype.b=function(){return this};Sb.prototype.$classData=v({od:0},"scala.math.Fractional$",{od:1,c:1,f:1,d:1});var Rb=void 0;function Ub(){}Ub.prototype=new w;Ub.prototype.constructor=Ub;Ub.prototype.b=function(){return this};Ub.prototype.$classData=v({pd:0},"scala.math.Integral$",{pd:1,c:1,f:1,d:1});var Tb=void 0;function Wb(){}Wb.prototype=new w;
Wb.prototype.constructor=Wb;Wb.prototype.b=function(){return this};Wb.prototype.$classData=v({qd:0},"scala.math.Numeric$",{qd:1,c:1,f:1,d:1});var Vb=void 0;function ac(){}ac.prototype=new w;ac.prototype.constructor=ac;ac.prototype.b=function(){return this};ac.prototype.$classData=v({Od:0},"scala.util.Either$",{Od:1,c:1,f:1,d:1});var $b=void 0;function cc(){}cc.prototype=new w;cc.prototype.constructor=cc;cc.prototype.b=function(){return this};cc.prototype.i=function(){return"Left"};
cc.prototype.$classData=v({Pd:0},"scala.util.Left$",{Pd:1,c:1,f:1,d:1});var bc=void 0;function ec(){}ec.prototype=new w;ec.prototype.constructor=ec;ec.prototype.b=function(){return this};ec.prototype.i=function(){return"Right"};ec.prototype.$classData=v({Qd:0},"scala.util.Right$",{Qd:1,c:1,f:1,d:1});var dc=void 0;function af(){this.rb=!1}af.prototype=new w;af.prototype.constructor=af;af.prototype.b=function(){this.rb=!1;return this};
af.prototype.$classData=v({Td:0},"scala.util.control.NoStackTrace$",{Td:1,c:1,f:1,d:1});var bf=void 0;function cf(){this.ea=null}cf.prototype=new ie;cf.prototype.constructor=cf;cf.prototype.b=function(){he.prototype.wa.call(this,vb());return this};cf.prototype.$classData=v({fe:0},"scala.collection.IndexedSeq$$anon$1",{fe:1,gc:1,c:1,Aa:1});function df(){}df.prototype=new fe;df.prototype.constructor=df;function ef(){}ef.prototype=df.prototype;function ge(){this.Ca=this.ea=null}ge.prototype=new ie;
ge.prototype.constructor=ge;ge.prototype.wa=function(a){if(null===a)throw A(null);this.Ca=a;he.prototype.wa.call(this,a)};ge.prototype.$classData=v({we:0},"scala.collection.generic.GenTraversableFactory$$anon$1",{we:1,gc:1,c:1,Aa:1});function ff(){}ff.prototype=new ke;ff.prototype.constructor=ff;function gf(){}gf.prototype=ff.prototype;function Bb(){}Bb.prototype=new w;Bb.prototype.constructor=Bb;Bb.prototype.b=function(){return this};Bb.prototype.i=function(){return"::"};
Bb.prototype.$classData=v({ze:0},"scala.collection.immutable.$colon$colon$",{ze:1,c:1,f:1,d:1});var Ab=void 0;function Ob(){}Ob.prototype=new w;Ob.prototype.constructor=Ob;Ob.prototype.b=function(){return this};Ob.prototype.$classData=v({Ee:0},"scala.collection.immutable.Range$",{Ee:1,c:1,f:1,d:1});var Nb=void 0;function hf(){this.ea=null}hf.prototype=new ie;hf.prototype.constructor=hf;hf.prototype.b=function(){he.prototype.wa.call(this,Gb());return this};
hf.prototype.$classData=v({Ie:0},"scala.collection.immutable.Stream$StreamCanBuildFrom",{Ie:1,gc:1,c:1,Aa:1});function Mb(){}Mb.prototype=new w;Mb.prototype.constructor=Mb;Mb.prototype.b=function(){return this};Mb.prototype.$classData=v({Oe:0},"scala.collection.mutable.StringBuilder$",{Oe:1,c:1,f:1,d:1});var Lb=void 0;function jf(){this.n=0;this.oa=null}jf.prototype=new w;jf.prototype.constructor=jf;jf.prototype.b=function(){kf=this;this.oa=(new q).P(0,0);return this};
function lf(a,b,c){return 0===(-2097152&c)?""+(4294967296*c+ +(b>>>0)):mf(a,b,c,1E9,0,2)}function Ed(a,b,c){return 0>c?-(4294967296*+((0!==b?~c:-c|0)>>>0)+ +((-b|0)>>>0)):4294967296*c+ +(b>>>0)}function Ld(a,b){if(-9223372036854775808>b)return a.n=-2147483648,0;if(0x7fffffffffffffff<=b)return a.n=2147483647,-1;var c=b|0,d=b/4294967296|0;a.n=0>b&&0!==c?-1+d|0:d;return c}
function mf(a,b,c,d,e,h){var k=(0!==e?da(e):32+da(d)|0)-(0!==c?da(c):32+da(b)|0)|0,p=k,t=0===(32&p)?d<<p:0,u=0===(32&p)?(d>>>1|0)>>>(31-p|0)|0|e<<p:d<<p;p=b;var G=c;for(b=c=0;0<=k&&0!==(-2097152&G);){var J=p,ba=G,Zb=t,Ic=u;if(ba===Ic?(-2147483648^J)>=(-2147483648^Zb):(-2147483648^ba)>=(-2147483648^Ic))J=G,ba=u,G=p-t|0,J=(-2147483648^G)>(-2147483648^p)?-1+(J-ba|0)|0:J-ba|0,p=G,G=J,32>k?c|=1<<k:b|=1<<k;k=-1+k|0;J=u>>>1|0;t=t>>>1|0|u<<31;u=J}k=G;if(k===e?(-2147483648^p)>=(-2147483648^d):(-2147483648^
k)>=(-2147483648^e))k=4294967296*G+ +(p>>>0),d=4294967296*e+ +(d>>>0),1!==h&&(u=k/d,e=u/4294967296|0,t=c,c=u=t+(u|0)|0,b=(-2147483648^u)<(-2147483648^t)?1+(b+e|0)|0:b+e|0),0!==h&&(d=k%d,p=d|0,G=d/4294967296|0);if(0===h)return a.n=b,c;if(1===h)return a.n=G,p;a=""+p;return""+(4294967296*b+ +(c>>>0))+"000000000".substring(a.length|0)+a}
function nf(a,b,c,d,e){if(0===(d|e))throw(new of).e("/ by zero");if(c===b>>31){if(e===d>>31){if(-1!==d){var h=b%d|0;a.n=h>>31;return h}return a.n=0}if(-2147483648===b&&-2147483648===d&&0===e)return a.n=0;a.n=c;return b}if(h=0>c){var k=-b|0;c=0!==b?~c:-c|0}else k=b;0>e?(b=-d|0,d=0!==d?~e:-e|0):(b=d,d=e);e=c;0===(-2097152&e)?0===(-2097152&d)?(k=(4294967296*e+ +(k>>>0))%(4294967296*d+ +(b>>>0)),a.n=k/4294967296|0,k|=0):a.n=e:0===d&&0===(b&(-1+b|0))?(a.n=0,k&=-1+b|0):0===b&&0===(d&(-1+d|0))?a.n=e&(-1+
d|0):k=mf(a,k,e,b,d,1)|0;return h?(h=a.n,a.n=0!==k?~h:-h|0,-k|0):k}jf.prototype.$classData=v({Te:0},"scala.scalajs.runtime.RuntimeLong$",{Te:1,c:1,f:1,d:1});var kf=void 0;function r(){kf||(kf=(new jf).b());return kf}function C(){this.N=!1;this.O=null}C.prototype=new w;C.prototype.constructor=C;C.prototype.b=function(){return this};C.prototype.i=function(){return"LazyRef "+(this.N?"of: "+this.O:"thunk")};function Vc(a,b){a.O=b;a.N=!0;return b}
C.prototype.$classData=v({Ye:0},"scala.runtime.LazyRef",{Ye:1,c:1,f:1,d:1});var pf=v({Ze:0},"scala.runtime.Nothing$",{Ze:1,t:1,c:1,d:1});function qf(){}qf.prototype=new w;qf.prototype.constructor=qf;function rf(){}rf.prototype=qf.prototype;var oa=v({tc:0},"java.lang.String",{tc:1,c:1,d:1,Gb:1,J:1},void 0,void 0,function(a){return"string"===typeof a});function sf(){this.m=null}sf.prototype=new ye;sf.prototype.constructor=sf;sf.prototype.C=function(a){D.prototype.s.call(this,""+a);return this};
sf.prototype.$classData=v({yc:0},"java.lang.AssertionError",{yc:1,gf:1,t:1,c:1,d:1});
var qa=v({Bc:0},"java.lang.Byte",{Bc:1,ja:1,c:1,d:1,J:1},void 0,void 0,function(a){return pa(a)}),va=v({Fc:0},"java.lang.Double",{Fc:1,ja:1,c:1,d:1,J:1},void 0,void 0,function(a){return"number"===typeof a}),ua=v({Hc:0},"java.lang.Float",{Hc:1,ja:1,c:1,d:1,J:1},void 0,void 0,function(a){return"number"===typeof a}),ta=v({Kc:0},"java.lang.Integer",{Kc:1,ja:1,c:1,d:1,J:1},void 0,void 0,function(a){return"number"===typeof a&&(a|0)===a&&1/a!==1/-0}),ya=v({Oc:0},"java.lang.Long",{Oc:1,ja:1,c:1,d:1,J:1},
void 0,void 0,function(a){return a instanceof q});function tf(){this.m=null}tf.prototype=new Ae;tf.prototype.constructor=tf;function R(){}R.prototype=tf.prototype;tf.prototype.e=function(a){D.prototype.s.call(this,a);return this};tf.prototype.$classData=v({x:0},"java.lang.RuntimeException",{x:1,E:1,t:1,c:1,d:1});var sa=v({Sc:0},"java.lang.Short",{Sc:1,ja:1,c:1,d:1,J:1},void 0,void 0,function(a){return ra(a)});function uf(){this.p=null}uf.prototype=new w;uf.prototype.constructor=uf;f=uf.prototype;
f.b=function(){this.p="";return this};f.kc=function(a,b){return this.p.substring(a,b)};f.i=function(){return this.p};f.Ab=function(a){uf.prototype.b.call(this);if(0>a)throw(new vf).b();return this};f.K=function(){return this.p.length|0};f.$classData=v({Tc:0},"java.lang.StringBuilder",{Tc:1,c:1,Gb:1,wc:1,d:1});function wf(){}wf.prototype=new w;wf.prototype.constructor=wf;function xf(){}xf.prototype=wf.prototype;wf.prototype.i=function(){return"\x3cfunction1\x3e"};function yf(){}yf.prototype=new w;
yf.prototype.constructor=yf;function zf(){}zf.prototype=yf.prototype;yf.prototype.i=function(){return"\x3cfunction1\x3e"};function Qb(){}Qb.prototype=new w;Qb.prototype.constructor=Qb;Qb.prototype.b=function(){return this};Qb.prototype.$classData=v({nd:0},"scala.math.Equiv$",{nd:1,c:1,sf:1,f:1,d:1});var Pb=void 0;function Yb(){}Yb.prototype=new w;Yb.prototype.constructor=Yb;Yb.prototype.b=function(){return this};Yb.prototype.$classData=v({td:0},"scala.math.Ordering$",{td:1,c:1,tf:1,f:1,d:1});
var Xb=void 0;function Ye(){}Ye.prototype=new w;Ye.prototype.constructor=Ye;Ye.prototype.b=function(){return this};Ye.prototype.i=function(){return"\x3c?\x3e"};Ye.prototype.$classData=v({Md:0},"scala.reflect.NoManifest$",{Md:1,c:1,w:1,f:1,d:1});var Xe=void 0;function Af(){}Af.prototype=new w;Af.prototype.constructor=Af;function Bf(){}Bf.prototype=Af.prototype;Af.prototype.h=function(){return!this.I()};Af.prototype.i=function(){return"\x3citerator\x3e"};Af.prototype.W=function(a){for(;this.I();)a.H(this.R())};
function Cf(){}Cf.prototype=new ee;Cf.prototype.constructor=Cf;function Df(){}Df.prototype=Cf.prototype;function Ue(){}Ue.prototype=new gf;Ue.prototype.constructor=Ue;Ue.prototype.b=function(){Te=this;if(null===this)throw A(null);return this};Ue.prototype.$classData=v({Ce:0},"scala.collection.immutable.Map$",{Ce:1,Gf:1,If:1,Df:1,c:1});var Te=void 0;function q(){this.r=this.q=0}q.prototype=new Od;q.prototype.constructor=q;f=q.prototype;
f.B=function(a){return a instanceof q?this.q===a.q&&this.r===a.r:!1};f.i=function(){var a=r(),b=this.q,c=this.r;return c===b>>31?""+b:0>c?"-"+lf(a,-b|0,0!==b?~c:-c|0):lf(a,b,c)};f.P=function(a,b){this.q=a;this.r=b;return this};f.Ab=function(a){q.prototype.P.call(this,a,a>>31);return this};f.u=function(){return this.q^this.r};f.$classData=v({Se:0},"scala.scalajs.runtime.RuntimeLong",{Se:1,ja:1,c:1,d:1,J:1});
function S(){this.ic=r().oa;this.Ea=null;this.jb=0;this.Da=null;this.$a=0;this.Za=!1;this.g=0}S.prototype=new Rd;S.prototype.constructor=S;S.prototype.Pa=function(a){this.ic=a;Qd.prototype.Pa.call(this,Ge());this.Ea=null;this.g=(1|this.g)<<24>>24;this.jb=0;this.g=(2|this.g)<<24>>24;this.Da=null;this.g=(4|this.g)<<24>>24;this.$a=0;this.g=(8|this.g)<<24>>24;this.Za=!1;this.g=(16|this.g)<<24>>24;Sd(this,a);return this};
function T(a){if(0===(2&a.g)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 161");return a.jb}function U(a){if(0===(1&a.g)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 160");return a.Ea}
function Ef(a){if(0===(8&a.g)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 163");return a.$a}function Ff(a){if(0===(16&a.g)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 164");return a.Za}
function V(a){if(0===(4&a.g)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 162");return a.Da}function Gf(a,b){a.Za=b;a.g=(16|a.g)<<24>>24}function Hf(a,b){a.$a=b;a.g=(8|a.g)<<24>>24}function W(a,b){a.jb=b;a.g=(2|a.g)<<24>>24}
function Sd(a,b){Gf(a,!1);Hf(a,0);var c=ka(Na(Sa),[O()]);a.Ea=c;a.g=(1|a.g)<<24>>24;c=ka(Na(Sa),[2]);a.Da=c;a.g=(4|a.g)<<24>>24;V(a).a[0]=0;c=V(a).a;var d=oe();if(0===(4&d.j)<<24>>24)throw(new K).e("Uninitialized field: /home/el_ergo/Repositories/Tortoise/engine/src/main/scala/MersenneTwisterFast.scala: 144");c[1]=d.Qb;U(a).a[0]=b.q;for(W(a,1);T(a)<O();)U(a).a[T(a)]=m(1812433253,U(a).a[-1+T(a)|0]^(U(a).a[-1+T(a)|0]>>>30|0))+T(a)|0,b=U(a),c=T(a),b.a[c]=b.a[c],W(a,1+T(a)|0)}
S.prototype.nextInt=function(){for(var a=arguments.length|0,b=0,c=[];b<a;)c.push(arguments[b]),b=b+1|0;switch(c.length|0){case 0:if(T(this)>=O()){b=0;c=U(this);for(var d=V(this);b<(O()-L()|0);)a=c.a[b]&N()|c.a[1+b|0]&I(),c.a[b]=c.a[b+L()|0]^(a>>>1|0)^d.a[1&a],b=1+b|0;for(;b<(-1+O()|0);)a=c.a[b]&N()|c.a[1+b|0]&I(),c.a[b]=c.a[b+(L()-O()|0)|0]^(a>>>1|0)^d.a[1&a],b=1+b|0;a=c.a[-1+O()|0]&N()|c.a[0]&I();c.a[-1+O()|0]=c.a[-1+L()|0]^(a>>>1|0)^d.a[1&a];W(this,0)}a=U(this).a[W(this,1+T(this)|0),-1+T(this)|
0];a^=a>>>11|0;a^=a<<7&M();a^=a<<15&P();return a^(a>>>18|0);case 1:a=c[0]|0;if(0>=a)throw(new Q).e("n must be positive");if((a&(-a|0))===a){if(T(this)>=O()){b=0;d=U(this);for(var e=V(this);b<(O()-L()|0);)c=d.a[b]&N()|d.a[1+b|0]&I(),d.a[b]=d.a[b+L()|0]^(c>>>1|0)^e.a[1&c],b=1+b|0;for(;b<(-1+O()|0);)c=d.a[b]&N()|d.a[1+b|0]&I(),d.a[b]=d.a[b+(L()-O()|0)|0]^(c>>>1|0)^e.a[1&c],b=1+b|0;c=d.a[-1+O()|0]&N()|d.a[0]&I();d.a[-1+O()|0]=d.a[-1+L()|0]^(c>>>1|0)^e.a[1&c];W(this,0)}c=U(this).a[W(this,1+T(this)|0),
-1+T(this)|0];c^=c>>>11|0;c^=c<<7&M();c^=c<<15&P();b=a>>31;c=(c^(c>>>18|0))>>>1|0;d=c>>31;var h=65535&a;e=a>>>16|0;var k=65535&c,p=c>>>16|0,t=m(h,k);k=m(e,k);var u=m(h,p);h=t+((k+u|0)<<16)|0;t=(t>>>16|0)+u|0;a=(((m(a,d)+m(b,c)|0)+m(e,p)|0)+(t>>>16|0)|0)+(((65535&t)+k|0)>>>16|0)|0;a=h>>>31|0|a<<1}else{do{if(T(this)>=O()){c=0;d=U(this);for(e=V(this);c<(O()-L()|0);)b=d.a[c]&N()|d.a[1+c|0]&I(),d.a[c]=d.a[c+L()|0]^(b>>>1|0)^e.a[1&b],c=1+c|0;for(;c<(-1+O()|0);)b=d.a[c]&N()|d.a[1+c|0]&I(),d.a[c]=d.a[c+(L()-
O()|0)|0]^(b>>>1|0)^e.a[1&b],c=1+c|0;b=d.a[-1+O()|0]&N()|d.a[0]&I();d.a[-1+O()|0]=d.a[-1+L()|0]^(b>>>1|0)^e.a[1&b];W(this,0)}b=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];b^=b>>>11|0;b^=b<<7&M();b^=b<<15&P();b^=b>>>18|0;b=b>>>1|0;c=b%a|0}while(0>((b-c|0)+(-1+a|0)|0));a=c}return a;default:throw"No matching overload";}};
S.prototype.nextGaussian=function(){if(Ff(this)){Gf(this,!1);var a=Ef(this)}else{var b;do{if(T(this)>=O()){a=0;var c=U(this);for(b=V(this);a<(O()-L()|0);){var d=c.a[a]&N()|c.a[1+a|0]&I();c.a[a]=c.a[a+L()|0]^(d>>>1|0)^b.a[1&d];a=1+a|0}for(;a<(-1+O()|0);)d=c.a[a]&N()|c.a[1+a|0]&I(),c.a[a]=c.a[a+(L()-O()|0)|0]^(d>>>1|0)^b.a[1&d],a=1+a|0;d=c.a[-1+O()|0]&N()|c.a[0]&I();c.a[-1+O()|0]=c.a[-1+L()|0]^(d>>>1|0)^b.a[1&d];W(this,0)}d=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];d^=d>>>11|0;d^=d<<7&M();d^=d<<15&
P();d^=d>>>18|0;if(T(this)>=O()){a=0;c=U(this);for(var e=V(this);a<(O()-L()|0);)b=c.a[a]&N()|c.a[1+a|0]&I(),c.a[a]=c.a[a+L()|0]^(b>>>1|0)^e.a[1&b],a=1+a|0;for(;a<(-1+O()|0);)b=c.a[a]&N()|c.a[1+a|0]&I(),c.a[a]=c.a[a+(L()-O()|0)|0]^(b>>>1|0)^e.a[1&b],a=1+a|0;b=c.a[-1+O()|0]&N()|c.a[0]&I();c.a[-1+O()|0]=c.a[-1+L()|0]^(b>>>1|0)^e.a[1&b];W(this,0)}b=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];b^=b>>>11|0;b^=b<<7&M();b^=b<<15&P();b^=b>>>18|0;if(T(this)>=O()){c=0;e=U(this);for(var h=V(this);c<(O()-L()|0);)a=
e.a[c]&N()|e.a[1+c|0]&I(),e.a[c]=e.a[c+L()|0]^(a>>>1|0)^h.a[1&a],c=1+c|0;for(;c<(-1+O()|0);)a=e.a[c]&N()|e.a[1+c|0]&I(),e.a[c]=e.a[c+(L()-O()|0)|0]^(a>>>1|0)^h.a[1&a],c=1+c|0;a=e.a[-1+O()|0]&N()|e.a[0]&I();e.a[-1+O()|0]=e.a[-1+L()|0]^(a>>>1|0)^h.a[1&a];W(this,0)}a=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];a^=a>>>11|0;a^=a<<7&M();a^=a<<15&P();a^=a>>>18|0;if(T(this)>=O()){h=U(this);var k=V(this);for(e=0;e<(O()-L()|0);)c=h.a[e]&N()|h.a[1+e|0]&I(),h.a[e]=h.a[e+L()|0]^(c>>>1|0)^k.a[1&c],e=1+e|0;for(;e<
(-1+O()|0);)c=h.a[e]&N()|h.a[1+e|0]&I(),h.a[e]=h.a[e+(L()-O()|0)|0]^(c>>>1|0)^k.a[1&c],e=1+e|0;c=h.a[-1+O()|0]&N()|h.a[0]&I();h.a[-1+O()|0]=h.a[-1+L()|0]^(c>>>1|0)^k.a[1&c];W(this,0)}c=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];c^=c>>>11|0;c^=c<<7&M();c^=c<<15&P();c^=c>>>18|0;e=d>>>6|0;d=e<<27;e=e>>>5|0|e>>31<<27;h=b>>>5|0;b=h>>31;h=d+h|0;d=(-2147483648^h)<(-2147483648^d)?1+(e+b|0)|0:e+b|0;d=-1+2*(Ed(r(),h,d)/9007199254740992);b=a>>>6|0;a=b<<27;b=b>>>5|0|b>>31<<27;e=c>>>5|0;c=e>>31;e=a+e|0;a=(-2147483648^
e)<(-2147483648^a)?1+(b+c|0)|0:b+c|0;a=-1+2*(Ed(r(),e,a)/9007199254740992);b=d*d+a*a}while(1<=b||0===b);c=bb();e=bb();h=b;b=-2*+(e.k?e.Ya:Za(e)).log(h)/b;c=+(c.k?c.Ya:Za(c)).sqrt(b);Hf(this,a*c);Gf(this,!0);a=d*c}return a};
S.prototype.nextDouble=function(){if(T(this)>=O()){var a=0;for(var b=U(this),c=V(this);a<(O()-L()|0);){var d=b.a[a]&N()|b.a[1+a|0]&I();b.a[a]=b.a[a+L()|0]^(d>>>1|0)^c.a[1&d];a=1+a|0}for(;a<(-1+O()|0);)d=b.a[a]&N()|b.a[1+a|0]&I(),b.a[a]=b.a[a+(L()-O()|0)|0]^(d>>>1|0)^c.a[1&d],a=1+a|0;d=b.a[-1+O()|0]&N()|b.a[0]&I();b.a[-1+O()|0]=b.a[-1+L()|0]^(d>>>1|0)^c.a[1&d];W(this,0)}d=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];d^=d>>>11|0;d^=d<<7&M();d^=d<<15&P();d^=d>>>18|0;if(T(this)>=O()){b=0;c=U(this);for(var e=
V(this);b<(O()-L()|0);)a=c.a[b]&N()|c.a[1+b|0]&I(),c.a[b]=c.a[b+L()|0]^(a>>>1|0)^e.a[1&a],b=1+b|0;for(;b<(-1+O()|0);)a=c.a[b]&N()|c.a[1+b|0]&I(),c.a[b]=c.a[b+(L()-O()|0)|0]^(a>>>1|0)^e.a[1&a],b=1+b|0;a=c.a[-1+O()|0]&N()|c.a[0]&I();c.a[-1+O()|0]=c.a[-1+L()|0]^(a>>>1|0)^e.a[1&a];W(this,0)}a=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];a^=a>>>11|0;a^=a<<7&M();a^=a<<15&P();b=d>>>6|0;d=b<<27;b=b>>>5|0|b>>31<<27;c=(a^(a>>>18|0))>>>5|0;a=c>>31;c=d+c|0;d=(-2147483648^c)<(-2147483648^d)?1+(b+a|0)|0:b+a|0;return Ed(r(),
c,d)/9007199254740992};
S.prototype.nextLong=function(a){var b=+a;a=r();b=Ld(a,b);a=(new q).P(b,a.n);b=a.r;if(0===b?0===a.q:0>b)throw(new Q).e("n must be positive");for(var c,d,e;;){if(T(this)>=O()){e=0;c=U(this);for(d=V(this);e<(O()-L()|0);)b=c.a[e]&N()|c.a[1+e|0]&I(),c.a[e]=c.a[e+L()|0]^(b>>>1|0)^d.a[1&b],e=1+e|0;for(;e<(-1+O()|0);)b=c.a[e]&N()|c.a[1+e|0]&I(),c.a[e]=c.a[e+(L()-O()|0)|0]^(b>>>1|0)^d.a[1&b],e=1+e|0;b=c.a[-1+O()|0]&N()|c.a[0]&I();c.a[-1+O()|0]=c.a[-1+L()|0]^(b>>>1|0)^d.a[1&b];W(this,0)}b=U(this).a[W(this,
1+T(this)|0),-1+T(this)|0];b^=b>>>11|0;b^=b<<7&M();b^=b<<15&P();b^=b>>>18|0;if(T(this)>=O()){c=0;d=U(this);for(var h=V(this);c<(O()-L()|0);)e=d.a[c]&N()|d.a[1+c|0]&I(),d.a[c]=d.a[c+L()|0]^(e>>>1|0)^h.a[1&e],c=1+c|0;for(;c<(-1+O()|0);)e=d.a[c]&N()|d.a[1+c|0]&I(),d.a[c]=d.a[c+(L()-O()|0)|0]^(e>>>1|0)^h.a[1&e],c=1+c|0;e=d.a[-1+O()|0]&N()|d.a[0]&I();d.a[-1+O()|0]=d.a[-1+L()|0]^(e>>>1|0)^h.a[1&e];W(this,0)}e=U(this).a[W(this,1+T(this)|0),-1+T(this)|0];e^=e>>>11|0;e^=e<<7&M();e^=e<<15&P();e^=e>>>18|0;c=
b+(e>>31)|0;b=c>>>1|0;c=e>>>1|0|c<<31;d=b;e=c;h=d;b=r();e=nf(b,e,h,a.q,a.r);h=b.n;b=e;e=h;h=c;var k=e;c=h-b|0;d=(-2147483648^c)>(-2147483648^h)?-1+(d-k|0)|0:d-k|0;k=a.r;h=-1+a.q|0;k=-1!==h?k:-1+k|0;if(!(0>((-2147483648^(c+h|0))<(-2147483648^c)?1+(d+k|0)|0:d+k|0)))break}b=(new q).P(b,e);a=b.q;b=b.r;return Ed(r(),a,b)};S.prototype.setSeed=function(a){a|=0;Sd(this,(new q).P(a,a>>31))};
S.prototype.load=function(a){Ca();if(null===a)throw(new z).b();var b=Oe().Fb.exec("\\s");if(null!==b){b=b[1];if(void 0===b)throw(new F).e("undefined.get");b=(new y).C(If(new Jf,Me(b),0))}else b=x();if(b.h()){var c=Oe().Eb.exec("\\s");if(null!==c){b=c[0];if(void 0===b)throw(new F).e("undefined.get");b="\\s".substring(b.length|0);var d=0;var e=c[1];if(void 0!==e)for(var h=e.length|0,k=0;k<h;){var p=k;d|=Ne(Oe(),65535&(e.charCodeAt(p)|0));k=1+k|0}c=c[2];if(void 0!==c)for(e=c.length|0,h=0;h<e;)k=h,d&=
~Ne(Oe(),65535&(c.charCodeAt(k)|0)),h=1+h|0;b=(new y).C(If(new Jf,b,d))}else b=x()}b=b.h()?If(new Jf,"\\s",0):b.T();if(null===b)throw(new Kf).C(b);d=b.ga|0;b=new l.RegExp(b.fa,"g"+(0!==(2&d)?"i":"")+(0!==(8&d)?"m":""));d=new Je;d.X=b;d.sb="\\s";a=ma(a);if(""===a)a=ja(Na(oa),[""]);else{c=a.length|0;b=new Td;b.Vb=d;b.Cb=a;b.Xb=0;b.Wb=c;d=b.Vb;c=new l.RegExp(d.X);d=c!==d.X?c:new l.RegExp(d.X.source,(d.X.global?"g":"")+(d.X.ignoreCase?"i":"")+(d.X.multiline?"m":""));b.kb=d;d=b.Cb;c=b.Xb;e=b.Wb;d="string"===
typeof d?d.substring(c,e):d.kc(c,e);b.Db=ma(d);b.Y=null;b.cb=!0;d=[];for(c=e=0;2147483646>c&&Ud(b);)0!==Xd(b)&&(h=Vd(b).index|0,e=a.substring(e,h),d.push(null===e?null:e),c=1+c|0),e=Xd(b);a=a.substring(e);d.push(null===a?null:a);d=ja(Na(oa),d);for(b=d.a.length;0!==b&&""===d.a[-1+b|0];)b=-1+b|0;if(b===d.a.length)a=d;else if(a=ka(Na(oa),[b]),d=d.a,c=a.a,d!==c||0>(0+b|0))for(e=0;e<b;e=e+1|0)c[0+e|0]=d[0+e|0];else for(e=b-1|0;0<=e;e=e-1|0)c[0+e|0]=d[0+e|0]}b=a.a[0];if(b!==pe())throw A((new tf).e('identifier mismatch: expected "'+
pe()+'", got "'+b+'"'));b=V(this);d=(new X).e(a.a[1]);c=Ee();b.a[0]=Ce(c,d.v);b=V(this);d=(new X).e(a.a[2]);c=Ee();b.a[1]=Ce(c,d.v);b=(new X).e(a.a[3]);d=Ee();W(this,Ce(d,b.v));b=(new X).e(a.a[4]);we||(we=(new ue).b());c=we;e=b.v;0===(1&c.k)<<24>>24&&0===(1&c.k)<<24>>24&&(c.wb=new l.RegExp("^[\\x00-\\x20]*([+-]?(?:NaN|Infinity|(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?)[fFdD]?)[\\x00-\\x20]*$"),c.k=(1|c.k)<<24>>24);b=c.wb.exec(e);if(null!==b)b=b[1],b=+l.parseFloat(void 0===b?void 0:b);else if(0===
(2&c.k)<<24>>24&&0===(2&c.k)<<24>>24&&(c.vb=new l.RegExp("^[\\x00-\\x20]*([+-]?)0[xX]([0-9A-Fa-f]*)\\.?([0-9A-Fa-f]*)[pP]([+-]?\\d+)[fFdD]?[\\x00-\\x20]*$"),c.k=(2|c.k)<<24>>24),d=c.vb.exec(e),null!==d){b=d[1];k=d[2];h=d[3];d=d[4];""===k&&""===h&&c.ha(e);e=""+k+h;c=-((h.length|0)<<2)|0;for(h=0;;)if(h!==(e.length|0)&&48===(65535&(e.charCodeAt(h)|0)))h=1+h|0;else break;h=e.substring(h);""===h?b="-"===b?-0:0:(e=(k=15<(h.length|0))?h.substring(0,15):h,h=c+(k?(-15+(h.length|0)|0)<<2:0)|0,c=+l.parseInt(e,
16),d=+l.parseInt(d,10),e=Ga(d)+h|0,h=e/3|0,d=+l.Math.pow(2,h),e=+l.Math.pow(2,e-(h<<1)|0),d=c*d*d*e,b="-"===b?-d:d)}else b=c.ha(e);Hf(this,b);b=a.a[5];if("true"===b)Gf(this,!0);else if("false"===b)Gf(this,!1);else throw A((new tf).e('expected true or false, got "'+b+'"'));for(b=0;b<O();)d=U(this),c=b,e=(new X).e(a.a[6+b|0]),h=Ee(),d.a[c]=Ce(h,e.v),b=1+b|0;Se||(Se=(new Re).b());if(!(a.a.length<=(6+b|0)))throw(new sf).C("assertion failed");};
S.prototype.save=function(){var a=Ef(this)===Ga(Ef(this))?Ef(this)+".0":Ef(this);a=(new B).e(pe()+" "+V(this).a[0]+" "+V(this).a[1]+" "+T(this)+" "+a+" "+Ff(this));for(var b=0;b<O();){hd(a," ");var c=U(this).a[b];hd(a,""+c);b=1+b|0}return a.F.p};S.prototype.clone=function(){var a=(new S).Pa(this.ic),b=U(this).tb();a.Ea=b;a.g=(1|a.g)<<24>>24;W(a,T(this));b=V(this).tb();a.Da=b;a.g=(4|a.g)<<24>>24;Hf(a,Ef(this));Gf(a,Ff(this));return a};
S.prototype.$classData=v({rc:0},"org.nlogo.tortoise.engine.MersenneTwisterFast",{rc:1,hf:1,c:1,d:1,bd:1,Hb:1});function of(){this.m=null}of.prototype=new R;of.prototype.constructor=of;of.prototype.e=function(a){D.prototype.s.call(this,a);return this};of.prototype.$classData=v({xc:0},"java.lang.ArithmeticException",{xc:1,x:1,E:1,t:1,c:1,d:1});function Q(){this.m=null}Q.prototype=new R;Q.prototype.constructor=Q;function Lf(){}Lf.prototype=Q.prototype;
Q.prototype.b=function(){D.prototype.s.call(this,null);return this};Q.prototype.e=function(a){D.prototype.s.call(this,a);return this};Q.prototype.$classData=v({Ib:0},"java.lang.IllegalArgumentException",{Ib:1,x:1,E:1,t:1,c:1,d:1});function Wd(){this.m=null}Wd.prototype=new R;Wd.prototype.constructor=Wd;Wd.prototype.e=function(a){D.prototype.s.call(this,a);return this};Wd.prototype.$classData=v({Ic:0},"java.lang.IllegalStateException",{Ic:1,x:1,E:1,t:1,c:1,d:1});function Y(){this.m=null}
Y.prototype=new R;Y.prototype.constructor=Y;Y.prototype.e=function(a){D.prototype.s.call(this,a);return this};Y.prototype.$classData=v({Jc:0},"java.lang.IndexOutOfBoundsException",{Jc:1,x:1,E:1,t:1,c:1,d:1});function eb(){}eb.prototype=new rf;eb.prototype.constructor=eb;eb.prototype.b=function(){return this};eb.prototype.$classData=v({Nc:0},"java.lang.JSConsoleBasedPrintStream$DummyOutputStream",{Nc:1,pc:1,c:1,nc:1,zc:1,oc:1});function vf(){this.m=null}vf.prototype=new R;
vf.prototype.constructor=vf;vf.prototype.b=function(){D.prototype.s.call(this,null);return this};vf.prototype.$classData=v({Pc:0},"java.lang.NegativeArraySizeException",{Pc:1,x:1,E:1,t:1,c:1,d:1});function z(){this.m=null}z.prototype=new R;z.prototype.constructor=z;z.prototype.b=function(){D.prototype.s.call(this,null);return this};z.prototype.$classData=v({Qc:0},"java.lang.NullPointerException",{Qc:1,x:1,E:1,t:1,c:1,d:1});function Mf(){this.m=null}Mf.prototype=new R;Mf.prototype.constructor=Mf;
Mf.prototype.e=function(a){D.prototype.s.call(this,a);return this};Mf.prototype.$classData=v({Vc:0},"java.lang.UnsupportedOperationException",{Vc:1,x:1,E:1,t:1,c:1,d:1});function F(){this.m=null}F.prototype=new R;F.prototype.constructor=F;F.prototype.e=function(a){D.prototype.s.call(this,a);return this};F.prototype.$classData=v({Xc:0},"java.util.NoSuchElementException",{Xc:1,x:1,E:1,t:1,c:1,d:1});function Kf(){this.ya=this.Mb=this.m=null;this.bb=!1}Kf.prototype=new R;Kf.prototype.constructor=Kf;
Kf.prototype.hb=function(){if(!this.bb&&!this.bb){if(null===this.ya)var a="null";else try{a=ma(this.ya)+" ("+("of class "+Xa(na(this.ya)))+")"}catch(b){if(null!==xd(vd(),b))a="an instance of class "+Xa(na(this.ya));else throw b;}this.Mb=a;this.bb=!0}return this.Mb};Kf.prototype.C=function(a){this.ya=a;D.prototype.s.call(this,null);return this};Kf.prototype.$classData=v({cd:0},"scala.MatchError",{cd:1,x:1,E:1,t:1,c:1,d:1});function Nf(){}Nf.prototype=new w;Nf.prototype.constructor=Nf;
function Of(){}Of.prototype=Nf.prototype;function Ze(){}Ze.prototype=new zf;Ze.prototype.constructor=Ze;Ze.prototype.b=function(){return this};Ze.prototype.H=function(){};Ze.prototype.$classData=v({jd:0},"scala.Predef$$anon$2",{jd:1,pf:1,c:1,V:1,f:1,d:1});function $e(){}$e.prototype=new xf;$e.prototype.constructor=$e;$e.prototype.b=function(){return this};$e.prototype.H=function(){};$e.prototype.$classData=v({kd:0},"scala.Predef$$anon$3",{kd:1,of:1,c:1,V:1,f:1,d:1});function Pc(){this.m=null}
Pc.prototype=new Pd;Pc.prototype.constructor=Pc;Pc.prototype.b=function(){D.prototype.s.call(this,null);return this};Pc.prototype.Na=function(){bf||(bf=(new af).b());return bf.rb?D.prototype.Na.call(this):this};Pc.prototype.$classData=v({Rd:0},"scala.util.control.BreakControl",{Rd:1,t:1,c:1,d:1,uf:1,vf:1});function sb(){}sb.prototype=new fe;sb.prototype.constructor=sb;sb.prototype.b=function(){H.prototype.b.call(this);return this};
sb.prototype.$classData=v({ke:0},"scala.collection.Iterable$",{ke:1,ma:1,ca:1,c:1,na:1,da:1});var rb=void 0;function fd(){}fd.prototype=new Bf;fd.prototype.constructor=fd;fd.prototype.b=function(){return this};fd.prototype.R=function(){throw(new F).e("next on empty iterator");};fd.prototype.I=function(){return!1};fd.prototype.$classData=v({me:0},"scala.collection.Iterator$$anon$2",{me:1,lb:1,c:1,nb:1,la:1,ka:1});function Pf(){this.lc=null}Pf.prototype=new Bf;Pf.prototype.constructor=Pf;
Pf.prototype.R=function(){if(this.I())ce();else return wb().eb.R()};Pf.prototype.I=function(){return!this.lc.h()};Pf.prototype.$classData=v({oe:0},"scala.collection.LinearSeqLike$$anon$1",{oe:1,lb:1,c:1,nb:1,la:1,ka:1});function qb(){}qb.prototype=new fe;qb.prototype.constructor=qb;qb.prototype.b=function(){H.prototype.b.call(this);pb=this;(new Oc).b();return this};qb.prototype.$classData=v({se:0},"scala.collection.Traversable$",{se:1,ma:1,ca:1,c:1,na:1,da:1});var pb=void 0;function Qf(){}
Qf.prototype=new Df;Qf.prototype.constructor=Qf;function Rf(){}Rf.prototype=Qf.prototype;function Sf(){this.ub=this.ua=0;this.mc=null}Sf.prototype=new Bf;Sf.prototype.constructor=Sf;Sf.prototype.R=function(){var a=this.mc.$(this.ua);this.ua=1+this.ua|0;return a};Sf.prototype.I=function(){return this.ua<this.ub};Sf.prototype.$classData=v({bf:0},"scala.runtime.ScalaRunTime$$anon$1",{bf:1,lb:1,c:1,nb:1,la:1,ka:1});function Jf(){this.ga=this.fa=null}Jf.prototype=new w;Jf.prototype.constructor=Jf;f=Jf.prototype;
f.aa=function(){return"Tuple2"};f.Z=function(){return 2};f.B=function(a){return this===a?!0:a instanceof Jf?Cd(Gd(),this.fa,a.fa)&&Cd(Gd(),this.ga,a.ga):!1};function If(a,b,c){a.fa=b;a.ga=c;return a}f.$=function(a){a:switch(a){case 0:a=this.fa;break a;case 1:a=this.ga;break a;default:throw(new Y).e(""+a);}return a};f.i=function(){return"("+this.fa+","+this.ga+")"};f.u=function(){return Yc(this)};f.$classData=v({uc:0},"scala.Tuple2",{uc:1,c:1,qf:1,za:1,l:1,f:1,d:1});function ve(){this.m=null}
ve.prototype=new Lf;ve.prototype.constructor=ve;ve.prototype.e=function(a){D.prototype.s.call(this,a);return this};ve.prototype.$classData=v({Rc:0},"java.lang.NumberFormatException",{Rc:1,Ib:1,x:1,E:1,t:1,c:1,d:1});function Tf(){}Tf.prototype=new Of;Tf.prototype.constructor=Tf;f=Tf.prototype;f.b=function(){return this};f.aa=function(){return"None"};f.Z=function(){return 0};f.h=function(){return!0};f.T=function(){throw(new F).e("None.get");};f.$=function(a){throw(new Y).e(""+a);};f.i=function(){return"None"};
f.u=function(){return 2433880};f.$classData=v({dd:0},"scala.None$",{dd:1,ed:1,c:1,za:1,l:1,f:1,d:1});var Uf=void 0;function x(){Uf||(Uf=(new Tf).b());return Uf}function y(){this.Ba=null}y.prototype=new Of;y.prototype.constructor=y;f=y.prototype;f.aa=function(){return"Some"};f.Z=function(){return 1};f.B=function(a){return this===a?!0:a instanceof y?Cd(Gd(),this.Ba,a.Ba):!1};f.h=function(){return!1};f.$=function(a){switch(a){case 0:return this.Ba;default:throw(new Y).e(""+a);}};f.T=function(){return this.Ba};
f.i=function(){Jd||(Jd=(new Id).b());var a=new Sf;a.mc=this;a.ua=0;a.ub=this.Z();return gd(a,this.aa()+"(",",")};f.C=function(a){this.Ba=a;return this};f.u=function(){return Yc(this)};f.$classData=v({ld:0},"scala.Some",{ld:1,ed:1,c:1,za:1,l:1,f:1,d:1});
function Vf(a){a=Xa(na(a.Yb()));for(var b=-1+(a.length|0)|0;;)if(-1!==b&&36===(65535&(a.charCodeAt(b)|0)))b=-1+b|0;else break;if(-1===b||46===(65535&(a.charCodeAt(b)|0)))return"";for(var c="";;){for(var d=1+b|0;;)if(-1!==b&&57>=(65535&(a.charCodeAt(b)|0))&&48<=(65535&(a.charCodeAt(b)|0)))b=-1+b|0;else break;for(var e=b;;)if(-1!==b&&36!==(65535&(a.charCodeAt(b)|0))&&46!==(65535&(a.charCodeAt(b)|0)))b=-1+b|0;else break;var h=1+b|0;if(b===e&&d!==(a.length|0))return c;for(;;)if(-1!==b&&36===(65535&(a.charCodeAt(b)|
0)))b=-1+b|0;else break;e=-1===b?!0:46===(65535&(a.charCodeAt(b)|0));var k;(k=e)||(k=65535&(a.charCodeAt(h)|0),k=!(90<k&&127>k||65>k));if(k){d=a.substring(h,d);h=c;if(null===h)throw(new z).b();c=""===h?d:""+d+qe(46)+c;if(e)return c}}}function Wf(){}Wf.prototype=new ef;Wf.prototype.constructor=Wf;function Xf(){}Xf.prototype=Wf.prototype;function We(){}We.prototype=new Rf;We.prototype.constructor=We;We.prototype.b=function(){Ve=this;if(null===this)throw A(null);return this};
We.prototype.$classData=v({Fe:0},"scala.collection.immutable.Set$",{Fe:1,Hf:1,Jf:1,Ef:1,ca:1,c:1,da:1});var Ve=void 0;function ub(){}ub.prototype=new Xf;ub.prototype.constructor=ub;ub.prototype.b=function(){H.prototype.b.call(this);return this};ub.prototype.$classData=v({qe:0},"scala.collection.Seq$",{qe:1,Xa:1,Wa:1,ma:1,ca:1,c:1,na:1,da:1});var tb=void 0;function Yf(){}Yf.prototype=new Xf;Yf.prototype.constructor=Yf;function Zf(){}Zf.prototype=Yf.prototype;
v({Mc:0},"java.lang.JSConsoleBasedPrintStream",{Mc:1,ef:1,df:1,pc:1,c:1,nc:1,zc:1,oc:1,wc:1});function K(){this.Ra=this.m=null}K.prototype=new R;K.prototype.constructor=K;f=K.prototype;f.aa=function(){return"UninitializedFieldError"};f.Z=function(){return 1};f.B=function(a){return this===a?!0:a instanceof K?this.Ra===a.Ra:!1};f.$=function(a){switch(a){case 0:return this.Ra;default:throw(new Y).e(""+a);}};f.e=function(a){this.Ra=a;D.prototype.s.call(this,a);return this};f.u=function(){return Yc(this)};
f.$classData=v({md:0},"scala.UninitializedFieldError",{md:1,x:1,E:1,t:1,c:1,d:1,za:1,l:1,f:1});function $f(){this.o=null}$f.prototype=new w;$f.prototype.constructor=$f;function Z(){}Z.prototype=$f.prototype;$f.prototype.B=function(a){return this===a};$f.prototype.i=function(){return this.o};$f.prototype.u=function(){return Fa(this)};function ag(){}ag.prototype=new w;ag.prototype.constructor=ag;function bg(){}bg.prototype=ag.prototype;function cg(){}cg.prototype=new Zf;cg.prototype.constructor=cg;
cg.prototype.b=function(){H.prototype.b.call(this);dg=this;(new cf).b();return this};cg.prototype.$classData=v({ee:0},"scala.collection.IndexedSeq$",{ee:1,ye:1,Xa:1,Wa:1,ma:1,ca:1,c:1,na:1,da:1});var dg=void 0;function vb(){dg||(dg=(new cg).b());return dg}function eg(){this.ia=this.fb=0;this.Ca=null}eg.prototype=new Bf;eg.prototype.constructor=eg;eg.prototype.R=function(){this.ia>=this.fb&&wb().eb.R();var a=this.Ca.pa(this.ia);this.ia=1+this.ia|0;return a};
function fg(a,b){var c=new eg;c.fb=b;if(null===a)throw A(null);c.Ca=a;c.ia=0;return c}eg.prototype.I=function(){return this.ia<this.fb};eg.prototype.$classData=v({he:0},"scala.collection.IndexedSeqLike$Elements",{he:1,lb:1,c:1,nb:1,la:1,ka:1,xf:1,f:1,d:1});function wd(){this.S=this.m=null}wd.prototype=new R;wd.prototype.constructor=wd;f=wd.prototype;f.aa=function(){return"JavaScriptException"};f.Z=function(){return 1};f.Na=function(){this.stackdata=this.S;return this};
f.B=function(a){return this===a?!0:a instanceof wd?Cd(Gd(),this.S,a.S):!1};f.$=function(a){switch(a){case 0:return this.S;default:throw(new Y).e(""+a);}};f.hb=function(){return ma(this.S)};f.C=function(a){this.S=a;D.prototype.s.call(this,null);return this};f.u=function(){return Yc(this)};f.$classData=v({Qe:0},"scala.scalajs.js.JavaScriptException",{Qe:1,x:1,E:1,t:1,c:1,d:1,za:1,l:1,f:1});function wc(){this.o=null}wc.prototype=new Z;wc.prototype.constructor=wc;
wc.prototype.b=function(){this.o="Boolean";return this};wc.prototype.$classData=v({Ad:0},"scala.reflect.ManifestFactory$BooleanManifest$",{Ad:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var vc=void 0;function ic(){this.o=null}ic.prototype=new Z;ic.prototype.constructor=ic;ic.prototype.b=function(){this.o="Byte";return this};ic.prototype.$classData=v({Bd:0},"scala.reflect.ManifestFactory$ByteManifest$",{Bd:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var hc=void 0;function mc(){this.o=null}mc.prototype=new Z;
mc.prototype.constructor=mc;mc.prototype.b=function(){this.o="Char";return this};mc.prototype.$classData=v({Cd:0},"scala.reflect.ManifestFactory$CharManifest$",{Cd:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var lc=void 0;function uc(){this.o=null}uc.prototype=new Z;uc.prototype.constructor=uc;uc.prototype.b=function(){this.o="Double";return this};uc.prototype.$classData=v({Dd:0},"scala.reflect.ManifestFactory$DoubleManifest$",{Dd:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var tc=void 0;
function sc(){this.o=null}sc.prototype=new Z;sc.prototype.constructor=sc;sc.prototype.b=function(){this.o="Float";return this};sc.prototype.$classData=v({Ed:0},"scala.reflect.ManifestFactory$FloatManifest$",{Ed:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var rc=void 0;function oc(){this.o=null}oc.prototype=new Z;oc.prototype.constructor=oc;oc.prototype.b=function(){this.o="Int";return this};
oc.prototype.$classData=v({Fd:0},"scala.reflect.ManifestFactory$IntManifest$",{Fd:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var nc=void 0;function qc(){this.o=null}qc.prototype=new Z;qc.prototype.constructor=qc;qc.prototype.b=function(){this.o="Long";return this};qc.prototype.$classData=v({Gd:0},"scala.reflect.ManifestFactory$LongManifest$",{Gd:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var pc=void 0;function gg(){this.L=null}gg.prototype=new bg;gg.prototype.constructor=gg;function hg(){}
hg.prototype=gg.prototype;gg.prototype.B=function(a){return this===a};gg.prototype.i=function(){return this.L};gg.prototype.u=function(){return Fa(this)};function kc(){this.o=null}kc.prototype=new Z;kc.prototype.constructor=kc;kc.prototype.b=function(){this.o="Short";return this};kc.prototype.$classData=v({Kd:0},"scala.reflect.ManifestFactory$ShortManifest$",{Kd:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var jc=void 0;function yc(){this.o=null}yc.prototype=new Z;yc.prototype.constructor=yc;
yc.prototype.b=function(){this.o="Unit";return this};yc.prototype.$classData=v({Ld:0},"scala.reflect.ManifestFactory$UnitManifest$",{Ld:1,U:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var xc=void 0;function ig(a,b){if(a===b)return!0;if(b&&b.$classData&&b.$classData.G.yf&&a&&a.$classData&&a.$classData.G.zf)return a.Pe()===b.Pe()&&a.Zf(b);a=a.xa();for(b=b.xa();a.I()&&b.I();)if(!Cd(Gd(),a.R(),b.R()))return!1;return!a.I()&&!b.I()}function yb(){}yb.prototype=new Xf;yb.prototype.constructor=yb;
yb.prototype.b=function(){H.prototype.b.call(this);xb=this;(new le).b();return this};yb.prototype.$classData=v({Ae:0},"scala.collection.immutable.List$",{Ae:1,Xa:1,Wa:1,ma:1,ca:1,c:1,na:1,da:1,f:1,d:1});var xb=void 0;function jg(){}jg.prototype=new Xf;jg.prototype.constructor=jg;jg.prototype.b=function(){H.prototype.b.call(this);kg=this;(new hf).b();return this};jg.prototype.$classData=v({Ge:0},"scala.collection.immutable.Stream$",{Ge:1,Xa:1,Wa:1,ma:1,ca:1,c:1,na:1,da:1,f:1,d:1});var kg=void 0;
function Gb(){kg||(kg=(new jg).b());return kg}function Ac(){this.L=null}Ac.prototype=new hg;Ac.prototype.constructor=Ac;Ac.prototype.b=function(){this.L="Any";x();zb();n(La);return this};Ac.prototype.$classData=v({yd:0},"scala.reflect.ManifestFactory$AnyManifest$",{yd:1,Ua:1,Ta:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var zc=void 0;function Ec(){this.L=null}Ec.prototype=new hg;Ec.prototype.constructor=Ec;Ec.prototype.b=function(){this.L="AnyVal";x();zb();n(La);return this};
Ec.prototype.$classData=v({zd:0},"scala.reflect.ManifestFactory$AnyValManifest$",{zd:1,Ua:1,Ta:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var Dc=void 0;function Gc(){this.L=null}Gc.prototype=new hg;Gc.prototype.constructor=Gc;Gc.prototype.b=function(){this.L="Nothing";x();zb();n(pf);return this};Gc.prototype.$classData=v({Hd:0},"scala.reflect.ManifestFactory$NothingManifest$",{Hd:1,Ua:1,Ta:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var Fc=void 0;function Jc(){this.L=null}Jc.prototype=new hg;
Jc.prototype.constructor=Jc;Jc.prototype.b=function(){this.L="Null";x();zb();n(Hd);return this};Jc.prototype.$classData=v({Id:0},"scala.reflect.ManifestFactory$NullManifest$",{Id:1,Ua:1,Ta:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var Hc=void 0;function Cc(){this.L=null}Cc.prototype=new hg;Cc.prototype.constructor=Cc;Cc.prototype.b=function(){this.L="Object";x();zb();n(La);return this};
Cc.prototype.$classData=v({Jd:0},"scala.reflect.ManifestFactory$ObjectManifest$",{Jd:1,Ua:1,Ta:1,c:1,A:1,z:1,y:1,w:1,f:1,d:1,l:1});var Bc=void 0;function Kb(){}Kb.prototype=new Zf;Kb.prototype.constructor=Kb;Kb.prototype.b=function(){H.prototype.b.call(this);Jb=this;return this};Kb.prototype.$classData=v({Me:0},"scala.collection.immutable.Vector$",{Me:1,ye:1,Xa:1,Wa:1,ma:1,ca:1,c:1,na:1,da:1,f:1,d:1});var Jb=void 0;function lg(){}lg.prototype=new w;lg.prototype.constructor=lg;function mg(){}
mg.prototype=lg.prototype;lg.prototype.Yb=function(){return this};lg.prototype.pb=function(){return Vf(this)};function ng(a,b){if(b&&b.$classData&&b.$classData.G.de){var c=a.K();if(c===b.K()){for(var d=0;d<c&&Cd(Gd(),a.pa(d),b.pa(d));)d=1+d|0;return d===c}return!1}return ig(a,b)}function og(a,b){for(var c=0,d=a.K();c<d;)b.H(a.pa(c)),c=1+c|0}function pg(){}pg.prototype=new mg;pg.prototype.constructor=pg;function qg(){}qg.prototype=pg.prototype;pg.prototype.Va=function(a){return ig(this,a)};
pg.prototype.W=function(a){for(var b=this.xa();b.I();)a.H(b.R())};function X(){this.v=null}X.prototype=new w;X.prototype.constructor=X;f=X.prototype;f.pa=function(a){a=65535&(this.v.charCodeAt(a)|0);return qe(a)};f.ib=function(a){return this.K()-a|0};f.Va=function(a){return ng(this,a)};f.h=function(){return 0===this.K()};f.B=function(a){pd||(pd=(new od).b());return a instanceof X?this.v===(null===a?null:a.v):!1};f.i=function(){return this.v};f.W=function(a){og(this,a)};
f.xa=function(){return fg(this,this.v.length|0)};f.K=function(){return this.v.length|0};f.Yb=function(){return this.v};f.e=function(a){this.v=a;return this};f.u=function(){var a=this.v;return Ba(Ca(),a)};f.pb=function(){return Vf(this)};f.$classData=v({Ke:0},"scala.collection.immutable.StringOps",{Ke:1,c:1,Je:1,ie:1,ge:1,dc:1,bc:1,l:1,ec:1,hc:1,fc:1,la:1,ka:1,ac:1,cc:1,Zb:1,$b:1,rd:1,J:1});function rg(){}rg.prototype=new qg;rg.prototype.constructor=rg;function sg(){}sg.prototype=rg.prototype;
rg.prototype.B=function(a){return a&&a.$classData&&a.$classData.G.mb?a===this||this.Va(a):!1};rg.prototype.h=function(){return 0===this.ib(0)};rg.prototype.i=function(){var a=this.pb()+"(";return gd(this,a,", ")};function tg(){}tg.prototype=new sg;tg.prototype.constructor=tg;function ug(){}ug.prototype=tg.prototype;function be(){}be.prototype=new sg;be.prototype.constructor=be;function vg(){}f=vg.prototype=be.prototype;
f.ib=function(a){if(0>a)a=1;else a:{var b=this,c=0;for(;;){if(c===a){a=b.h()?0:1;break a}if(b.h()){a=-1;break a}c=1+c|0;b=wg()}}return a};f.Va=function(a){if(a&&a.$classData&&a.$classData.G.ne)if(this===a)var b=!0;else{for(b=this;;){if(b.h()||a.h())c=!1;else{Gd();ce();var c=Cd(0,void 0,ce())}if(c)b=wg(),a=wg();else break}b=b.h()&&a.h()}else b=ig(this,a);return b};f.H=function(a){a|=0;for(var b=this,c=a;!b.h()&&0<c;)b=wg(),c=-1+c|0;if(0>a||b.h())throw(new Y).e(""+a);ce()};
f.W=function(a){for(var b=this;!b.h();)a.H(ce()),b=wg()};f.xa=function(){var a=new Pf;a.lc=this;return a};f.u=function(){return ae(this)};f.pb=function(){return"List"};function xg(){}xg.prototype=new vg;xg.prototype.constructor=xg;f=xg.prototype;f.aa=function(){return"Nil"};f.b=function(){return this};f.Z=function(){return 0};f.h=function(){return!0};function wg(){throw(new Mf).e("tail of empty list");}f.B=function(a){return a&&a.$classData&&a.$classData.G.mb?a.h():!1};
f.$=function(a){throw(new Y).e(""+a);};function ce(){throw(new F).e("head of empty list");}f.$classData=v({De:0},"scala.collection.immutable.Nil$",{De:1,Mf:1,$d:1,Zd:1,ae:1,c:1,re:1,ec:1,hc:1,fc:1,la:1,ka:1,ac:1,cc:1,ce:1,xe:1,je:1,be:1,Zb:1,bc:1,l:1,pe:1,gd:1,V:1,mb:1,$b:1,dc:1,Lf:1,Nf:1,Kf:1,Of:1,lf:1,ne:1,Af:1,za:1,Bf:1,f:1,d:1});var yg=void 0;function zb(){yg||(yg=(new xg).b());return yg}function B(){this.F=null}B.prototype=new ug;B.prototype.constructor=B;f=B.prototype;
f.b=function(){B.prototype.Bb.call(this,"");return this};f.pa=function(a){a=65535&(this.F.p.charCodeAt(a)|0);return qe(a)};f.ib=function(a){return this.K()-a|0};f.Va=function(a){return ng(this,a)};f.H=function(a){a=65535&(this.F.p.charCodeAt(a|0)|0);qe(a)};f.h=function(){return 0===this.K()};f.kc=function(a,b){return this.F.p.substring(a,b)};f.i=function(){return this.F.p};f.W=function(a){og(this,a)};function hd(a,b){a=a.F;a.p=""+a.p+b}f.xa=function(){return fg(this,this.F.K())};
f.Bb=function(a){var b=(new uf).Ab((a.length|0)+16|0);b.p=""+b.p+a;B.prototype.vc.call(this,b)};f.K=function(){return this.F.K()};f.vc=function(a){this.F=a};f.u=function(){return ae(this)};f.e=function(a){B.prototype.Bb.call(this,a);return this};
f.$classData=v({Ne:0},"scala.collection.mutable.StringBuilder",{Ne:1,Pf:1,$d:1,Zd:1,ae:1,c:1,re:1,ec:1,hc:1,fc:1,la:1,ka:1,ac:1,cc:1,ce:1,xe:1,je:1,be:1,Zb:1,bc:1,l:1,pe:1,gd:1,V:1,mb:1,$b:1,dc:1,Wf:1,Uf:1,Yf:1,nf:1,Xf:1,Rf:1,bd:1,Hb:1,Gb:1,Sf:1,de:1,ge:1,Tf:1,Je:1,ie:1,rd:1,J:1,Vf:1,Qf:1,Ff:1,Cf:1,f:1,d:1});
aa.MersenneTwisterFast=function(){for(var a=new S,b=arguments.length|0,c=0,d=[];c<b;)d.push(arguments[c]),c=c+1|0;void 0===d[0]?(oe(),c=fb(),b=r(),c=1E6*+(0,c.yb)(),c=Ld(b,c),b=(new q).P(c,b.n)):b=Ha(d[0]);S.prototype.Pa.call(a,b);return a};aa.MersenneTwisterFast.prototype=S.prototype;
}).call(this);


  module.exports = {
    MersenneTwisterFast: MersenneTwisterFast
  };

}).call(this);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"shim/random":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MersenneTwisterFast;

  ({MersenneTwisterFast} = require('./engine-scala'));

  /*
  On the JVM, we use Headless' MersenneTwisterFast.
  In the browser, we use a ScalaJS implementation of it.
  We can't the ScalaJS implementation in both environments,
  because MTF relies on bit-shifting, and JVM integers have
  a different number of bits than JS integers, leading to
  different results.
  */
  module.exports = MersenneTwisterFast();

}).call(this);

},{"./engine-scala":"shim/engine-scala"}],"shim/strictmath":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Cloner, genEnhancedMath;

  Cloner = require('./cloner');

  // We use this outside of GraalJS --JAB (4/10/15) / JMB (11/18)
  genEnhancedMath = function() {
    var obj;
    obj = Cloner(Math);
    // For functions that are not "close enough," or that don't exist in the browser, manually define them here!
    obj.toRadians = function(degrees) {
      return degrees * Math.PI / 180;
    };
    obj.toDegrees = function(radians) {
      return radians * 180 / Math.PI;
    };
    obj.PI = function() {
      return Math.PI; // Scala forces it to be a function in Nashorn, so it's a function here --JAB (4/8/15)
    };
    return obj;
  };

  module.exports = genEnhancedMath();

}).call(this);

},{"./cloner":"shim/cloner"}],"util/abstractmethoderror":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // (String) => Nothing
  module.exports = function(msg) {
    throw new Error(`Illegal method call: \`${msg}\` is abstract`);
  };

}).call(this);

},{}],"util/comparator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    NOT_EQUALS: {},
    // type Comparison = { toInt: Number }
    EQUALS: {
      toInt: 0
    },
    GREATER_THAN: {
      toInt: 1
    },
    LESS_THAN: {
      toInt: -1
    },
    // (Number, Number) => Comparison
    numericCompare: function(x, y) {
      if (x < y) {
        return this.LESS_THAN;
      } else if (x > y) {
        return this.GREATER_THAN;
      } else {
        return this.EQUALS;
      }
    },
    // (String, String) => Comparison
    stringCompare: function(x, y) {
      var comparison;
      comparison = x.localeCompare(y);
      if (comparison < 0) {
        return this.LESS_THAN;
      } else if (comparison > 0) {
        return this.GREATER_THAN;
      } else {
        return this.EQUALS;
      }
    }
  };

}).call(this);

},{}],"util/errors":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var StopInterrupt, askNobodyCheck, imperfectImport, missingReport, procedureArgumentsCheck, reportInContextCheck, stopInCommandCheck, stopInReportCheck;

  ({StopInterrupt} = require('util/exception'));

  // This file exists to contain errors that would otherwise
  // be added to the compiler-generated code, just to reduce
  // compiled code size a bit and to centralize the checks.
  // -Jeremy B June 2020

  // (AgentSet | Agent | Nobody) => AgentSet | Agent
  askNobodyCheck = function(agents) {
    if (agents === Nobody) {
      throw new Error("ASK expected input to be an agent or agentset but got NOBODY instead.");
    }
    return agents;
  };

  // () => Unit
  missingReport = function() {
    throw new Error("Reached end of reporter procedure without REPORT being called.");
  };

  // (Exception) => Unit
  stopInReportCheck = function(e) {
    if (e instanceof StopInterrupt) {
      throw new Error("STOP is not allowed inside TO-REPORT.");
    }
    throw e;
  };

  // (Exception) => Exception
  stopInCommandCheck = function(e) {
    if (!(e instanceof StopInterrupt)) {
      throw e;
    }
    return e;
  };

  // (Boolean) => Unit
  reportInContextCheck = function(reporterContext) {
    if (!reporterContext) {
      throw new Error("REPORT can only be used inside TO-REPORT.");
    }
  };

  // (Number, Number) => Unit
  procedureArgumentsCheck = function(neededArgs, givenArgs) {
    var plural;
    if (givenArgs < neededArgs) {
      plural = neededArgs === 1 ? "" : "s";
      throw new Error(`anonymous procedure expected ${neededArgs} input${plural}, but only got ${givenArgs}`);
    }
  };

  // (String) => Unit
  imperfectImport = function(primName) {
    throw new Error(`Unfortunately, no perfect equivalent to \`${primName}\` can be implemented in NetLogo Web.  However, the \'import-a\' and \'fetch\' extensions offer primitives that can accomplish this in both NetLogo and NetLogo Web.`);
  };

  module.exports = {askNobodyCheck, missingReport, stopInReportCheck, stopInCommandCheck, reportInContextCheck, procedureArgumentsCheck, imperfectImport};

}).call(this);

},{"util/exception":"util/exception"}],"util/exception":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentException, DeathInterrupt, HaltInterrupt, NetLogoException, StopInterrupt, TopologyInterrupt, ignoring;

  NetLogoException = class NetLogoException {
    constructor(message) {
      this.message = message;
    }

  };

  AgentException = class AgentException extends NetLogoException {};

  DeathInterrupt = class DeathInterrupt extends NetLogoException {};

  StopInterrupt = class StopInterrupt extends NetLogoException {};

  TopologyInterrupt = class TopologyInterrupt extends NetLogoException {};

  HaltInterrupt = class HaltInterrupt extends NetLogoException {
    constructor() {
      super("model halted by user");
    }

  };

  // [T] @ (Prototype) => (() => T) => T
  ignoring = function(exceptionType) {
    return function(f) {
      var ex;
      try {
        return f();
      } catch (error) {
        ex = error;
        if (!(ex instanceof exceptionType)) {
          throw ex;
        }
      }
    };
  };

  module.exports = {AgentException, DeathInterrupt, HaltInterrupt, ignoring, NetLogoException, StopInterrupt, TopologyInterrupt};

}).call(this);

},{}],"util/formatfloat":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MAX_NETLOGO_INT, formatFloat;

  MAX_NETLOGO_INT = 9007199254740992;

  // (Number) => String
  formatFloat = function(num) {
    var base, maybeBase;
    // Java always includes the decimal point, so `1e+38` in JS is `1.0E38` in Java.  We can't always do
    // `toExponential(1)` as then we'd truncate things like `1.222E38` to `1.2E38`.  -Jeremy B November 2020
    base = num > MAX_NETLOGO_INT || num < -MAX_NETLOGO_INT || ((0 < num && num < 1e-3)) || ((0 > num && num > -1e-3)) ? (maybeBase = num.toExponential(), maybeBase.includes('.') ? maybeBase : num.toExponential(1)) : num.toString(); // These negative exponent numbers are when Java will switch to scientific notation --JAB (12/25/17)
    return base.replace(/e\+?/, 'E'); // Java stringifies scientific notation with 'E' and 'E-', while JS uses 'e+' and 'e-'. --JAB (12/25/17)
  };

  module.exports = formatFloat;

}).call(this);

},{}],"util/iterator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Iterator;

  module.exports = Iterator = (function() {
    class Iterator {
      
      // (Array[T]) => Iterator[T]
      constructor(_items) {
        this._items = _items;
      }

      // ((T) => Boolean) => Boolean
      all(f) {
        var i, len, ref, x;
        ref = this._items;
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (!f(x)) {
            return false;
          }
        }
        return true;
      }

      // (T) => Boolean
      contains(x) {
        var i, len, ref, y;
        ref = this._items;
        for (i = 0, len = ref.length; i < len; i++) {
          y = ref[i];
          if (x === y) {
            return true;
          }
        }
        return false;
      }

      // ((T) => Boolean) => Boolean
      exists(f) {
        var i, len, ref, x;
        ref = this._items;
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (f(x)) {
            return true;
          }
        }
        return false;
      }

      // ((T) => Boolean) => Array[T]
      filter(f) {
        var i, len, ref, results, x;
        ref = this._items;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (f(x)) {
            results.push(x);
          }
        }
        return results;
      }

      // (Int) => T
      nthItem(n) {
        return this._items[n];
      }

      // [U] @ ((T) => U) => Array[U]
      map(f) {
        return this._items.map(f);
      }

      // ((T) => Unit) => Unit
      forEach(f) {
        this._items.forEach(f);
      }

      // () => Int
      size() {
        return this._items.length;
      }

      // () => Array[T]
      toArray() {
        return this._items;
      }

      // (Number, (Number, Number) => Boolean) => Boolean
      checkCount(n, check) {
        return check(this._items.length, n);
      }

    };

    Iterator.prototype._items = void 0; // [T] @ Array[T]

    return Iterator;

  }).call(this);

}).call(this);

},{}],"util/jstype":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var JSType;

  /*
  This class should be favored over Lodash when you want quick typechecking that need not be thorough.
  This was made specifically to compensate for the fact that Lodash's typechecking was swapped
  into the sorting code and caused a 25% performance hit in BZ Benchmark. --JAB (4/30/14)
  */
  JSType = class JSType {
    constructor(_x) { // (Any) => JSType
      this._x = _x;
    }

    isArray() {
      return Array.isArray(this._x);
    }

    isBoolean() {
      return typeof this._x === "boolean";
    }

    isFunction() {
      return typeof this._x === "function";
    }

    isNumber() {
      return typeof this._x === "number";
    }

    isObject() {
      return typeof this._x === "object";
    }

    isString() {
      return typeof this._x === "string";
    }

  };

  module.exports = function(x) {
    return new JSType(x);
  };

}).call(this);

},{}],"util/nlmath":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Exception, StrictMath,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  StrictMath = require('../shim/strictmath');

  Exception = require('./exception');

  module.exports = {
    // (Number) => Number
    abs: function(n) {
      return StrictMath.abs(n);
    },
    // (Number) => Number
    acos: function(radians) {
      return StrictMath.toDegrees(StrictMath.acos(radians));
    },
    // (Number) => Number
    asin: function(radians) {
      return StrictMath.toDegrees(StrictMath.asin(radians));
    },
    // (Number, Number) => Number
    atan: function(d1, d2) {
      if (d1 === 0) {
        if (d2 > 0) {
          return 0;
        } else {
          return 180;
        }
      } else if (d2 === 0) {
        if (d1 > 0) {
          return 90;
        } else {
          return 270;
        }
      } else {
        return (StrictMath.toDegrees(StrictMath.atan2(d1, d2)) + 360) % 360;
      }
    },
    // (Number) => Number
    ceil: function(n) {
      return StrictMath.ceil(n);
    },
    // (Number) => Number
    cos: function(degrees) {
      return StrictMath.cos(StrictMath.toRadians(degrees));
    },
    // (Number, Number) => Number
    distance2_2D: function(x, y) {
      return StrictMath.sqrt(x * x + y * y);
    },
    // (Number, Number, Number, Number) => Number
    distance4_2D: function(x1, y1, x2, y2) {
      return this.distance2_2D(x1 - x2, y1 - y2);
    },
    // (Number) => Number
    exp: function(n) {
      return StrictMath.exp(n);
    },
    // (Number) => Number
    floor: function(n) {
      return StrictMath.floor(n);
    },
    // (Number) => Number
    ln: function(n) {
      return StrictMath.log(n);
    },
    // (Number, Number) => Number
    log: function(num, base) {
      return StrictMath.log(num) / StrictMath.log(base);
    },
    // (Number*) => Number
    max: function(...xs) {
      return Math.max(...xs); // Variadic `max` doesn't exist on the Java `Math` object --JAB (9/23/15)
    },
    
    // (Number*) => Number
    min: function(...xs) {
      return Math.min(...xs); // Variadic `min` doesn't exist on the Java `Math` object --JAB (9/15/15)
    },
    
    // (Number, Number) => Number
    mod: function(a, b) {
      return modulo(a, b);
    },
    // (Number) => Number
    normalizeHeading: function(heading) {
      if ((0 <= heading && heading < 360)) {
        return heading;
      } else {
        return ((heading % 360) + 360) % 360;
      }
    },
    // (Number, Number) => Number
    precision: function(n, places) {
      var multiplier, result;
      multiplier = StrictMath.pow(10, NLMath.trunc(places));
      result = StrictMath.floor(n * multiplier + .5) / multiplier;
      if (places > 0) {
        return result;
      } else {
        return StrictMath.round(result);
      }
    },
    // (Number, Number) => Number
    pow: function(base, exponent) {
      return StrictMath.pow(base, exponent);
    },
    // (Number) => Number
    round: function(n) {
      return StrictMath.round(n);
    },
    // (Number) => Number
    sin: function(degrees) {
      return StrictMath.sin(StrictMath.toRadians(degrees));
    },
    // (Number) => Number
    sqrt: function(n) {
      return StrictMath.sqrt(n);
    },
    // (Number) => Number
    squash: function(x) {
      if (StrictMath.abs(x) < 3.2e-15) {
        return 0;
      } else {
        return x;
      }
    },
    // (Number, Number) => Number
    subtractHeadings: function(h1, h2) {
      var diff;
      diff = (h1 % 360) - (h2 % 360);
      if ((-180 < diff && diff <= 180)) {
        return diff;
      } else if (diff > 0) {
        return diff - 360;
      } else {
        return diff + 360;
      }
    },
    // (Number) => Number
    tan: function(degrees) {
      return StrictMath.tan(StrictMath.toRadians(degrees));
    },
    // (Number) => Number
    toInt: function(n) {
      return n | 0;
    },
    trunc: function(n) {
      return StrictMath.trunc(n);
    }
  };

}).call(this);

},{"../shim/strictmath":"shim/strictmath","./exception":"util/exception"}],"util/notimplemented":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // [T] @ (String, T) => () => T
  module.exports = function(name, defaultValue = {}) {
    if ((typeof console !== "undefined" && console !== null) && (console.warn != null)) {
      console.warn(`The \`${name}\` primitive has not yet been implemented.`);
    }
    return function() {
      return defaultValue;
    };
  };

}).call(this);

},{}],"util/rng":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AuxRandom, RNG, Random;

  Random = require('../shim/random');

  AuxRandom = require('../shim/auxrandom');

  // We need an auxiliary RNG for non-deterministic RNG events (e.g. code run within monitors),
  // so I sloppily manage what RNG is being used here.  I plan to, soon enough, clean up this
  // mess by deleting this file and replacing it with a proper context-passing system. --JAB (10/17/14)
  module.exports = RNG = (function() {
    class RNG {
      
      // () => RNG
      constructor() {
        // () => Number
        this.nextGaussian = this.nextGaussian.bind(this);
        // (Number) => Number
        this.nextInt = this.nextInt.bind(this);
        // (Number) => Number
        this.nextLong = this.nextLong.bind(this);
        // () => Number
        this.nextDouble = this.nextDouble.bind(this);
        this._mainRNG = Random;
        this._currentRNG = this._mainRNG;
      }

      // () => String
      exportState() {
        return this._mainRNG.save();
      }

      // (String) => Unit
      importState(state) {
        this._mainRNG.load(state);
      }

      nextGaussian() {
        return this._currentRNG.nextGaussian();
      }

      nextInt(limit) {
        return this._currentRNG.nextInt(limit);
      }

      nextLong(limit) {
        return this._currentRNG.nextLong(limit);
      }

      nextDouble() {
        return this._currentRNG.nextDouble();
      }

      // (Number) => Unit
      setSeed(seed) {
        this._currentRNG.setSeed(seed);
      }

      // [T] @ (() => T) => T
      withAux(f) {
        return this._withAnother(AuxRandom)(f);
      }

      // [T] @ (() => T) => T
      withClone(f) {
        return this._withAnother(Random.clone())(f);
      }

      // [T] @ (Generator) => (() => T) => T
      _withAnother(rng) {
        return (f) => {
          var prevRNG, result;
          prevRNG = this._currentRNG;
          this._currentRNG = rng;
          result = (function() {
            try {
              return f();
            } finally {
              this._currentRNG = prevRNG;
            }
          }).call(this);
          return result;
        };
      }

    };

    // type Generator = { nextInt: (Number) => Number, nextLong: (Number) => Number, nextDouble: () => Number, setSeed: (Number) => Unit }
    RNG.prototype._currentRNG = void 0; // Generator

    RNG.prototype._mainRNG = void 0; // Generator

    return RNG;

  }).call(this);

}).call(this);

},{"../shim/auxrandom":"shim/auxrandom","../shim/random":"shim/random"}],"util/shufflerator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Iterator, Shufflerator;

  Iterator = require('./iterator');

  module.exports = Shufflerator = (function() {
    class Shufflerator extends Iterator {
      
      // [T] @ (Array[T], (T) => Boolean, (Number) => Number) => Shufflerator
      constructor(items, _itemIsValid, _nextInt) {
        super(items);
        this._itemIsValid = _itemIsValid;
        this._nextInt = _nextInt;
        this._i = 0;
        this._nextOne = null;
        this._fetch();
      }

      // [U] @ ((T) => U) => Array[U]
      map(f) {
        var acc;
        acc = [];
        this.forEach(function(x) {
          return acc.push(f(x));
        });
        return acc;
      }

      // ((T) => Unit) => Unit
      forEach(f) {
        var next;
        while (this._hasNext()) {
          next = this._next();
          if (this._itemIsValid(next)) {
            f(next);
          }
        }
      }

      // [U >: T] @ ((T) => Boolean, U) => U
      find(f, dflt) {
        var next;
        while (this._hasNext()) {
          next = this._next();
          if (this._itemIsValid(next) && (f(next) === true)) {
            return next;
          }
        }
        return dflt;
      }

      // () => Array[T]
      toArray() {
        var acc;
        acc = [];
        this.forEach(function(x) {
          return acc.push(x);
        });
        return acc;
      }

      // () => Boolean
      _hasNext() {
        return this._i <= this._items.length;
      }

      // () => T
      _next() {
        var result;
        result = this._nextOne;
        this._fetch();
        return result;
      }

      /*
      I dislike this.  The fact that the items are prepolled annoys me.  But there are two problems with trying to "fix"
      that. First, fixing it involves changing JVM NetLogo/Headless.  To me, that requires a disproportionate amount of
      effort to do, relative to how likely--that is, not very likely--that this code is to be heavily worked on in the
      future.  The second problem is that it's not apparent to me how to you can make this code substantially cleaner
      without significantly hurting performance.  The very idea of a structure that statefully iterates a collection in
      a random order is difficult to put into clear computational terms.  When it needs to be done _efficiently_, that
      becomes even more of a problem.  As far as I can tell, the only efficient way to do it is like how we're doing it
      (one variable tracking the current index/offset, and an array where consumed items are thrown into the front).
      Whatever.  The whole point is that this code isn't really worth worrying myself over, since it's pretty stable.
      --JAB (7/25/14)
      */
      // () => Unit
      _fetch() {
        var randNum;
        if (this._hasNext()) {
          if (this._i < this._items.length - 1) {
            randNum = this._i + this._nextInt(this._items.length - this._i);
            this._nextOne = this._items[randNum];
            this._items[randNum] = this._items[this._i];
          } else {
            this._nextOne = this._items[this._i];
          }
          this._i++;
          if (!this._itemIsValid(this._nextOne)) {
            this._fetch();
          }
        } else {
          this._nextOne = null;
        }
      }

    };

    Shufflerator.prototype._i = void 0; // Number

    Shufflerator.prototype._nextOne = void 0; // T

    return Shufflerator;

  }).call(this);

}).call(this);

},{"./iterator":"util/iterator"}],"util/stablesort":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var rangeUntil, zip;

  ({zip} = require('brazierjs/array'));

  ({rangeUntil} = require('brazierjs/number'));

  // [T] @ (Array[(T, U)]) => ((U, T) => Int) => Array[T]
  module.exports = function(arr) {
    return function(f) {
      var pairs, sortFunc;
      sortFunc = function(x, y) {
        var result;
        // The JS `Array.sort()` implementation flips the arguments relative to what you'd expect: if you're array is [0 2 4] the first two arguments
        // to your `f` will be (2, 0).  That's not a big deal for results, but it is a big deal for getting error messages to be identical to desktop by
        // argument position.  So we flip the result back the other way with `-1 * result`.
        // -Jeremy B February 2021
        result = f(y[1], x[1]);
        if (result !== 0) {
          return -1 * result;
        } else if (x[0] < y[0]) {
          return -1;
        } else {
          return 1;
        }
      };
      pairs = zip(rangeUntil(0)(arr.length))(arr);
      return pairs.sort(sortFunc).map(function(pair) {
        return pair[1];
      });
    };
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/number":"brazier/number"}],"util/timer":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Timer;

  module.exports = Timer = (function() {
    class Timer {
      // () => Timer
      constructor() {
        this.reset();
      }

      // () => Number
      elapsed() {
        return (Date.now() - this._startTime) / 1000;
      }

      // () => Unit
      reset() {
        this._startTime = Date.now();
      }

    };

    // Number
    Timer.prototype._startTime = void 0;

    return Timer;

  }).call(this);

}).call(this);

},{}]},{},["bootstrap"]);
